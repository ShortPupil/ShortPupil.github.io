<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言程序设计笔记</title>
    <url>/post/840ee81f/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> number[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">-1</span>)&#123;</span><br><span class="line">        number[cnt] = x;</span><br><span class="line">        sum += x;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, sum/cnt);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i=<span class="number">0</span> ; i&lt;cnt ;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>越界… </p>
<h3 id="集成初始化时的定位"><a href="#集成初始化时的定位" class="headerlink" title="集成初始化时的定位"></a>集成初始化时的定位</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">13</span>] = &#123;[<span class="number">1</span>]=<span class="number">2</span>,<span class="number">3</span>,[<span class="number">5</span>]=<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next美化优化记录</title>
    <url>/post/5b7ae5f0/</url>
    <content><![CDATA[<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>这么久都没做过Hexo的优化记录，有些功能忘了，有些功能以前做过。这篇文章就用来记录自己容易忘记的美化和一些好的优化博文。</p>
<h1 id="小功能"><a href="#小功能" class="headerlink" title="小功能"></a>小功能</h1><h2 id="设置字体颜色"><a href="#设置字体颜色" class="headerlink" title="设置字体颜色"></a>设置字体颜色</h2><p><strong>链接</strong>：<a href="https://oldgerman.github.io/6c57f882/">hexo 博客如何写出彩色字体，能实时预览的那种？ | OldGerman’s Blog</a></p>
<p><span style="color:white;background:black;font-family:仿宋;">黑白配</span></p>
<h3 id="span-style-设置字体属性"><a href="#span-style-设置字体属性" class="headerlink" title="span - - - style | 设置字体属性"></a>span - - - style | 设置字体属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&#x27;color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;&#x27;</span>&gt;文字&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>style后传入的参数以分号隔开，参数数量可裁剪</p>
<p>其中color：支持三种格式 颜色名，十六进制颜色值，RGB取色器</p>
<p>示例：</p>
<ol>
<li>三种color格式显示同样的红色字体：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;color:red;&quot;</span>&gt;红不红？&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p><span style="color:red;">红不红？</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;color:rgb(255, 0, 0);&quot;</span>&gt;红不红？&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p><span style="color:rgb(255, 0, 0);">红不红？</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;color:#FF0000;&quot;</span>&gt;红不红？&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p><span style="color:#FF0000;">红不红？</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&#x27;color:white;background:black;font-size:50px;font-family:仿宋;&#x27;</span>&gt;黑白配&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>黑底白字仿宋50px：黑白配</p>
<h3 id="b-amp-strong-加粗字体"><a href="#b-amp-strong-加粗字体" class="headerlink" title="b &amp; strong | 加粗字体"></a>b &amp; strong | 加粗字体</h3><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;我被B标签加粗&lt;/b&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>我被Strong标签加粗<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<ol>
<li>加粗字体：<strong>加粗</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;加粗&lt;/b&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>紫色加粗：<strong>骚紫色加粗</strong></p>
<p><b><span style="color:rgb(255, 0, 255);">骚紫色加粗</span></b></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:rgb(255, 0, 255);&quot;</span>&gt;</span>骚紫色加粗<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/b&gt;</span><br></pre></td></tr></table></figure>
<h3 id="sup-amp-sub-上标-amp-下标"><a href="#sup-amp-sub-上标-amp-下标" class="headerlink" title="sup &amp; sub | 上标 &amp; 下标"></a>sup &amp; sub | 上标 &amp; 下标</h3><p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">上标：&lt;sup&gt;内容&lt;/sup&gt;</span><br><span class="line">下标：&lt;sub&gt;内容&lt;/sub&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mm&lt;sup&gt;<span class="number">2</span>&lt;/sup&gt;</span><br></pre></td></tr></table></figure>
<p>平方毫米: mm<sup>2</sup></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">y = log&lt;sub&gt;<span class="number">2</span> &lt;/sub&gt;x</span><br></pre></td></tr></table></figure>
<p>对数:y = log<sub>2 </sub>x</p>
<h3 id="div-align-各种对齐"><a href="#div-align-各种对齐" class="headerlink" title="div - - align | 各种对齐"></a>div - - align | 各种对齐</h3><p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;奇怪的知识增加了！&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<div align="center">奇怪的知识增加了！</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#x27;color:white;background:black;font-size:20px;&#x27;</span>&gt;</span>&amp;#12288“事情总会朝着意想不到的方向发展”&amp;#12288<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<div align="center"><span style="color:white;background:black;font-size:20px;">&#12288“事情总会朝着意想不到的方向发展”&#12288</span></div>



<h2 id="note使用"><a href="#Note使用" class="headerlink" title="Note使用"></a>Note使用</h2><p><strong>参考链接</strong>：<a href="https://jinnsjj.github.io/uncategorized/hexo-next-note/">在hexo-NexT中插入note提示块 | JOHZEN (jinnsjj.github.io)</a></p>
<p>next主题有个小功能还没用过，在主题配置文件中有：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: flat</span><br><span class="line">  icons: true</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<div class="note default"><p>default 提示块标签</p></div>
<div class="note primary"><p>primary 提示块标签</p></div>
<div class="note success"><p>success 提示块标签</p></div>
<div class="note info"><p>info 提示块标签</p></div>
<div class="note warning"><p>warning 提示块标签</p></div>
<div class="note danger"><p>danger 提示块标签</p></div>
<p>代码如下：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选项卡使用"><a href="#选项卡使用" class="headerlink" title="选项卡使用"></a>选项卡使用</h2><p>效果如下：<br><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">tab 1</a></li><li class="tab"><a href="#tab-2">tab 2</a></li><li class="tab"><a href="#tab-3">A</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><strong>选项卡 1</strong> </p>
</div><div class="tab-pane" id="tab-2"><p><strong>选项卡 2</strong></p>
</div><div class="tab-pane" id="tab-3"><p><strong>选项卡 3</strong> 名字为A</p>
</div></div></div></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tab,1 %&#125; 名字为tab，默认在第1个选项卡，如果是-1则隐藏</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**选项卡 1**</span> </span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**选项卡 2**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab A --&gt;</span><br><span class="line"><span class="strong">**选项卡 3**</span> 名字为A</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><h2 id="随机背景图"><a href="#随机背景图" class="headerlink" title="随机背景图"></a>随机背景图</h2><p>思路就是将喜欢的图片打包上传到图床，通过<code>url.csv</code>文件中给出的图床链接来实现一个随机图片 API，<code>backgound:url</code>调用相应的API。</p>
<p>找资源的网站：</p>
<p><a target="_blank" href="https://www.nbfox.com/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">麦田艺术 - 收尽世界名画，无水印高清油画免费下载 (nbfox.com)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://www.nbfox.com/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<p><a target="_blank" href="https://gallerix.asia/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">绘画和绘画 – 加勒里克斯在线博物馆 (gallerix.asia)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://gallerix.asia/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<p><a target="_blank" href="https://new.shuge.org/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">书格 (shuge.org)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://new.shuge.org/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<p>图床：<a href="https://github.com/ShortPupil/VPicture">新建一个github repo就行</a></p>
<p>下面链接里都有工具详细的使用方法</p>
<p>本地图片上传工具：</p>
<p><a target="_blank" href="https://github.com/Molunerfinn/picgo/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">Molunerfinn/PicGo: A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder (github.com)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://github.com/Molunerfinn/picgo/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<p>随机生成背景图方法：</p>
<p><a target="_blank" href="https://github.com/YieldRay/Random-Picture" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">YieldRay/Random-Picture: 随机图片api (github.com)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://github.com/YieldRay/Random-Picture</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<p>我的background路径设置文件是 <code>...\themes\next\source\css\_custom\custom.styl</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">   <span class="comment">// 替换成自己的随机图片链接</span></span><br><span class="line">   <span class="attribute">background</span>:url(https://fine-clam-<span class="number">71</span>.deno.dev);</span><br><span class="line">   <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">   <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">   <span class="attribute">background-position</span>:center;</span><br><span class="line">   <span class="attribute">background-size</span>:cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate的三种状态、事务机制、缓存懒加载</title>
    <url>/post/b4ceab5d/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>了解hibernate的底层实现对于使用还是很重要的</p>
<p>今天有个用hibernate进行查询出了不少错误，问题在于没有理解其持久状态和事务机制</p>
<h1 id="1-三种状态"><a href="#1-三种状态" class="headerlink" title="1. 三种状态"></a>1. 三种状态</h1><h2 id="11-临时状态transient"><a href="#1-1-临时状态-Transient" class="headerlink" title="1.1 临时状态(Transient)"></a>1.1 临时状态(Transient)</h2><p>当new一个实体对象后, 这个对象处于临时状态, 即这个对象只是一个<strong>保存临时数据的内存区域</strong>, 如果没有变量引用这个对象, 则会被jre垃圾回收机制回收. 这个对象所保存的数据与数据库没有任何关系, 除非通过<strong>Session的save或者SaveOrUpdate</strong>把临时对象与数据库关联, 并把数据插入或者更新到数据库, 这个对象才转换为持久对象.</p>
<h2 id="12-持久状态persistent"><a href="#1-2-持久状态-Persistent" class="headerlink" title="1.2 持久状态(Persistent)"></a>1.2 持久状态(Persistent)</h2><p>持久化对象的实例在<strong>数据库中有对应的记录, 并拥有一个持久化表示（ID）</strong>. 对持久化对象进行delete操作后, 数据库中对应的记录将被删除, 那么持久化对象与数据库记录不再存在对应关系, 持久化对象变成临时状态. 持久化对象被修改变更后, 不会马上同步到数据库, 直到数据库事务提交. 在同步之前, 持久化对象是脏的（Dirty）.</p>
<h2 id="13-游离状态detached"><a href="#1-3-游离状态-Detached" class="headerlink" title="1.3 游离状态(Detached)"></a>1.3 游离状态(Detached)</h2><p>当Session进行了Close、Clear或者evict后, <strong>持久化对象虽然拥有持久化标识符和与数据库对应记录一致的值, 但是因为会话已经消失, 对象不在持久化管理之内</strong>, 所以处于游离. 游离状态的对象与临时状态对象是十分相似的, 只是它还含有持久化标识.</p>
<h1 id="2-事务机制"><a href="#2-事务机制" class="headerlink" title="2 事务机制"></a>2 事务机制</h1><h2 id="21-常见的qampa"><a href="#2-1-常见的Q-amp-A" class="headerlink" title="2.1 常见的Q&amp;A"></a>2.1 常见的Q&amp;A</h2><h3 id="211-gettransaction-begintransaction"><a href="#2-1-1-getTransaction、beginTransaction" class="headerlink" title="2.1.1 getTransaction、beginTransaction"></a>2.1.1 getTransaction、beginTransaction</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">factory.getSession().getTransaction().hasCode = <span class="number">832665667</span>;</span><br><span class="line">factory.getSession().beginTransaction().hasCode = <span class="number">2119928380</span>;</span><br><span class="line">factory.getSession().getTransaction().hascode = <span class="number">2119928380</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用session.getTransaction()的时候，会创建一个全新的Transaction对象；</li>
<li>调用session.beginTransaction()的时候，会创建一个全新的Transaction对象，没有使用上一步的Transaction对象哦；</li>
<li>再次调用session.getTransaction()的时候，会看到这时返回的是第2步创建的Transaction对象；</li>
<li>这时调用session.getCurrentTransaction()，会看到仍然返回第2步创建的Transaction对象；</li>
</ul>
<p><strong>结论</strong>：通常情况下一个session内只会处理一个事务，所以大多数时候可直接调用session.beginTransaction()方法创建一个全新的transaction对象，并开始该事务。 </p>
<h3 id="212-gettransaction-getcurrenttransaction"><a href="#2-1-2-getTransaction、getCurrentTransaction" class="headerlink" title="2.1.2 getTransaction、getCurrentTransaction"></a>2.1.2 getTransaction、getCurrentTransaction</h3><h3 id="213-如果不断的调用gettransaction是否会返回同一个transaction对象"><a href="#2-1-3-如果不断的调用getTransaction，是否会返回同一个transaction对象？" class="headerlink" title="2.1.3 如果不断的调用getTransaction，是否会返回同一个transaction对象？"></a>2.1.3 如果不断的调用getTransaction，是否会返回同一个transaction对象？</h3><h3 id="214-通过gettransaction创建transaction对象begin之后再调用sessionbegintransaction是否会开启两个事务"><a href="#2-1-4-通过getTransaction创建transaction对象begin之后，再调用session-beginTransaction是否会开启两个事务？" class="headerlink" title="2.1.4 通过getTransaction创建transaction对象begin之后，再调用session.beginTransaction是否会开启两个事务？"></a>2.1.4 通过getTransaction创建transaction对象begin之后，再调用session.beginTransaction是否会开启两个事务？</h3><h3 id="215-当transactioncommit调用之后再次调用sessionbegintransaction是否会继续沿用之前的transaction"><a href="#2-1-5-当transaction-commit-调用之后再次调用session-beginTransaction是否会继续沿用之前的transaction？" class="headerlink" title="2.1.5 当transaction.commit()调用之后再次调用session.beginTransaction是否会继续沿用之前的transaction？"></a>2.1.5 当transaction.commit()调用之后再次调用session.beginTransaction是否会继续沿用之前的transaction？</h3><h3 id="216-是否总是需要手工调用transactionrollback实现事务回滚"><a href="#2-1-6-是否总是需要手工调用transaction-rollback实现事务回滚？" class="headerlink" title="2.1.6 是否总是需要手工调用transaction.rollback实现事务回滚？"></a>2.1.6 是否总是需要手工调用transaction.rollback实现事务回滚？</h3><h2 id="22-session-amp-transaction-scope事务范围"><a href="#2-2-session-amp-transaction-scope（事务范围）" class="headerlink" title="2.2 session &amp; transaction scope（事务范围）"></a>2.2 session &amp; transaction scope（事务范围）</h2><h3 id="221-操作单元"><a href="#2-2-1-操作单元" class="headerlink" title="2.2.1 操作单元"></a>2.2.1 操作单元</h3><ul>
<li>别用_session-per-operation_这种反模式了，也就是说，在单个线程中， 不要因为一次简单的数据库调用，就打开和关闭一次<code>Session</code>！数据库事务也是如此。</li>
<li>最常用的模式是 <em>每个请求一个会话(<strong>session-per-request</strong>)</em>——一 个新的Hibernate <code>Session</code>被打开，并且<strong>执行这个操作单元中所有的数据库操作</strong>。 一旦操作完成（同时对客户端的响应也准备就绪），session被同步，然后关闭。</li>
<li>key：<strong>在服务器端要处理请求的时候，开启事务，在响应发送给客户之前结束事务。</strong></li>
<li>通常的方案有<code>ServletFilter</code>，在service方法中进行pointcut的AOP拦截器，或者proxy/interception容器。</li>
<li>在任何时间，任何地方，你的应用代码可以通过简单的调用<code>sessionFactory.getCurrentSession()</code>来访问”当前session”，用于处理请求。你总是会得到当前数据库事务范围内的<code>Session</code>。</li>
</ul>
<h3 id="222-长对话"><a href="#2-2-2-长对话" class="headerlink" title="2.2.2 长对话"></a>2.2.2 长对话</h3><ul>
<li><p>长时间运行的对话（conversation）例子</p>
<ul>
<li>在界面的第一屏，打开对话框，用户所看到的数据是被一个特定的 <code>Session</code> 和数据 库事务载入(load)的。用户可以随意修改对话框中的数据对象。</li>
<li>5分钟后，用户点击“保存”，期望所做出的修改被持久化；同时他也期望自己是唯一修改这个信息的人，不会出现 修改冲突。</li>
</ul>
</li>
<li>我们必须使用<strong>多个数据库事务</strong>来实现这个对话。</li>
<li>如果仅仅只有一 个数据库事务（最后的那个事务）保存更新过的数据，而所有其他事务只是单纯的读取数据（例如在一个跨越多个请求/响应周期的向导风格的对话框中），那么应用程序事务将保证其<strong>原子性</strong>。</li>
<li>hibernate有用的特性<ul>
<li><em>自动版本化</em> - Hibernate能够自动进行乐观并发控制 ，如果在用户思考 的过程中发生并发修改，Hibernate能够自动检测到。一般我们只在<strong>对话结束</strong>时才检查。</li>
<li><em>脱管对象</em>（Detached  Objects）- 如果你决定采用前面已经讨论过的 _session-per-request_模式，所有载入的实例在用户思考的过程  中都处于与Session脱离的状态。Hibernate允许你<strong>把与Session脱离的对象重新关联到Session上</strong>，<strong>并且对修改进行持久化</strong>，这种模式被称为 <em>session-per-request-with-detached-objects</em>。自动版本化被用来隔离并发修改。</li>
<li><em>Extended (or Long) Session</em> - Hibernate 的<code>Session</code>  可以在数据库事务提交之后和底层的JDBC连接断开，当一个新的客户端请求到来的时候，它又重新连接上底层的  JDBC连接。这种模式被称之为<strong>_session-per-conversation_</strong>，这种情况可 能会造成不必要的Session和JDBC连接的重新关联。自动版本化被用来隔离并发修改, <strong><code>Session</code>通常不允许自动flush,而是明确flush</strong>。</li>
</ul>
</li>
</ul>
<h3 id="213-关注对象标识considering-object-identity"><a href="#2-1-3-关注对象标识（Considering-object-identity）" class="headerlink" title="2.1.3 关注对象标识（Considering object identity）"></a>2.1.3 关注对象标识（Considering object identity）</h3><ul>
<li>当应用程序在两个不同的session中并发访问具有同一持久化标 识的业务对象实例的时候，这个业务对象的<strong>两个实例事实上是不相同的</strong>（从 JVM识别来看）。这种冲突可以通过在同步和提交的时候使用<strong>自动版本化</strong>和<strong>乐观锁定</strong>方法来解决。</li>
<li><strong>只要在单个线程只持有一个</strong> <code>Session</code>，<strong>应用程序就不需要同步任何业务对象</strong>。在<code>Session</code> 的范围内，应用程序可以放心的使用<code>==</code>进行对象比较。</li>
<li>应用程序在<code>Session</code>的外面使用<code>==</code>进行对象比较可能会导致<strong>无法预期的结果</strong>。例如，如果你把两个脱管对象实例放进同一个 <code>Set</code>的时候，就可能发生。开发人员必须<strong>覆盖持久化类的<code>equals()</code>方法和 <code>hashCode()</code> 方法，从而实现自定义的对象相等语义</strong>。</li>
<li>不要使用数据库标识 来实现对象相等，应该使用<strong>业务键值</strong>，由<strong>唯一的，通常不变的属性</strong>组成。</li>
</ul>
<h3 id="214-问题"><a href="#2-1-4-问题" class="headerlink" title="2.1.4 问题"></a>2.1.4 问题</h3><ul>
<li>决不要使用反模式<strong>_session-per-user-session_或者 session-per-application</strong>（这个规定几乎没有例外）</li>
<li><code>Session</code> 对象是非线程安全的。</li>
<li>一个由Hibernate抛出的异常意味着你必须立即回滚数据库事务，并立即关闭<code>Session</code> </li>
<li><code>Session</code> 缓存了处于持久化状态的每个对象（Hibernate会监视和检查脏数据）。</li>
</ul>
<h2 id="23-事务声明"><a href="#2-3-事务声明" class="headerlink" title="2.3 事务声明"></a>2.3 事务声明</h2><p>手工启动，提交，或者回滚数据库事务</p>
<p>通常情况下，结束 <code>Session</code> 包含了四个不同的阶段:</p>
<ul>
<li>同步session(flush,刷出到磁盘）</li>
<li>提交事务</li>
<li>关闭session</li>
<li>处理异常</li>
</ul>
<h3 id="231-非托管环境"><a href="#2-3-1-非托管环境" class="headerlink" title="2.3.1 非托管环境"></a>2.3.1 非托管环境</h3><p>session/transaction常见处理方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Non-managed environment idiom</span></span><br><span class="line">Session sess = factory.openSession();</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    tx = sess.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tx.commit(); <span class="comment">//自动触发session的同步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tx != <span class="keyword">null</span>) tx.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// or display error message</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    sess.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hibernate内置的<strong>“current session”上下文管理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Non-managed environment idiom with getCurrentSession()</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    factory.getCurrentSession().beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    factory.getCurrentSession().getTransaction().commit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    factory.getCurrentSession().getTransaction().rollback();</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// or display error message</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你所有的一切就是<code>SessionFactory</code></p>
<h3 id="232-使用jta"><a href="#2-3-2-使用JTA" class="headerlink" title="2.3.2 使用JTA"></a>2.3.2 使用JTA</h3><h3 id="233-异常处理"><a href="#2-3-3-异常处理" class="headerlink" title="2.3.3 异常处理"></a>2.3.3 异常处理</h3><p>标准的 <code>JDBCException</code>子类型是：</p>
<ul>
<li><code>JDBCConnectionException</code> - 指明底层的JDBC通讯出现错误</li>
<li><code>SQLGrammarException</code> - 指明发送的SQL语句的语法或者格式错误</li>
<li><code>ConstraintViolationException</code> - 指明某种类型的约束违例错误</li>
<li><code>LockAcquisitionException</code> - 指明了在执行请求操作时，获取 所需的锁级别时出现的错误。</li>
<li><code>GenericJDBCException</code> - 不属于任何其他种类的原生异常</li>
</ul>
<h3 id="234-事务超时"><a href="#2-3-4-事务超时" class="headerlink" title="2.3.4 事务超时"></a>2.3.4 事务超时</h3><p>在托管环境中，Hibernate会把事务超时转交给JTA。这一功能通过<strong>Hibernate <code>Transaction</code>对象进行抽象</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Session sess = factory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">    //set transaction timeout to 3 seconds</span><br><span class="line">    sess.getTransaction().setTimeout(3);</span><br><span class="line">    sess.getTransaction().begin();</span><br><span class="line"></span><br><span class="line">    // do some work</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    sess.getTransaction().commit()</span><br><span class="line">&#125;</span><br><span class="line">catch (RuntimeException e) &#123;</span><br><span class="line">    sess.getTransaction().rollback();</span><br><span class="line">    throw e; // or display error message</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">    sess.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-缓存懒加载"><a href="#3-缓存懒加载" class="headerlink" title="3. 缓存懒加载"></a>3. 缓存懒加载</h1><h2 id="31-常见使用qampa"><a href="#3-1-常见使用Q-amp-A" class="headerlink" title="3.1 常见使用Q&amp;A"></a>3.1 常见使用Q&amp;A</h2><h3 id="311-对于manytoone注解默认fetchtypeeager"><a href="#3-1-1-对于ManyToOne注解默认FetchType-EAGER" class="headerlink" title="3.1.1 对于ManyToOne注解默认FetchType.EAGER"></a>3.1.1 对于ManyToOne注解默认FetchType.EAGER</h3><p>EAGER是什么意思呢？比如User类有个role属性，当加载user对象的时候，就会同时加载role对象，也就是你期望的只有一条简单sql从user表查询，但是却执行了两条sql（或者是join查询）。</p>
<p>所以，通常情况下对于ManyToOne注解，都需要<strong>手工设置fetch = FetchType.LAZY</strong>，否则会出现严重性能问题。</p>
<h2 id="32-缓存机制"><a href="#3-2-缓存机制" class="headerlink" title="3.2 缓存机制"></a>3.2 缓存机制</h2><h3 id="321-一级缓存"><a href="#3-2-1-一级缓存" class="headerlink" title="3.2.1 一级缓存"></a>3.2.1 一级缓存</h3><p>Session缓存表示将查询结果放置到Session的临时存储空间（一级缓存中），一旦session关闭，则缓存关闭。方法有<code>load</code>、<code>save</code>、<code>update</code>、<code>delete</code></p>
<h3 id="322-二级缓存"><a href="#3-2-2-二级缓存" class="headerlink" title="3.2.2 二级缓存"></a>3.2.2 二级缓存</h3><p>二级缓存是将查询的数据放置在SessionFactory临时存储空间中，因为一个SessionFactory可以创建多个Session对象，所以范围比Session缓存的要大，多个Session可以共享二级缓存的数据。</p>
<h2 id="33-懒加载"><a href="#3-3-懒加载" class="headerlink" title="3.3 懒加载"></a>3.3 懒加载</h2><p>表示<strong>查询当前对象或关联对象数据时，不真正访问数据库，当使用对象非主键属性时，才真正发送查询语句，访问数据库。</strong>由于在某些情况下，查的数据在后续流程到可能用不上，如果做查询处理就多余了，所以延迟加载功能可以提高性能，合理使用即可。当然了Hibernate框架是通过Cglib代理来完成延迟加载功能的扩展的。</p>
<h3 id="331-延迟加载会出现的问题"><a href="#3-3-1-延迟加载会出现的问题" class="headerlink" title="3.3.1 延迟加载会出现的问题"></a>3.3.1 延迟加载会出现的问题</h3><p>延迟加载功能是<strong>运用的一级缓存</strong>，也就是利用的是session的内存，一般情况下，我们在用完session后会进行关闭，但是关闭后我们就无法进行延迟查询数据了，也就是说，延迟加载功能就将失效，剖出异常：<strong>No Sesssion</strong>，所以这是需要我们解决的。</p>
<h3 id="332-处理no-session"><a href="#3-3-2-处理No-Session" class="headerlink" title="3.3.2 处理No  Session"></a>3.3.2 处理No  Session</h3><p>在处理父子表中经常出现No Session</p>
<h4 id="3321-解决原理"><a href="#3-3-2-1-解决原理" class="headerlink" title="3.3.2.1 解决原理"></a>3.3.2.1 解决原理</h4><p>基于对Hibernate和JPA的理解，在ORM中，其为了提升性能使用了Lazy加载，就是在使用的时候，才会加载额外的数据，故导致了在使用之时再加载数据之时， session失效的问题出现。所以问题的目标点实现提前加载数据</p>
<h4 id="3322-方法"><a href="#3-3-2-2-方法" class="headerlink" title="3.3.2.2 方法"></a>3.3.2.2 方法</h4><p>查看hibernate配置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;current_session_context_class&quot;</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>In order to overcome this problem you could change the configuration of  session factory or open another session and only than ask for those lazy loaded objects. But what I would suggest here is to initialize this  lazy collection in getModelByModelGroup itself and call:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hibernate.initialize(subProcessModel.getElement()) </span><br></pre></td></tr></table></figure>
<p> <a href="https://www.zhihu.com/question/24863332/answer/48376158">AOP编程思想</a></p>
<p><a href="https://www.cnblogs.com/leotsai/p/hibernate-transaction-session-flush-commit-rollback.html">参考博客</a> <a href="https://www.kancloud.cn/wizardforcel/hibernate-doc/103753">hibernate中文文档</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习</title>
    <url>/post/f0242a65/</url>
    <content><![CDATA[<h1 id="jvm"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="一-基础原理jvm内存区域划分-类加载机制-自实现自定义类加载器"><a href="#一、基础原理：JVM内存区域划分、类加载机制、自实现自定义类加载器" class="headerlink" title="一、基础原理：JVM内存区域划分、类加载机制、自实现自定义类加载器"></a>一、基础原理：JVM内存区域划分、类加载机制、自实现自定义类加载器</h2><h3 id="1-何为jvm"><a href="#1-何为JVM" class="headerlink" title="1. 何为JVM"></a>1. 何为JVM</h3><p>三个问题</p>
<ul>
<li><p>JVM和操作系统的关系：</p>
<ul>
<li>C++直接在操作系统上运行编译后的二进制文件</li>
<li>Java新增一个处于程序和操作系统中间层的虚拟机（JVM）：抽象程度高</li>
<li>JVM约等于操作系统；Java字节码约等于汇编语言</li>
<li>JAVA -&gt; java字节码 -&gt; JVM -&gt; 操作系统函数</li>
<li>JVM上承开发语言，下接操作系统，中间接口是字节码</li>
</ul>
</li>
<li><p>JVM\JRE\JDK的关系</p>
<ul>
<li>JVM需要别人提供 .class文件</li>
<li>JRE：Java Runtime Environment Java运行时环境 = 基本类库+JVM标准</li>
<li>JDK：Java Development Kit = JRE + 好用小工具(Javac java jar)</li>
</ul>
</li>
<li><p>JVM虚拟机规范和Java语言规范的关系</p>
<ul>
<li><p>Java        -&gt;  Java语言规范<br>————-Java 字节码————<br>Hotspot VM  -&gt;  Java虚拟机规范</p>
</li>
<li><p>两者没有必然的联系，但是要提高代码效率，需要了解一些执行层面的指示</p>
</li>
<li><p>了解JVM用于调优+故障排查，可以<strong>掌握运行中的各种资源分配</strong></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/JVM1.drawio.png?raw=true" alt="JVM1.drawio.png"></p>
<ul>
<li>为什么Java研发系统需要JVM<ul>
<li>JVM解释的是类似于汇编语言的字节码，需要一个抽象的运行时环境<br>同时，这个虚拟环境也需要解决字节码加载、自动垃圾回收、并发等一系列问题<br>JVM其实是一个规范，定义了class文件的结构、加载机制、数据存储、运行时栈等诸多内容<br>最常用的JVM实现就是Hotspot</li>
</ul>
</li>
<li>JVM的运行原理<ul>
<li>JVM生命周期跟JAVA程序运行一样，当程序运行结束，JVM实例也跟着消失了</li>
</ul>
</li>
<li>JAVA代码如何运行的<ul>
<li>Java文件 -&gt; 编译器 -&gt; 字节码 -&gt; JVM -&gt; 机器码</li>
</ul>
</li>
</ul>
<h3 id="2-jvm内存管理-理解"><a href="#2-JVM内存管理-理解" class="headerlink" title="2.  JVM内存管理 理解"></a>2.  JVM内存管理 理解</h3><h4 id="21-jvm的内存区域是如何高效划分的"><a href="#2-1-JVM的内存区域是如何高效划分的" class="headerlink" title="2.1 JVM的内存区域是如何高效划分的"></a>2.1 JVM的内存区域是如何高效划分的</h4><ul>
<li>问：为什么要问JVM的内存区域划分？</li>
<li>答：JAVA最引以为豪的就是其自动内存管理机制，相比于C++手动内存管理、难以理解的指针</li>
</ul>
<p>JVM内存布局：<strong>静态成员变量；动态成员变量；区域变量；短小紧凑的对象声明；庞大复杂的内存声明</strong></p>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/JVM%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.drawio.png?raw=true" alt="JVM内存布局.drawio.png"></p>
<ul>
<li>JVM堆中的数据共享，</li>
<li>执行引擎：可以执行字节码的模块</li>
<li>执行引擎在线程切换时如何恢复？ 用程序计数器</li>
<li>JVM的内存划分与多线程息息相关， 如程序运行时用的栈、本地方法栈，其维度都是线程</li>
<li>本地内存包含元数据区和一些直接内存</li>
</ul>
<h4 id="22-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2 虚拟机栈"></a>2.2 虚拟机栈</h4><p>栈里的每条数据，就是<strong>栈帧</strong></p>
<p>线程的生命历程同栈帧：在每个Java方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了</p>
<p>每个栈帧都包含四个区域：</p>
<ol>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接</li>
<li>返回地址</li>
</ol>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/%E8%99%9A%E6%8B%9F%E6%A0%88%E5%B8%A71.drawio.png?raw=true" alt></p>
<h4 id="23-程序计数器"><a href="#2-3-程序计数器" class="headerlink" title="2.3 程序计数器"></a>2.3 程序计数器</h4><ul>
<li>问：若我们的程序在线程之间切换，如何指导这个线程执行到什么地方了</li>
<li>答：需要有个地方对线程运行到的点位进行<strong>缓冲记录</strong>。用<strong>程序计数器</strong></li>
</ul>
<p>程序计数器是一块较小的内存空间</p>
<p>其作用可以看做是当前线程所指新的字节码的行号指示器，即存的是<strong>当前线程执行的进度</strong></p>
<p>包括：指令、跳转、分支、循环、异常处理、线程恢复</p>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A81.drawio.png?raw=true" alt="程序计数器1.drawio.png"></p>
<h4 id="24-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h4><p><img src="https://github.com/ShortPupil/VPicture/blob/main/%E5%A0%861.drawio.png?raw=true" alt="堆1.drawio.png"></p>
<p>java包括 基本数据类型、普通对象</p>
<ul>
<li>对7种基本数据类型，有两种情况</li>
<li>对普通对象，JVM会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。如把这个引用保存在虚拟机栈的局部变量表</li>
</ul>
<h4 id="25-元空间"><a href="#2-5-元空间" class="headerlink" title="2.5 元空间"></a>2.5 元空间</h4><ul>
<li>问：为什么有Metaspace区域？它有什么问题？</li>
<li>在Java8之前，这些类的信息是放在一个叫<strong>Perm区</strong>的内存里面的<br>更早版本，甚至String.intern相关的运行时常量池也放在这里<br>这个区域有<strong>大小限制</strong>，很容易造成<strong>JVM内存溢出</strong>，从而造成JVM崩溃</li>
<li>方法区，作为一个概念，依然存在<br>它的<strong>物理存储的容器</strong>，就是Metaspace<br>这个区域存储的内容，包括：<strong>类的信息、常量池、方法数据、方法代码</strong></li>
</ul>
<h4 id="26-其他"><a href="#2-6-其他" class="headerlink" title="2.6 其他"></a>2.6 其他</h4><ul>
<li>问：我们常说的字符串常量，存放在哪呢？</li>
<li><p>答：由于常量池，在java7之后，放到了堆中，我们创建的字符串，将会在堆上分配</p>
</li>
<li><p>问：堆、非堆、本地内存 之间的关系</p>
</li>
<li><p>答：堆——软绵绵，松散而有弹性，也就是数据密度低，而非堆——紧凑、数据密度高</p>
</li>
<li><p>JVM的<strong>运行时区域</strong>是<strong>栈</strong>，而<strong>存储区域</strong>是<strong>堆</strong>，很多变量，其实在编译期就已经固定了</p>
</li>
</ul>
<h3 id="3-jvm的类加载机制"><a href="#3-JVM的类加载机制" class="headerlink" title="3. JVM的类加载机制"></a>3. JVM的类加载机制</h3><h4 id="31-三个问题"><a href="#3-1-三个问题" class="headerlink" title="3.1 三个问题"></a>3.1 三个问题</h4><ol>
<li><strong>我们能够通过一定的手段，覆盖HashMap类的实现么？</strong></li>
<li><strong>有哪些地方打破了Java的类加载机制？</strong></li>
<li><strong>如何加载一个远程的。class文件？怎样加密。class文件？</strong> ： 实现新的类加载器</li>
</ol>
<h4 id="32-类加载过程"><a href="#3-2-类加载过程" class="headerlink" title="3.2 类加载过程"></a>3.2 类加载过程</h4><p>​                                                    linking<br>加载loading -&gt; (验证verifying -&gt; 准备preparing -&gt; 解析resolving) -&gt; 初始化initiallsing</p>
<ul>
<li><p>加载：<br>加载的主要作用是将外部的.class文件，加载到Java的方法区内<br>加载阶段主要是<strong>找到</strong>并<strong>加载</strong>类的二进制数据，比如从jar包里或者war包里找到它们</p>
</li>
<li><p>验证<br>肯定<strong>不能任何 .class文件都能加载</strong>，那样太不安全了，容易受到恶意代码的攻击<br>验证阶段在虚拟机整个类加载过程中占了很大一部分，不符合规范的将抛出java.lang.VerifyError错误<br>像一些低版本的JVM,是无法加载一些高版本的类库的，就是在这个阶段完成的</p>
</li>
<li><p>准备<br>从这部分开始，将为一些类变量分配内存，并将其初始化为默认值<br>此时，实例对象还没有分配内存，所以这些动作是在方法区上进行的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a); <span class="comment">// 输出0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        System.out.println(a); <span class="comment">// 无法通过编译</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**因为局部变量不像类变量那样存在准备阶段</span></span><br><span class="line"><span class="comment">  *类变量有两次赋初始值的过程</span></span><br><span class="line"><span class="comment">  *1. 准备阶段，赋予初始值 （可以是指定值）</span></span><br><span class="line"><span class="comment">  *2. 初始化阶段，赋予城御园定义的值*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解析<br>解析在类加载中是非常非常重要的一环，是将符号引用替换为直接引用的过程<br><strong>符号引用是一种定义</strong>，可以是任何字面上的含义，而<strong>直接引用就是直接指向目标的指针、相对偏移量</strong><br>经常发生的异常，与解析阶段有关</p>
<ul>
<li>java.lang.NoSuchFieldError根据继承关系从下往上，找不到相关字段时的报错</li>
<li>java.lang.lllegalAccessError字段或者方法，访问权限不具备时的错误</li>
<li>java.lang.NoSuchMethodError找不到相关方法时的错误</li>
</ul>
</li>
<li><p>初始化<br>如果前面的流程一切顺利的话，接下来该初始化成员变量了<br>到了这一步，才真正开始执行一些字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">        b=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出内容：1 0</span></span><br><span class="line"><span class="comment">// a b唯一的区别就是他们的static代码块的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b=b+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无法通过编译：static语句块，只能访问到定义在static语句块之前的变量</span></span><br></pre></td></tr></table></figure>
<p>JVM会保证在子类的初始化方法执行之前，父类的初始化方法已经执行完毕（父类&gt;子类）</p>
<p>JVM第一个被执行的类初始化方法一定是java,lang.Object；也意味着父类中定义的static语句块要优先于子类</p>
</li>
<li><p>问：<code>&lt;cinit&gt;</code> 方法 和<code>&lt;init&gt;</code>方法有什么区别？</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    A ab = <span class="keyword">new</span> B();</span><br><span class="line">    ab = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出： 1 a 2 b 2 b</span></span><br><span class="line"><span class="comment">// static 在&lt;cinit&gt; 类加载阶段就已经执行，且只会执行一次</span></span><br><span class="line"><span class="comment">// &lt;init&gt; 在对象初始化阶段执行，且每次对象初始化都会执行一次</span></span><br></pre></td></tr></table></figure>
<h4 id="33-类加载器"><a href="#3-3-类加载器" class="headerlink" title="3.3 类加载器"></a>3.3 类加载器</h4><ul>
<li>问：类加载器是如何保证整个过程（类加载过程）的<strong>安全性</strong>？ 类不能被轻易覆盖，否则会被恶意攻击</li>
<li>答：利用 严格的等级制度</li>
</ul>
<p>包括（从父到子）</p>
<ul>
<li>Bootstrap ClassLoader<br>加载器中的大boss，任何类的加载行为，都要经它过问<br>作用是加载核心类库，也就是rt.jar、resources..jar、charsets.jar等<br>这些jar包的路径是可以指定的<br>-Xbootclasspath参数可以完成指定操作<br>这个加载器是C++编写的，随着JVM启动</li>
<li>Extention ClassLoader<br>扩展类加载器，主要用于加载 lib/ext 目录下的jar包和。class文件<br>同样的，通过系统变量java.ext.dirs可以指定这个目录<br>这个加载器是个Java类，继承自URLClassLoader</li>
<li>App classLoader<br>Java类的默认加载器，有时也叫作System ClassLoader<br>一般用来加载classpath下的其他所有jar包和。class文件<br>我们写的代码，会<strong>首先尝试使用</strong>这个类加载器进行加载</li>
<li>Custom ClassLoader<br>自定义加载器，支持一些个性化的扩展功能</li>
<li><img src="https://github.com/ShortPupil/VPicture/blob/main/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.drawio.png?raw=true" alt="双亲委派机制.drawio.png"></li>
</ul>
<p><strong>双亲委派机制</strong></p>
<ul>
<li><p>双亲委派机制的意思是<strong>除了顶层的启动类加载器以外</strong><br>其余的类加载器，在加载之前，都会委派给它的父加载器进行加载<br>这样<strong>一层层向上传递</strong>，<strong>直到祖先们都无法胜任</strong>，它才会真正的加载</p>
</li>
<li><p>java类有一定的优先级层次划分机制，如果没有双亲委派模型，就会导致多个类加载情形，导致混乱</p>
</li>
</ul>
<p><strong>打破双亲委派机制的情况</strong></p>
<ol>
<li><p>tomcat：使用shared类加载器实现共享和分离</p>
</li>
<li><p>SPI：SPI机制(Service Provider Interface)，是Java提供的一套用来被第三方实现或者扩展的API。可以用来启用框架扩展和替换组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>) <span class="comment">// 用于加载所需要的驱动类</span></span><br><span class="line">mysql-connector-java-<span class="number">8.0</span><span class="number">.15</span>.jar!/META-INF/services/java.sql.Driver <span class="comment">//路径</span></span><br><span class="line">com.mysql.cj.jdbc.Driver <span class="comment">//内容</span></span><br></pre></td></tr></table></figure>
<p>“基于接口的编程十策略模式+配置文件” 组合实现的动态加载机制；<br>主要使用<code>java,util.ServiceLoader</code>类进行动态装载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     接口调用</span><br><span class="line">使用方 -&gt; 标准服务接口 -&gt; 接口实现类A 接口实现类B</span><br><span class="line">               本地服务发现服务加载</span><br></pre></td></tr></table></figure>
</li>
<li><p>OSGI : 曾经非常流行，Eclipse使用OSGi作为插件系统的基础<br>OSGI是服务平台的规范，旨在用于需要长运行时间、动态更新和对运行环境破坏最小的系统<br>随着jigsaw的发展(<strong>旨在为Java SE平台设计、实现一个标准的模块系统</strong>)<br>个人认为，现在的OSGi，意义已经不是很大了<br>只需要知道有<strong>这么个复杂的东西实现了模块化</strong>，<strong>每个模块可以独立安装、启动、停止、卸载</strong>，就可以了 </p>
</li>
</ol>
<h4 id="34-如何替换jdk的类"><a href="#3-4-如何替换JDK的类" class="headerlink" title="3.4 如何替换JDK的类"></a>3.4 如何替换JDK的类</h4><ul>
<li>以HashMap为例<br>当Java的原生API不能满足需求时<br>比如我们要修改HashMap类，就必须要使用到<strong>Java的endorsed技术</strong>——我们需要<strong>将自己的HashMap类，打包成一个jar包，然后放到-Djava.endorsed.dirs指定的目录中</strong>。注意类名和包名，应该和JDK自带的是一样的<br>但是，java.lang包下面的类除外，因为这些都是特殊保护的。而<strong>双亲委派机制，是无法直接在应用中替换JDK的原生类的</strong>。但是<strong>有时候又不得不进行一下增强、替换</strong><br>比如你想要调试一段代码，或者比Java团队早发现了一个Bug<br>所以，<strong>Java提供了endorsed技术，用于替换这些类</strong><br>这个目录下的jar包，会比rt,jar中的文件，优先级更高，可以被最先加载到</li>
</ul>
<h3 id="4-从栈帧看字节码如何在jvm中流转"><a href="#4-从栈帧看字节码如何在JVM中流转" class="headerlink" title="4. 从栈帧看字节码如何在JVM中流转"></a>4. 从栈帧看字节码如何在JVM中流转</h3><h4 id="41-三个问题"><a href="#4-1-三个问题" class="headerlink" title="4.1 三个问题"></a>4.1 三个问题</h4><ol>
<li>怎么查看字节码文件？</li>
<li>字节码文件长什么样子？</li>
<li>对象初始化之后，具体的字节码如何执行？</li>
</ol>
<h4 id="42-两个字节码查看工具"><a href="#4-2-两个字节码查看工具" class="headerlink" title="4.2 两个字节码查看工具"></a>4.2 两个字节码查看工具</h4><ul>
<li><p><strong>javap</strong>是 JDK自带的反解析工具<br>作用是将 .class字节码文件解析成可读的文件格式<br>javac中可以指定一些额外的内容输出到字节码，常用的有：<br><code>javac-g:lines</code> 强制生成LineNumberTable<br><code>javac-g:vars</code> 强制生成LocalVariableTable<br><code>javac-g</code> 生成所有的debug信息</p>
<p><code>javav -p -v Helloworld</code></p>
</li>
<li><p><strong>jclasslib</strong>是一个图形化的工具，能够更加直观的查看字节码中的内容<br>分门别类的对类中的各个部分进行了整理，非常的人性化</p>
</li>
</ul>
<h4 id="43-一个例子"><a href="#4-3-一个例子" class="headerlink" title="4.3 一个例子"></a>4.3 一个例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">23456</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> text = <span class="keyword">this</span>.a + num;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b = <span class="keyword">new</span> B();  <span class="comment">// 此处触发B类的加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">long</span> num = <span class="number">65432</span>;</span><br><span class="line">        <span class="keyword">long</span> ret = a.b.test(num);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="https://github.com/ShortPupil/VPicture/blob/main/%E6%9F%A5%E7%9C%8B%E5%AD%97%E8%8A%82%E7%A0%81.drawio.png?raw=true" alt="查看字节码.drawio.png"></p>
<h2 id="二-垃圾回收理论为主"><a href="#二、垃圾回收：理论为主" class="headerlink" title="二、垃圾回收：理论为主"></a>二、垃圾回收：理论为主</h2><h3 id="1-oom相关问题"><a href="#1-OOM相关问题" class="headerlink" title="1. OOM相关问题"></a>1. OOM相关问题</h3><h4 id="11-gc-roots"><a href="#1-1-GC-Roots" class="headerlink" title="1.1 GC Roots"></a>1.1 GC Roots</h4><p><strong>JVM的GC动作是不受程序控制的，它会在满足条件的时候，自动触发</strong><br>发生GC的时候，一个对象，JVM总能够找到引用它的祖先<br>找到最后，<strong>如果发现这个祖先已经名存实亡了，它们都会被清理掉</strong><br>而<strong>能够躲过垃圾回收的那些祖先比较特殊，它们的名字就叫作GC Roots</strong></p>
<p>从GC Roots向下追溯、搜索，会产生一个叫作Reference Chain的链条<br>当一个对象不能和任何一个GC Root产生关系时，就会被无情的诛杀掉</p>
<p>GC Roots是<strong>一组必须活跃的引用</strong>,就是<strong>程序接下来通过直接引用或者间接引用，能够访问到的潜在被使用的对象</strong><br>包括：</p>
<ul>
<li>java线程中，当前所有正在被调用的方法的引用类型参数、局部变量、临时值等.也就是与我们栈帧相关的各种引用</li>
<li>所有当前被加载的Java类</li>
<li>Java类的引用类型静态变量</li>
<li>运行时常量池里的引用类型常量(String或Class类型</li>
<li>JVM内部数据结构的一些引用，比如sun.jvm.hotspot.memory.Universe类</li>
<li>用于同步的监控对象，比如调用了对象的wait0方法</li>
<li>JNI handles,包括global handles和local handles</li>
</ul>
<p>因此主要分为三大类</p>
<ol>
<li><strong>活动线程的相关引用</strong></li>
<li><strong>类的静态变量的引用</strong></li>
<li><strong>JNI引用</strong></li>
</ol>
<p>注意</p>
<ol>
<li>这里说的是活跃的引用，而不是对象，对象是不能作为GC Roots的</li>
<li>GC过程是<strong>找出所有活对象，并把其余空间认定为“无用”</strong>；而不是找出所有死掉的对象，并回收它们占用的空间。所以，哪怕JVM的堆非常的大，基于tracing的GC方式，回收速度也会非常快。</li>
</ol>
<h4 id="12-引用级别"><a href="#1-2-引用级别" class="headerlink" title="1.2 引用级别"></a>1.2 引用级别</h4><blockquote>
<p>问：<strong>弱引用有什么用处</strong></p>
</blockquote>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/GC%20Roots.drawio.png?raw=true" alt="GC Roots.drawio.png"></p>
<p>其关系可以分为 <strong>强引用、软引用、弱引用、虚引用</strong>…… </p>
<ul>
<li><p>强引用Strong references<br>当内存空间不足，系统撑不住了，JVM就会抛出OutOfMemoryError错误<br><strong>即使程序会异常终止，这种对象也不会被回收</strong><br>这种引用属于最普通最强硬的一种存在，<strong>只有在和GC Roots断绝关系时，才会被消灭掉</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">Object o = <span class="keyword">new</span> Object(); </span><br><span class="line"><span class="keyword">static</span> Map&lt;User, <span class="keyword">long</span>&gt; userVisitMap = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">userVisitMap.put(user, time);  <span class="comment">//由于它被userVisitMap引用，我们没有其他手段remove掉它，这个时就发生了内存泄漏(memory leak)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>软引用Soft references<br>在<strong>内存足够的时候，软引用对象不会被回收</strong>，<strong>只有在内存不足时，系统则会回收软引用对象</strong><br>如果<strong>回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong><br>这种特性非常适合用在<strong>缓存技术</strong>上。比如网页缓存、图片缓存等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">Object object = <span class="keyword">new</span> Object(); </span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> SoftReference(object);</span><br><span class="line"><span class="comment">// 同时可以设置每MB堆空闲空间中SoftReference的存活时间，这个值默认时间是1s=1000</span></span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB = &lt;N&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用Weak references<br>弱引用对象相比较软引用，要更加无用一些，它拥有更短的生命周期<br>在Java中，用java.lang.ref.WeakReference类来表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">Object object = <span class="keyword">new</span> Object（）;</span><br><span class="line">WeakReference&lt;Object&gt;<span class="function">softRef new <span class="title">WeakReference</span><span class="params">(object)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚引l用Phantom References<br>主要用来跟踪对象被垃圾回收的活动<br>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象之前，把这个虚引用加入到<br>与之关联的引用队列中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚引用的实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startMonitoring</span><span class="params">(ReferenceQueue&lt;MyObject&gt;referenceQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">Reference&lt;MyObject&gt;ref)</span></span>&#123;</span><br><span class="line">    ExecutorService ex Executors.newSingleThreadExecutor();</span><br><span class="line">    ex.execute(()-&gt;&#123;</span><br><span class="line">    	<span class="keyword">while</span> (referenceQueue.poll()!=ref)&#123;</span><br><span class="line">    		<span class="comment">//don&#x27;t hang forever</span></span><br><span class="line">    		<span class="keyword">if</span>(finishFlag)</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   		 System.out.println(<span class="string">&quot;--ref gc&#x27;ed--&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    ex.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="13-oom场景"><a href="#1-3-OOM场景" class="headerlink" title="1.3 OOM场景"></a>1.3 OOM场景</h4><p>  <img src="https://github.com/ShortPupil/VPicture/blob/main/JVM%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.drawio.png?raw=true" alt="JVM内存布局.drawio.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区域</th>
<th>是否线程私有</th>
<th>是否会发生OOM</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序计数器</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>方法区</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>直接内存</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>堆</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<p> 典型的OOM场景如图</p>
<p>不要为了方便把对象到处引用。即使引用了，也要正在合适的时机手动清理。</p>
<h4 id="14-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><ul>
<li>GC Roots的专业叫法，<strong>可达性分析法</strong>。另外，还有一种叫作引用计数法的方式，在判断对象的存活问题上，经常被提及。遍历所有的可达对象，这个过程即为标记</li>
<li>因为有循环依赖的硬伤，现在主流的JVM,没有一个是采用引用计数法来实现GC的，所以大体了解一下就可以</li>
<li>引用计数法是在对象头里维护一个counter计数器，被引用一次数量+1，引用失效记数-1。计数器为0时，就被认为无效</li>
</ul>
<h3 id="2-垃圾回收机制"><a href="#2-垃圾回收机制" class="headerlink" title="2. 垃圾回收机制"></a>2. 垃圾回收机制</h3><p>JVM是有<strong>专门的线程</strong>在做这件事情，当内存空间达到一定条件时，会<strong>自动触发</strong><br>这个过程就叫作GC。负责GC的组件，就叫作垃圾回收器</p>
<ul>
<li>JVM中有哪些垃圾回收算法？它们各自有什么优劣？</li>
<li>CMS垃圾回收器是怎么工作的？有哪些阶段？</li>
<li>服务卡顿的元凶到底是谁？</li>
</ul>
<ol>
<li>几种重要回收算法</li>
<li>分代垃圾回收的内存划分和GC过程</li>
<li>当前JVM中几种常见的垃圾回收期</li>
</ol>
<p>本节重点知识记录</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>算法</th>
<th>分代</th>
<th>名词</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mark</td>
<td>年轻代</td>
<td>weak generational hypothesis</td>
</tr>
<tr>
<td>Sweep</td>
<td>Survivor</td>
<td>分配担保</td>
</tr>
<tr>
<td>Copy</td>
<td>Eden</td>
<td>提升</td>
</tr>
<tr>
<td>Compact</td>
<td>老年代</td>
<td>卡片标记</td>
</tr>
<tr>
<td></td>
<td>GC: Minor GC、Major GC</td>
<td>STW</td>
</tr>
</tbody>
</table>
</div>
<h4 id="21-复制-标记-清除-标记整理"><a href="#2-1-复制、标记-清除、标记整理" class="headerlink" title="2.1 复制、标记-清除、标记整理"></a>2.1 复制、标记-清除、标记整理</h4><p><img src="https://github.com/ShortPupil/VPicture/blob/main/%E6%A0%87%E8%AE%B0.PNG?raw=true" alt="标记.PNG"></p>
<ul>
<li><p>灰色结点被清除</p>
</li>
<li><p>申请了| 1k | 2k | 3k | 4k | 5k |，由于某种原因，2k和4k的内存不再使用，就要交给垃圾回收器回收</p>
</li>
<li><p>在程序设计中，一般遇到扩缩容或者碎片整理问题时，<strong>复制算法</strong>都是非常有效的<br>比如：HashMap的扩容也是使用同样的思路，Redis的rehash也是类似的</p>
</li>
<li><p><img src="https://github.com/ShortPupil/VPicture/blob/main/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.PNG?raw=true" alt="复制算法.PNG"></p>
</li>
<li><pre><code class="lang-java">/**整理算法例子*/
last = 0;
for(i=0;i&lt;mems.length;i++)&#123;
    if(mems[i] != null)&#123;
        mems[last++]=mems [i];
        changeReference(mems[last]);
    &#125;
&#125;
clear(mems,last,mems.length);
// 以上情况只是一个理想状态。对象的引用关系一般都是非常复杂的
// 从效率上来说，一般整理算法是要低于复制算法的
</code></pre>
</li>
<li><ol>
<li><p>·复制算法(Copy)<br>复制算法是所有算法里面效率最高的，缺点是会造成一定的空间浪费</p>
</li>
<li><p>标记-清除(Mark-Sweep)<br>效率一般，缺点是会造成内存碎片问题</p>
</li>
<li><p>标记-整理(Mark-Compact)<br>效率比前两者要差，但没有空间浪费，也消除了内存碎片问题</p>
<p>没有最优算法，只有最合适的算法</p>
</li>
</ol>
</li>
</ul>
<h4 id="22-分代"><a href="#2-2-分代" class="headerlink" title="2.2 分代"></a>2.2 分代</h4><ul>
<li><p>弱代假设 weak generational hypothesis</p>
<p>JVM是<strong>计算节点</strong>，而不是存储节点<br>研究表明，大部分对象，可以分为两类：1.大部分对象的生命周期都很短；2.其他对象则很可能会存活很长时间。即大部分死的快，其他的活的长</p>
</li>
<li><p><strong>年轻代</strong> Young generation</p>
<ul>
<li><strong>复制算法</strong></li>
<li>*|to (Survivor0)|from (Survivor 1)| Edge(TLAB1) (TLAB2)(TLAB3)…(TLABn)|</li>
<li>分为一个伊甸园空间，两个幸存者空间</li>
<li>当年轻代中的Eden区分配满时，就会触发<strong>年轻代的GC (Minor GC)</strong></li>
<li>在Eden区执行了第一次GC之后，存活的对象会被移动到其中一个Survivor分区(以下简称from)</li>
<li>Eden区再次GC之后，存活的对象同样会被堆积在from上</li>
<li>如果GC之后from区已经满了，这时会采用复制算法，将Eden和from区一起清理。存活的对象会被复制到to区；接下来，只需要清空from区就可以了<br>所以在这个过程中，<strong>总会有一个Survivor分区是空置的</strong>。Eden、from、to的默认比例是8:1:1，所以只会造成10%的空间浪费。<strong>这个比例，是由参数-XX:SurvivorRatio进行配置的(默认为8)</strong></li>
<li>TLAB：Thread Local Allocation Buffer：<strong>JVM默认给每个线程开辟一个buffer区域，用来加速对象分配。</strong>这个buffer就放在Eden区中</li>
</ul>
</li>
<li><p><strong>老年代</strong> Tenured generation/Old generation</p>
<ul>
<li><p><strong>标记-清理、标记-整理算法</strong></p>
</li>
<li><p>老年代一般使用“标记-清除”、“标记整理”算法，因为老年代的对象存活率一般是比较高的。<strong>空间又比较大，拷贝起来并不划算，还不如采取就地收集的方式</strong></p>
</li>
<li><blockquote>
<p>问：对象怎么进入老年代呢？</p>
</blockquote>
</li>
<li><ol>
<li><p><strong>提升(Promotion)</strong><br>如果<strong>对象够老</strong>，会通过“提升”进入老年代<br>关于对象老不老，是<strong>通过它的年龄(age)来判断</strong>的。每当发生一次Minor GC,存话下来的对象年龄都会加1。直到达到一定的阈值，就会把这些“老顽固”给提升到老年代<br>这些对象如果变的不可达，直到老年代发生GC的时候，才会被清理掉<br>这个阈值，可以通过参数~XX:+MaxTenuringThreshold进行配置，最大值是l5,因为它是用4bit存储<br>的(所以网络上那些要把这个值调的很大的文章，是没有什么根据的)</p>
</li>
<li><p><strong>分配担保</strong></p>
<p>看一下年轻代的图，<strong>每次存活的对象，都会放入其中一个幸存区，这个区域默认的比例是10%</strong><br>但是<strong>我们无法保证每次存活的对象都小于10%，当Survivor空间不够，就需要依赖其他内存（指老年代）进行分配担保</strong><br>这个时候，对象也会直接在老年代上分配</p>
</li>
<li><p><strong>大对象直接在老年代分配</strong><br>超出某个大小的对象将直接在老年代分配。这个值是通过参数-X:PretenureSizeThreshold进行配置的，默认为0，意思是<strong>全部首选Eden区进行分配</strong></p>
</li>
<li><p><strong>动态对象年龄判定</strong><br>有的垃圾回收算法，并不要求age必须达到15才能晋升到老年代，它会使用一些<strong>动态的计算方法</strong>（一般不受外部控制）如果<strong>幸存区中相同年龄对象大小的和，大于幸存区的一半，大于或等于ag的对象</strong>将会直接进入老年代</p>
</li>
</ol>
</li>
<li><p>卡片标记</p>
</li>
<li><blockquote>
<p>对象的引用关系是一个巨大的网状。有的对象可能在Ede区，有的可能在老年代，那么这种<strong>跨代的引用是如何处理的呢</strong>？<br>由于Minor GC是单独发生的，如果一个老年代的对象引用了它，<strong>如何确保能够让年轻代的对象存活呢</strong>？</p>
<p>对于是、否的判断，通常都会用Bitmap（位图）和布隆过滤器来加快搜索的速度</p>
</blockquote>
<ul>
<li>JVM也是用了类似的方法。其实，<strong>老年代是被分成众多的卡页(card page)的(一般数量是2的次幂)</strong><br><strong>卡表(Card Table)就是用于标记卡页状态的一个集合</strong>，每个卡表项对应一个卡页<br>如果年轻代有对象分配，而且老年代有对象指向这个新对象，那么这个老年代对象所对应内存的卡页就会标识为dirty,卡表只需要非常小的存储空间就可以保留这些状态<br><strong>垃圾回收时，就可以先读这个卡表，进行快速判断</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>图总结：</p>
</li>
<li><p><strong>Minor GC</strong>：发生在年轻代的GC<br><strong>Major GC</strong>：发生在老年代的GC<br><strong>Full GC</strong>：全堆垃圾回收，比如Metaspace区引起年轻代和老年代的回收</p>
</li>
<li><p><img src="https://github.com/ShortPupil/VPicture/blob/main/HotSpot%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.PNG?raw=true" alt="HotSpot垃圾回收器.PNG"></p>
</li>
</ul>
<h4 id="23-垃圾回收器"><a href="#2-3-垃圾回收器" class="headerlink" title="2.3 垃圾回收器"></a>2.3 垃圾回收器</h4><p>年轻代垃圾回收器</p>
<ol>
<li><strong>Serial垃圾收集器</strong><br>处理GC的只有一条线程，并且在垃圾回收的过程中暂停一切用户线程<br>这可以说是<strong>最简单</strong>的垃圾回收器。因为简单，所以高效它通常用在<strong>客户端应用</strong>上。因为客户端应用不会频繁创建很多对象，用户也不会感觉出明显的卡顿。相反，它使用的资源更少，也更轻量级</li>
<li>ParNew垃圾收集器<br>ParNew是Serial的多线程版本，由<strong>多条GC线程并行地进行垃圾清理，清理过程依然要停止用户线程</strong><br>ParNew<strong>追求“低停顿时间”</strong>，与Serial唯一区别就是使用了多线程进行垃圾收集，在多CPU环境下性<br>能比Serial会有一定程度的提升<br>但线程切换需要<strong>额外的开销，因此在单CPU环境中表现不如Serial</strong></li>
<li><strong>Parallel Scavenge垃圾收集器</strong><br>另一个多线程版本的垃圾回收器。它与ParNew的主要区别是：<ul>
<li>Parallel Scavenge: 追求<strong>CPU吞吐量</strong>，能够在较短时间内完成指定任务，<strong>适合没有交互的后台计算</strong><br><strong>弱交互强计算</strong></li>
<li>ParNew:追求降低用户停顿时间，<strong>适合交互式应用，强交互弱计算</strong></li>
</ul>
</li>
</ol>
<p>老年代垃圾回收期</p>
<ol>
<li><p>Serial Old垃圾收集器<br>与年轻代的Serial垃圾收集器对应，都是单线程版本，同样适合客户端使用</p>
<ul>
<li>年轻代的Serial,使用复制算法</li>
<li>老年代的Old Serial,使用标记-整理算法</li>
</ul>
</li>
<li><p>Parallel Old<br>Parallel Old收集器是Parallel Scavenge的老年代版本，追求CPU吞吐量</p>
</li>
</ol>
<p><strong>CMS垃圾收集器</strong></p>
<ul>
<li>CMS(Concurrent Mark Sweep)收集器是<strong>以获取最短GC停顿时间为目标</strong>的收集器，它在垃圾收集时<br>使得用户线程和GC线程能够并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。<br>长期来看，CMS垃圾回收器，是要被G1等垃圾回收器替换掉的。在Java8之后，使用它将会抛出一个警告</li>
<li>全称Mostly Concurrent Mark and Sweep Garbage Collector（主要并发标记清除垃圾收集器）<br>设计目标是<strong>避免在老年代GC时出现长时间的卡顿</strong>（但它并不是一个老年代回收器）<br>使用的是<strong>Sweep</strong>而不是Compact,所以它的主要问题是<strong>碎片化</strong><br>随着JVM的长时间运行，<strong>碎片化会越来越严重，只有通过Full GC才能完成整理</strong></li>
</ul>
<p>垃圾回收器的相关命令</p>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%9F%E5%91%BD%E4%BB%A4.PNG?raw=true" alt="垃圾回收期命令.PNG"></p>
<p>线上使用最多的垃圾回收器：就有<strong>CMS</strong>和<strong>G1</strong>，以及Java8默认的<strong>Parallel Scavenge</strong></p>
<ul>
<li>CMS的设置参数：-XX:+UseConcMarkSweepGC</li>
<li>Java8的默认参数：-XX:+UseParallelGC</li>
<li>Java13的默认参数：-XX:+UseG1GC</li>
</ul>
<h4 id="24-stw-stop-the-world"><a href="#2-4-STW-Stop-the-world" class="headerlink" title="2.4 STW Stop the world"></a>2.4 STW Stop the world</h4><p>为了保证程序不会乱套，最好的办法就是暂停用户的一切线程<br>也就是在这段时间，你是不能new对象的，只能等待<br>表现在JVM上就是<strong>短暂的卡顿，什么都干不了</strong>，这个头疼的现象，就叫作Stop the world,简称STW</p>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/STW.PNG?raw=true" alt="STW.PNG"></p>
<p>例子：某个高并发服务的峰值流量是10万/秒，后面有10台负载均衡的机器，每台机器平均下来需要1万/秒。假设某台机器发生了STW持续了1秒，本来10ms就能返回10万个请求，此时需要等待1秒。在用户那里的表现就是会卡顿，而且GC频繁卡顿则会十分明显。</p>
<p>1.<strong>年轻代是GC的重灾区，大部分对象活不到老年代</strong><br>2.面试经常问，都是些非常朴素的原理<br>3.为后面对G1和ZGC的介绍打下基础</p>
<h3 id="3-cms-不太会"><a href="#3-CMS-不太会" class="headerlink" title="3. CMS 不太会"></a>3. CMS 不太会</h3><h4 id="31-cms回收过程"><a href="#3-1-CMS回收过程" class="headerlink" title="3.1 CMS回收过程"></a>3.1 CMS回收过程</h4><ol>
<li><p><strong>初始标记(Initial Mark)</strong><br>初始标记阶段，<strong>只标记直接关联GC Root的对象</strong>，不用向下追溯。因为最耗时的就在tracing阶段，这样就<strong>极大地缩短了初始标记时间</strong></p>
</li>
<li><p><strong>并发标记(Concurrent Mark)</strong><br>在初始标记的基础上，进行并发标记。这一步骤主要是tracinng的过程，用于标记所有可达的对象。这个过程会持续比较长的时间，但却<strong>可以和用户线程并行</strong><br>在这个阶段的执行过程中，可能会产生很多变化：</p>
<p>​    有些对象，从新生代晋升到了老年代<br>​    有些对象，直接分配到了老年代<br>​    老年代或者新生代的对象引用发生了变化</p>
</li>
<li><p><strong>并发预清理(Concurrent Preclean)</strong><br>并发预清理也是<strong>不需要STW</strong>的，目的是为了让重新标记阶段的STW尽可能短。这个时候，<strong>老年代中被标记为dity的卡页中的对象，就会被重新标记，然后清除掉dity的状态</strong><br>由于这个阶段也是可以并发的，在执行过程中引用关系依然会发生一些变化<br>我们可以假定这个清理动作是第一次清理。所以重新标记阶段，有可能还会有处于dity状态的卡页</p>
</li>
<li><p><strong>并发可取消的预清理(Concurrent Abortable Preclean)</strong><br>因为重新标记是需要STW的，所以会有很多次预清理动作<br>并发可取消的预清理，顾名思义，在满足某些条件的时候可以终止，比如迭代次数、有用工作量、消耗的系统时间等。<strong>这个阶段是可选的</strong>。<br>换句话说，<strong>这个阶段是“并发预清理”阶段的一种优化</strong>：第一个意图，是避免回扫年轻代的大量对象；另外一个意图，就是当满足最终标记的条件时，自动退出</p>
</li>
<li><p><strong>最终标记(Final Remark)</strong><br>通常CMS会尝试在年轻代尽可能空的情况下运行Final Remark阶段，以免接连多次发生STW事件。这是CMS垃圾回收阶段的第二次STW阶段，目标是完成老年代中所有存活对象的标记。<br>我们前面多轮的preclean阶段，一直在和应用线程玩追赶游戏，<strong>有可能跟不上引用的变化速度</strong>。本轮的标记动作就需要STW来处理这些情况<br><strong>如果预处理阶段做的不够好，会显著增加本阶段的STW时间</strong>。CMS垃圾回收器把回收过程分了多个部分，而影响最大的不是STW阶段本身，而是它之前的预处理动作</p>
</li>
<li><p><strong>并发清除(Concurrent Sweep)</strong><br>此阶段用户线程被重新激活，目标是删掉不可达的对象，并回收它们的空间<br>由于CMS并发清理阶段用户线程还在运行中，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃<br>圾出现在标记过程之后，CMS无法在当次GC中处理掉它们，只好留待下一次GC时再清理掉<br>这一部分垃圾就称为“浮动垃圾”</p>
</li>
<li><p><strong>并发重置(Concurrent Reset)</strong><br>此阶段与应用程序并发执行，重置CMS算法相关的内部数据，为下一次GC循环做准备</p>
</li>
</ol>
<h4 id="32-内存碎片"><a href="#3-2-内存碎片" class="headerlink" title="3.2 内存碎片"></a>3.2 内存碎片</h4><p>由于CMS在执行过程中，用户线程还需要运行，那就需要保证有充足的内存空间供用户使用<br>如果等到老年代空间快满了，再开启这个回收过程，用户线程可能会产生“Concurrent Mode Failure”<br>的错误，这时会临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了(STW)<br>当老年代的使用率达到70%，就会触发GC了<br>如果你的系统老年代增长不是太快，可以调高这个参数，降低内存回收的次数</p>
<p>CMS提供了两个参数来解决这个问题：</p>
<ol>
<li>UseCMSCompactAtFullCollection（默认开启），表示在要进行Full GC的时候，进行内存碎片整理<br>内存整理的过程是无法并发的，所以停顿时间会变长</li>
<li>CMSFullGCsBeforeCompaction,每隔多少次不压缩的Full GC后，执行一次带压缩的Full GC<br>默认值为0，表示每次进入Full GC时都进行碎片整理</li>
</ol>
<h4 id="33-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h4><p>总结一下CMS中都会有哪些停顿(STW)</p>
<ol>
<li>初始标记，这部分的停顿时间较短</li>
<li>Minor GC（可选），在预处理阶段对年轻代的回收，停顿由年轻代决定</li>
<li>重新标记，由于preclaen阶段的介入，这部分停顿也较短</li>
<li>Serial-Old收集老年代的停顿，主要发生在预留空间不足的情况下，时间会持续很长</li>
<li>Full GC,永久代空间耗尽时的操作，由于会有整理阶段，持续时间较长<br>在发生GC问题时，你一定要明确发生在哪个阶段，然后对症下药。<strong>gclog</strong>通常能够非常详细的表现这个过程</li>
</ol>
<p>长期来看，CMS垃圾回收器，是要被G1等垃圾回收器替换掉的。</p>
<h3 id="4-g1问题"><a href="#4-G1问题" class="headerlink" title="4. G1问题"></a>4. G1问题</h3><blockquote>
<p>G1的回收原理是什么？为什么G1比传统GC回收性能好？</p>
<p>为什么G1如此完美仍然会有ZGC?</p>
</blockquote>
<p>在发生Minor GC时，由于Survivor区已经放不下了，多出的对象只能提升(promotion)到老年代。但是此时老年代因为空间碎片的缘故，会发生concurrent mode failure的错误。这时就需要降级为Serail Old垃圾回收器进行收集。<br>这就是比concurrent mode failure更加严重的<strong>promotion failed问题</strong></p>
<h4 id="41-g1-的kpi思路-和-特点"><a href="#4-1-G1-的KPI思路-和-特点" class="headerlink" title="4.1 G1 的KPI思路 和 特点"></a>4.1 G1 的KPI思路 和 特点</h4><ul>
<li><p>G1的思路：它不要求每次都把垃圾清理的干干净净，它只是努力做它认为对的事情。我们要求G1<strong>,在任意1秒的时间内，停顿不得超过10ms</strong>,这就是在给它制定KPI<br><strong>G1会尽量达成这个目标，它能够推算出本次要收集的大体区域，以增量的方式完成收集</strong><br>这也是使用G1垃圾回收器不得不设置的一个参数：<strong>-XX:MaxGCPauseMillis=10</strong></p>
</li>
<li><p>G1(全称<strong>GarbageFirst GC</strong>)的目标是用来干掉CMS的，它同样是一款软实时垃圾回收器。相比CMS,G1的使用更加人性化。<br>比如CMS垃圾回收器的相关参数有72个，而G1的参数只有26个</p>
</li>
<li><p>为了达成上面制定的KPI,它和前面介绍的垃圾回收器，<strong>在对堆的划分上有一些不同</strong>（问题）<br>一小份区域的大小是固定的，名字叫作<strong>小堆区(Region)</strong>。小堆区可以是Eden区，也可以是Survivor区，还可以是Old区，所以G1的<strong>年轻代</strong>和<strong>老年代</strong>的概念都是<strong>逻辑</strong>上的。<br>每一块Region,大小都是一致的，它的数值是在1M到32M字节之间的一个2的幂值数</p>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/G1%E5%88%86%E5%8C%BA.PNG?raw=true" alt="G1分区.PNG"></p>
</li>
</ul>
<h4 id="42-g1的垃圾回收过程"><a href="#4-2-G1的垃圾回收过程" class="headerlink" title="4.2 G1的垃圾回收过程"></a>4.2 G1的垃圾回收过程</h4><p><strong>逻辑上</strong>，G1分为年轻代和老年代。但它的年轻代和老年代比例，并不是那么“固定”。为了达到MaxGCPauseMillis所规定的效果，G1会自动调整两者之间的比例<br>G1的回收过程主要分为<strong>3类</strong>：</p>
<ol>
<li>G1<strong>“年轻代”的垃圾回收，同样叫Minor GC</strong>, 这个过程和我们前面描述的类似，发生时机就是Eden区满的时候。</li>
<li>老年代的垃圾收集，严格上来说其实不算是收集，它是一个<strong>“并发标记”</strong>的过程，顺便清理了一点点对象。</li>
<li>真正的清理，发生在<strong>“混合模式”，</strong>它不止清理年轻代，还会将老年代的一部分区域进行清理</li>
</ol>
<h4 id="43-rset"><a href="#4-3-RSet" class="headerlink" title="4.3 RSet"></a>4.3 RSet</h4><p>RSet是一个空间换时间的数据结构。与Card Table有些不同的地方</p>
<ul>
<li>Card Table是一种<strong>points-out</strong>（我引用了谁的对象）的结构</li>
<li>RSet<strong>记录了其他Region中的对象引用本Region中对象的关系</strong>，属于<strong>points-into</strong>结构</li>
<li>对于年轻代的Region,RSet只保存了来自老年代的引用，是因为年轻代的回收是针对所有年轻代Region的，没必要画蛇添足。所以说年轻代Region的RSet有可能是空的。</li>
<li>RSt通常会占用很大的空间，大约5%或者更高，不仅仅是空间方面，很多计算开销也是比较大的。为了维护RSet,程序运行的过程中，写入某个字段就会产生一个post-write barrier</li>
<li>为了减少这个开销，将内容放入RSt的过程是异步的，而且经过了很多的优化：Write Barrier把脏卡信息存放到本地缓冲区(local buffer),有专门的GC线程负责收集，并将相关信息传给被引用Region的RSet</li>
<li>参数<code>-XX:G1ConcRefinementThreads</code>或者<code>-XX:ParallelGCThreads</code>可以控制这个异步的过程。如果并发优化线程跟不上缓冲区的速度，就会在用户进程上完成</li>
</ul>
<h4 id="44-g1具体回收过程-不会"><a href="#4-4-G1具体回收过程-不会" class="headerlink" title="4.4 G1具体回收过程 不会"></a>4.4 G1具体回收过程 不会</h4><p><strong>年轻代的收集</strong>包括下面的回收阶段：</p>
<ol>
<li>扫描根<br>根，可以看作是我们前面介绍的GC Roots,加上RSet记录的其他Region的外部引用</li>
<li>更新RS<br>处理dirty card queue中的卡页，更新Rset<br>此阶段完成后，RSt可以准确的反映老年代对所在的内存分段中对象的引用，可以看作是第一步的补充</li>
<li>处理RS<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象</li>
<li>复制对象<br>这个阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的Region<br>这个过程和其他垃圾回收算法一样，包括对象的年龄和晋升</li>
<li>处理引用<br>处理Soft、Weak、Phantom、Final、.JNI Weak等引用，结束收集</li>
</ol>
<p>具体标记过程</p>
<ol>
<li><p>初始标记(Initial Mark)<br>这个过程共用了Minor GC的暂停，这是因为它们可以复用root scan操作<br>虽然是STW的，但是时间通常非常短。</p>
</li>
<li><p>Root区扫描(Root Region Scan)</p>
</li>
<li><p>并发标记(Concurrent Mark)<br>这个阶段从GC Roots开始对heap中的对象标记，标记线程与应用程序线程并行执行<br>并且收集各个Region的存活对象信息。</p>
</li>
<li><p>重新标记(Remaking)<br>和CMS类似，也是STW的。标记那些在并发标记阶段发生变化的对象。</p>
</li>
<li><p>清理阶段(Cleanup)<br>这个过程不需要STW,如果发现Region里全是垃圾，在这个阶段会立马被清除掉<br>不全是垃扔的Region:并不会被立马处理，它会在Mixed GC阶段，进行收集</p>
<p><strong>混合回收(Mixed GC)</strong><br>能并发清理老年代中的整个整个的小堆区是一种最优情形<br>混合收集过程，不只清理年轻代，还会将一部分老年代区域也加入到CSt中<br>通过Concurrent Marking阶段，我们已经统计了老年代的垃圾占比<br>在Minor GC之后，如果判断这个占比达到了某个阈值，下次就会触发Mixed GC.。这个阈值，由-XX:G1HeapWastePercent参数进行设置(默认是堆大小的5%)。因为这种情况下，GC会花费很多的时间但是回收到的内存却很少<br>所以这个参数也是可以调整Mixed GC的频率的<br>还有参数G1MixedGCCountTarget,用于控制一次并发标记之后，最多执行Mixed GC的次数</p>
</li>
</ol>
<h4 id="5-zgc"><a href="#5-ZGC" class="headerlink" title="5. ZGC"></a>5. ZGC</h4><p>在系统切换到G1垃圾回收器之后，线上发生的严重GC问题已经非常少了<br>这归功于<strong>G1的预测模型和它创新的分区模式</strong><br>但预测模型也会有失效的时候。它并不是总如我们期望的那样运行，尤其是你给它定下一个苛刻的目标之后<br>另外，<strong>如果应用的内存非常吃紧，对内存进行部分回收根本不够始终要进行整个Heap的回收，那么G1要做的工作量就一点也不会比其他垃圾回收器少</strong><br><strong>而且因为本身算法复杂了，还可能比其他回收器要差</strong></p>
<p>最新的ZGC垃圾回收器，就有3个令人振奋的Flag:<br>1.停顿时间不会超过10ms<br>2.停顿时间不会随着堆的增大而增大(不管多大的堆都能保持在10s以下)<br>3.可支持几百M,甚至几T的堆大小(最大支持4T)</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器</title>
    <url>/post/58b717aa/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="java容器分类"><a href="#java容器分类" class="headerlink" title="java容器分类"></a>java容器分类</h2><p><strong>Collection</strong></p>
<ul>
<li>List</li>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector</li>
<li><ul>
<li>Stack</li>
</ul>
</li>
<li>Set</li>
<li>HashSet</li>
<li><ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
<p><strong>Map</strong></p>
<ul>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
<li>ConcurrentHashMap</li>
<li>Hashtable</li>
</ul>
<h2 id="最常使用的list-set-map的区别"><a href="#最常使用的List、Set、Map的区别" class="headerlink" title="最常使用的List、Set、Map的区别"></a>最常使用的List、Set、Map的区别</h2><h3 id="collection-和-map-的区别"><a href="#Collection-和-Map-的区别" class="headerlink" title="Collection 和 Map 的区别"></a>Collection 和 Map 的区别</h3><p>容器内每个为之所存储的元素个数不同。</p>
<p>Collection类型，每个位置只有一个元素。</p>
<p>Map类型，持有 key-value pair，强调映射关系。</p>
<h3 id="各自的子类关系"><a href="#各自的子类关系" class="headerlink" title="各自的子类关系"></a>各自的子类关系</h3><p>Collection<br>​     - List：将以特定次序存储元素。所以取出来的顺序可能和放入顺序不同。<br>​          - ArrayList<br>​          - LinkedList<br>​          - Vector<br>​     - Set ： 不能含有重复的元素<br>​                    - HashSet<br>​                    - TreeSet</p>
<h3 id="其他特征"><a href="#其他特征" class="headerlink" title="其他特征"></a>其他特征</h3><p>List，Set，Map将持有对象一律视为Object。</p>
<p>Collection、List、Set、Map都是接口，不能实例化。继承自它们的 ArrayList, Vector, HashTable, HashMap是具象class，这些才能被实例化。</p>
<h2 id="map的辨析"><a href="#Map的辨析" class="headerlink" title="Map的辨析"></a>Map的辨析</h2><h3 id="hashmap和treemap的取舍"><a href="#HashMap和TreeMap的取舍" class="headerlink" title="HashMap和TreeMap的取舍"></a>HashMap和TreeMap的取舍</h3><p>这是在使用map时经常要考虑的，方法原则就是</p>
<ul>
<li><strong>插入、删除、定位一个元素</strong>——HashMap更能体现map的映射关系</li>
<li><strong>对一个key集合进行有序的遍历</strong>——TreeMap 效率更高</li>
</ul>
<h3 id="hashset的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h3><p>HashSet本身是基于HashMap实现，底层使用HashMap保存全部元素，基本是直接调用底层HashMap的方法。具体可见以下代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是<strong>HashSet不允许元素重复，HashMap中Key值必须唯一，value可重复</strong>。以下代码说明原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 将添加到此set中的元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果此 set 中尚未包含指定元素，则添加指定元素。如果此 set 已包含该元素，则该调用不更改 set 并返回false。但底层<strong>实际将该元素作为 key 放入 HashMap</strong>。新添加的 Entry 的 value 会将覆盖原来 Entry 的 value（HashSet 中的 value 都是<code>PRESENT</code>），但 key 不会有任何改变，因此如果向 HashSet 中添加一个已经存在的元素时，新添加的集合元素将不会被放入 HashMap中，<strong>原来的元素也不会有任何改变</strong>，这也就满足了 Set 中元素<strong>不重复</strong>的特性。</p>
<h2 id="list辨析"><a href="#List辨析" class="headerlink" title="List辨析"></a>List辨析</h2><h3 id="arraylist和linkedlist"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h3><ul>
<li><p>ArrayList是实现了基于<strong>动态数组</strong>的数据结构，而LinkedList是基于<strong>链表</strong>的数据结构；</p>
</li>
<li><p>对于<strong>随机访问get和set</strong>，ArrayList要优于LinkedList，因为LinkedList要移动指针；</p>
</li>
<li><p>对于添加和删除操作add和remove，在<strong>非首尾的增加的操作</strong>，LinkedList要比ArrayList快，因为ArrayList要移动数据。</p>
</li>
</ul>
<h3 id="数据与list之间的转化"><a href="#数据与List之间的转化" class="headerlink" title="数据与List之间的转化"></a>数据与List之间的转化</h3><ul>
<li>数组转List：使用Arrays.asList(array)进行转换</li>
<li>List转数组：使用List自带的toArray()方法</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="iterator是什么"><a href="#Iterator是什么" class="headerlink" title="Iterator是什么"></a>Iterator是什么</h3><p>Iterator提供遍历任何Collection的接口。</p>
<h3 id="iterator的特点"><a href="#Iterator的特点" class="headerlink" title="Iterator的特点"></a>Iterator的特点</h3><p><strong>更加安全</strong>，因为可以确保在当前遍历的集合原色被更改时，就会抛出ConcurrentModificationException异常。</p>
<h3 id="iterator和listiterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h3><ul>
<li>Iterator可以遍历Set和List集合，ListIterator只能遍历List</li>
<li>Iterator只能<strong>单向</strong>遍历， ListIterator可以<strong>双向（向前/后）遍历</strong></li>
<li>ListIterator从Iterator中继承，并添加了一些额外的功能</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/SpeedMe/article/details/22398395">List、Set、Map的区别</a> </p>
<p><a href="http://wiki.jikexueyuan.com/project/java-collection/hashset.html">HashSet的实现原理</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程实战 第16章 Java内存模型</title>
    <url>/post/8e8c1241/</url>
    <content><![CDATA[<h2 id="1-为什么需要内存模型"><a href="#1-为什么需要内存模型" class="headerlink" title="1. 为什么需要内存模型"></a>1. 为什么需要内存模型</h2><p>Java语言规范要求JVM在线程中维护一种类似<strong>串行</strong>的语义：只要程序的最终结果与在严格串行环境中执行的结果相同，则上述操作都是允许的。</p>
<p>多线程环境中，维护程序的串行性会导致很大的<strong>性能开销</strong>。只有当多个线程要共享数据时，才必须协调它们之间的操作，并且JVM依赖程序通过同步操作来找到这些协调操作将在何处发生。</p>
<h3 id="11-平台的内存模型"><a href="#1-1-平台的内存模型" class="headerlink" title="1.1 平台的内存模型"></a>1.1 平台的内存模型</h3><p>不同处理器拥有自己的缓存，并且定期和主内存进行协调。</p>
<p>不同级别的缓存一致性（Cache Coherence）</p>
<p>为了使java开发人员无需关心不同架构上内存模型之间的差异，java还<strong>提供了自己的内存模型</strong>，并且<strong>JVM通过在适当的位置上插入内存栅栏</strong>来屏蔽在JMM与底层平台内存模型之间的差异。</p>
<p>程序执行一种简单假设：想象在程序中只存在唯一的操作执行顺序，而不考虑这些操作在何种处理器上执行，并且每次读取变量时，都能获得<strong>在执行序列中最近一次写入该变量的值</strong>。——串行一致性，但现代多处理器架构中不提供</p>
<p>跨线程共享数据时，出现的问题，需要通过使用<strong>内存栅栏</strong>来防止。而Java程序不需要指定内存栅栏的位置，只需通过<strong>正确地使用同步来找出何时将访问共享状态</strong>。</p>
<h3 id="12-重排序"><a href="#1-2-重排序" class="headerlink" title="1.2 重排序"></a>1.2 重排序</h3><p>如果在程序中没有包含足够的同步，可能产生起卦的结果，错误实例——可能由重排序导致的交替执行方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PossibleRecording</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>, y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="function">Thread one new <span class="title">Thread</span><span class="params">(new Runnable()</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">               a = <span class="number">1</span>;</span><br><span class="line">               x = b;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">Thread other new <span class="title">Thread</span><span class="params">(new Runnable()</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">               b = <span class="number">1</span>;</span><br><span class="line">               y = a;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        one.start(); other.start();</span><br><span class="line">        one.join(); other.join();</span><br><span class="line">        System.out.println(x + <span class="string">&quot;,&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能发成内存级的重排序。</p>
<h3 id="13-java内存模型简介"><a href="#1-3-Java内存模型简介" class="headerlink" title="1.3 Java内存模型简介"></a>1.3 Java内存模型简介</h3><p>JMM为程序中所有操作定义了一个偏序关系，称为<strong>Happens-Before</strong></p>
<ul>
<li><strong>程序顺序规则</strong>：如果<strong>程序中</strong>操作A在操作B之前，那么在<strong>线程中</strong>A将在B之前执行</li>
<li><strong>监视器锁规则</strong>：在监视器锁上的解锁操作必须在同一监视器锁上的加锁操作之前执行</li>
<li><strong>volatile变量规则</strong>：对volatile变量的写入操作必须在对该变量的读操作之前执行</li>
<li><strong>线程启动规则</strong>：在线程上对Thread.Start的调用必须在该线程中执行任何操作之前执行</li>
<li><strong>线程结束规则</strong>：线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行。</li>
<li><strong>中断规则</strong>：当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行</li>
<li><strong>终结器规则</strong>：对象的构造函数必须在启动该对象的终结期之前执行完成</li>
<li><strong>传递性</strong>：如果A在B之前执行，并且B在C之前执行，则A必须在C之前执行</li>
</ul>
<p><img src="https://gitee.com/songzi2625/resources/raw/master/image/Happens-Before.png" alt></p>
<h3 id="14-借助同步"><a href="#1-4-借助同步" class="headerlink" title="1.4 借助同步"></a>1.4 借助同步</h3>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高效代码例子</title>
    <url>/post/e157f0a1/</url>
    <content><![CDATA[<p>转自<a href="https://mp.weixin.qq.com/s/izVH7nVkQVpYbyJKN35uLA">阿里云云栖号_常意</a> </p>
<p>参考《重构》第3章，代码的坏味道</p>
<h2 id="1-常量amp变量"><a href="#1-常量-amp-变量" class="headerlink" title="1. 常量&amp;变量"></a>1. 常量&amp;变量</h2><h3 id="11-直接赋值常量值禁止声明新变量"><a href="#1-1-直接赋值常量值，禁止声明新变量" class="headerlink" title="1.1 直接赋值常量值，禁止声明新变量"></a>1.1 直接赋值常量值，禁止声明新变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">Long i = <span class="keyword">new</span> Long(<span class="number">1L</span>);</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">Long i = <span class="number">1L</span>;</span><br><span class="line">String s = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="12-当成员变量值无需改变时尽量定义为静态变量"><a href="#1-2-当成员变量值无需改变时，尽量定义为静态变量" class="headerlink" title="1.2 当成员变量值无需改变时，尽量定义为静态变量"></a>1.2 当成员变量值无需改变时，尽量定义为静态变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpConnection</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeout = <span class="number">5L</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpConnection</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> timeout = <span class="number">5L</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-尽量使用基本数据类型避免自动装箱和拆箱"><a href="#1-3-尽量使用基本数据类型，避免自动装箱和拆箱" class="headerlink" title="1.3 尽量使用基本数据类型，避免自动装箱和拆箱"></a>1.3 尽量使用基本数据类型，避免自动装箱和拆箱</h3><p>Java 中的基本数据类型double、float、long、int、short、char、boolean，分别对应包装类Double、Float、Long、Integer、Short、Character、Boolean。</p>
<p>JVM支持基本类型与对应包装类的自动转换，被称为自动装箱和拆箱。装箱和拆箱都是需要CPU和内存资源的，所以应尽量避免使用自动装箱和拆箱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">Integer sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] values = ...;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> value : values)&#123;</span><br><span class="line">    sum += value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] values = ...;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> value : values)&#123;</span><br><span class="line">    sum += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-如果变量的初值会被覆盖就没有必要给变量赋初值"><a href="#1-4-如果变量的初值会被覆盖，就没有必要给变量赋初值" class="headerlink" title="1.4 如果变量的初值会被覆盖，就没有必要给变量赋初值"></a>1.4 如果变量的初值会被覆盖，就没有必要给变量赋初值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">List&lt;UserDO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    userList = userDAO.queryActive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">List&lt;UserDO&gt; userList;</span><br><span class="line"><span class="keyword">if</span>(isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    userList = userDAO.queryActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-尽量使用函数内的基本类型临时变量"><a href="#1-5-尽量使用函数内的基本类型临时变量" class="headerlink" title="1.5 尽量使用函数内的基本类型临时变量"></a>1.5 尽量使用函数内的基本类型临时变量</h3><p>在函数内，基本类型的参数和临时变量都保存在栈（Stack）中，访问速度较快；对象类型的参数和临时变量的引用都保存在栈（Stack）中，内容都保存在堆（Heap）中，访问速度较慢。在类中，任何类型的成员变量都保存在堆（Heap）中，访问速度较慢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumlator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">double</span>[] values)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> value : values)&#123;</span><br><span class="line">            result += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumlator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> result = <span class="number">0.0D</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">double</span>[] values)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0.0D</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> value : values)&#123;</span><br><span class="line">            sum += value;</span><br><span class="line">        &#125;</span><br><span class="line">        result += sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-尽量不要在循环体外定义变量"><a href="#1-6-尽量不要在循环体外定义变量" class="headerlink" title="1.6 尽量不要在循环体外定义变量"></a>1.6 尽量不要在循环体外定义变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">UserVO userVO; <span class="comment">//不再循环体外定义变量</span></span><br><span class="line">List&lt;UserVO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; USERVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span>(UserDO userDO : userDOList)&#123;</span><br><span class="line">    userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVO.setId(userDO.getId());</span><br><span class="line">    ...</span><br><span class="line">    userVOList.add(userVO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">List&lt;UserVO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; USERVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span>(UserDO userDO : userDOList)&#123;</span><br><span class="line">    userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVO.setId(userDO.getId());</span><br><span class="line">    ...</span><br><span class="line">    userVOList.add(userVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-不可变的静态常量尽量使用非线程安全类"><a href="#1-7-不可变的静态常量，尽量使用非线程安全类" class="headerlink" title="1.7 不可变的静态常量，尽量使用非线程安全类"></a>1.7 不可变的静态常量，尽量使用非线程安全类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&gt; CLASS_MAP;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, Class&gt; classMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    classMap.put(<span class="string">&quot;VARCHAR&quot;</span>, java.lang.String.class);</span><br><span class="line">    ...</span><br><span class="line">    CLASS_MAP = Collection.unmodifiableMap(classMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&gt; CLASS_MAP;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, Class&gt; classMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    classMap.put(<span class="string">&quot;VARCHAR&quot;</span>, java.lang.String.class);</span><br><span class="line">    ...</span><br><span class="line">    CLASS_MAP = Collection.unmodifiableMap(classMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-不可变的成员变量尽量使用非线程安全类"><a href="#1-8-不可变的成员变量，尽量使用非线程安全类" class="headerlink" title="1.8 不可变的成员变量，尽量使用非线程安全类"></a>1.8 不可变的成员变量，尽量使用非线程安全类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Strategy&gt; strategyList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Strategy&gt; strategyMap;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(strategyList)) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = (<span class="keyword">int</span>) Math.ceil(strategyList.size() * <span class="number">4.0</span> / <span class="number">3</span>);</span><br><span class="line">            Map&lt;String, Strategy&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);  <span class="comment">//要使用非线程安全类</span></span><br><span class="line">            <span class="keyword">for</span>(Strategy strategy : strategyList)&#123;</span><br><span class="line">                map.put(strategy.getType, strategy);</span><br><span class="line">            &#125;</span><br><span class="line">            strategyMap = Collections.unmodifiableMap(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Strategy&gt; strategyList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Strategy&gt; strategyMap;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(strategyList)) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = (<span class="keyword">int</span>) Math.ceil(strategyList.size() * <span class="number">4.0</span> / <span class="number">3</span>);</span><br><span class="line">            Map&lt;String, Strategy&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(size);</span><br><span class="line">            <span class="keyword">for</span>(Strategy strategy : strategyList)&#123;</span><br><span class="line">                map.put(strategy.getType, strategy);</span><br><span class="line">            &#125;</span><br><span class="line">            strategyMap = Collections.unmodifiableMap(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-对象amp类"><a href="#2-对象-amp-类" class="headerlink" title="2. 对象&amp;类"></a>2. 对象&amp;类</h2><h3 id="21-禁止使用json转化对象"><a href="#2-1-禁止使用JSON转化对象" class="headerlink" title="2.1 禁止使用JSON转化对象"></a>2.1 禁止使用JSON转化对象</h3><p>影响性能！</p>
<p><del>我经常用json转换</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = JSON.parseArray(JSON.toJSONString(userDOList), UserVO.class); <span class="comment">//不要用json转换对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正例 老老实实赋值</span></span><br><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span>(UserDO userDO : userVOList)&#123;</span><br><span class="line">    UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    userVO.setId(userDO.getId());</span><br><span class="line">    ...</span><br><span class="line">    userVOList.add(userVO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//VO是new创建，GC回收。值对象，业务对象，用于业务层之间的数据传递</span></span><br><span class="line"><span class="comment">//PO是向数据库中添加数据时创建，删除数据库中数据时消除。有状态，每个属性代表当前状态，与数据库表字段对应。需要序列化接口。</span></span><br></pre></td></tr></table></figure>
<h3 id="22-尽量不适用反射赋值对象"><a href="#2-2-尽量不适用反射赋值对象" class="headerlink" title="2.2 尽量不适用反射赋值对象"></a>2.2 尽量不适用反射赋值对象</h3><p>影响性能！x2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">List&lt;UserVO&gt; userVOList = <span class="keyword">new</span> ArrayList&lt;&gt;(userDOList.size());</span><br><span class="line"><span class="keyword">for</span>(UserDO userDO : userVOList)&#123;</span><br><span class="line">    UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">    BeanUtils.copyProperties(userDO, userVO);<span class="comment">//不要用反射赋值</span></span><br><span class="line">    userVOList.add(userVO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例，同上</span></span><br></pre></td></tr></table></figure>
<h3 id="23-采用lambda表达式替换内部匿名类"><a href="#2-3-采用Lambda表达式替换内部匿名类" class="headerlink" title="2.3 采用Lambda表达式替换内部匿名类"></a>2.3 采用Lambda表达式替换内部匿名类</h3><p>Lambda表达式在大多数虚拟机中采用<code>invokeDynamic</code>指令实现，相对于匿名内部类在<strong>效率上会更高一些</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">List&lt;User&gt; userList = ...; </span><br><span class="line">Collections.sort(userList, <span class="keyword">new</span> Comparator&lt;User&gt;()&#123; <span class="comment">//匿名内部类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User user1, User user2)</span></span>&#123;</span><br><span class="line">        Long userId1 = user1.getId();</span><br><span class="line">        Long userId2 = user2.getId();</span><br><span class="line">        <span class="keyword">return</span> userId1.compareTo(userId2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">List&lt;User&gt; userList = ...; </span><br><span class="line">Collections.sort(userList, (user1, user2) -&gt; &#123; <span class="comment">//使用lambda表达式</span></span><br><span class="line">    Long userId1 = user1.getId();</span><br><span class="line">    Long userId2 = user2.getId();</span><br><span class="line">    <span class="keyword">return</span> userId1.compareTo(userId2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="24-避免不必要的子类定义"><a href="#2-4-避免不必要的子类定义" class="headerlink" title="2.4 避免不必要的子类定义"></a>2.4 避免不必要的子类定义</h3><p>原因：多一个类就多一份类加载</p>
<h3 id="25-尽量使用指定类的final修饰符"><a href="#2-5-尽量使用指定类的final修饰符" class="headerlink" title="2.5 尽量使用指定类的final修饰符"></a>2.5 尽量使用指定类的final修饰符</h3><p>原因：类指定了final修饰符以后，该类不可以被继承。类为final，则该类的所有方法都是final，<strong>Java编译器会寻找机会内联所有的final方法</strong>。内联对于提升Java运行效率作用重大。</p>
<p>注：使用Spring的AOP特性时，需要对Bean进行动态代理，如果bean类添加final修饰，会导致异常</p>
<h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="31-把跟类成员变量无关的方法声明成静态方法"><a href="#3-1-把跟类成员变量无关的方法声明成静态方法" class="headerlink" title="3.1 把跟类成员变量无关的方法声明成静态方法"></a>3.1 把跟类成员变量无关的方法声明成静态方法</h3><p>静态方法本质上就不在属于某个对象，属于它所在的类。只要通过类名就可以访问，<strong>不用消耗资源反复创建对象</strong>。</p>
<p>注：即使在类内部的私有方法，没有用到类成员变量，也应该声明为静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">(Date date)</span></span>&#123; <span class="comment">//声明为静态方法</span></span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    calendar.setTime(date);</span><br><span class="line">    <span class="keyword">return</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-尽量使用基本数据类型作为方法参数类型"><a href="#3-2-尽量使用基本数据类型作为方法参数类型" class="headerlink" title="3.2 尽量使用基本数据类型作为方法参数类型"></a>3.2 尽量使用基本数据类型作为方法参数类型</h3><p>原因：避免不必要的装箱、拆箱和空指针判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(Double value1, Double value2)</span></span>&#123; <span class="comment">//不必要的拆箱</span></span><br><span class="line">    <span class="keyword">double</span> double1 = Objects.isNull(value1) ? <span class="number">0.0D</span> : value1; <span class="comment">//不必要的空指针</span></span><br><span class="line">    <span class="keyword">double</span> double2 = Objects.isNull(value2) ? <span class="number">0.0D</span> : value2;</span><br><span class="line">    <span class="keyword">return</span> double1+double2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> result = sum(<span class="number">1.0D</span>, <span class="number">2.0D</span>) <span class="comment">//不必要的装箱</span></span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> value1, <span class="keyword">double</span> value2)</span></span>&#123; <span class="comment">//只改这一处，简洁很多，但有空指针的情况要格外注意</span></span><br><span class="line">    <span class="keyword">return</span> double1+double2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> result = sum(<span class="number">1.0D</span>, <span class="number">2.0D</span>) </span><br></pre></td></tr></table></figure>
<h3 id="33-尽量使用基本数据类型作为方法返回值类型"><a href="#3-3-尽量使用基本数据类型作为方法返回值类型" class="headerlink" title="3.3 尽量使用基本数据类型作为方法返回值类型"></a>3.3 尽量使用基本数据类型作为方法返回值类型</h3><p>原因同上</p>
<h3 id="34-协议方法参数值返回值非空避免不必要的空指针判断"><a href="#3-4-协议方法参数值-返回值非空，避免不必要的空指针判断" class="headerlink" title="3.4 协议方法参数值/返回值非空，避免不必要的空指针判断"></a>3.4 协议方法参数值/返回值非空，避免不必要的空指针判断</h3><p>协议编程，用@NonNull @Nullable标注参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="meta">@NonNull</span> UserDO user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(user.getIsValid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="35-被调用方法已支持判空处理调用方法无需再进行判空处理"><a href="#3-5-被调用方法已支持判空处理，调用方法无需再进行判空处理" class="headerlink" title="3.5 被调用方法已支持判空处理，调用方法无需再进行判空处理"></a>3.5 被调用方法已支持判空处理，调用方法无需再进行判空处理</h3><h3 id="36-尽量避免不必要的函数封装"><a href="#3-6-尽量避免不必要的函数封装" class="headerlink" title="3.6 尽量避免不必要的函数封装"></a>3.6 尽量避免不必要的函数封装</h3><p>原因：方法调用会引起出栈和入栈，消耗CPU和内存。但可以为了代码简洁易维护，增加方法调用而牺牲性能。</p>
<h3 id="37-尽量指定方法的final修饰符"><a href="#3-7-尽量指定方法的final修饰符" class="headerlink" title="3.7 尽量指定方法的final修饰符"></a>3.7 尽量指定方法的final修饰符</h3><p>原因，同类的原因。方法指定final修饰符，可以让方法不可以被重写，Java编译器会寻找机会内联所有的final方法。</p>
<p>注：所有的private方法会隐式地被指定final修饰符，所以无须再为其指定final修饰符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-表达式"><a href="#4-表达式" class="headerlink" title="4. 表达式"></a>4. 表达式</h2><h3 id="41-尽量减少方法的重复调用"><a href="#4-1-尽量减少方法的重复调用" class="headerlink" title="4.1 尽量减少方法的重复调用"></a>4.1 尽量减少方法的重复调用</h3><h3 id="42尽量避免不必要的方法调用"><a href="#4-2-尽量避免不必要的方法调用" class="headerlink" title="4.2.尽量避免不必要的方法调用"></a>4.2.尽量避免不必要的方法调用</h3><h3 id="43-尽量使用移位来代替正整数乘除"><a href="#4-3-尽量使用移位来代替正整数乘除" class="headerlink" title="4.3 尽量使用移位来代替正整数乘除"></a>4.3 尽量使用移位来代替正整数乘除</h3><p>原因：用移位操作可以极大地提高性能！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = a &lt;&lt; <span class="number">2</span>; <span class="comment">//乘4</span></span><br><span class="line"><span class="keyword">int</span> num2 = a &gt;&gt; <span class="number">2</span>; <span class="comment">//除4</span></span><br></pre></td></tr></table></figure>
<h3 id="44-提取公共表达式只计算一次值重复利用值"><a href="#4-4-提取公共表达式，只计算一次值，重复利用值" class="headerlink" title="4.4 提取公共表达式，只计算一次值，重复利用值"></a>4.4 提取公共表达式，只计算一次值，重复利用值</h3><h3 id="45-尽量不在条件表达式里用取反"><a href="#4-5-尽量不在条件表达式里用-取反" class="headerlink" title="4.5 尽量不在条件表达式里用!取反"></a>4.5 尽量不在条件表达式里用<code>!</code>取反</h3><h3 id="46对于多常量选择分支尽量使用switch语句而不是if-else语句"><a href="#4-6-对于多常量选择分支，尽量使用switch语句而不是if-else语句" class="headerlink" title="4.6.对于多常量选择分支，尽量使用switch语句而不是if-else语句"></a>4.6.对于多常量选择分支，尽量使用switch语句而不是if-else语句</h3><p>和面向对象原则不太一样。</p>
<p>原因：switch语句进行了跳转优化，Java中采用<code>tableswitch</code>或<code>lookupswitch</code>指令实现，对于多常量选择分支处理效率更高。</p>
<h2 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h2><h3 id="51-尽量不用正则表达式匹配"><a href="#5-1-尽量不用正则表达式匹配" class="headerlink" title="5.1 尽量不用正则表达式匹配"></a>5.1 尽量不用正则表达式匹配</h3><p>注意是匹配，用字符串匹配操作</p>
<h3 id="52-尽量使用字符替换字符串"><a href="#5-2-尽量使用字符替换字符串" class="headerlink" title="5.2 尽量使用字符替换字符串"></a>5.2 尽量使用字符替换字符串</h3><p>字符串长度不确定，而字符长度固定为1</p>
<h3 id="53-尽量使用stringbuilder进行字符串拼接"><a href="#5-3-尽量使用StringBuilder进行字符串拼接" class="headerlink" title="5.3 尽量使用StringBuilder进行字符串拼接"></a>5.3 尽量使用StringBuilder进行字符串拼接</h3><p>原因：String是final类，内容不可修改，所以每次字符串拼接都会生成一个新对象。StringBuilder在初始化时申请了一块内存，以后的字符串拼接都在这块内存中执行，不会申请新内存和生成新对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正例</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>( i != <span class="number">0</span>) sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="54-不要使用转化字符串建议使用stringvalueof"><a href="#5-4-不要使用””-转化字符串-建议使用String-valueOf" class="headerlink" title="5.4 不要使用””+转化字符串,建议使用String.valueOf."></a>5.4 不要使用””+转化字符串,建议使用String.valueOf.</h3><p>使用””+进行字符串转化，使用方便但是效率低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">12345</span>;</span><br><span class="line">String s = String.valueOf(i);</span><br></pre></td></tr></table></figure>
<h2 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h2><h3 id="61-不要使用循环拷贝数组"><a href="#6-1-不要使用循环拷贝数组" class="headerlink" title="6.1 不要使用循环拷贝数组"></a>6.1 不要使用循环拷贝数组</h3><p>尽量使用<code>System.arraycopy</code>拷贝数组，也可以使用<code>Arrays.copyOf</code>拷贝数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="keyword">int</span>[] sources = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] targets = <span class="keyword">new</span> <span class="keyword">int</span>[sources.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;targets.length ; i++)&#123;</span><br><span class="line">    targets[i] = sources[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="keyword">int</span>[] sources = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] targets = <span class="keyword">new</span> <span class="keyword">int</span>[sources.length];</span><br><span class="line">System.arraycopy(sources, <span class="number">0</span>, targets, <span class="number">0</span>, targets.length);</span><br></pre></td></tr></table></figure>
<h3 id="62-集合转化为类型t数组时尽量传入空数组t0"><a href="#6-2-集合转化为类型T数组时，尽量传入空数组T-0" class="headerlink" title="6.2 集合转化为类型T数组时，尽量传入空数组T[0]"></a>6.2 集合转化为类型T数组时，尽量传入空数组T[0]</h3><p>将集合转换为数组有2种形式：<code>toArray(new T[n])</code>和<code>toArray(new T[0])</code>。</p>
<p>原因：在旧的Java版本中，建议使用<code>toArray(new T[n])</code>，因为创建数组时所需的反射调用非常慢。在OpenJDK6后，反射调用是内在的，使得性能得以提高，<code>toArray(new T[0])</code>比<code>toArray(new T[n])</code>效率更高。此外，<code>toArray(new T[n])</code>比<code>toArray(new T[0])</code>多获取一次列表大小，如果计算列表大小耗时过长，也会导致<code>toArray(new T[n])</code>效率降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,...);</span><br><span class="line">Integer[] integers = integerList.toArray(<span class="keyword">new</span> Integer[integerList.size()]);</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,...);</span><br><span class="line">Integer[] integers = integerList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="63-集合转化为object数组时尽量使用toarray方法"><a href="#6-3-集合转化为Object数组时，尽量使用toArray-方法" class="headerlink" title="6.3 集合转化为Object数组时，尽量使用toArray()方法"></a>6.3 集合转化为Object数组时，尽量使用toArray()方法</h3><p>转化Object数组时，没有必要使用toArray[new Object[0]]，可以直接使用toArray()。避免了类型的判断，也避免了空数组的申请，所以效率会更高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; objectList =Arrays.asList(<span class="number">1</span>,<span class="string">&quot;2&quot;</span>,<span class="number">3</span>,<span class="string">&quot;4&quot;</span>,<span class="number">5</span>,...);</span><br><span class="line">Object[] objects = objectList.toArray();</span><br></pre></td></tr></table></figure>
<h2 id="7-集合"><a href="#7-集合" class="headerlink" title="7. 集合"></a>7. 集合</h2><h3 id="71-初始化集合时尽量指定集合大小"><a href="#7-1-初始化集合时，尽量指定集合大小" class="headerlink" title="7.1 初始化集合时，尽量指定集合大小"></a>7.1 初始化集合时，尽量指定集合大小</h3><p>原因：当默认大小不再满足数据需求时就会扩容，<strong>每次扩容的时间复杂度有可能是O(n)</strong>。所以，尽量指定预知的集合大小，就能避免或减少集合的扩容次数。</p>
<h3 id="72-不要用循环拷贝集合"><a href="#7-2-不要用循环拷贝集合" class="headerlink" title="7.2 不要用循环拷贝集合"></a>7.2 不要用循环拷贝集合</h3><p>原因：尽量使用JDK提供的方法拷贝集合，底层用<code>System.arraycopy</code>实现，进行数据的批量拷贝效率高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="keyword">for</span>(UserDO user1 : user1List) &#123;</span><br><span class="line">    userList.add(user1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">userList.addAll(user1List);</span><br></pre></td></tr></table></figure>
<h3 id="73-尽量使用arraysaslist转化数组为列表"><a href="#7-3-尽量使用Arrays-asList转化数组为列表" class="headerlink" title="7.3 尽量使用Arrays.asList转化数组为列表"></a>7.3 尽量使用Arrays.asList转化数组为列表</h3><h3 id="74-直接迭代需要使用的集合"><a href="#7-4-直接迭代需要使用的集合" class="headerlink" title="7.4 直接迭代需要使用的集合"></a>7.4 直接迭代需要使用的集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = ...;</span><br><span class="line"><span class="keyword">for</span>(Long userId : userMap.keySet())&#123;</span><br><span class="line">    <span class="comment">//用其他操作获取user</span></span><br><span class="line">    UserDO user = userMap.get(userId);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = ...;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Long, UserDO&gt; userEntry: userMap.entrySet())&#123;</span><br><span class="line">    Long userId = userEntry.getKey();</span><br><span class="line">    UserDO user = userMap.getValue();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="75-不要使用size方法检测空必须使用isempty方法检测空"><a href="#7-5-不要使用size方法检测空，必须使用isEmpty方法检测空" class="headerlink" title="7.5 不要使用size方法检测空，必须使用isEmpty方法检测空"></a>7.5 不要使用size方法检测空，必须使用isEmpty方法检测空</h3><p>原因：使用size方法来检测空逻辑上没有问题，但使用isEmpty方法使得代码<strong>更易读</strong>，并且可以获得更好的性能。任何isEmpty方法实现的时间复杂度都是O(1)，但是<strong>某些size方法实现的时间复杂度有可能是O(n)</strong>。</p>
<h3 id="76-非随机访问的list尽量使用迭代代替随机访问"><a href="#7-6-非随机访问的List，尽量使用迭代代替随机访问" class="headerlink" title="7.6 非随机访问的List，尽量使用迭代代替随机访问"></a>7.6 非随机访问的List，尽量使用迭代代替随机访问</h3><h3 id="77-尽量使用hashset判断值存在"><a href="#7-7-尽量使用HashSet判断值存在" class="headerlink" title="7.7 尽量使用HashSet判断值存在"></a>7.7 尽量使用HashSet判断值存在</h3><p>原因：在Java集合类库中，List的contains方法普遍时间复杂度是O(n)，而HashSet的时间复杂度为O(1)。</p>
<h3 id="78-避免先判断存在再进行获取"><a href="#7-8-避免先判断存在再进行获取" class="headerlink" title="7.8 避免先判断存在再进行获取"></a>7.8 避免先判断存在再进行获取</h3><p>原因：如果需要先判断存在再进行获取，可以直接获取并判断空，<strong>从而避免了二次查找操作</strong>。</p>
<h2 id="8-异常"><a href="#8-异常" class="headerlink" title="8. 异常"></a>8. 异常</h2><h3 id="81-避免在循环中捕获异常"><a href="#8-1-避免在循环中捕获异常" class="headerlink" title="8.1 避免在循环中捕获异常"></a>8.1 避免在循环中捕获异常</h3><p>原因：当循环体抛出异常后，<strong>无需循环继续执行</strong>（注意前提）时，没有必要在循环体中捕获异常。因为，过多的捕获异常会降低程序执行效率。</p>
<h3 id="82-禁止使用异常控制业务流程"><a href="#8-2-禁止使用异常控制业务流程" class="headerlink" title="8.2 禁止使用异常控制业务流程"></a>8.2 禁止使用异常控制业务流程</h3><p>原因：异常处理效率比条件表达式低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(UserDO user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(user.getIsValid());</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//用异常控制业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(UserDO user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(user)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(user.getIsValid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-缓冲区"><a href="#9-缓冲区" class="headerlink" title="9. 缓冲区"></a>9. 缓冲区</h2><h3 id="91-初始化时尽量指定缓冲区大小"><a href="#9-1-初始化时尽量指定缓冲区大小" class="headerlink" title="9.1 初始化时尽量指定缓冲区大小"></a>9.1 初始化时尽量指定缓冲区大小</h3><p>原因同数组指定缓冲区一样。</p>
<h3 id="92-尽量重复使用同一缓冲区"><a href="#9-2-尽量重复使用同一缓冲区" class="headerlink" title="9.2 尽量重复使用同一缓冲区"></a>9.2 尽量重复使用同一缓冲区</h3><p>针对缓冲区，Java虚拟机需要花时间生成对象，还要花时间进行垃圾回收处理。所以，尽量重复利用缓冲区。</p>
<h3 id="93-尽量使用缓冲流减少io操作"><a href="#9-3-尽量使用缓冲流减少IO操作" class="headerlink" title="9.3 尽量使用缓冲流减少IO操作"></a>9.3 尽量使用缓冲流减少IO操作</h3><p>使用缓冲流：</p>
<ul>
<li><p>BufferedReader</p>
</li>
<li><p>BufferedWriter</p>
</li>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>…</li>
</ul>
<p>可以大幅减少IO次数并提升IO速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">FileOutputStream output = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">BufferInputStream input = <span class="keyword">new</span> BufferInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">BufferOutputStream output = <span class="keyword">new</span> BufferOutputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;b&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="10-线程"><a href="#10-线程" class="headerlink" title="10. 线程"></a>10. 线程</h2><h3 id="101-在单线程中尽量使用非线程安全类"><a href="#10-1-在单线程中，尽量使用非线程安全类" class="headerlink" title="10.1 在单线程中，尽量使用非线程安全类"></a>10.1 在单线程中，尽量使用非线程安全类</h3><p>原因：避免不必要的同步开销</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="number">128</span>);</span><br><span class="line">buffer.append(<span class="string">&quot;select * from&quot;</span>).append(T_USER).append(<span class="string">&quot; where id = ?&quot;</span>);</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">StringBuilder buffer = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>); <span class="comment">//这是非线程安全类</span></span><br><span class="line">buffer.append(<span class="string">&quot;select * from&quot;</span>).append(T_USER).append(<span class="string">&quot; where id = ?&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="102-在多线程中尽量使用线程安全类"><a href="#10-2-在多线程中，尽量使用线程安全类" class="headerlink" title="10.2 在多线程中，尽量使用线程安全类"></a>10.2 在多线程中，尽量使用线程安全类</h3><p>原因：代码更简洁高效</p>
<h3 id="103-尽量减少同步代码块范围"><a href="#10-3-尽量减少同步代码块范围" class="headerlink" title="10.3 尽量减少同步代码块范围"></a>10.3 尽量减少同步代码块范围</h3><p>原因：在一个方法中，可能只有一小部分的逻辑是需要同步控制的，如果同步控制了整个方法会影响执行效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    ...<span class="comment">//一些非同步操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>（<span class="keyword">this</span>）&#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//一些非同步操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="104-尽量合并为同一同步代码块"><a href="#10-4-尽量合并为同一同步代码块" class="headerlink" title="10.4 尽量合并为同一同步代码块"></a>10.4 尽量合并为同一同步代码块</h3><p>同步代码块是有性能开销的，如果确定可以合并为同一同步代码块，就应该尽量合并为同一同步代码块。</p>
<h3 id="105-尽量使用线程池减少线程开销"><a href="#10-5-尽量使用线程池减少线程开销" class="headerlink" title="10.5 尽量使用线程池减少线程开销"></a>10.5 尽量使用线程池减少线程开销</h3><p>原因：多线程中两个必要的开销：线程的创建和上下文切换。采用线程池，可以尽量地避免这些开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService EXECUTOR_SERVICE = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">    executorService.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux分章重点——第一、二、三章</title>
    <url>/post/d525d77d/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="ch1-认识linux系统"><a href="#Ch1-认识Linux系统" class="headerlink" title="Ch1 认识Linux系统"></a>Ch1 认识Linux系统</h1><h2 id="内核的版本怎么命名的什么是发行版有哪些常见的发行版"><a href="#内核的版本，怎么命名的，什么是发行版，有哪些常见的发行版" class="headerlink" title="内核的版本，怎么命名的，什么是发行版，有哪些常见的发行版"></a>内核的版本，怎么命名的，什么是发行版，有哪些常见的发行版</h2><p>Linux的版本号分为两部分,即<strong>内核版本</strong>与<strong>发行版本</strong>。</p>
<h2 id="内核版本号"><a href="#内核版本号" class="headerlink" title="内核版本号"></a>内核版本号</h2><p>由3个数字组成:<code>r.x.y</code>。 </p>
<p><code>r</code>:目前发布的内核主版本。 </p>
<p><code>x</code>:偶数表示稳定版本;奇数表示开发版本。 </p>
<p><code>y</code>:错误修补的次数。 </p>
<h2 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h2><p>一些组织和厂家,将Linux系统的内核、应用软件和文档包装起来,并提供一些系统安装界面、系统配置设定管理工具,就构成了 Linux发行版本 。<br>相对于Linux操作系统内核版本，各发布厂商发行版本的版本号各不相同，与Linux系统内核的版本号是相对独立的。</p>
<h2 id="主流发行版"><a href="#主流发行版：" class="headerlink" title="主流发行版："></a>主流发行版：</h2><p>Mandriva、Red Hat、SUSE、Debian、Ubuntu、Red Flag</p>
<h1 id="ch2-fedora-17系统的安装和删除"><a href="#Ch2-Fedora-17系统的安装和删除" class="headerlink" title="Ch2 Fedora 17系统的安装和删除"></a>Ch2 Fedora 17系统的安装和删除</h1><p>分区方案好好看看，最少有几个分区，简单的分区方案，合理的分区方案，每一个分区是干什么的</p>
<h2 id="1分区命名方案"><a href="#1-分区命名方案" class="headerlink" title="1.分区命名方案"></a>1.分区命名方案</h2><p>Linux系统使用字母和数字的组合来指代硬盘分区</p>
<p>Linux系统使用一种更加灵活的命名方案, 该命名方案是基于文件的,文件名的格式为 <code>/dev/xxyN</code>, </p>
<p><code>/dev/</code>:这是Linux系统下所有设备文件所在的目录名。 </p>
<p><code>xx</code>:分区名的前两个字母表示分区所在设备的类型,通常是hd(IDE硬盘)或sd(SCSI硬盘)。 </p>
<p><code>y</code>:这个字母表示分区所在的设备。</p>
<p><code>N</code>:最后的数字N代表分区。<br>/dev/sda1     /dev/sda2</p>
<h2 id="2分区方案"><a href="#2．分区方案" class="headerlink" title="2．分区方案"></a>2．分区方案</h2><h3 id="1最简单的分区方案至少需要的分区"><a href="#1-最简单的分区方案（至少需要的分区）" class="headerlink" title="(1)最简单的分区方案（至少需要的分区）"></a>(1)最简单的分区方案（至少需要的分区）</h3><p>SWAP分区:即交换分区,建议大小是物理内存的1~2倍。</p>
<p>/分区:建议大小在10GB以上。</p>
<p>使用以上的分区方案,所有的数据都放在/分区上,对于系统来说不安全,数据不容易备份。 </p>
<h3 id="2合理的分区方案-6个注意swap没有且是大写"><a href="#2-合理的分区方案。6个，注意SWAP没有-且是大写" class="headerlink" title="(2)合理的分区方案。6个，注意SWAP没有/且是大写"></a>(2)合理的分区方案。6个，注意SWAP没有/且是大写</h3><p><code>/boot</code>分区:用来存放与Linux系统启动有关的程序,比如启动引导装载程序等,建议大小为100MB。 </p>
<p><code>/usr</code>分区:用来存放Linux系统中的应用程序,其相关数据较多,建议大于9GB。</p>
<p><code>/var</code>分区:用来存放Linux系统中经常变化的数据以及日志文件,建议大小为1GB。 </p>
<p><code>/</code>分区:Linux系统的根目录,所有的目录都挂在这个目录下面,建议大小为2GB。 </p>
<p><code>SWAP</code>分区:交换分区，实现虚拟内存,建议大小是物理内存的1~2倍。 </p>
<p><code>/home</code>分区:存放普通用户的数据,是普通用户的宿主目录,建议大小为剩下的空间。</p>
<h3 id="root的提示符-普通用户的提示符"><a href="#root的提示符、普通用户的提示符" class="headerlink" title="root的提示符、普通用户的提示符"></a>root的提示符、普通用户的提示符</h3><p>普通用户： <code>$</code>      </p>
<p>root用户： <code>#</code></p>
<p>切换为root用户：<code>su root</code></p>
<p>切换到普通用户it：<code>su – it</code></p>
<p>普通用户执行root用户才能的操作：<code>sudo 操作</code></p>
<h1 id="ch3-走进linux图形界面"><a href="#Ch3-走进Linux图形界面" class="headerlink" title="Ch3 走进Linux图形界面"></a>Ch3 走进Linux图形界面</h1><p>两种界面：图形化界面、字符界面</p>
<p>登录 关机 重启命令<br>如果需要以超级管理员（root）身份登录系统进行管理，在登录提示后输入用户名为“root”，按“回车”键后，在口令提示中输入安装时设置的根口令，然后按“回车”键即可。<br>在切断计算机电源之前必须首先关闭 Fedora 17系统。不执行关闭Fedora 17系统就 直接切断计算机的电源,会导致未存盘数据的丢失或者系统的损害。 </p>
<p>系统日志保存在哪个目录下</p>
<pre><code>一般保存在`/var/log`目录下
</code></pre><p>终端的命名tty pty pts</p>
<pre><code>`tty`：终端设备的统称

`pty`：虚拟终端

`pts`：pty的实现方式，与ptmx配合使用实现pty
</code></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux分章重点——第九、十、十一、十二章</title>
    <url>/post/1d5f1dc5/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="91-硬盘分区从分区到使用的步骤"><a href="#9-1-硬盘分区：从分区到使用的步骤" class="headerlink" title="9.1 硬盘分区：从分区到使用的步骤"></a>9.1 硬盘分区：从分区到使用的步骤</h3><ol>
<li>使用fdisk命令在硬盘上创建分区。 <code>fdisk -l /dev/sdb</code></li>
<li>使用mkfs命令在分区上创建文件系统。<code>mkfs -t ext4 /dev/sdb1</code></li>
<li>使用mount命令挂载文件系统，或修改/etc/fstab文件使得开机自动挂载文件系统<code>mount -o ro /dev/sdb1 /mnt/kk</code></li>
<li>使用umount卸载文件0系统。</li>
</ol>
<h3 id="92-挂载手动挂载-mnt-etcfstab"><a href="#9-2-挂载：手动挂载-mnt、etc-fstab" class="headerlink" title="9.2 挂载：手动挂载 mnt、etc/fstab"></a>9.2 挂载：手动挂载 mnt、etc/fstab</h3><p><strong>mount</strong>:mount 【选项】【设备名称】【挂载点】</p>
<p><strong>etc/fstab</strong>: </p>
<p>/dev/sda5    /mnt/kk    ext4     defaults     0     0</p>
<p>1行包含着1个设备或分区的信息。</p>
<p>第1列是设备名或者设备UUID+号</p>
<p>第2列是它的挂载点</p>
<p>第3列是它的文件系统格式</p>
<p>第4列是挂载参数</p>
<p>第5列是转储选项</p>
<p>第6列是文件系统检查选项。</p>
<h3 id="93-权限设定字符-数字"><a href="#9-3-权限设定：字符、数字" class="headerlink" title="9.3 权限设定：字符、数字"></a>9.3 权限设定：字符、数字</h3><h4 id="931-文字设定"><a href="#9-3-1-文字设定" class="headerlink" title="9.3.1 文字设定"></a>9.3.1 文字设定</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod [ugoa][+-=][rwx][文件或目录名]</span><br></pre></td></tr></table></figure>
<p>u表示该文件的所有者，g表示与该文件的所有者属于同一个组的用户，o表示其他用户，a表示以上三者；</p>
<p>+表示增加指定权限，-表示取消指定权限，=表示设定权限等于指定权限；</p>
<p>r表示可读取，w表示可写入，x表示表示文件可执行或目录可进入。</p>
<h4 id="932-数字设定"><a href="#9-3-2-数字设定" class="headerlink" title="9.3.2 数字设定"></a>9.3.2 数字设定</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [n1n2n3] [文件或目录名]</span><br></pre></td></tr></table></figure>
<p>使用数字设定法更改文件权限，首先必须了解数字表示的含义：0表示没有权限，1表示可执行权限，2表示写入权限，4表示读取权限，然后将其相加。所以数字属性的格式应为3个0～7的8进制数，其顺序是（u），（g），（o）。</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
<li>-:0</li>
</ul>
<p>example——对/root/ab文件设置权限，所有者为读取、写入和执行权限，同组用户<br>为读取和写入权限，而其他用户没有任何权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 760 /root/ab</span><br></pre></td></tr></table></figure>
<h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="101-rpm使用"><a href="#10-1-rpm使用" class="headerlink" title="10.1 rpm使用"></a>10.1 rpm使用</h3><h4 id="1011-安装"><a href="#10-1-1-安装" class="headerlink" title="10.1.1 安装"></a>10.1.1 安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh [RPM包文件名]</span><br></pre></td></tr></table></figure>
<h4 id="1012-卸载"><a href="#10-1-2-卸载" class="headerlink" title="10.1.2 卸载"></a>10.1.2 卸载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm –e [RPM包名称]</span><br></pre></td></tr></table></figure>
<h4 id="1013-查询"><a href="#10-1-3-查询" class="headerlink" title="10.1.3 查询"></a>10.1.3 查询</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm –q [RPM包名称] #查询指定软件包的详细信息</span><br><span class="line">rpm –qa #查询系统中所有已安装的RPM软件包</span><br><span class="line">rpm –qi [RPM包名称] #查询指定已安装软件包的描述信息</span><br><span class="line">rpm –ql [RPM包名称] #查询某已安装软件包所含的文件列表</span><br><span class="line">rpm –qR [RPM包名称] #查询软件包的依赖要求   </span><br><span class="line">rpm –qf [文件名] #查询系统中指定文件属于哪个软件包</span><br></pre></td></tr></table></figure>
<h4 id="1014-升级"><a href="#10-1-4-升级" class="headerlink" title="10.1.4 升级"></a>10.1.4 升级</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm –Uvh [RPM包文件名称] </span><br></pre></td></tr></table></figure>
<h3 id="102-tar使用"><a href="#10-2-tar使用" class="headerlink" title="10.2 tar使用"></a>10.2 tar使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar cvf 压缩包名称.tar 源文件/目录 #创建压缩</span><br><span class="line">tar xvf 压缩文件 #解压</span><br></pre></td></tr></table></figure>
<p>tar调用gzip、bzip2</p>
<h3 id="103-进程ps-kill"><a href="#10-3-进程：ps、kill" class="headerlink" title="10.3 进程：ps、kill"></a>10.3 进程：ps、kill</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps ax|grep less #查看less进程是否在运行。</span><br><span class="line">kill -9 5975 #强制杀死进程号是5975的进程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="104-任务计划cron分时日月周命令at在命令行上写或者-f文件脚本"><a href="#10-4-任务计划：cron“分时日月周”-命令；at在命令行上写，或者-f文件-脚本" class="headerlink" title="10.4 任务计划：cron“分时日月周”+命令；at在命令行上写，或者-f文件+脚本"></a>10.4 任务计划：cron“分时日月周”+命令；at在命令行上写，或者-f文件+脚本</h3><h4 id="1041-crontab"><a href="#10-4-1-crontab" class="headerlink" title="10.4.1 crontab"></a>10.4.1 crontab</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab [-u username] -e <span class="comment">#编辑工作表</span></span><br><span class="line">&lt;minute&gt; &lt;hour&gt; &lt;day&gt; &lt;month&gt; &lt;dayofweek&gt; &lt;commands&gt; <span class="comment">#编辑命令</span></span><br></pre></td></tr></table></figure>
<h4 id="1042-at"><a href="#10-4-2-at" class="headerlink" title="10.4.2 at"></a>10.4.2 at</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">at [-f script] [-m -l -r] [time] [date] </span><br></pre></td></tr></table></figure>
<p>example——在5天之后的此时此刻将/root/a文件复制到/home目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@PC-LINUX ~]<span class="comment"># at now +5 days </span></span><br><span class="line">at&gt; cp /root/a /home </span><br><span class="line">at&gt; &lt;EOT&gt;  //按[Ctrl+D]键退出 </span><br></pre></td></tr></table></figure>
<h3 id="105-服务的管理systemctl启动-停止"><a href="#10-5-服务的管理：systemctl启动、停止" class="headerlink" title="10.5 服务的管理：systemctl启动、停止"></a>10.5 服务的管理：systemctl启动、停止</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start/stop service_name</span><br></pre></td></tr></table></figure>
<h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><h3 id="网卡配置-命名"><a href="#网卡配置、命名" class="headerlink" title="网卡配置、命名"></a>网卡配置、命名</h3><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;硬件地址&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][IP地址]</span><br></pre></td></tr></table></figure>
<h4 id="修改好ip地址之后如何起作用-如何生效"><a href="#修改好ip地址之后，如何起作用、如何生效？" class="headerlink" title="修改好ip地址之后，如何起作用、如何生效？"></a>修改好ip地址之后，如何起作用、如何生效？</h4><p>第四节：网络服务的管理</p>
<ul>
<li>ntsysv：基于文本的程序。它允许为每个运行级别配置引导时要启动的服务。对于独立服务而言，改变不会立即生效。</li>
<li>systemctl命令：Fedora 17中新的管理服务的命令，用来替换chkconfig和service命令。</li>
<li>chkconfig和service命令：允许在不同运行级别启动和关闭服务的命令行工具。</li>
</ul>
<h3 id="网络服务管理"><a href="#网络服务管理" class="headerlink" title="网络服务管理"></a>网络服务管理</h3><ul>
<li>ntsysv</li>
<li>systemctl</li>
<li>chkconfig、service</li>
</ul>
<h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><h3 id="ssh-sftp-scopy的格式"><a href="#SSH、SFTP、Scopy的格式" class="headerlink" title="SSH、SFTP、Scopy的格式"></a>SSH、SFTP、Scopy的格式</h3><h4 id="ssh"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -l username ip_address</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh username@ip_address [command]</span><br></pre></td></tr></table></figure>
<h4 id="scp"><a href="#SCP" class="headerlink" title="SCP"></a>SCP</h4><p>将本地文件传输到远程主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp [本地文件][用户名@远程主机IP地址:/目标文件]</span><br></pre></td></tr></table></figure>
<p>把远程文件传输到本地主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp [用户名@远程主机IP地址:/源文件] [本地文件]</span><br></pre></td></tr></table></figure>
<h4 id="sftp"><a href="#SFTP" class="headerlink" title="SFTP"></a>SFTP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sftp [用户名@远程主机IP地址]</span><br></pre></td></tr></table></figure>
<h3 id="vnc稍微看一下"><a href="#VNC稍微看一下" class="headerlink" title="VNC稍微看一下"></a>VNC稍微看一下</h3><h4 id="apache配置文件端口-目录"><a href="#apache配置文件：端口、目录" class="headerlink" title="apache配置文件：端口、目录"></a>apache配置文件：端口、目录</h4><p>Apache服务器的配置文件是/etc/httpd/conf/httpd.conf。</p>
<p>修改配置需要在这个配置文件下修改。</p>
<p><a href="https://blog.csdn.net/qq_33230935/article/details/78639056">参考学长博客</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux分章重点——第五、六、七、八章</title>
    <url>/post/85c5dc00/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="ch5-文件和目录"><a href="#Ch5-文件和目录" class="headerlink" title="Ch5 文件和目录"></a>Ch5 文件和目录</h1><p>文件类型，ls -l所看到的信息，每一段都要搞得很清楚（作业第4题） ⽬目录常用命令，选项挑一些重点的看</p>
<p>比如：ls -a/-l，但是-F就不不⽤用看<br>文件目录命令，PPT有一个表要好好看一看</p>
<p>ls -l</p>
<p>以长格式的形式查看当前目录下所有可见文件的详细属性。(l就是long)<br>​    </p>
<ol>
<li>第1列:1.第1个字符表示文件的类型  2.第2～4个字符表示文件所有者对此文件的访问权限 3.第5～7个字符表示用户组对此文件的访问权限  4.第8～10个字符表示其他用户对此文件的访问权限</li>
<li>第2列:文件的链接数 </li>
<li>第3列:文件的所有者</li>
<li>第4列:文件的用户组名 </li>
<li>第5列:文件所占的字节数  </li>
<li>第6～8列:文件上一次的修改时间</li>
<li>第9列:文件名</li>
</ol>
<p>ls -a</p>
<p>显示包含连隐藏文件在内的所有文件。(a就是all)</p>
<hr>
<h1 id="ch6-linux常用操作命令"><a href="#Ch6-Linux常用操作命令" class="headerlink" title="Ch6 Linux常用操作命令"></a>Ch6 Linux常用操作命令</h1><p>很多命令，但是考的不多，要把命令看一下是干什么的，不用深入了解</p>
<p>第二小节：<strong>grep</strong>，<strong>ﬁnd</strong> </p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>使用grep命令可以查找文件中符合条件的字符串。</p>
<p>命令语法：<br>grep [选项][查找模式][文件名]</p>
<p>【例6.22】显示所有以d开头的文件中包含 “test”的行数据内容。</p>
<p>[root@PC-LINUX ~]#cat d1</p>
<p>1</p>
<p>test1</p>
<p>[root@PC-LINUX ~]# cat d2</p>
<p>2</p>
<p>test2</p>
<p>//查看文件d1和d2的文件内容</p>
<p>[root@PC-LINUX ~]# grep ‘test’ d*</p>
<p>d1:test1</p>
<p>d2:test2</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>使用find命令可以将文件系统中符合条件的文件或目录列出来，可以指定文件的名称、类别、时间、大小以及权限等不同信息的组合，只有完全相符的文件才会被列出来。</p>
<p>命令语法：<br>find [路径][选项][-print]</p>
<p>【例6.27】列出当前目录及其子目录下所有最近20天内更新过的文件。</p>
<p>[root@PC-LINUX ~]# find . -ctime -20</p>
<p>.</p>
<p>./install.log</p>
<p>./.mission-control</p>
<p>./.mission-control/accounts</p>
<p>./.mission-control/accounts/accounts.cfg </p>
<p>./anaconda-ks.cfg</p>
<p>./install.log.syslog</p>
<p>./.tcshrc</p>
<p>./.gconf</p>
<p>./.gconf/apps</p>
<p>./.gconf/apps/%gconf.xml</p>
<p>./.gconf/apps/nm-applet</p>
<p>./.gconf/apps/nm-applet/%gconf.xml<br>………………………………………………</p>
<hr>
<h1 id="ch7-shell编程"><a href="#Ch7-Shell编程" class="headerlink" title="Ch7 Shell编程"></a>Ch7 Shell编程</h1><p>不会超过20行<br>环境变量、特殊变量要掌握，语句的语法要掌握<br>写题</p>
<hr>
<h1 id="ch8-用户和组群账号管理"><a href="#Ch8-用户和组群账号管理" class="headerlink" title="Ch8 用户和组群账号管理"></a>Ch8 用户和组群账号管理</h1><p>用户管理：添加账号、删除账号、添加组 </p>
<p>涉及⽂件、password的格式</p>
<p>常⽤⽂件、⽂件的每⼀⾏，要求低，不⽤写每⼀⾏是什么</p>
<p>字符常⽤的，添加、删除⽤户、修改密码，这些对应⽂件中主要的信息的命令重要</p>
<p>修改⽤户的有效期什么的，考的可能性⼩</p>
<p>group命令，要认识</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux分章重点——第四章</title>
    <url>/post/c62aba6d/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="ch4-linux字符界面操作-重点"><a href="#Ch4-Linux字符界面操作-重点" class="headerlink" title="Ch4 Linux字符界面操作 重点"></a>Ch4 Linux字符界面操作 重点</h1><h2 id="进入命令行的方式"><a href="#进入命令行的方式" class="headerlink" title="进入命令行的方式"></a>进入命令行的方式</h2><ul>
<li>字符界面</li>
<li>图形界面下的终端</li>
<li>虚拟控制台</li>
</ul>
<h2 id="虚拟控制台的切换"><a href="#虚拟控制台的切换" class="headerlink" title="虚拟控制台的切换"></a>虚拟控制台的切换</h2><ul>
<li>在<strong>字符界面</strong>下，虚拟控制台的切换可以通过按<code>Alt+F1</code>~<code>Alt+F6</code>键实现</li>
<li>在<strong>图形界面</strong>下，可以使用<code>Ctrl+Alt+F2</code>～<code>Ctrl+Alt+F6</code>键切换不同的字符虚拟控制台，在 使用<code>Ctrl+Alt+F1</code>切换会图形界面</li>
</ul>
<h2 id="系统关机重启"><a href="#系统关机-重启" class="headerlink" title="系统关机/重启"></a>系统关机/重启</h2><p><code>shutdown halt reboot init</code><br>​<br><code>shutdown</code>：安全地关闭系统</p>
<p>shutdown [选项] [时间] [警告信息]<br>​<br>​                <code>shutdown -h now</code> 立即关闭系统<br>​<br>                <code>shutdown -h 45</code>定时45分钟后关闭系统</p>
<pre><code>            `shutdown -r now`重新启动系统,并发出警告信息
</code></pre><p><code>halt</code>：引发主机关闭系统=调用 “shutdown —h”命令执行关闭系统<br>​<br>​             [root@PC-LINUX ~]# halt</p>
<p><code>reboot</code>：引发主机重启,参数与“halt”相似。<br>​<br>​             [root@PC-LINUX ~]# reboot </p>
<p><code>init</code>：“init”命令是所有进程的祖先,它的进程号始终为“1”,所以发送“TERM”信号给 “init”会终止所有的用户进程和守护进程等。</p>
<p>“init” 定义了7个运行级别,其中<code>init 0</code>为关闭系统,<code>init 6</code>为重启，通过init可以完成不同运行级别之间的切换 </p>
<p>shutdown和init都是既可以关机又可以重启：</p>
<p><code>shutdown –h now</code>和<code>init 0</code>用于关机 + halt</p>
<p><code>shutdown –r now</code>和<code>init 6</code>用户重启  + reboot</p>
<h2 id="运行级别-0~6-要很清楚3字符-5图形-0关机-6重启"><a href="#运行级别-0～6-要很清楚，3字符、5图形、0关机、6重启" class="headerlink" title="运行级别 0～6 要很清楚，3字符、5图形、0关机、6重启"></a>运行级别 0～6 要很清楚，3字符、5图形、0关机、6重启</h2><p>Linux运行级别有如下7种：</p>
<pre><code>0:*停止运行*,所有进程中止,关闭系统。 
1:*单用户模式*,用于维护系统,只有少数进程运行。
2:*多用户模式*,除了NFS服务没有启动外,其他和运行级别3一样。
3:*完整的多用户模式*,进入Linux系统的字符界面。 
4:*没有使用*(可由用户定义)。 
5:*完整的多用户模式*(带有基于X Window的图形界面)。
6:*重新引导计算机*。
</code></pre><p><img src="https://raw.githubusercontent.com/ShortPupil/wordpress_picture/master/linux_4/ok.png" alt></p>
<h2 id="man帮助命令"><a href="#man帮助命令" class="headerlink" title="man帮助命令"></a>man帮助命令</h2><p>man是一种显示Unix/Linux在线手册的命令。可以用来<strong>查看命令、函数或文件</strong>的帮助手册,另外它还可以显示一些gzip压缩格式的文件。<br>man命令格式化并显示在线的手册页。 </p>
<p><code>help</code>使用help命令可以查找Shell命令的用法<br>查看mkdir命令帮助：<br>​    [root@PC-LINUX ~]# mkdir —help<br>（注意help前有两条-）</p>
<p><code>whereis</code>命令可以查找命令所在的位置</p>
<h2 id="shell里技巧性的"><a href="#Shell里技巧性的" class="headerlink" title="Shell里技巧性的"></a>Shell里技巧性的</h2><h3 id="命令行自动补全"><a href="#命令行自动补全" class="headerlink" title="命令行自动补全"></a>命令行自动补全</h3><p>输入第一个之后按下Tab键,自动补齐</p>
<h3 id="光标上翻下翻"><a href="#光标上翻下翻" class="headerlink" title="光标上翻下翻"></a>光标上翻下翻</h3><pre><code>[Ctrl+k]:删除从光标到行尾的部分。 
[Ctrl+u]:删除从光标到行首的部分。
[Alt+d]:删除从光标到当前单词结尾的部分。 
[Ctrl+w]:删除从光标到当前单词开头的部分。 
[Ctrl+a]:将光标移到行首。 
[Ctrl+e]:将光标移到行尾。 
[Alt+a]:将光标移到当前单词头部。 
[Alt+e]:将光标移到当前单词尾部。
[Ctrl+y]:插入最近删除的单词。
[!$]:重复前一个命令最后的参数。
</code></pre><h3 id="一行上执行多个命令"><a href="#一行上执行多个命令" class="headerlink" title="一行上执行多个命令"></a>一行上执行多个命令</h3><p><img src="https://raw.githubusercontent.com/ShortPupil/wordpress_picture/master/linux_4/more1.png" alt></p>
<p><img src="https://raw.githubusercontent.com/ShortPupil/wordpress_picture/master/linux_4/more2.png" alt></p>
<h2 id="管道管道什么意思管道有什么作用具体怎么使用"><a href="#管道，管道什么意思，管道有什么作用，具体怎么使用" class="headerlink" title="管道，管道什么意思，管道有什么作用，具体怎么使用"></a>管道，管道什么意思，管道有什么作用，具体怎么使用</h2><p>管道可以通过组合许多小程序共同完成复杂的任务，可以将某个命令的输出信息当作某个命令的输入，由管道符号“|”来标识。</p>
<p><strong>命令语法</strong>：[命令1] | [命令2] | [命令3]</p>
<p>|more之后就可以分页显示上一个命令的输出</p>
<h2 id="vi-编辑的是ascii文本"><a href="#vi-（编辑的是ASCII文本）" class="headerlink" title="vi （编辑的是ASCII文本）"></a>vi （编辑的是ASCII文本）</h2><h3 id="三种模式三种模式之间的转换及命令"><a href="#三种模式，三种模式之间的转换及命令" class="headerlink" title="三种模式，三种模式之间的转换及命令"></a>三种模式，三种模式之间的转换及命令</h3><p>vi编辑器有3种基本工作模式,分别是<strong>命令行模式</strong>、<strong>插入模式</strong>和<strong>末行模式</strong>。</p>
<p>当在Shell提示符下输入“vi文件名”之后就进入了命令行模式,在命令行模式下是不能输入任何数据的。</p>
<p>在命令行模式下输入文本插入命令就可以进入插入模式,这时候就可以开始输入文字了。</p>
<p>从插入模式切换为命令行模式只需按“Esc”键。</p>
<p>在命令行模式下,按转义命令冒号键“:”可以进入末行模式。</p>
<p>命令行模式：控制屏幕光标的移动，字符、字或行的删除，移动、复制某区域及进入插入模式，或者到末行模式<br>注：下面操作都是只能在命令行模式下控制，在输入模式下会变成输入</p>
<h3 id="屏幕光标的移动"><a href="#屏幕光标的移动" class="headerlink" title="屏幕光标的移动"></a>屏幕光标的移动</h3><p><code>h j k l</code>分别对应：左 下 上 右</p>
<p><code>Ctrl + b f u d</code> 分别对应：</p>
<p>屏幕向前移动一页、向后移动一页、向前移动半页、向后移动半页<br><img src="https://raw.githubusercontent.com/ShortPupil/wordpress_picture/master/linux_4/yidongbanye.png" alt><br>​<br> 注：0和^的效果是一样的，都是所在行的行首；$是在行尾<br>​    </p>
<h3 id="字符-字或行的删除"><a href="#字符、字或行的删除" class="headerlink" title="字符、字或行的删除"></a>字符、字或行的删除</h3><p><code>X</code> 删除光标所在位置前面一个字符  x 删除光标所在位置的一个字符</p>
<p><code>nX</code> 例20X，删除光标所在位置前面20个字符</p>
<p><code>nx</code> 例6x，删除光标所在位置开始的6个字符</p>
<h3 id="复制某区域"><a href="#复制某区域" class="headerlink" title="复制某区域"></a>复制某区域</h3><p><img src="https://raw.githubusercontent.com/ShortPupil/wordpress_picture/master/linux_4/fuzhimoquyu.png" alt></p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>y，以字为单位</p>
<h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><p><img src="https://raw.githubusercontent.com/ShortPupil/wordpress_picture/master/linux_4/tihuancaozuo.png" alt></p>
<h3 id="撤销上一次操作"><a href="#撤销上一次操作" class="headerlink" title="撤销上一次操作"></a>撤销上一次操作</h3><p><code>u</code>，多次u，多次撤销</p>
<h3 id="跳至指定的行"><a href="#跳至指定的行" class="headerlink" title="跳至指定的行"></a>跳至指定的行</h3><p><img src="https://raw.githubusercontent.com/ShortPupil/wordpress_picture/master/linux_4/tiaozhizhidingdehang.png" alt><br>第一个g小写，第二个行后的G大写</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>存盘退出：<code>ZZ</code><br>不存盘退出：<code>ZQ</code></p>
<h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><p> (仍然必须在命令行模式下，输入下面操作，光标移到这些位置，然后进入插入模式，从这些位置开始可以被编辑)</p>
<ul>
<li>I行首<br> i光标当前位置<br>  A行末        </li>
<li>a光标下一个位置<br> O 光标上一行插入一行        </li>
<li>o 光标下一行插入一行，从行首开始输<br> S 删除光标所在行        </li>
<li>s 删除光标位置的一个字符</li>
<li><img src="https://raw.githubusercontent.com/ShortPupil/wordpress_picture/master/linux_4/yigezifu.png" alt></li>
</ul>
<p>S和dd的区别是，dd只删，S删完之后进入插入模式</p>
<h3 id="进入末行模式"><a href="#进入末行模式" class="headerlink" title="进入末行模式"></a>进入末行模式</h3><p>确保先按“ESC”进入命令行模式，再按“：”进入末行模式</p>
<p>末行模式：将文件保存或退出编辑器，也可以设置编辑环境，如寻找字符串、列出行号等。</p>
<h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><p><code>w</code>:在冒号后输入字母“w”就可以将文件保存起来。</p>
<p>离开vi编辑器操作如下</p>
<p><code>q</code>:按“q”即退出vi,如果无法离开vi,可以在“q”后跟一个“!”强制符离开vi </p>
<p><code>wq</code>:一般建议离开时,搭配“w”一起使用,这样在退出的时候还可以保存文件</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB学习</title>
    <url>/post/88175981/</url>
    <content><![CDATA[<h1 id="一-了解"><a href="#一、了解" class="headerlink" title="一、了解"></a>一、了解</h1><h2 id="1什么是mongodb"><a href="#1-什么是MongoDB" class="headerlink" title="1.什么是MongoDB?"></a>1.什么是MongoDB?</h2><p>MongoDB和MySQL一样都是数据库, 都是存储数据的仓库,<br>不同的是MySQL是关系型数据库, 而MongoDB是非关系型数据库</p>
<h2 id="2什么是非关系型数据库"><a href="#2-什么是非关系型数据库" class="headerlink" title="2.什么是非关系型数据库?"></a>2.什么是非关系型数据库?</h2><ul>
<li><p>在’关系型数据库’中, 数据都是存储在表中的, 对存储的内容有严格的要求<br>因为在创建表的时候我们就</p>
<p>已经规定了表中有多少个字段,已经规定了每个字段将来要存储什么类型数据,已经规定了每个字段将来是否可以为空,是否必须唯一等等</p>
</li>
<li><p>在’非关系型数据库’中, 没有表概念, 所以存储数据更加灵活<br>因为不需要创建表,所以也</p>
<p>没有规定有哪些字段,也没有规定每个字段数据类型,也没有规定每个字段将来是否可以为空,是否必须唯一等等</p>
</li>
<li><p>‘关系型数据库’由于操作的都是结构化的数据, 所以我们需要使用结构化语言SQL来操作</p>
</li>
<li><p>‘非关系型数据库’由于数据没有严格的结构要求, 所以无需使用SQL来操作</p>
</li>
</ul>
<h2 id="3什么是mongodb"><a href="#3-什么是MongoDB" class="headerlink" title="3.什么是MongoDB?"></a>3.什么是MongoDB?</h2><p>存储文档(BSON)的非关系型数据库<br>例如在MySQL中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|--------------------------------------------------------|</span><br><span class="line">|   name(varchar(255) not null)   |    age(int unique)   |</span><br><span class="line">|--------------------------------------------------------|</span><br><span class="line">我们可以把            &#x27;zs&#x27;, 33        保存到表中</span><br><span class="line">但是我们不能将         33, &#x27;zs&#x27;       保存到表中</span><br><span class="line">但我们不能能将         null, 33       保存到表中</span><br><span class="line">但是我们不能将         &#x27;zs&#x27;, 33,  &#x27;男&#x27; 保存到表中</span><br><span class="line">但是我们不能再次将     &#x27;zs&#x27;, 33        保存到表中</span><br></pre></td></tr></table></figure>
<p>例如在MongoDB中:</p>
<p>我们可以把         {name: ‘zs’, age: 33};              保存到集合中<br>我们也可以把       {name: 33, age: ‘zs’};              保存到集合中<br>我们也可以把       {name: null, age: 33};              保存到集合中<br>我们也可以把       {name: ‘zs’, age: 33, gender:’男’}; 保存到集合中<br>但是我们可以再次将 {name: ‘zs’, age: 33};              保存到集合中</p>
<ul>
<li>‘非关系型数据库’可以看做是’关系型数据库’的功能阉割版本,<br>通过减少用不到或很少用的功能，从而提升数据库的性能</li>
</ul>
<h2 id="4mongodb是如何存储文档的"><a href="#4-MongoDB是如何存储文档的" class="headerlink" title="4.MongoDB是如何存储文档的?"></a>4.MongoDB是如何存储文档的?</h2><p>MySQL中所有的数据都是存储在表中的, 而MongoDB中所有的数据都是存储在集合中的</p>
<h3 id="41mysql"><a href="#4-1MySQL" class="headerlink" title="4.1MySQL"></a>4.1MySQL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                |--行1</span><br><span class="line">        |--表1--|--行2</span><br><span class="line">数据库--|       |--行3</span><br><span class="line">        |--表2</span><br><span class="line">        |--... ...</span><br></pre></td></tr></table></figure>
<h3 id="42mongodb"><a href="#4-2MongoDB" class="headerlink" title="4.2MongoDB"></a>4.2MongoDB</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  |--文档1</span><br><span class="line">        |--集合1--|--文档2</span><br><span class="line">`数据库--|         |--文档3`</span><br><span class="line">        `|--集合2`</span><br><span class="line">        `|--... ...`</span><br></pre></td></tr></table></figure>
<h2 id="5一般开发如何选择"><a href="#5-一般开发如何选择" class="headerlink" title="5.一般开发如何选择?"></a>5.一般开发如何选择?</h2><ul>
<li>关系型数据库和非关系型数据库之间并不是替代关系, 而是互补关系<br>所以在企业开发中大部分情况是结合在一起使用.</li>
<li>对于数据模型比较简单、数据性能要求较高、数据灵活性较强的数据, 我们存储到非关系型数据库中<br>相反则存储到关系型数据库中</li>
<li>具体使用: 会在项目中实现</li>
</ul>
<h1 id="二-基本操作学习"><a href="#二、-基本操作学习" class="headerlink" title="二、 基本操作学习"></a>二、 基本操作学习</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.导入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mongodb://MongoDB服务器IP地址:MongoDB服务器端口号/需要打开的数据库名称</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 2.利用mongoose链接MongoDB服务器</span></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://127.0.0.1:27017/my_mongodb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.监听链接成功还是失败</span></span><br><span class="line"><span class="keyword">let</span> db = mongoose.connection;</span><br><span class="line">db.on(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err, <span class="string">&#x27;连接失败&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">db.once(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">db.once(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;断开连接&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义集合中存储数据规则</span></span><br><span class="line"><span class="keyword">let</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.利用规则创建集合</span></span><br><span class="line"><span class="comment">// 注意点: 只要创建好了模型, 那么以后就可以使用模型来操作这个集合</span></span><br><span class="line"><span class="comment">// 注意点: mongoose会自动将我们指定的集合名称变成复数</span></span><br><span class="line"><span class="keyword">let</span> User = mongoose.model(<span class="string">&#x27;User&#x27;</span>, userSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.利用集合创建文档</span></span><br><span class="line"><span class="comment">// 注意点: 只要创建好了对象, 那么以后就可以使用对象来操作文档</span></span><br><span class="line"><span class="keyword">let</span> u = <span class="keyword">new</span> User(&#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.操作文档</span></span><br><span class="line">u.save(<span class="function">(<span class="params">err, product</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;文档保存成功&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>1.连接MongoDB服务器<br>通过mongo连接MongoDB服务器</p>
<p>2.查看数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show dbs</span><br><span class="line">#和MySQL中的 show databases; 指令一样</span><br></pre></td></tr></table></figure>
<p>3.创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 数据库名称</span><br><span class="line">#和MySQL中的 use 指令一样, 只不过MongoDB中的use数据库不存在会自动创建</span><br></pre></td></tr></table></figure>
<p>4.查看数据库中有哪些集合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> collections</span><br><span class="line"># 和MySQL中的 <span class="keyword">show</span> tables; 指令一样</span><br></pre></td></tr></table></figure>
<p>5.创建集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.createCollection(&#x27;集合名称&#x27;);</span><br><span class="line">#和MySQL中的 create table xxx(); 指令一样</span><br></pre></td></tr></table></figure>
<p>6.插入数据<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.集合名称.insert(文档对象);</span><br><span class="line">#和MySQL中的 insert into xxx values () 指令一样</span><br></pre></td></tr></table></figure><br>7.查询数据<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.集合名称.find();</span><br><span class="line">#和MySQL中的 select * from xxx; 指令一样</span><br></pre></td></tr></table></figure><br>8.删除集合<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.集合名称.drop()</span><br><span class="line">#和MySQL中的 drop table xxx; 指令一样</span><br></pre></td></tr></table></figure><br>9.删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.dropDatabase()</span><br><span class="line">#在哪个数据库中就会删除哪个数据库</span><br><span class="line">#和MySQL中的 drop database xxx; 指令一样</span><br></pre></td></tr></table></figure>
<p>10.和MySQL的不同</p>
<ul>
<li>没有MySQL中表的概念, 取而代之的是集合</li>
<li>创建集合时不用指定集合中有哪些字段</li>
<li>只要是一个合法的文档对象都可以往里面存储</li>
<li>… …</li>
</ul>
<h1 id="三-创建文档"><a href="#三、创建文档" class="headerlink" title="三、创建文档"></a>三、创建文档</h1><h2 id="1主键"><a href="#1-主键" class="headerlink" title="1.主键"></a>1.主键</h2><ul>
<li>MongoDB的主键和MySQL一样, 也是用于保证每一条<strong>数据唯一性</strong>的</li>
<li><p>和MySQL不同的是, MongoDB中的主键无需明确指定</p>
<ul>
<li>每一个文档被添加到集合之后, MongoDB都会<strong>自动添加主键</strong></li>
<li>MongoDB中文档主键的名称叫做 _id</li>
</ul>
</li>
<li><p>默认情况下文档主键是一个ObjectId类型的数据</p>
<ul>
<li>ObjectId类型是一个12个字节字符串(5e8c5ae9-c9d35e-759b-d6847)<ul>
<li>4字节是存储这条数据的时间戳</li>
<li>3字节的存储这条数据的那台电脑的标识符</li>
<li>2字节的存储这条数据的MongoDB进程id</li>
<li>3字节是计数器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2为什么要使用objectid类型数据作为主键"><a href="#2-为什么要使用ObjectId类型数据作为主键" class="headerlink" title="2.为什么要使用ObjectId类型数据作为主键?"></a>2.为什么要使用ObjectId类型数据作为主键?</h2><p>因为MongoDB是支持’横向扩展’的数据库</p>
<ul>
<li>横向扩展是指’增加数据库服务器的台数’</li>
<li>纵向扩展是指’增加数据库库服务器的配置’</li>
<li>过去一个数据库只能安装在一台电脑上, 但是每台电脑的性能是有峰值的</li>
<li>一旦达到峰值就会导致服务器卡顿、宕机、重启等问题.<br>所以过去为了防止如上问题的出现,我们只能不断的’纵向扩展’<br>也就是不断的提升服务器的配置, 让服务器能处理更多的请求<br>但是纵向扩展也是有峰值的, 一台电脑的配置不可能无限提升<br>所以为了解决这个问题就有了分布式数据库</li>
<li><strong>分布式数据库</strong>是指<strong>可以在多台电脑上安装数据库, 然后把多台电脑组合成一个完整的数据库,</strong><br><strong>在分布式数据库中,我们可以通过不断同步的方式, 让多台电脑都保存相同的内容</strong><br>当用户请求数据时, 我们可以把请求派发给不同的数据库服务器处理<br>当某一台服务器宕机后, 我们还可以继续使用其它服务器处理请求<br>从而有效的解决了单台电脑性能峰值和单台电脑宕机后服务器不能使用的问题</li>
</ul>
<p>2.2为什么要使用ObjectId类型数据作为主键?</p>
<p>正是因为MongoDB是一个分布式数据库, 正是因为分布式数据库可以把请求派发给不同的服务器<br>所以第一次插入数据时, 我们可能派发给了A服务器, 插入到了A服务器的数据库中<br>但是第二次插入数据时, 我们又可能派发给了B服务器, 插入到了B服务器的数据库中<br>但是B服务器此时并不知道A服务器当前的主键值是多少, 如果通过MySQL中简单的递增来保证数据的唯一性<br>那么将来在多台服务器同步数据的时候就会出现重复的情况, 所以MongoDB的主键并没有使用简单的递增<br>而是使用了ObjectId类型数据作为主键</p>
<h2 id="3是否支持其它类型数据作为主键"><a href="#3-是否支持其它类型数据作为主键" class="headerlink" title="3.是否支持其它类型数据作为主键?"></a>3.是否支持其它类型数据作为主键?</h2><p>3.1 在MongoDB中支持除了’数组类型’以外的其它类型数据作为主键<br>3.2 在MongoDB中甚至还支持将一个文档作为另一个文档的主键(复合主键)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.person.insert(&#123;name: <span class="string">&#x27;lnj&#x27;</span>, age: <span class="number">33</span>&#125;);</span><br><span class="line">db.person.insert(&#123;_id: <span class="number">1</span>, name: <span class="string">&#x27;lnj&#x27;</span>, age: <span class="number">33</span>&#125;); #报错，这个_id是由ESRI的软件来管理的，是不能够手动更改的</span><br><span class="line"></span><br><span class="line">db.person.insert(&#123;_id: <span class="string">&#x27;1&#x27;</span>, name: <span class="string">&#x27;lnj&#x27;</span>, age: <span class="number">33</span>&#125;);</span><br><span class="line">db.person.insert(&#123;_id: &#123;name:<span class="string">&#x27;it66&#x27;</span>, gender: <span class="string">&#x27;男&#x27;</span>&#125;, name: <span class="string">&#x27;lnj&#x27;</span>, age: <span class="number">33</span>&#125;);</span><br><span class="line">#db.person.insert(&#123;_id: &#123;name:<span class="string">&#x27;it66&#x27;</span>, gender: <span class="string">&#x27;男&#x27;</span>&#125;, name: <span class="string">&#x27;lnj&#x27;</span>, age: <span class="number">33</span>&#125;); #报错</span><br><span class="line">db.person.insert(&#123;_id: &#123;gender: <span class="string">&#x27;男&#x27;</span>, name:<span class="string">&#x27;it66&#x27;</span>&#125;, name: <span class="string">&#x27;lnj&#x27;</span>, age: <span class="number">33</span>&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="四-文档操作-增删改查"><a href="#四、文档操作-增删改查" class="headerlink" title="四、文档操作 增删改查"></a>四、文档操作 增删改查</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.导入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.利用mongoose链接MongoDB服务器</span></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://127.0.0.1:27017/my&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.监听链接成功还是失败</span></span><br><span class="line"><span class="keyword">let</span> db = mongoose.connection;</span><br><span class="line">db.on(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err, <span class="string">&#x27;连接失败&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">db.once(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">db.once(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;断开连接&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义集合中存储数据规则</span></span><br><span class="line"><span class="keyword">let</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.利用规则创建集合</span></span><br><span class="line"><span class="keyword">let</span> User = mongoose.model(<span class="string">&#x27;User&#x27;</span>, userSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加</span></span><br><span class="line">User.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>:<span class="number">666</span>&#125;, <span class="function">(<span class="params">err, result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;插入成功&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">User.create([</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>, <span class="attr">age</span>:<span class="number">22</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">&#x27;ww&#x27;</span>, <span class="attr">age</span>:<span class="number">21</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">&#x27;zl&#x27;</span>, <span class="attr">age</span>:<span class="number">23</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">&#x27;lnj&#x27;</span>, <span class="attr">age</span>:<span class="number">33</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="function">(<span class="params">err, result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;插入成功&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> User.create([</span><br><span class="line">            &#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>, <span class="attr">age</span>:<span class="number">22</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">name</span>:<span class="string">&#x27;ww&#x27;</span>, <span class="attr">age</span>:<span class="number">21</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">name</span>:<span class="string">&#x27;zl&#x27;</span>, <span class="attr">age</span>:<span class="number">23</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">name</span>:<span class="string">&#x27;lnj&#x27;</span>, <span class="attr">age</span>:<span class="number">33</span>&#125;,</span><br><span class="line">        ]);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">User.find(&#123;&#125;,&#123;&#125;,<span class="function">(<span class="params">err, docs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">User.find(&#123;&#125;,&#123;<span class="attr">_id</span>:<span class="number">0</span>, <span class="attr">name</span>:<span class="number">1</span>, <span class="attr">age</span>:<span class="number">1</span>&#125;,<span class="function">(<span class="params">err, docs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">User.find(&#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>&#125;,&#123;<span class="attr">_id</span>:<span class="number">0</span>, <span class="attr">name</span>:<span class="number">1</span>, <span class="attr">age</span>:<span class="number">1</span>&#125;,<span class="function">(<span class="params">err, docs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">User.find(&#123;&#125;,&#123;<span class="attr">_id</span>:<span class="number">0</span>, <span class="attr">name</span>:<span class="number">1</span>, <span class="attr">age</span>:<span class="number">1</span>&#125;,&#123; <span class="attr">skip</span>: <span class="number">5</span>, <span class="attr">limit</span>: <span class="number">5</span>&#125;,<span class="function">(<span class="params">err, docs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> User.find(&#123;&#125;,&#123;<span class="attr">_id</span>:<span class="number">0</span>, <span class="attr">name</span>:<span class="number">1</span>, <span class="attr">age</span>:<span class="number">1</span>&#125;,&#123; <span class="attr">skip</span>: <span class="number">5</span>, <span class="attr">limit</span>: <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">User.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">888</span>&#125;&#125;,<span class="function">(<span class="params">err, docs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;更新成功&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(docs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">User.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">888</span>&#125;&#125;, &#123;<span class="attr">multi</span>: <span class="literal">true</span>&#125;,<span class="function">(<span class="params">err, docs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;更新成功&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(docs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">   <span class="keyword">let</span> result = <span class="keyword">await</span> User.update(&#123;<span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">123</span>&#125;&#125;, &#123;<span class="attr">multi</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">   <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">User.remove(&#123;<span class="attr">name</span>:<span class="string">&#x27;ww&#x27;</span>&#125;, &#123;&#125;, <span class="function">(<span class="params">err, docs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(docs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">User.deleteOne(&#123;<span class="attr">name</span>:<span class="string">&#x27;lnj&#x27;</span>&#125;, <span class="function">(<span class="params">err, docs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(docs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> User.deleteOne(&#123;<span class="attr">name</span>:<span class="string">&#x27;lnj&#x27;</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h1 id="五-聚合"><a href="#五、聚合" class="headerlink" title="五、聚合"></a>五、聚合</h1><h2 id="1什么是聚合操作"><a href="#1-什么是聚合操作" class="headerlink" title="1.什么是聚合操作?"></a>1.什么是聚合操作?</h2><ul>
<li>聚合操作就是通过一个方法完成一系列的操作</li>
<li>在聚合操作中, 每一个操作我们称之为一个阶段,<br>聚合操作会将上一个阶段处理结果传给下一个阶段继续处理,<br>所有阶段都处理完毕会返回一个新的结果集给我们</li>
</ul>
<h2 id="2聚合操作格式"><a href="#2-聚合操作格式" class="headerlink" title="2.聚合操作格式"></a>2.聚合操作格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.aggregate(&lt;pipeline&gt;, &lt;options&gt;)</span><br><span class="line">&lt;pipeline&gt;: 定义每个阶段操作</span><br><span class="line">&lt;options&gt; : 聚合操作额外配置</span><br></pre></td></tr></table></figure>
<h2 id="project"><a href="#project" class="headerlink" title="$project"></a>$project</h2><p>1.聚合管道阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$project: 对输入文档进行再次投影</span><br><span class="line">作用    : 按照我们需要的格式生成结果集</span><br><span class="line">格式    : &#123;$project:&#123;&lt;field&gt;:&lt;value&gt;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>2.示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;Jonathan&#x27;, lastName:&#x27;Lee&#x27;&#125;, age:18, book:&#123;name:&#x27;玩转HTML&#x27;, price: 88&#125;&#125;,</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;Amelie&#x27;, lastName:&#x27;Jiang&#x27;&#125;, age:17, book:&#123;name:&#x27;玩转JavaScript&#x27;, price: 99&#125;&#125;</span><br><span class="line">])</span><br><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $project:&#123;</span><br><span class="line">            _id:0,</span><br><span class="line">            clientName: &#x27;$name.firstName&#x27;,</span><br><span class="line">            clientAge: &#x27;$age&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>5.聚合表达式</p>
<p>5.1 字段路径表达式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&lt;filed&gt;: 使用$来指示字段路径</span><br><span class="line">$&lt;filed&gt;.&lt;sub-field&gt;: 使用$和.来指示内嵌文档字段路径</span><br></pre></td></tr></table></figure><br>5.2 字段路径表达式示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$name</span><br><span class="line">$book.name</span><br></pre></td></tr></table></figure><br>6.注意点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注意点: $project修改的是结果集而不是原有的集合</span><br><span class="line">db.person.find()</span><br><span class="line">// 注意点: 如果字段表达式使用了不存在的字段, 那么会自动用Null填充</span><br><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $project:&#123;</span><br><span class="line">            _id:0,</span><br><span class="line">            fullName: [&#x27;$name.firstName&#x27;, &#x27;$name.middleName&#x27;,&#x27;$name.lastName&#x27;],</span><br><span class="line">            clientAge: &#x27;$age&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="match"><a href="#match" class="headerlink" title="$match"></a>$match</h2><p>1.聚合管道阶段<br><code>$match</code>: 和<code>find</code>方法中的第一个参数一样, 用于筛选符合条件的文档<br>格式  : <code>&#123;$match:&#123;&lt;query&gt;&#125;&#125;</code></p>
<p>2.示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $match:&#123;</span><br><span class="line">            &#x27;name.firstName&#x27;:&#x27;Jonathan&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $match:&#123;</span><br><span class="line">            &#x27;name.firstName&#x27;:&#x27;Jonathan&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $project:&#123;</span><br><span class="line">            _id:0,</span><br><span class="line">            clientName: &#x27;$name.firstName&#x27;,</span><br><span class="line">            clientAge: &#x27;$age&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>3.使用技巧:<br>应该在聚合操作的最前面使用<code>$match</code>, 这样可以有效减少处理文档的数量, 大大提升处理的效率</p>
<h2 id="limit-skip"><a href="#limit-skip" class="headerlink" title="$limit $skip"></a>$limit $skip</h2><p>1.聚合管道阶段<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$limit: 和游标的limit方法一样, 用于指定获取几个文档</span><br><span class="line">格式  : &#123;$limit:&lt;number&gt;&#125;</span><br><span class="line">$skip : 和游标的skip方法一样, 用于指定跳过几个文档</span><br><span class="line">格式  : &#123;$skip:&lt;number&gt;&#125;</span><br></pre></td></tr></table></figure><br>2.示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $skip:1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $limit:1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $project:&#123;</span><br><span class="line">            _id:0,</span><br><span class="line">            clientName: &#x27;$name.firstName&#x27;,</span><br><span class="line">            clientAge: &#x27;$age&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<h2 id="unwind"><a href="#unwind" class="headerlink" title="$unwind"></a>$unwind</h2><p>1.聚合管道阶段<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$unwind: 展开数组字段</span><br><span class="line">格式   : &#123;$unwind:&#123;path:&lt;field&gt;&#125;&#125;</span><br></pre></td></tr></table></figure><br>2.示例:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.update(&#123;&#x27;name.firstName&#x27;:&#x27;Jonathan&#x27;&#125;, &#123;$set:&#123;tags:[&#x27;html&#x27;, &#x27;js&#x27;]&#125;&#125;)</span><br><span class="line">db.person.update(&#123;&#x27;name.firstName&#x27;:&#x27;Amelie&#x27;&#125;, &#123;$set:&#123;tags:&#x27;vue&#x27;&#125;&#125;)</span><br><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $unwind:&#123;</span><br><span class="line">            path:&#x27;$tags&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>注意点:<br>3.1 $unwind会为数组中的每个元素创建一个新的文档<br>3.2 可以通过includeArrayIndex属性添加展开之后的元素在原数组中的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $unwind:&#123;</span><br><span class="line">            path:&#x27;$tags&#x27;,</span><br><span class="line">            includeArrayIndex: &#x27;index&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>3.3 如果需要展开的字段不存在, 或者数组中没有元素, 或者为null, 会被unwind剔除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;san&#x27;, lastName:&#x27;zhang&#x27;&#125;, age:20&#125;,</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;si&#x27;, lastName:&#x27;li&#x27;&#125;, age:21, tags:[]&#125;,</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;wu&#x27;, lastName:&#x27;wang&#x27;&#125;, age:22, tags:null&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>3.4 如果想让unwind不剔除不存在/没有元素/为Null的文档, 那么可以添加preserveNullAndEmptyArrays属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $unwind:&#123;</span><br><span class="line">            path:&#x27;$tags&#x27;,</span><br><span class="line">            includeArrayIndex: &#x27;index&#x27;,</span><br><span class="line">            preserveNullAndEmptyArrays: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="sort"><a href="#sort" class="headerlink" title="$sort"></a>$sort</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.聚合管道阶段</span><br><span class="line">$sort: 和文档游标sort方法一样, 对文档进行排序</span><br><span class="line">格式   : `&#123;$sort:&#123;&lt;field&gt;&gt;:1|-1&#125;&#125;`</span><br></pre></td></tr></table></figure>
<p>2.示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $sort:&#123;</span><br><span class="line">            age: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="lookup"><a href="#lookup" class="headerlink" title="$lookup"></a>$lookup</h2><p>1.聚合管道阶段<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$lookup: 用来做关联查询</span><br><span class="line">格式   :</span><br><span class="line">&#123;$lookup:&#123;</span><br><span class="line">    from: 关联集合名称,</span><br><span class="line">    localField: 当前集合中的字段名称,</span><br><span class="line">    foreignField:关联集合中的字段名称,</span><br><span class="line">    as: 输出字段的名称</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><br>2.示例:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;Jonathan&#x27;, lastName:&#x27;Lee&#x27;&#125;, age:18, books:[&#x27;html&#x27;, &#x27;js&#x27;]&#125;,</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;Amelie&#x27;, lastName:&#x27;Jiang&#x27;&#125;, age:19, books:[&#x27;vue&#x27;]&#125;,</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;si&#x27;, lastName:&#x27;Li&#x27;&#125;, age:20, books:[]&#125;</span><br><span class="line">])</span><br><span class="line">db.books.insert([</span><br><span class="line">    &#123;name:&#x27;html&#x27;, price:88&#125;,</span><br><span class="line">    &#123;name:&#x27;js&#x27;, price:99&#125;,</span><br><span class="line">    &#123;name:&#x27;vue&#x27;, price:110&#125;,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $lookup:&#123;</span><br><span class="line">            from: &#x27;books&#x27;,</span><br><span class="line">            localField: &#x27;books&#x27;,</span><br><span class="line">            foreignField: &#x27;name&#x27;,</span><br><span class="line">            as: &#x27;booksData&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<p>3.和unwind阶段结合使用<br>可以有效的过滤掉无效数据<br>可以给每个匹配的结果生成一个新的文档<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $unwind:&#123;</span><br><span class="line">            path:&#x27;$books&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $lookup:&#123;</span><br><span class="line">            from: &#x27;books&#x27;,</span><br><span class="line">            localField: &#x27;books&#x27;,</span><br><span class="line">            foreignField: &#x27;name&#x27;,</span><br><span class="line">            as: &#x27;booksData&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<h2 id="lookup"><a href="#lookup-1" class="headerlink" title="$lookup"></a>$lookup</h2><p>1.聚合管道阶段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$lookup: 用来做关联查询</span><br><span class="line">格式   :</span><br><span class="line">&#123;$lookup:&#123;</span><br><span class="line">    from: 关联集合名称,</span><br><span class="line">    let: &#123;定义给关联集合的聚合操作使用的当前集合的常量&#125;,</span><br><span class="line">    pipeline: [关联集合的聚合操作]</span><br><span class="line">    as: 输出字段的名称</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>2.示例:<br>不相关查询<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $lookup:&#123;</span><br><span class="line">            from: &#x27;books&#x27;,</span><br><span class="line">            pipeline: [</span><br><span class="line">                &#123;</span><br><span class="line">                    $match:&#123;</span><br><span class="line">                        price:&#123;$gte:100&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            as: &#x27;booksData&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><br>相关查询<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $lookup:&#123;</span><br><span class="line">            from: &#x27;books&#x27;,</span><br><span class="line">            let: &#123; bks: &#x27;$books&#x27;&#125;,</span><br><span class="line">            pipeline: [</span><br><span class="line">                &#123;</span><br><span class="line">                    $match:&#123;</span><br><span class="line">                        $expr:&#123;</span><br><span class="line">                            $and:[</span><br><span class="line">                            &#123;$gte: [&#x27;$price&#x27;, 100]&#125;,</span><br><span class="line">                            &#123;$in: [&#x27;$name&#x27;, &#x27;$$bks&#x27;]&#125;</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                        //price:&#123;$gte:100&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            as: &#x27;booksData&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><br>3系统变量表达式<br><code>$$&lt;variable&gt;</code>: 使用$$来指示系统变量</p>
<h2 id="group"><a href="#group" class="headerlink" title="$group"></a>$group</h2><p>1.聚合管道阶段<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$group: 对文档进行分组</span><br><span class="line">格式  :</span><br><span class="line">&#123;$group:&#123;</span><br><span class="line">    _id:&lt;expression&gt;,</span><br><span class="line">    &lt;field1&gt;: &#123;&lt;accumulator1&gt;: &lt;expression1&gt;&#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;&#125;</span><br><span class="line">_id: 定义分组规则</span><br><span class="line">&lt;field&gt;: 定义新字段</span><br></pre></td></tr></table></figure><br>2.示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">&#123;name:&#x27;zs&#x27;, age:10, city:&#x27;北京&#x27;&#125;,</span><br><span class="line">&#123;name:&#x27;ls&#x27;, age:20, city:&#x27;上海&#x27;&#125;,</span><br><span class="line">&#123;name:&#x27;ww&#x27;, age:30, city:&#x27;北京&#x27;&#125;,</span><br><span class="line">&#123;name:&#x27;zl&#x27;, age:40, city:&#x27;上海&#x27;&#125;,</span><br><span class="line">&#123;name:&#x27;lnj&#x27;, age:50, city:&#x27;北京&#x27;&#125;,</span><br><span class="line">&#123;name:&#x27;jjj&#x27;, age:60, city:&#x27;广州&#x27;&#125;,</span><br><span class="line">])</span><br><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;$group:&#123;</span><br><span class="line">        _id:&#x27;$city&#x27;,</span><br><span class="line">        totalAge:&#123;$sum:&#x27;$age&#x27;&#125;,</span><br><span class="line">        avgAge:&#123;$avg:&#x27;$age&#x27;&#125;,</span><br><span class="line">        minAge:&#123;$min:&#x27;$age&#x27;&#125;,</span><br><span class="line">        maxAge:&#123;$max:&#x27;$age&#x27;&#125;,</span><br><span class="line">        totalName:&#123;$push:&#x27;$name&#x27;&#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<h2 id="out"><a href="#out" class="headerlink" title="$out"></a>$out</h2><p>1.聚合管道阶段<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$out: 前面阶段处理完的文档写入一个新的集合</span><br><span class="line">格式: &#123;$out: &lt;new collection name&gt;&#125;</span><br></pre></td></tr></table></figure><br>2.示例:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        $group:&#123;</span><br><span class="line">            _id: &#x27;$city&#x27;,</span><br><span class="line">            totalAge: &#123;$sum:&#x27;$age&#x27;&#125;,</span><br><span class="line">            avgAge: &#123;$avg: &#x27;$age&#x27;&#125;,</span><br><span class="line">            minAge: &#123;$min: &#x27;$age&#x27;&#125;,</span><br><span class="line">            maxAge: &#123;$max: &#x27;$age&#x27;&#125;,</span><br><span class="line">            totalAges: &#123;$push: &#x27;$age&#x27;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $out:&#x27;newPerson&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line">db.newPerson.find()</span><br></pre></td></tr></table></figure><br>3.注意点:<br>如果利用$out写入一个已经存在的集合, 那么集合中的原有数据会被覆盖</p>
<h2 id="allowdiskuse-额外配置"><a href="#allowDiskUse-额外配置" class="headerlink" title="allowDiskUse 额外配置"></a>allowDiskUse 额外配置</h2><p>1.聚合操作额外配置<br><code>db.&lt;collection&gt;.aggregate(&lt;pipeline&gt;, &lt;options&gt;)</code></p>
<p>格式:<code>&#123;allowDiskUse: &lt;boolean&gt;&#125;</code></p>
<p>allowDiskUse默认取值是false, 默认情况下管道阶段占用的内存不能超过100M,如果超出100M就会报错<br>如果需要处理的数据比较多, 聚合操作使用的内存可能超过100M, 那么我们可以将allowDiskUse设置为true<br>如果allowDiskUse设置为true, 那么一旦超出100M就会将操作的数据写入到临时文件中, 然后再继续操作</p>
<h2 id="ltfiledgt"><a href="#lt-filed-gt" class="headerlink" title="$ &lt;filed&gt;"></a><code>$ &lt;filed&gt;</code></h2><p>1.字段路径表达式</p>
<p><code>$&lt;filed&gt;</code>: 使用$来指示字段路径</p>
<p><code>$&lt;filed&gt;.&lt;sub-field&gt;</code>: 使用$和.来指示内嵌文档字段路径</p>
<p>2.示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$name</span><br><span class="line">$book.name</span><br></pre></td></tr></table></figure>
<p>3.系统变量表达式</p>
<p><code>$$CURRENT</code>: 表示当前操作的文档</p>
<p>4.示例</p>
<p><code>$$CURRENT.name</code>  等价于 <code>$name</code></p>
<p>5.常量表达式</p>
<p><code>$literal:&lt;value&gt;</code> : 表示常量<code>&lt;value&gt;</code></p>
<p>6.示例</p>
<p><code>$literal:&#39;$name&#39;</code> : 表示常量字符串<code>$name</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;Jonathan&#x27;, lastName:&#x27;Lee&#x27;&#125;, age:18&#125;,</span><br><span class="line">    &#123;name:&#123;firstName:&#x27;Amelie&#x27;, lastName:&#x27;Jiang&#x27;&#125;, age:19&#125;</span><br><span class="line">])</span><br><span class="line">db.person.find()</span><br><span class="line"></span><br><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;$project:&#123;</span><br><span class="line">        _id:0,</span><br><span class="line">        //myName:&#x27;$name.firstName&#x27;, // 字段路径表达式</span><br><span class="line">        //myAge:&#x27;$age&#x27; // 字段路径表达式</span><br><span class="line">        //myName:&#x27;$$CURRENT.name.firstName&#x27;, //系统变量表达式</span><br><span class="line">        //myAge:&#x27;$$CURRENT.age&#x27; // 系统变量表达式</span><br><span class="line">        myName:&#x27;$name.firstName&#x27;,</span><br><span class="line">        myAge:&#123;$literal:&#x27;$age&#x27;&#125; // 常量表达式</span><br><span class="line">    &#125;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="convert"><a href="#convert" class="headerlink" title="$convert"></a>$convert</h2><p>1.数据类型转换操作符</p>
<ul>
<li>MongoDB对于文档的格式并没有强制性的要求, 同一个集合中存储的文档, 字段的个数和数据类型都可以不同<br>对与文档的格式没有强制性的要求是MongoDB的一大优势, 但是同时也增加了数据消费端的使用难度<br>因为我们在使用数据的时候, 有可能同一个字段取出来的数据类型是不同的, 这样非常不利于我们后续操作<br>所以也正是因为如此, MongoDB在4.0中推出了$convert数据类型转换操作符</li>
<li>通过$convert数据类型转换操作符, 我们可以将不同的数据类型转换成相同的数据类型,<br>以便于后续我们在使用数据的过程中能够统一对数据进行处理</li>
</ul>
<p>2.$convert格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$convert:&#123;</span><br><span class="line">    input: &#x27;需要转换的字段&#x27;,</span><br><span class="line">    to: &#x27;转换之后的数据类型&#x27;,</span><br><span class="line">    onError: &#x27;不支持的转换类型&#x27;,</span><br><span class="line">    onNull: &#x27;没有需要转换的数据&#x27;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><br>3.示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">&#123;name:&#x27;zs&#x27;, timestamp:ISODate(&#x27;2020-08-09T11:23:34.733Z&#x27;)&#125;,</span><br><span class="line">&#123;name:&#x27;ls&#x27;, timestamp:&#x27;2021-02-14 12:00:06 +0800  &#x27;&#125;,</span><br><span class="line">&#123;name:&#x27;ww&#x27;, timestamp:&#x27;  2023-04-01T12:00:00Z&#x27;&#125;,</span><br><span class="line">&#123;name:&#x27;zl&#x27;, timestamp:&#x27;1587009270000&#x27;&#125;,</span><br><span class="line">&#123;name:&#x27;it666&#x27;, timestamp:&#x27;Sunday&#x27;&#125;,</span><br><span class="line">&#123;name:&#x27;itzb&#x27;&#125;,</span><br><span class="line">])</span><br><span class="line">db.person.aggregate([</span><br><span class="line">    &#123;$project:&#123;</span><br><span class="line">        _id:0,</span><br><span class="line">        timestamp:&#123;</span><br><span class="line">            $convert:&#123;</span><br><span class="line">                input:&#x27;$timestamp&#x27;,</span><br><span class="line">                to:&#x27;date&#x27;,</span><br><span class="line">                onError: &#x27;不支持的转换类型&#x27;,</span><br><span class="line">                onNull: &#x27;没有需要转换的数据&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<h2 id="聚合管道优化"><a href="#聚合管道优化" class="headerlink" title="聚合管道优化"></a>聚合管道优化</h2><p><a href="https://docs.mongoing.com/aggregation/aggregation-pipeline/aggregation-pipeline-optimization">聚合管道优化 - MongoDB-CN-Manual (mongoing.com)</a></p>
<h1 id="六-索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h1><h2 id="1什么是索引"><a href="#1-什么是索引" class="headerlink" title="1.什么是索引?"></a>1.什么是索引?</h2><ul>
<li>索引就相当于字典中的目录(拼音/偏旁部首手)<br>有了目录我们就能通过目录快速的找到想要的结果.</li>
<li>但是如果没有目录(拼音/偏旁部首手), 没有索引<br>那么如果想要查找某条数据就必须从前往后一条一条的查找</li>
<li>所以索引就是用于提升数据的查询速度的</li>
</ul>
<h2 id="2如何获取索引"><a href="#2-如何获取索引" class="headerlink" title="2.如何获取索引"></a>2.如何获取索引</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.getIndexes()</span><br><span class="line"></span><br><span class="line">db.person.insert([</span><br><span class="line">&#123;name:&#x27;cs&#x27;, age:19&#125;,</span><br><span class="line">&#123;name:&#x27;as&#x27;, age:18&#125;,</span><br><span class="line">&#123;name:&#x27;bs&#x27;, age:17&#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h2 id="3如何创建索引"><a href="#3-如何创建索引" class="headerlink" title="3.如何创建索引"></a>3.如何创建索引</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.createIndex(&#123;&lt;field&gt;:&lt;1 or -1&gt;, ...&#125;, &lt;options&gt;)</span><br><span class="line">&lt;keys&gt;   : 指定创建索引的字段</span><br><span class="line">&lt;options&gt;: 索引的额外配置</span><br></pre></td></tr></table></figure>
<h2 id="4创建单键索引"><a href="#4-创建单键索引" class="headerlink" title="4.创建单键索引"></a>4.创建单键索引</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.createIndex(&#123;name:1&#125;)</span><br><span class="line">db.person.explain().find(&#123;age:17&#125;)</span><br><span class="line">db.person.explain().find(&#123;name:&#x27;cs&#x27;&#125;)</span><br><span class="line">db.person.explain().find(&#123;name:&#x27;cs&#x27;&#125;, &#123;_id: 0, name:1&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="5查看是否使用索引"><a href="#5-查看是否使用索引" class="headerlink" title="5.查看是否使用索引"></a>5.查看是否使用索引</h2><p>和MySQL一样, 我们可以通过explain来查看索引效果<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.explain().&lt;method()&gt;</span><br><span class="line">winningPlan-&gt;stage-&gt;COLLSCAN-&gt;遍历整个集合查询</span><br><span class="line">winningPlan-&gt;stage-&gt;IXSCAN-&gt;  通过索引查询</span><br><span class="line">winningPlan-&gt;stage-&gt;FETCH-&gt;   根据索引存储的地址取出对应文档</span><br></pre></td></tr></table></figure><br>6.索引格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">as -&gt; &#123;name:&#x27;as&#x27;, age:18, tags:[&#x27;ahtml&#x27;, &#x27;bcss&#x27;]&#125;</span><br><span class="line">bs:-&gt; &#123;name:&#x27;bs&#x27;, age:17, tags:[&#x27;cjs&#x27;, &#x27;dvue&#x27;]&#125;</span><br><span class="line">cs:-&gt; &#123;name:&#x27;cs&#x27;, age:19, tags:[&#x27;enode&#x27;, &#x27;freact&#x27;]&#125;</span><br></pre></td></tr></table></figure><br>7.注意点:</p>
<ul>
<li>和MySQL一样, MongoDB默认也会为主键自动创建索引</li>
<li>如果查询条件中只需要查询出索引字段, 那么就不会再取出完整文档, 这样效率更高</li>
</ul>
<h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>1.和MySQL一样, MongoDB也支持复合索引, 也就是将多个字段的值作为索引</p>
<p>2.示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">&#123;name:&#x27;cs&#x27;, age:19&#125;,</span><br><span class="line">&#123;name:&#x27;as&#x27;, age:18&#125;,</span><br><span class="line">&#123;name:&#x27;bs&#x27;, age:17&#125;,</span><br><span class="line">&#123;name:&#x27;bs&#x27;, age:20&#125;,</span><br><span class="line">])</span><br><span class="line">db.person.createIndex(&#123;name:1, age:-1&#125;)</span><br><span class="line">db.person.explain().find(&#123;name:&#x27;bs&#x27;, age:17&#125;)</span><br><span class="line">db.person.explain().find(&#123;name:&#x27;bs&#x27;&#125;)</span><br><span class="line">db.person.explain().find(&#123;age:17&#125;)</span><br></pre></td></tr></table></figure><br>3.索引格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(as, 18)-&gt;&#123;name:&#x27;as&#x27;, age:18&#125;</span><br><span class="line">(bs, 20)-&gt;&#123;name:&#x27;bs&#x27;, age:20&#125;</span><br><span class="line">(bs, 17)-&gt;&#123;name:&#x27;bs&#x27;, age:17&#125;</span><br><span class="line">(cs, 19)-&gt;&#123;name:&#x27;cs&#x27;, age:19&#125;</span><br></pre></td></tr></table></figure><br>4.注意点:<br>复合件索引只支持前缀子查询, 也就是A,B,C复合索引. A,B,C会使用索引, A,B会使用索引, A会使用索引<br>但是B不会使用索引, C也不会使用索引, B,C也不会使用索引</p>
<h2 id="多键索引"><a href="#多键索引" class="headerlink" title="多键索引"></a>多键索引</h2><p>多键索引是专门针对数组字段的, 会为数组字段的每一个元素都创建一个索引</p>
<p>2.示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">&#123;name:&#x27;as&#x27;, age:18, tags:[&#x27;ahtml&#x27;, &#x27;bcss&#x27;]&#125;,</span><br><span class="line">&#123;name:&#x27;bs&#x27;, age:17, tags:[&#x27;cjs&#x27;, &#x27;enode&#x27;]&#125;,</span><br><span class="line">&#123;name:&#x27;cs&#x27;, age:19, tags:[ &#x27;dvue&#x27;, &#x27;freact&#x27;]&#125;,</span><br><span class="line">])</span><br><span class="line">db.person.explain().find(&#123;&#x27;tags&#x27;:&#123;$in:[&#x27;ahtml&#x27;]&#125;&#125;)</span><br><span class="line">db.person.createIndex(&#123;tags:1&#125;)</span><br><span class="line">db.person.explain().find(&#123;&#x27;tags&#x27;:&#123;$in:[&#x27;ahtml&#x27;]&#125;&#125;)</span><br></pre></td></tr></table></figure><br>3.格式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;ahtml&#x27;-&gt;&#123;name:&#x27;as&#x27;, age:18, tags:[&#x27;ahtml&#x27;, &#x27;bcss&#x27;]&#125;</span><br><span class="line">&#x27;bcss&#x27;-&gt;&#123;name:&#x27;as&#x27;, age:18, tags:[&#x27;ahtml&#x27;, &#x27;bcss&#x27;]&#125;</span><br><span class="line">&#x27;cjs&#x27;-&gt;&#123;name:&#x27;bs&#x27;, age:17, tags:[&#x27;cjs&#x27;, &#x27;enode&#x27;]&#125;</span><br><span class="line">&#x27;dvue&#x27;-&gt;&#123;name:&#x27;cs&#x27;, age:19, tags:[ &#x27;dvue&#x27;, &#x27;freact&#x27;]&#125;</span><br><span class="line">&#x27;enode&#x27;-&gt;&#123;name:&#x27;bs&#x27;, age:17, tags:[&#x27;cjs&#x27;, &#x27;enode&#x27;]&#125;</span><br><span class="line">&#x27;freact&#x27;-&gt;&#123;name:&#x27;cs&#x27;, age:19, tags:[ &#x27;dvue&#x27;, &#x27;freact&#x27;]&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="索引对排序的影响"><a href="#索引对排序的影响" class="headerlink" title="索引对排序的影响"></a>索引对排序的影响</h2><p>如果排序的字段, 正好是索引的字段, 那么会大大提升排序效率</p>
<p>2.示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">&#123;name:&#x27;cs&#x27;, age:19&#125;,</span><br><span class="line">&#123;name:&#x27;as&#x27;, age:18&#125;,</span><br><span class="line">&#123;name:&#x27;bs&#x27;, age:17&#125;</span><br><span class="line">])</span><br><span class="line">db.person.explain().find().sort(&#123;name:1&#125;)</span><br><span class="line">db.person.createIndex(&#123;name:1&#125;)</span><br><span class="line">db.person.explain().find().sort(&#123;name:1&#125;)</span><br><span class="line">db.person.explain().find().sort(&#123;name:1, age:-1&#125;)</span><br><span class="line">db.person.createIndex(&#123;name:1, age:-1&#125;)</span><br><span class="line">db.person.explain().find().sort(&#123;name:1, age:-1&#125;)</span><br></pre></td></tr></table></figure></p>
<p>3.注意点<br>如果是复合索引, 那么只有排序条件是前缀查询的形式才会使用索引来排序<br>例如:<br>复合件索引只支持前缀子查询, 也就是A,B,C复合索引.<br>A,B,C会使用索引, A,B会使用索引, A会使用索引.<br>但是B不会使用索引, C也不会使用索引, B,C也不会使用索引</p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>默认情况下MongoDB和MySQL一样, 都会自动为主键创建索引, 这个索引就是一个唯一索引<br>除了主键可以作为唯一索引以外, 只要某个字段的取值是唯一的, 我们也可以手动给这个字段添加唯一索引<br>格式: <code>db.&lt;collection&gt;.createIndex(&#123;&lt;field&gt;:&lt;1 or -1&gt;, ...&#125;, &#123;unique:true&#125;&#125;)</code></p>
<p>2.示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">&#123;name:&#x27;cs&#x27;, age:19&#125;,</span><br><span class="line">&#123;name:&#x27;as&#x27;, age:18&#125;,</span><br><span class="line">&#123;name:&#x27;bs&#x27;, age:17&#125;</span><br><span class="line">])</span><br><span class="line">db.person.getIndexes()</span><br><span class="line">db.person.createIndex(&#123;age:1&#125;, &#123;unique:true&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;zs&#x27;, age:20&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;ls&#x27;&#125;)</span><br><span class="line">db.person.find()</span><br><span class="line">db.person.insert(&#123;name:&#x27;ls&#x27;&#125;)</span><br><span class="line">db.person.createIndex(&#123;name:1,age:1&#125;, &#123;unique:true&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;ww&#x27;, age:22&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;ww&#x27;, age:22&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;ww&#x27;, age:23&#125;)</span><br></pre></td></tr></table></figure><br>3.注意点<br>3.1如果为某个字段添加了唯一索引, 那么就不能再给这个字段添加重复的值<br>3.2如果插入的数据中没有包含唯一索引的字段, 那么第一次会自动用null填充, 第二次会报错<br>3.3如果是复合唯一索引, 那么复合字段的组合不能重复</p>
<h2 id="索引的稀疏性"><a href="#索引的稀疏性" class="headerlink" title="索引的稀疏性"></a>索引的稀疏性</h2><p>默认情况下MongoDB会给每一个文档都创建索引, 哪怕这个文档中没有指定索引的字段或者字段的取值是Null<br>但是这样大大增加了索引的体积, 所以为了进一步优化索引占用的存储空间, 我们可以创建稀疏索引<br>也就是只会为存在索引字段,并且索引字段取值不是null的文档创建索引<br>格式: db.<collection>.createIndex({<field>:<1 or -1>, …}, {sparse:true}})</1></field></collection></p>
<p>2.示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">&#123;name:&#x27;cs&#x27;, age:19&#125;,</span><br><span class="line">&#123;name:&#x27;as&#x27;, age:18&#125;,</span><br><span class="line">&#123;name:&#x27;bs&#x27;, age:17&#125;</span><br><span class="line">])</span><br><span class="line">db.person.find()</span><br><span class="line">db.person.getIndexes()</span><br><span class="line">db.person.createIndex(&#123;age:1&#125;, &#123;unique:true&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;lnj&#x27;&#125;) // lnj null</span><br><span class="line">db.person.insert(&#123;name:&#x27;lnj&#x27;&#125;) // lnj null</span><br><span class="line">// 注意点: 如果索引具备了唯一性又具备了稀疏性, 那么就可以多次添加缺失了索引字段的文档了</span><br><span class="line">// 原因 : 如果索引具备了稀疏性, 那么就不会为缺失了索引字段或者索引字段取值是null的文档创建索引了, 所以就不会冲突了</span><br><span class="line">db.person.createIndex(&#123;age:1&#125;, &#123;unique:true, sparse: true&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;lnj&#x27;&#125;) // lnj null</span><br><span class="line">db.person.insert(&#123;name:&#x27;lnj&#x27;&#125;) // lnj null</span><br></pre></td></tr></table></figure>
<p>3.注意点<br>3.1如果索引字段既具备唯一性又具备稀疏性, 那么就可以在集合中保存多个缺失唯一索引字段的文档</p>
<h2 id="索引生存时间"><a href="#索引生存时间" class="headerlink" title="索引生存时间"></a>索引生存时间</h2><p>针对日期字段或者包含日期的数组字段, 我们可以在创建索引的时候, 指定索引的生存时间,<br>一旦索引超过了指定的生存时间, 那么MongoDB会自动删除超过生存时间的文档<br>格式: db.<collection>.createIndex({<field>:<1 or -1>, …}, {expireAfterSeconds:second}})</1></field></collection></p>
<p>2.示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.createIndex(&#123;addTime:1&#125;, &#123;expireAfterSeconds: 5&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;zs&#x27;, addTime:new Date()&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;ls&#x27;, addTime:new Date()&#125;)</span><br><span class="line">db.person.insert(&#123;name:&#x27;ww&#x27;, addTime:new Date()&#125;)</span><br></pre></td></tr></table></figure></p>
<p>3.注意点<br>3.0 MongoDB会定期清理超过时间的文档, 但是无法保证即时性(也就是设置的过期时间是1秒, 但是可能3秒后才会清除)<br>3.1 复合索引字段是不具备生存时间特性的, 也就是不能在复合索引中指定生存时间<br>3.2 当数组字段中包含多个日期, 我们给数组字段设置生存时间时, 系统会按照数组中最小的时间来计算生存时间<br>例如: <code>&#123;name:&#39;it666&#39;, times:[&#39;2022-04-16 09:13:33&#39;,&#39;2022-04-16 07:13:33&#39;,&#39;2022-04-16 08:13:33&#39;]&#125;</code><br>       会按照’2022-04-16 07:13:33’来计算生存时间</p>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p><code>db.&lt;collection&gt;.dropIndex(&lt;IndexName | IndexDefine&gt;)</code></p>
<p>2.示例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.person.insert([</span><br><span class="line">&#123;name:&#x27;cs&#x27;, age:19&#125;,</span><br><span class="line">&#123;name:&#x27;as&#x27;, age:18&#125;,</span><br><span class="line">&#123;name:&#x27;bs&#x27;, age:17&#125;</span><br><span class="line">])</span><br><span class="line">db.person.find()</span><br><span class="line">db.person.getIndexes()</span><br><span class="line">db.person.createIndex(&#123;name:1&#125;)</span><br><span class="line">db.person.dropIndex(&#x27;name_1&#x27;) // 通过索引的名称来删除</span><br><span class="line">db.person.dropIndex(&#123;name:1&#125;) // 通过索引的定义来删除</span><br><span class="line">// 注意点: 如果是复合索引, 如果需要通过索引的定义来删除, 那么就必须一模一样才能正确的删除</span><br><span class="line">db.person.createIndex(&#123;name:1, age:-1&#125;)</span><br><span class="line">db.person.dropIndex(&#123;name:1&#125;) // 报错</span><br><span class="line">db.person.dropIndex(&#123;age:-1&#125;) // 报错</span><br><span class="line">db.person.dropIndex(&#123;age:-1, name:1&#125;) // 报错</span><br><span class="line">db.person.dropIndex(&#123;name:1, age:-1&#125;) // 不会报错</span><br></pre></td></tr></table></figure><br>3.注意点<br>3.1在MongoDB中没有修改索引的方法, 所以如果想修改索引就必须先删除再重新创建<br>3.2如果删除的索引是多个字段, 如果是通过索引定义来删除, 那么传入的参数必须和定义一模一样才可以</p>
<h1 id="七-数据模型"><a href="#七、数据模型" class="headerlink" title="七、数据模型"></a>七、数据模型</h1><p>1.文档之间关系<br>MongoDB对于文档的格式并没有强制性的要求, 但不等于我们不能在文档中表达数据的关系<br>在MongoDB中我们可以通过’内嵌式结构’和’规范式结构’来表达文档之间的关系</p>
<p>2.内嵌式结构<br>在一个文档中又包含了另一个文档, 我们就称之为内嵌式结构<br>例如:<br>{<br>    name:’zs’,<br>    age:’18’,<br>    card:{<br>        num:’420626200002023556’,<br>        date: 88<br>    }<br>}</p>
<p>3.规范式结构<br>将文档存储在不同的集合中, 然后通过某一个字段来建立文档之间的关系, 我们就称之为规范式<br>{<br>    _id: 1,<br>    num:’420626200002023556’,<br>    date: 88<br>}<br>{<br>    name:’zs’,<br>    age:’18’,<br>    cardId: 1<br>}</p>
<p>1.文档一对一关系<br>一个人有一张身份证<br>1.1内嵌式结构<br>db.person.insert({<br>    name:’zs’,<br>    age:’18’,<br>    card:{<br>        num:’420626200002023556’,<br>        date: 88<br>    }<br>})<br>db.person.find({name:’zs’})<br>优势: 一次查询就能得到所有数据<br>劣势: 如果数据比较复杂, 不方便管理和更新<br>应用场景: 数据不复杂/查询频率较高数据</p>
<p>1.2规范式结构<br>db.card.insert({<br>    _id: 123,<br>    num:’420626200002023556’,<br>    date: ‘2022-12-08’,<br>    userId: 456<br>})<br>db.person.insert({<br>    _id: 456,<br>    name:’zs’,<br>    age:’18’,<br>    cardId: 123<br>})<br>db.person.aggregate([<br>    {$lookup:{<br>        from: ‘card’,<br>        localField: ‘cardId’,<br>        foreignField: ‘_id’,<br>        as: ‘card’<br>    }}<br>])<br>优势: 如果数据比较复杂, 也方便管理和更新<br>劣势: 查询数据相对内嵌结果稍微有点复杂<br>应用场景: 数据比较复杂/更新频率较高数据</p>
<p>1.文档一对多关系<br>一个人有多本书<br>1.1内嵌式结构<br>db.person.insert({<br>    name:’zs’,<br>    age:’18’,<br>    books:[{<br>        name:’玩转HTML’,<br>        price: 88<br>    },<br>    {<br>        name:’玩转CSS’,<br>        price: 88<br>    }]<br>})<br>db.person.find({name:’zs’})<br>优势: 一次查询就能得到所有数据<br>劣势: 冗余数据较多, 不方便管理和更新<br>应用场景: 数据不复杂/查询频率较高数据</p>
<p>1.2规范式结构<br>db.books.insert([{<br>    _id: 1,<br>    name:’玩转HTML’,<br>    price: 88,<br>    userId:123<br>},<br>{<br>    _id: 2,<br>    name:’玩转CSS’,<br>    price: 88,<br>    userId:123<br>}])<br>db.person.insert({<br>    _id: 123,<br>    name:’ls’,<br>    age:’20’,<br>    booksId:[1, 2]<br>})<br>db.person.aggregate([<br>    {$lookup:{<br>        from: ‘books’,<br>        localField: ‘booksId’,<br>        foreignField: ‘_id’,<br>        as: ‘books’<br>    }}<br>])<br>优势: 冗余数据较少, 更新较为方便<br>劣势: 查询数据相对内嵌结果稍微有点复杂<br>应用场景: 数据比较复杂/更新频率较高数据</p>
<p>1.文档多对多关系<br>一个学生有多个老师<br>一个老师有多个学生<br>1.1内嵌式结构<br>db.students.insert([{name:’zs’, teachers:[{name:’it666’}, {name:’itzb’}]},<br>{name:’ls’, teachers:[{name:’it666’}, {name:’itzb’}]}])</p>
<p>db.teachers.insert([{name:’it666’, students:[{name:’zs’}, {name:’ls’}]},<br>{name:’itzb’, students:[{name:’zs’}, {name:’ls’}]}])<br>db.students.find({name:’zs’})<br>db.teachers.find({name:’itzb’})<br>优势: 一次查询就能得到所有数据<br>劣势: 冗余数据较多, 更新和管理较为复杂<br>应用场景: 数据比较简单/查询频率较高数据</p>
<p>1.2规范式结构<br>db.students.insert([{_id:1, name:’zs’},{_id:2, name:’ls’}])<br>db.teachers.insert([{_id:3, name:’it6666’},{_id:4, name:’itzb’}])<br>db.relation.insert([{stuId:1, teacherId:3},{stuId:1, teacherId:4},{stuId:2, teacherId:3},{stuId:2, teacherId:4}])</p>
<p>db.students.aggregate([<br>    {$lookup:{<br>        from: ‘relation’,<br>        localField: ‘_id’,<br>        foreignField:’stuId’,<br>        as: ‘relation’<br>    }},<br>    {$lookup:{<br>        from: ‘teachers’,<br>        localField: ‘relation.teacherId’,<br>        foreignField:’_id’,<br>        as: ‘teachers’<br>    }},<br>    {$project:{_id:0, name:1, teachers:1}}<br>])</p>
<p>优势: 冗余数据较少, 更新较为方便<br>劣势: 查询数据相对内嵌结果稍微有点复杂<br>应用场景: 数据比较复杂/更新频率较高数据</p>
<p>1.树形结构<br>在MongoDB中我们除了可以使用’内嵌式结构’和’规范式结构’来表示数据的关系以外<br>由于MongoDB数据的灵活性, 我们还可以使用’树形结构’来表示数据之间的关系</p>
<p>2.什么是树形结构<br>            Database<br>               |<br>     |——————————|<br> Relational           No-Relational<br>     |          |—————-|——————-|<br>   MySQL      Key-Value                Document<br>                |                         |<br>              Redis                    MongoDB</p>
<p>3.对于经常需要查询子节点的数据<br>{name:’Database’, parent:null}<br>{name:’No-Relational’, parent:’Database’}<br>{name:’Document’, parent:’No-Relational’}<br>{name:’MongoDB’, parent:’Document’}<br>{name:’Key-Value’, parent:’No-Relational’}<br>{name:’Redis’, parent:’Key-Value’}<br>例如:我们要查询非关系型数据库有几种类型, 我们可以使用find({parent:’No-Relational’})</p>
<p>4.对于经常需要查询父节点的数据<br>{name:’Database’, children:[‘Relational’, ‘No-Relational’]}<br>{name:’No-Relational’, children:[‘Key-Value’, ‘Document’]}<br>{name:’Document’, children:[‘MongoDB’]}<br>{name:’MongoDB’, children:[]}<br>例如:我们要查询MongoDB是什么类型的的数据, 我们可以使用find({children:{$in:[‘MongoDB’]}})</p>
<p>5.对于经常查询祖先或者后代节点的数据<br>{name:’Database’, ancestors:[]}<br>{name:’No-Relational’, ancestors:[‘Database’]}<br>{name:’Document’, ancestors:[‘Database’, ‘No-Relational’]}<br>{name:’MongoDB’, ancestors:[‘Database’, ‘No-Relational’, ‘Document’]}<br>例如: 我们要查询MongoDB的祖先有哪些, 我们可以使用find({name:’MongoDB’})<br>例如: 我们要查询Database的后代有哪些, 我们可以使用find({ancestors:{$in:[‘Database’]}}})</p>
<p>6.结合深度优先或者广度优先算法来实现树形结构</p>
<h1 id="八-复制集"><a href="#八、复制集" class="headerlink" title="八、复制集"></a>八、复制集</h1><p>1.MongoDB高可用性</p>
<ul>
<li>如果所有用户都从同一台MongoDB服务器上读写数据<br>那么如果这台MongoDB服务器宕机了, 用户就不能进行读写了</li>
<li>如果我们有多台MongoDB服务器, 并且每台服务器中存储的内容都相同<br>那么即使有一台服务器宕机了, 用户依然可以进行读写数据, 因为用户还可以继续使用其它保存了相同内容的服务器</li>
<li>以上这种特点, 我们就称之为’高可用性’</li>
</ul>
<p>2.MongoDB数据安全性</p>
<ul>
<li>如果所有数据都保存在同一台MongoDB服务器上<br>那么如果这台MongoDB服务器坏了, 那么很有可能会导致数据丢失</li>
<li>如果我们有多台MongoDB服务器, 并且每台服务器中存储的内容都相同<br>那么即使有一台服务器坏了, 那么依然不会导致数据丢失, 因为我们还有其它保存了相同内容的服务器</li>
<li>以上这种特点, 我们就称之为’数据的安全性’</li>
</ul>
<p>3.MongoDB数据分流</p>
<ul>
<li>如果所有用户都从同一台MongoDB服务器上读写数据<br>那么由于服务器的性能限制和网络传输速度的限制<br>会导致同一时刻用户量较多时, 服务器负荷增大, 数据处理速度变慢的问题<br>会导致由于用户距离服务器较远, 网络传输时间变长, 响应速度变慢的问题</li>
<li>如果我们有多台MongoDB服务器, 并且每台服务器中存储的内容都相同, 并且安放到了不同的地区<br>那么我们可以采用就近原则返回数据, 提升网络的传输速度<br>那么我们可以采用请求分流, 降低每台服务器负荷, 提升数据处理速度</li>
<li>以上这种特点, 我们就称之为’数据分流’</li>
</ul>
<p>4.MongoDB复制集</p>
<ul>
<li>在MongoDB中我们可以通过复制集来实现如上的功能</li>
<li>复制集就是使用多台保存了相同内容的MongoDB服务器来组成一个数据库集群<br>这个数据库集群中的每一台MongoDB服务我们称之为一个节点</li>
</ul>
<p>1.MongoDB复制集特点</p>
<ul>
<li>复制集中必须有一个主节点<ul>
<li>主节点主要负责写入数据和读取</li>
</ul>
</li>
<li>复制集中除了主节点以外的节点我们称之为’副节点’<ul>
<li>副节点默认情况下只能读取数据, 不能写入数据</li>
<li>副节点主要负责从主节点不断复制数据</li>
</ul>
</li>
<li>复制集中所有的节点都会不断的相互发送心跳请求<ul>
<li>心跳请求的目的是相互检查节点的健康程度(是否发生故障)</li>
<li>默认情况下每个2秒发送一次心跳请求</li>
<li>默认情况下如果10秒没有收到某一个节点心跳请求, 系统就会认定为超时</li>
</ul>
</li>
<li>复制集中节点的个数是有限制的<ul>
<li>每个复制集中最多只能有50个节点</li>
<li>由于节点会发送心跳请求(消耗性能), 所以并不是节点越多越好</li>
</ul>
</li>
</ul>
<p>2.复制集选举</p>
<ul>
<li>复制集最大的特点之一就是高可用性,<br>但是在复制集中只有一个主节点, 只有主节点可以读写<br>那么如果主节点宕机了, 也就意味着用户只能读取数据, 不能写入数据了</li>
<li>复制集中的主节点是通过选举出来的, 也就是一旦当前主节点宕机了<br>MongoDB会通过自动选举的方式, 将其它的副节点设置为主节点</li>
<li>正式因为复制集的这个特点, 大大的保证了数据库的高可用性</li>
</ul>
<p>1.选举规则</p>
<ul>
<li>一旦发现主节点没有响应/发送心跳请求, 那么副节点就会认为主节点挂了</li>
<li>一旦发现主节点挂了, 任意一个副节点都可以发起选举</li>
<li>(发起选举的节点我们称之为候选节点, 每一个节点内部都有一个选举计数器)</li>
<li>发起选举的节点会给自己先投一票, 然后将自己的票数依次发送给其它节点</li>
<li>其它节点收到投票请求后,会先利用发送过来的票数同步自己计数器的票数<br>然后再对比自己的数据和候选节点的数据哪个更完整<br>如果自己的更完整, 那么会投出反对票<br>如果候选节点的更完整, 那么会投出赞同票</li>
<li>最后如果超过半数的节点投出赞同票, 那么候选节点就会变成主节点</li>
<li>最后如果没有超过半数节点投出赞同票, 那么其它节点会重新发起选举, 重复上述过程</li>
</ul>
<p>2.选举注意点</p>
<ul>
<li>一个复制集中最多只能有7个投票节点</li>
<li>如果某个节点没有返回投票结果, 那么默认就是不赞同<ul>
<li>挂掉的节点不会返回结果</li>
</ul>
</li>
<li>因为选举需要超过半数节点同意,才会将副节点变成主节点<br>所以在企业开发中一个复制集至少需要3个节点<br>否则一旦主节点挂了, 永远无法完成投票</li>
<li>因为选举需要超过半数节点同意,才会将副节点变成主节点<br>所以在企业开发中节点的个数最好是奇数</li>
</ul>
<p>3.触发选举的其它条件</p>
<ul>
<li>初始化复制集时, 会自动触发选举</li>
<li>有新节点加入时, 会自动触发选举</li>
<li>当前主节点挂掉时, 会自动触发选举</li>
</ul>
<p>1.初始化同步</p>
<ul>
<li>将一个新的节点加入到复制集中时, 就需要进行初始化同步</li>
<li>初始化同步会先情况自己所有的内容, 保证将来自己和主节点一模一样</li>
<li>初始化同步会将主节点中现有所有的’数据库’,’集合’,’文档’,’索引’全部拷贝过来</li>
<li>但是在拷贝的过程中主节点仍然可能会做一些其它操作, 新增一些其它的数据等<br>所以仅仅做一次大型的拷贝是不能保证副节点和主节点一模一样的</li>
</ul>
<p>2.同步写库记录</p>
<ul>
<li>每个节点中都有一个local数据库, 这个数据库中有一个oplog的集合<br>这个集合就是专门用来保存数据库的操作记录的(写库记录)</li>
<li>做完初始化同步之后, 副节点就会定期从主节点中拷贝写库记录<br>将写库记录保存到自己的local数据库中, 然后执行写库记录中的操作<br>从而使得自己的内容和主节点的内容保持高度一致</li>
</ul>
<p>3.写库记录注意点</p>
<ul>
<li>写库记录是可以被多次应用的, 但是多次应用和一次应用的效果是一样的<br>也就是有效的防止了多次应用造成的主节点和副节点内容不一致问题</li>
<li>应用写库记录的时候是通过多线程分批次应用的, 这样大大提高了引用的效率和性能</li>
</ul>
<p>1.投票节点</p>
<ul>
<li>投票节点就是不保存任何数据, 只参与投票的节点</li>
<li>无论是初始化同步, 还是同步写库记录, 其实都会消耗服务器性能<br>所以在企业开发中并不是副节点越多越好<br>所以在保证高可用性、数据库安全性的同时, 为了提升服务器的性能<br>我们还可以添加投票节点</li>
<li>投票节点不保存任何数据, 所以就不存在同步数据带来的性能消耗问题</li>
<li>投票节点可以投票, 就保证了不会出现副节点过少无法完成投票问题</li>
</ul>
<p>1.MongoDB复制集搭建<br><a href="https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2012plus-4.2.6.zip">https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2012plus-4.2.6.zip</a><br>1.1解压MongoDB安装包<br>1.2在安装目录下新建data/conf/log文件夹<br>1.3在conf文件夹下新建mongo.config<br>1.4在mongo.config中配置如下内容<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Where and how to store data.</span><br><span class="line">storage:</span><br><span class="line">  dbPath: D:\Developer\MongoDB666\mongodb27020\data</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line"># where to write logging data.</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path:  D:\Developer\MongoDB666\mongodb27020\log\mongo.log</span><br><span class="line"># network interfaces</span><br><span class="line">net:</span><br><span class="line">  port: 27020</span><br><span class="line">  bindIp: 127.0.0.1</span><br></pre></td></tr></table></figure><br>1.5注册配置MongoDB<br>1.5.1注册服务<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongod --config D:\Developer\MongoDB666\mongodb27018\bin\mongo.config --serviceName &quot;MongoDB27018&quot; --serviceDisplayName &quot;MongoDB27018&quot; --replSet &quot;it666&quot; --install</span><br><span class="line">mongod --config D:\Developer\MongoDB666\mongodb27019\bin\mongo.config --serviceName &quot;MongoDB27019&quot; --serviceDisplayName &quot;MongoDB27019&quot; --replSet &quot;it666&quot; --install</span><br><span class="line">mongod --config D:\Developer\MongoDB666\mongodb27020\bin\mongo.config --serviceName &quot;MongoDB27020&quot; --serviceDisplayName &quot;MongoDB27020&quot; --replSet &quot;it666&quot; --install</span><br></pre></td></tr></table></figure><br>1.5.2手动启动服务<br>1.5.3测试连接<br>mongo —host 127.0.0.1 —port 27018<br>mongo —host 127.0.0.1 —port 27019<br>mongo —host 127.0.0.1 —port 27020<br>1.6初始化复制集<br>rs.initiate({<br>_id: ‘it666’,<br>members: [<br>{_id: 0, host: ‘127.0.0.1:27018’},<br>{_id: 1, host: ‘127.0.0.1:27019’},<br>{_id: 2, host: ‘127.0.0.1:27020’}]<br>})<br>1.7在主节点写入读取<br>1.8在副节点读取rs.slaveOk()</p>
<p>_id            整数 节点的唯一标识。<br>host       字符串    节点的IP地址，包含端口号。<br>arbiterOnly    布尔值    是否为投票节点，默认是false。是设置投票(选举)节点有关的参数<br>priority   整数 选举为主节点的权值，默认是1，范围0-1000。<br>hidden     布尔值    是否隐藏，默认false，是设置隐藏节点有关的参数。<br>votes      整数 投票数，默认为1，取值是0或1，是设置”投票“节点有关的参数。<br>slaveDelay 整数 延时复制，是设置延时节点有关的参数。单位秒(s)</p>
<h1 id="九-分片"><a href="#九、分片" class="headerlink" title="九、分片"></a>九、分片</h1><p>1.什么是复制集?<br>‘多台’’保存了相同数据’的MongoDB服务器组成</p>
<p>2.复制集解决的问题<br>高可用性-服务器宕机不会影响我们继续使用<br>数据安全性-服务器损坏数据不会丢失</p>
<p>3.复制集不能解决的问题</p>
<ul>
<li>服务器容量的问题</li>
<li>我们都知道一台服务器的容量是有上限的<br>所以我们只能通过增加服务器的台数来提升容量</li>
<li>复制集虽然是由多台电脑组成的, 但是由于多台电脑保存的数据都是一样的<br>所以在复制集中虽然电脑增多了, 但是容量并没有增加<br>所以复制集是不能解决服务器容量问题的</li>
</ul>
<p>5.MongoDB中如何增加服务器容量?</p>
<ul>
<li>通过’分片’来实现</li>
</ul>
<p>6.什么是分片?</p>
<ul>
<li>分片就是将数据库集合中的数据拆分成多份, 分布式的保存到多台电脑上<ul>
<li>这样不同的电脑保存不同的数据, 就大大的提升了服务器的容量</li>
</ul>
</li>
</ul>
<p>7.分片注意点</p>
<ul>
<li>并不是数据库所有的集合都需要使用分片, 对于那些不使用分片的集合会统一保存到主分片中<ul>
<li>默认每个数据库都有一个主分片, 保存那些不需要分片的集合数据</li>
<li>在创建数据库的时候, 系统会自动选择存储内容最少的分片作为主分片</li>
</ul>
</li>
</ul>
<ul>
<li>1.分片集群结构<br>1.分片服务器: 用于保存集合中的一部分数据<br>2.配置服务器: 用于保存分片数据的数据段和数据范围<br>3.mongos路由(路由服务器): 用于分发请求到保存对应数据的分片服务器上</li>
</ul>
<p>3.分片集群执行流程<br>用户发送请求到’mongos路由’ -&gt; ‘mongos路由’去’配置服务器’查询数据在哪个分片服务器<br>‘mongos路由’根据’配置服务器’返回的结果到对应的’分片服务器’操作数据<br>‘分片服务器’将操作结果返回给’mongos路由’, ‘mongos路由’将最终结果返回给用户</p>
<p>1.如何将数据存储到不同的分片服务器上的?<br>通过分片片键</p>
<p>2.什么是分片片键?<br>2.1可以将文档的一个或多个字设置成分片片键<br>2.2设置完分片片键后, MongoDB会自动对字段可能的取值进行划分, 划分出一个个的数据段<br>2.3划分完数据段之后,  MongoDB会自动决定哪些分片服务器保存哪些数据段对应的数据<br>例如: {name:’lnj’, age:33}<br>      age:min    20     40     60     80    age:max<br>         |———-|———|———|———|———|</p>
<p> 分片服务器1      分片服务器2       分片服务器3<br>|—————-|    |—————-|     |—————-|<br>|   min-20  |    |   80-max  |     |   40-60   |<br>|   20-40   |    |   60-80   |     |           |<br>|—————-|    |—————-|     |—————-|</p>
<p>3.注意点:<br>1.片键可以是一个字段也可以是多个字段<br>2.只有索引字段才能设置为片键<br>3.分片服务器保存哪些数据段的值是随机的, 并不是连续的<br>4.数据段的划分可以使用片键的取值, 也可以使用片键取值的哈希值</p>
<p>1.如何选择片键<br>使用分片的目的是为了将数据存储到不同的服务器上<br>所以在选择片键的时候<br>1.1应该选择取值范围更广的字段作为片键<br>因为如果取值范围太小, 那么划分出来的数据段就太少, 那么分配到不同服务器的概率就越小<br>例如: 取值如果只有true或false, 那么就只能划分出两个数据段<br>      那么也就最多只能保存到两台服务器上<br>1.2应该选择取值分配更平衡字段作为片键<br>因为如果取值范围不平衡, 就会导致某一个数据段的数据太多, 某一台分片服务器压力太大<br>例如: 将age作为片键, 但是我们的用户90%都集中中20~30岁,<br>      那么就会导致保存20~30数据段的分片服务器存储数据过多压力过大<br>1.3不应该选择单向增加或者减少的字段作为片键<br>因为如果取值是单向增加或者减少的, 那么就会出现可能出现的最小值数据段或者最大值数据段保存的数据过多,<br>对应的分片服务器压力过大</p>
<p>2.片键选择技巧<br>2.1如果片键字段取值范围不够广, 那么我们可以使用复合片键<br>2.2如果片键字段的取值不够平衡, 那么我们可以使用复合片键<br>2.3如果片键字段的取值是单向增加或减少的, 那么我们可以使用片键字段的哈希值</p>
<p>3.片键注意点<br>片键一旦选择就不能更改, 所以在前期选择片键时一定要多动脑</p>
<p>1.数据段分裂<br>分片的主要目的就是将数据分配到不同的服务器中保存,<br>提升服务器的容量, 让数据更加的均衡, 更有效的降低服务器的压力<br>但是随着时间推移, 某些数据段中保存的数据会越来越多,<br>所以为了保证个分片均衡, 当某个数据段数据过多或体积过大的时候,<br>系统就会自动在下一次操作这个数据段时(新增/更新), 将一个大的数据段分裂成多个小的数据段</p>
<p>3.分片平衡<br>除了当某个数据段数据过多或体积过大的时候会自动对数据段进行分裂以外<br>当各分片服务器上保存的数据段之间数量相差较大时, 还会自动触发分片服务器数据段迁移<br>在MongoDB中后台会自动运行一个’集群平衡器’来负责监视分片的平衡和调整分片的平衡</p>
<p>1.分片查询注意事项<br>1.1用户的请求会发送给mongos路由服务器,<br>路由服务器会根据查询条件去配置服务器查询对应的数据段和属于哪个分片服务器<br>1.2如果用户查询的条件是分片片键字段,<br>那么路由服务器会返回保存在那一台分片服务器上, 路由服务器就会去对应的分片服务器获取数据,<br>并将取到的数据返回给用户<br>1.3如果用户查询的条件不是分片片键字段,<br>那么配置服务器无法告知路由服务器数据保存在哪一个分片服务器上<br>路由服务器会把请求发送到所有的分片服务器上, 然后再将查询到的数据汇总后返回给用户</p>
<p>1.分片集群搭建<br>1.1搭建配置服务器复制集</p>
<pre><code>- 早期版本的配置服务器只要一台即可
- 最新版本MongoDB要求配置服务器必须是一个复制集
</code></pre><p>1.2搭建分片服务器复制集</p>
<pre><code>- 用于保存数据的多台电脑
</code></pre><p>1.3搭建路由服务器</p>
<pre><code>- 用于建立配置服务器和分片服务器之间的关系
</code></pre><p>1.搭建配置服务器集群<br>1.1编写配置文件<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据保存到哪</span><br><span class="line">storage:</span><br><span class="line">  dbPath: D:\Developer\MongoDB666\mongodb-config-27018\data</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">#  engine:</span><br><span class="line">#  mmapv1:</span><br><span class="line">#  wiredTiger:</span><br><span class="line"># 日志保存到哪</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path:  D:\Developer\MongoDB666\mongodb-config-27018\log\mongod.log</span><br><span class="line"># 绑定的IP和端口号</span><br><span class="line">net:</span><br><span class="line">  port: 27018</span><br><span class="line">  bindIp: 127.0.0.1</span><br><span class="line"># 复制集名称</span><br><span class="line">replication:</span><br><span class="line">  replSetName: &#x27;it666&#x27;</span><br><span class="line"># 复制集的作用</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: configsvr</span><br></pre></td></tr></table></figure><br>1.2注册MongoDB服务<br>管理员权限运行终端, 执行如下指令<br>mongod —config D:\Developer\MongoDB666\mongodb-config-27018\bin\mongo.config —serviceName “MongoDB27018” —serviceDisplayName “MongoDB27018”  —install<br>mongod —config D:\Developer\MongoDB666\mongodb-config-27019\bin\mongo.config —serviceName “MongoDB27019” —serviceDisplayName “MongoDB27019”  —install<br>mongod —config D:\Developer\MongoDB666\mongodb-config-27020\bin\mongo.config —serviceName “MongoDB27020” —serviceDisplayName “MongoDB27020”  —install<br>在任务管理器中开启任务<br>1.3测试服务可用性<br>mongo —host 127.0.0.1 —port 27018<br>mongo —host 127.0.0.1 —port 27019<br>mongo —host 127.0.0.1 —port 27020<br>1.4添加复制集<br>rs.initiate({<br>_id: ‘it666’,<br>configsvr: true,<br>members: [<br>{_id: 0, host: ‘127.0.0.1:27018’},<br>{_id: 1, host: ‘127.0.0.1:27019’},<br>{_id: 2, host: ‘127.0.0.1:27020’}]<br>})</p>
<p>2.搭建分片服务器集群<br>2.1编写配置文件<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据保存到哪</span><br><span class="line">storage:</span><br><span class="line">  dbPath: D:\Developer\MongoDB666\mongodb-shard-27021\data</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true</span><br><span class="line">#  engine:</span><br><span class="line">#  mmapv1:</span><br><span class="line">#  wiredTiger:</span><br><span class="line"># 日志保存到哪</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path:  D:\Developer\MongoDB666\mongodb-shard-27021\log\mongod.log</span><br><span class="line"># 绑定的IP和端口号</span><br><span class="line">net:</span><br><span class="line">  port: 27021</span><br><span class="line">  bindIp: 127.0.0.1</span><br><span class="line"># 复制集名称</span><br><span class="line">replication:</span><br><span class="line">  replSetName: &#x27;itzb&#x27;</span><br><span class="line"># 复制集的作用</span><br><span class="line">sharding:</span><br><span class="line">    clusterRole: shardsvr</span><br></pre></td></tr></table></figure><br>2.2注册MongoDB服务<br>管理员权限运行终端, 执行如下指令<br>mongod —config D:\Developer\MongoDB666\mongodb-shard-27021\bin\mongo.config —serviceName “MongoDB27021” —serviceDisplayName “MongoDB27021”  —install<br>mongod —config D:\Developer\MongoDB666\mongodb-shard-27022\bin\mongo.config —serviceName “MongoDB27022” —serviceDisplayName “MongoDB27022”  —install<br>mongod —config D:\Developer\MongoDB666\mongodb-shard-27023\bin\mongo.config —serviceName “MongoDB27023” —serviceDisplayName “MongoDB27023”  —install<br>在任务管理器中开启任务</p>
<p>2.3测试服务可用性<br>mongo —host 127.0.0.1 —port 27021<br>mongo —host 127.0.0.1 —port 27022<br>mongo —host 127.0.0.1 —port 27023</p>
<p>2.4添加复制集<br>rs.initiate({<br>_id: ‘itzb’,<br>members: [<br>{_id: 0, host: ‘127.0.0.1:27021’},<br>{_id: 1, host: ‘127.0.0.1:27022’},<br>{_id: 2, host: ‘127.0.0.1:27023’}]<br>})</p>
<p>3.搭建路由服务器<br>3.1编写配置文件<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 日志保存到哪</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path:  D:\Developer\MongoDB666\mongodb-router-27024\log\mongod.log</span><br><span class="line"># 绑定的IP和端口号</span><br><span class="line">net:</span><br><span class="line">  port: 27024</span><br><span class="line">  bindIp: 127.0.0.1</span><br><span class="line"># 配置服务器地址</span><br><span class="line">sharding:</span><br><span class="line">  configDB: it666/127.0.0.1:27018,127.0.0.1:27019,127.0.0.1:27020</span><br></pre></td></tr></table></figure><br>3.2注册MongoDB服务<br>管理员权限运行终端, 执行如下指令<br>mongos  —config D:\Developer\MongoDB666\mongodb-router-27024\bin\mongo.config —serviceName “MongoDB27024” —serviceDisplayName “MongoDB27024”  —install<br>在任务管理器中开启任务</p>
<p>3.3测试服务可用性<br>mongo —host 127.0.0.1 —port 27024</p>
<p>3.4添加分片服务器<br>sh.addShard( “itzb/127.0.0.1:27021”)<br>sh.addShard( “itzb/127.0.0.1:27022”)<br>sh.addShard( “itzb/127.0.0.1:27023”)</p>
<p>3.5给指定数据库开启分片<br>sh.enableSharding(“demo”)</p>
<p>3.6指定分片片键<br>sh.shardCollection(“demo.user”,{‘age’:1})<br>sh.shardCollection(“demo.user”,{‘name’:hashed})</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基准测试工具使用记录</title>
    <url>/post/8aabd1de/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="apache-ab压力测试工具"><a href="#Apache-ab压力测试工具" class="headerlink" title="Apache ab压力测试工具"></a>Apache ab压力测试工具</h2><h3 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h3><ol>
<li><a href="https://www.apachehaus.com/cgi-bin/download.plx">下载地址</a></li>
<li>压缩包中提供了readme_first.html文件，有相关安装、使用说明</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>对本站点进行测试</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">H</span>:\apache_ab\Apache24\bin&gt;ab <span class="literal">-n</span> <span class="number">100</span> <span class="literal">-c</span> <span class="number">10</span> http://songzi.info/s</span><br><span class="line">This is ApacheBench, Version <span class="number">2.3</span> &lt;<span class="variable">$Revision:</span> <span class="number">1843412</span> <span class="variable">$</span>&gt;</span><br><span class="line">Copyright <span class="number">1996</span> Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking songzi.info (be patient).....done</span><br><span class="line"></span><br><span class="line"><span class="comment">## 服务器软件</span></span><br><span class="line">Server Software:        GitHub.com</span><br><span class="line"><span class="comment">## 站点名</span></span><br><span class="line">Server Hostname:        songzi.info</span><br><span class="line"><span class="comment">## 端口</span></span><br><span class="line">Server Port:            <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 请求路径</span></span><br><span class="line">Document Path:          /s</span><br><span class="line"><span class="comment">## 页面数据量</span></span><br><span class="line">Document Length:        <span class="number">9340</span> bytes</span><br><span class="line"></span><br><span class="line"><span class="comment">## 并发数量</span></span><br><span class="line">Concurrency Level:      <span class="number">10</span></span><br><span class="line"><span class="comment">## 总共使用时间</span></span><br><span class="line">Time taken <span class="keyword">for</span> tests:   <span class="number">33.206</span> seconds</span><br><span class="line"><span class="comment">## 总请求数</span></span><br><span class="line">Complete requests:      <span class="number">100</span></span><br><span class="line"><span class="comment">## 失败的请求</span></span><br><span class="line">Failed requests:        <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Non<span class="literal">-2xx</span> responses:      <span class="number">100</span></span><br><span class="line">Total transferred:      <span class="number">976686</span> bytes</span><br><span class="line">HTML transferred:       <span class="number">934000</span> bytes</span><br><span class="line"><span class="comment">## 每秒多少请求，表示服务器的吞吐量</span></span><br><span class="line">Requests per second:    <span class="number">3.01</span> [<span class="comment">#/sec] (mean)</span></span><br><span class="line"><span class="type">Time</span> <span class="type">per</span> <span class="type">request</span>:       <span class="number">3320.588</span> [<span class="type">ms</span>] (<span class="type">mean</span>)</span><br><span class="line"><span class="type">Time</span> <span class="type">per</span> <span class="type">request</span>:       <span class="number">332.059</span> [<span class="type">ms</span>] (<span class="type">mean</span>, <span class="type">across</span> <span class="type">all</span> <span class="type">concurrent</span> <span class="type">requests</span>)</span><br><span class="line"><span class="comment">## 每秒获取的数据长度</span></span><br><span class="line"><span class="type">Transfer</span> <span class="type">rate</span>:          <span class="number">28.72</span> [<span class="type">Kbytes</span>/<span class="type">sec</span>] <span class="type">received</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 连接时间的数据</span></span><br><span class="line"><span class="type">Connection</span> <span class="type">Times</span> (<span class="type">ms</span>)</span><br><span class="line">              <span class="type">min</span>  <span class="type">mean</span>[+/-<span class="type">sd</span>] <span class="type">median</span>   <span class="type">max</span></span><br><span class="line"><span class="type">Connect</span>:      <span class="number">270</span>  <span class="number">325</span> <span class="number">110.6</span>    <span class="number">301</span>    <span class="number">1297</span></span><br><span class="line"><span class="type">Processing</span>:   <span class="number">335</span> <span class="number">2798</span> <span class="number">607.0</span>   <span class="number">2789</span>    <span class="number">4493</span></span><br><span class="line"><span class="type">Waiting</span>:      <span class="number">298</span> <span class="number">1646</span> <span class="number">830.3</span>   <span class="number">1609</span>    <span class="number">3630</span></span><br><span class="line"><span class="type">Total</span>:        <span class="number">700</span> <span class="number">3123</span> <span class="number">602.3</span>   <span class="number">3123</span>    <span class="number">4781</span></span><br><span class="line"></span><br><span class="line"><span class="type">Percentage</span> <span class="type">of</span> <span class="type">the</span> <span class="type">requests</span> <span class="type">served</span> <span class="type">within</span> <span class="type">a</span> <span class="type">certain</span> <span class="type">time</span> (<span class="type">ms</span>)</span><br><span class="line"><span class="comment">## 50%的请求在3123ms内返回 </span></span><br><span class="line">  <span class="number">50</span>%   <span class="number">3123</span></span><br><span class="line">  <span class="number">66</span>%   <span class="number">3162</span></span><br><span class="line">  <span class="number">75</span>%   <span class="number">3247</span></span><br><span class="line">  <span class="number">80</span>%   <span class="number">3485</span></span><br><span class="line">  <span class="number">90</span>%   <span class="number">3998</span></span><br><span class="line">  <span class="number">95</span>%   <span class="number">4009</span></span><br><span class="line">  <span class="number">98</span>%   <span class="number">4085</span></span><br><span class="line">  <span class="number">99</span>%   <span class="number">4781</span></span><br><span class="line"> <span class="number">100</span>%   <span class="number">4781</span> (<span class="built_in">long</span><span class="type">est</span> <span class="type">request</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础1</title>
    <url>/post/7de48ef/</url>
    <content><![CDATA[<h1 id="1-数据类型相关"><a href="#1-数据类型相关" class="headerlink" title="1. 数据类型相关"></a>1. 数据类型相关</h1><h2 id="11-数据类型分类"><a href="#1-1-数据类型分类" class="headerlink" title="1.1 数据类型分类"></a>1.1 数据类型分类</h2><p>四类： 字符串、日期 / 时间、数值以及二进制</p>
<ul>
<li>字符串类型：以 <strong>char、varchar、text</strong> 为代表，用于存储字符、字符串数据 </li>
<li>日期 / 时间类型：以 <strong>date、time、datetime、timestamp</strong> 为代表，用于存储日期或时间，这种数据类型也是比 较难抉择的 </li>
<li>数值类型：以 <strong>tinyint、int、bigint、float、double、decimal</strong> 为代表，用于存储整数或小数 </li>
<li>二进制类型：以 <strong>tityblob、blob、mediumblob、longblob</strong> 为代表，用于存储二进制数据，适用场景最为受限 </li>
</ul>
<h2 id="12-数据类型基本介绍"><a href="#1-2-数据类型基本介绍" class="headerlink" title="1.2 数据类型基本介绍"></a>1.2 数据类型基本介绍</h2><h3 id="121-字符串类型"><a href="#1-2-1-字符串类型" class="headerlink" title="1.2.1 字符串类型"></a>1.2.1 字符串类型</h3><p><code>char</code></p>
<ul>
<li>固定长度的字符串，长度范围1~255之间，且必须是在创建表时制定</li>
<li>特别：如果未达到指定长度，会使用空格填充到指定长度——如果我们想要存储不同记录的字符串长度差别较大，会造成较大的空间浪费</li>
<li>当我们需要存储一些长度固定的数据列时，使用 char 是非常合适的：手机号码、身份证号</li>
</ul>
<p><code>varchar</code></p>
<ul>
<li>它定义了一个可变长度的字符串，创建时指定它所允许的 最大长度。<ul>
<li>例如，如果创建时声明了 varchar (x)，则只能存储不超过 x 个字符的数据，且 x 的最大值是 65535。</li>
</ul>
</li>
<li>对于长度不固定的数据列，使用 varchar 就是最合适的：姓名、邮箱地址</li>
<li>区别char、varchar<ul>
<li>定义了 char (x)，如果存入的字符个数小于 x，则以<strong>空格</strong>填充，<strong>查询时再将空格去掉</strong>（类似于 trim 操作）。所以，<strong>char 类型存储的字符串末尾不能有空格</strong>，而 varchar 则没有这一限制 </li>
<li>char (x) 长度是固定的，不论存入什么，都会占用 x 个字节。但是 varchar 占用的字节数是<strong>存入的字符数 + 1（x &lt;= 255）或 + 2（x &gt; 255）</strong> </li>
<li><strong>char 由于长度固定，不需要考虑边界问题，检索速度要快于 varchar</strong> </li>
</ul>
</li>
</ul>
<p><code>tinytext</code>、<code>text</code>、<code>mediumtext</code>、<code>longtext</code>：变长字符串，区别是存储空间的不同</p>
<ul>
<li>tinytext：最大长度是（2^8 - 1）个字符 </li>
<li>text：最大长度是（2^16 - 1）个字符 </li>
<li>mediumtext：最大长度是（2^24 - 1）个字符 </li>
<li>longtext：最大长度是（2^32 - 1）个字符</li>
<li>当我们存储的数据量比较大，应考虑使用文本。建议数<strong>据量超过500个字符</strong>时，应考虑使用文本。</li>
<li>文本类型<strong>不能有默认值</strong>，且在<strong>创建索引时需要指定前多少个字符</strong>。 </li>
</ul>
<h3 id="122-日期时间类型"><a href="#1-2-2-日期-时间类型" class="headerlink" title="1.2.2 日期/时间类型"></a>1.2.2 日期/时间类型</h3><p><code>date</code></p>
<ul>
<li>存储范围是 ‘1000-01-01’ 到 ‘9999-12-31’</li>
<li>场景有限，只能存储 “年月日”。常用出生年月</li>
</ul>
<p><code>time</code></p>
<ul>
<li>用于存储时间，不仅可以表示一天中的时间，也可以用于表示两个时间的时间间隔</li>
<li>MySQL 将 time 的小时范围扩大了，而且支持负值</li>
<li>time 允许以 “D HH:MM:SS” 的格式存储。其中，D 的取值是 0 ~ 34。如果要 存储时间间隔，time 则是以（时间间隔 <em> 小时）作为小时进行存储。它的计算公式是：D </em> 24 + HH。例如，插入了 “2 19:20:00”，相当于插入 67:20:00</li>
</ul>
<p><code>datetime</code></p>
<ul>
<li>取值范围是 ‘1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。</li>
<li>它是最常见，用途最广的数据类型。例如：存储数据插入时 间、订单完成时间等等</li>
</ul>
<p><code>timestamp</code></p>
<ul>
<li>它的取值范围是：‘1970-01-01 00:00:01.000000’ UTC 到 ‘2038-01-19 03:14:07.999999’ UTC。它与 datetime 的主要区别在于时间范围要小一些</li>
<li>timestamp 是与时区相关的，能够反映 “当前时间”。当插入时间时，会先转换为本地时区后再存储；查询时 间时，会转换为本地时区后再显示。所以，<strong>不同时区的人看到的同一时间是不一样的</strong>。</li>
</ul>
<p>通常 <strong>datetime</strong> 是最佳选择。理由如下： </p>
<ul>
<li>时间范围跨度足够大，能够满足所有的时间需求 </li>
<li>即使是只用于存储日期或时间，也可以存储日期时间，只需要在代码中处理即可。避免将来需求变更时对数据 表的 Schema 有所变动</li>
</ul>
<h3 id="123-数值类型"><a href="#1-2-3-数值类型" class="headerlink" title="1.2.3 数值类型"></a>1.2.3 数值类型</h3><h4 id="1231-整数类型"><a href="#1-2-3-1-整数类型" class="headerlink" title="1.2.3.1 整数类型"></a>1.2.3.1 整数类型</h4><div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占据空间</th>
<th>范围（有符号）</th>
<th>范围（无符号）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>tinyint</td>
<td>1个字节</td>
<td>-2^7 - 2^7 - 1</td>
<td>0-255</td>
<td>小整数值</td>
</tr>
<tr>
<td>smallint</td>
<td>2个字节</td>
<td>-2^15 - 2^15 - 1</td>
<td>0-65535</td>
<td>大整数值</td>
</tr>
<tr>
<td>mediumint</td>
<td>3个字节</td>
<td>-2^23 - 2^23 - 1</td>
<td>0-16777215</td>
<td>大整数值</td>
</tr>
<tr>
<td>int</td>
<td>4个字节</td>
<td>-2^31 - 2^31 - 1</td>
<td>0 - 4294967295</td>
<td>大整数值</td>
</tr>
<tr>
<td>bigint</td>
<td>8个字节</td>
<td>-2^63 - 2^63 - 1</td>
<td>0 - 18446744073709551615</td>
<td>极大整数值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="1232-浮点类型"><a href="#1-2-3-2-浮点类型" class="headerlink" title="1.2.3.2 浮点类型"></a>1.2.3.2 浮点类型</h4><ul>
<li>float (M, D)：其中 M 定义显示长度，D 定义小数位数。但是它们是可选的，且默认值是 float (10, 2)，<strong>2 是小数的位数，10 是数字的总长（包括小数）</strong>。它的小数精度可以到 24 个浮点。 </li>
<li>double (M, D)：M 和 D 的含义与 float 是相同的，默认值是 double (16, 4)。它的小数精度可以达到 53 位。</li>
</ul>
<h4 id="1233-定点类型"><a href="#1-2-3-3-定点类型" class="headerlink" title="1.2.3.3 定点类型"></a>1.2.3.3 定点类型</h4><ul>
<li><code>decimal</code> 被称为定点数据类型，由于它保存的是精确值，所以它通常用于精度要求非常高的计算中。 </li>
<li>另外，也可以利用 decimal 去保存比 bigint 还要大的整数值。</li>
<li>MySQL 自身实现了对 decimal 的高精度计算</li>
<li>假如我们定义了 decimal (18, 9)：<ul>
<li>不包含小数点的数字总数（整数位数 + 小数位数）位数是 18，不指定的情况下默认是 10 </li>
<li>9 则代表小数的位数，如果不指定，默认是 0</li>
</ul>
</li>
</ul>
<h3 id="124-二进制类型"><a href="#1-2-4-二进制类型" class="headerlink" title="1.2.4 二进制类型"></a>1.2.4 二进制类型</h3><p>二进制数据类型<strong>理论上可以存储任何数据</strong>，可以是文本数据，也可以存储图像或者其他多媒体数据。二进制数据类型相对于其他的数据类型来说，使用频率是比较低的。</p>
<ul>
<li><code>tityblob</code>:最大支持255字节</li>
<li><code>blob</code>:最大支持64KB</li>
<li><code>mediumblob</code>:最大支持16MB</li>
<li><code>longblob</code>:最大支持4GB</li>
</ul>
<h2 id="13-数据类型使用建议"><a href="#1-3-数据类型使用建议" class="headerlink" title="1.3 数据类型使用建议"></a>1.3 数据类型使用建议</h2><ol>
<li><p>使用<strong>NOT NULL</strong></p>
<p>这个建议适用于所有的数据类型，MySQL 在索引值为 NULL 的列时，需要额外的存储空间，所以，相对于NOT NULL 来说，<strong>NULL 会占用更多的空间</strong>。另外，在进行<strong>比较</strong>和<strong>计算</strong>时，MySQL <strong>要对 NULL 值做特别的处理</strong>，使用效 率较低。 </p>
</li>
<li><p>带有 <strong>COMMENT</strong></p>
<p>COMMENT 用于定义列的注释信息，就好像我们在写代码一样，把重要的或者不易理解的地方，加上一些注释， 方便以后查阅。</p>
</li>
<li><p>使用存储需要的最小数据类型：<strong>在满足需求的同时选择最小的</strong>。</p>
<p>例如，要存储事件状态，可以选择tinyint；要存储班级人数，可以选择smallint等等。关于最小数据类型，它有两大优势：</p>
<ul>
<li>越小的数据类型占用的磁盘、内存、CPU缓存都会更小，存取速度也会更快</li>
<li>小的数据类型建立索引时所需要的空间也相对较小，这样一页中所能存储的索引节点数量也就越多，遍历时IO次数就会越少，索引的性能也就越好</li>
</ul>
</li>
<li><p><strong>选择简单的数据类型</strong><br>例子：在一列中存储10、100、201这样的数据，我们可以选择使用int或varchar来存储。但是整型要比字符型的操作复杂度小太多，那么，选择整型（例如int)就是最简单的数据类型。</p>
</li>
<li><p><strong>尽量避免使用text和blob</strong></p>
<p>MySQL内存临时表并不支持text、blob这样的大数据类型，如果查询时包含有这样的数据，则<strong>排序操作必须使用磁盘临时表，性能会下降很多</strong>。而且对于这种数据，<strong>MySQL还要做二次查询（因为MySQL实际保存的是指针，而不是真实数据）</strong>，会使SQL性能变得很差。</p>
<p>但是，也并不是说我们一定就不能用text和blob。<strong>如果确实有需求需要使用这样的数据类型</strong>，那么<strong>在查询时一定不要直接SELECT*,而是取出需要的列</strong>。这样MySQL就不会去主动查询这些数据列，也是提高性能的一种惯用手段。最后，还需要注意，<strong>因为MySQL对索引长度的限制，text类型只能用到前缀索引，并且由于存储的是指针，txt列上不能有默认值</strong>。</p>
</li>
</ol>
<h2 id="14-qampa"><a href="#1-4-Q-amp-A" class="headerlink" title="1.4 Q&amp;A"></a>1.4 Q&amp;A</h2><ol>
<li><p>将时间转换为时间戳，并使用int或者bigint类型去存储，这么做可行度？</p>
<p><strong>date类型的时间要精确到分秒才能转成13位的long类型,且必须通过数据库语句,在数据库中进行插入bigint类型的操作,java中bigint类型只能支持11位.</strong></p>
</li>
<li><p>大多数时候，我们会选择将主键设置为bigint数据类型，你知道这是为什么吗？</p>
<p><a href="https://blog.csdn.net/nrsc272420199/article/details/102877399">https://blog.csdn.net/nrsc272420199/article/details/102877399</a></p>
<ul>
<li><p>（1）mysql索引B+树的高度应为：2-4<br>（2）一个bigint类型的数据为8B，一个integer类型的数据为4B，在B+树上每个指针的大小为6B，如下图：<img src="https://img-blog.csdnimg.cn/20191111003904404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这样的话，对于B+树来说一个非叶子节点能存储的索引的个数为：</p>
<p>主键为integer类型 ： 16384/(4+6) ≈ 1638个<br>主键为bigint类型：16384/(8+6)≈ 1170个</p>
<p>假如每条数据大小为1K（1024B）的话，一个叶子节点就可以存大概16条数据</p>
<p>那假如B+树的高度为4层的话，那mysql存储的所有数据的条数应为：</p>
<p>主键为integer类型：1638 <em> 1638 </em> 1638 <em> 16 = 70317217152 大于int的上限42亿<br>主键为bigint类型：1170 </em> 1170 <em> 1170 </em> 16 = 25625808000 肯定远小于long的上限，也大于42亿</p>
<p>也就是说<strong>虽然42亿的预留量可能已经非常充足了，但万一不够了呢</strong>？</p>
<p><strong>既然mysql即使是256亿的数据量也仅需4次IO就可以查到，而这个时候int类型的预留量肯定不够了，bigint却十分充足，为什么不用bigint呢</strong>？</p>
<p>我想得可能正是基于这个原因，阿里才会强制要求mysql表的主键应为bigint unsigned类型。</p>
</li>
</ul>
</li>
</ol>
<h1 id="2-schema设计规范"><a href="#2-Schema设计规范" class="headerlink" title="2. Schema设计规范"></a>2. Schema设计规范</h1><p>Schema 设计指的是对数据表的的设计，在实际业务中，也可以把它的概念扩展为对库和表的设计。</p>
<h2 id="21-schema设计的目标"><a href="#2-1-Schema设计的目标" class="headerlink" title="2.1  Schema设计的目标"></a>2.1  Schema设计的目标</h2><p>可用 + 好用</p>
<ul>
<li><p>可用</p>
<ul>
<li><p>设计的数据库和数据表能够支撑当前的业务需求，且在技术实现上没有太大的弊端</p>
</li>
<li><p>这个设计目标的核心其实是对需求的理解。确实，理清了需求，你会得出结论： </p>
<p>应该存储哪些数据、这些数据是什么类型、在代码中怎样使用这些数据等等。余下的建库建表也自然就水到渠成了</p>
</li>
</ul>
</li>
<li><p>好用</p>
<ul>
<li>需求也许不会变化，但是随着<strong>业务量的增长触发数据和并发的增长</strong>，数据库是否还能保持相对较高的性能是个 值得思考的问题，同时也是衡量设计目标是否好用的重要指标。</li>
<li>无论什么时候，我们对 MySQL（数据库）的使用都肯定是<strong>围绕数据的增删改查</strong>。而这些基本的操作，当数据 量加速膨胀的过程中，也会引起<strong>性能瓶颈</strong>。所以，好用的设计目标讲究能够 “预见未来”，能够对未来做出预判。例如：将<strong>通用信息单独使用一张表存储、建立适当的索引</strong>等等</li>
</ul>
</li>
</ul>
<h2 id="22-schema通用的设计原则"><a href="#2-2-Schema通用的设计原则" class="headerlink" title="2.2 Schema通用的设计原则"></a>2.2 Schema通用的设计原则</h2><ol>
<li><strong>使用小写的名称，且只有英文字母</strong>：不论是库、表还是数据列，应该是只包含英文字母的名称，不要出现特殊 字符或者是数字。这也比较好理解，英文字母不论是阅读还是编码都非常的便捷。另外，由于 MySQL 是大小 写不敏感的，选择一律小写的名称能够统一书写规则，避免不必要的书写错误。 </li>
<li><strong>取一个有意义的名称，单词之间使用下划线连接</strong>：除了基本的名称书写规范之外，取一个有意义的名称是非常 有必要的。例如：我们需要创建学生表，表的名称叫做 student 就会比 other 更易理解。当然，可能有些时候 我们无法用一个单词表达清楚想要的含义，此时，可以使用多个单词，且单词之间使用下划线连接，例如： insert_time。最后，名称不要过长，最长不要超过 32 个字符。 </li>
<li><strong>记住 “够用且尽量小” 的原则</strong>：很明显，这条原则对应的是数据表列的数据类型选择问题。占用空间少的数据类 型最直接的优势就是减少了用户数据存储空间和索引存储空间，这对于数据传输与检索的性能提高有着巨大意 义。</li>
<li><strong>不要使用物理外键</strong>：<strong>物理外键</strong>是说<strong>让数据库去管理表与表之间的关联关系</strong>，而它相对的<strong>逻辑外键</strong>，则是我们自己<strong>用代码去管理这种关系</strong>。这是因为物理外键存在两个重大缺陷：消耗数据库资源，降低数据库实例可扩展 性；母表一旦受损，子表很难恢复，造成数据丢失。 </li>
<li><strong>表一定要有主键</strong>：MySQL 并不要求表一定要有主键，但是<strong>主键的作用是能够唯一区分表中的每一行</strong>。没有主键，更新或删除表中的特定行将会很困难，因为没有安全的方法保证只涉及相关的行。并且，主键能够为方便 扩展、高可用的数据库系统做铺垫。 </li>
<li><strong>保持一致的字符集</strong>：库、表、数据列的字符集都应该是一致的，<strong>统一为 utf8 或 utf8mb4</strong>。字符集编码不仅影响 数据存储，还会影响客户端与数据库之间的交互，最常见的问题就是字符集导致的乱码。所以，相同的字符集更利于管理，也更方便去排查问题。 </li>
</ol>
<h2 id="23-库设计规范"><a href="#2-3-库设计规范" class="headerlink" title="2.3 库设计规范"></a>2.3 库设计规范</h2><p>MySQL 自身并没有对库的容量做出限制，也就是说，你几乎不用考虑表的数量上限问题。但是，当表的数量越 </p>
<p>多，越容易产生以下问题（以下所讨论的都是单个库）： </p>
<ul>
<li>表越多，需要<strong>维护的元数据（表结构、统计信息等）就会越多</strong>。即使是这些元数据只占据很少的空间，但是也 会让管理这些元数据变得很复杂，且通常也是不合理的需求分析造成的； </li>
<li><strong>表越多，可能存储的数据量也会越大，这无疑会给数据库造成压力。且大量的数据聚集在同一个库中也是非常 危险的，一旦出现库损坏，丢失的数据量也会更多</strong>。 </li>
</ul>
<p>综上所述，我们讨论了单库中表太多的缺陷，再去结合日常的工作实践来说，建议大家在一<strong>个库中创建的表数量不 要超过 200</strong>。更常见的情况是，<strong>一个库中只维护几十到 100 张表</strong></p>
<h2 id="24-表设计规范"><a href="#2-4-表设计规范" class="headerlink" title="2.4 表设计规范"></a>2.4 表设计规范</h2><h3 id="241-范式-反范式的选择"><a href="#2-4-1-范式、反范式的选择" class="headerlink" title="2.4.1 范式、反范式的选择"></a>2.4.1 范式、反范式的选择</h3><p><a href="https://songzi.info/post/1a233e39/">控制冗余的反范式模式 | 毫末室 (songzi.info)</a></p>
<ul>
<li><p>范式：核心思想是数据只出现一次，不存在信息冗余。</p>
<p>范式化设计的优点：使用更少的存储空间 ；由于没有冗余存储，增删改查的速度相对较快</p>
<ol>
<li>列不可再分</li>
<li>属性完全依赖于主键</li>
<li>属性不依赖于其它非主属性   属性直接依赖于主键</li>
</ol>
</li>
<li><p>反范式：破坏了范式的规范，它允许出现冗余的数据。所以，问题在于：冗余字段是否是可取的。</p>
<p>如果我们想要的数据出现在两张或者多张表中，对于范式不存在冗余的设计，就<strong>不得不采用关联查询</strong>。而这恰恰是反范式设计最大的优势，<strong>适当的冗余设计，可以减少或避免表关联，提高查询效率</strong>。 </p>
</li>
</ul>
<h3 id="242-宽表-窄表的选择"><a href="#2-4-2-宽表、窄表的选择" class="headerlink" title="2.4.2 宽表、窄表的选择"></a>2.4.2 宽表、窄表的选择</h3><p>MySQL 对于每张表有 4096 个列 的硬限制，而真正在使用上的限制又会取决于你所使用的存储引擎。例如：对于 InnoDB 来说，一张表最多可以有 1017 列。在不考虑 “宽和窄” 的问题上来说，MySQL 和存储引擎支持的列数目肯定是足够的了。 </p>
<p>以 40 列为界，超过 40 列的表，我们可以称之为宽表， 相对的，少于 40 列的表，我们称之为窄表。但同时，需要知道，这里的数字是人为定义的，MySQL 规范中并没 有这种定义。我这里的划分是基于工作经验和总结</p>
<p>对应的优缺点</p>
<ul>
<li>窄表较多，数据列会更加分散，<strong>编写关联查询的难度就会很大</strong> </li>
<li>数据项会有不同的安全级别，宽表中涉及的列过多，<strong>数据权限的管理</strong>会带来很大的挑战 </li>
<li>窄表数据量通常较少，但是<strong>等量的数据项会创建更多的表，管理难度大</strong> </li>
<li>宽表数据量通常较大，<strong>单表占据的存储空间过大，会降低排序、分组等查询的性能</strong> </li>
</ul>
<h3 id="243-合理的索引是提升性能的关键"><a href="#2-4-3-合理的索引是提升性能的关键" class="headerlink" title="2.4.3 合理的索引是提升性能的关键"></a>2.4.3 合理的索引是提升性能的关键</h3><p>典型的以空间换时间的优化策略：索引的存在，也会使插入、删除、更新的性能降低，因为这些操作都会伴随着索引的修改。所以，这一条设计规范所要追求的是空间与时间的平衡，达到既不占用过多的存储空间，也有较高的查询性能。 </p>
<p>索引创建和使用的特性： </p>
<ul>
<li>一定要为作为搜索条件的字段创建索引，不是搜索条件的字段建索引反而会降低使用性能</li>
<li>选择区分度高的字段作为索引字段，重复性高的字段不要加索引</li>
<li>联合索引存在 “最左前缀” 的特性，不要建多余的索引</li>
</ul>
<h2 id="25-qampa"><a href="#2-5-Q-amp-A" class="headerlink" title="2.5 Q&amp;A"></a>2.5 Q&amp;A</h2><ul>
<li><p>如果你的表没有定义主键，你知道 MySQL 会怎么做吗 ？ </p>
<p>InnoDB会自动帮你创建一个不可见的、长度为6字节的<code>row_id</code>，而且InnoDB维护了一个全局的<code>dictsys.row_id</code>，所以未定义主键的表都会共享该<code>row_id</code>，每次插入一条数据都把全局<code>row_id</code>当成主键id，然后全局<code>row_id</code>加1。</p>
<p>该全局row_id在代码实现上使用的事bigint unsigned类型，但实际上只给<code>row_id</code>保留了6字节，所以这种设计就会存在一个问题：如果全局<code>row_id</code>一直涨，直到2的48次幂-1时，这个时候再加1，<code>row_id</code>的低48位都会变为0，如果再插入新一行数据时，拿到的<code>row_id</code>就为0，这样的话就存在主键冲突的可能，所以为了避免这种隐患，每个表都需要一个主键。</p>
</li>
<li><p>我编写的 SQL 语句需要做多表的 join 操作，应该给哪些列建索引呢 ？</p>
<p><a href="https://www.cnblogs.com/process-h/p/14577257.html">多表关联查询中，关联字段都应该创建索引吗？ - 寻找的路上 - 博客园 (cnblogs.com)</a></p>
<p> 不管是内联还是外连接关联查询，为各个表建立索引应该<strong>要根据当时的条件</strong>来建立：</p>
<ul>
<li><strong>主表（驱动表）</strong>根据<strong>where中涉及到的列</strong>建索引（比如例子中的tb1需要给col1建立索引)</li>
<li><strong>从表根据被关联的列</strong>建立索引，如果where中涉及到从表的列，可以考虑结合关联列建立组合索引（注意最左匹配原则）。</li>
</ul>
</li>
</ul>
<h1 id="3-聚合与分组聚合"><a href="#3-聚合与分组聚合" class="headerlink" title="3. 聚合与分组聚合"></a>3. 聚合与分组聚合</h1><h2 id="31-聚合函数"><a href="#3-1-聚合函数" class="headerlink" title="3.1 聚合函数"></a>3.1 聚合函数</h2><p>数据库书分为单行函数、多行函数。</p>
<p>单行函数即函数会针对每一行返回一个结果，而多行函数 则是作用于多行（也可以作用于单行）并返回一个结果。</p>
<p>聚合函数则属于多行函数，表中的多行记录会参与计算， 并返回一个数值，且它通常用于分组的相关统计。 </p>
<h2 id="32-常用的聚合函数"><a href="#3-2-常用的聚合函数" class="headerlink" title="3.2 常用的聚合函数"></a>3.2 常用的聚合函数</h2><p><code>AVG</code> <code>COUNT</code> <code>MIN</code> <code>MAX</code> <code>SUM</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVG ([DISTINCT] expr)</td>
<td>返回 expr 的平均值 DISTINCT</td>
<td>选项用于去除字段值重复的行记录</td>
</tr>
<tr>
<td>COUNT(expr)</td>
<td>统计表中的行数</td>
<td></td>
</tr>
<tr>
<td>MIN ([DISTINCT] expr)</td>
<td>返回 expr 的最小值</td>
<td></td>
</tr>
<tr>
<td>MAX ([DISTINCT] expr)</td>
<td>返回 expr 的最大值</td>
<td></td>
</tr>
<tr>
<td>SUM ([DISTINCT] expr)</td>
<td>返回 expr 的和</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>每个聚合函数接受一个参数，参数可以是数据表列，也可以是函数表达式 </li>
<li>默认情况下，聚合函数会忽略列值为 NULL 的行，不参与计算 </li>
<li>聚合函数<strong>不允许嵌套</strong>，例如：COUNT(SUM(expr)) 是不合法的 </li>
<li>一次查询中<strong>可以出现多个聚合函数</strong>，例如：SELECT MAX(expr), MIN(expr) FROM … </li>
<li>关于 COUNT 函数，总结如下： <ul>
<li>COUNT(n) 和 COUNT(<em>) 用于<strong>统计表中的总行数</strong>，<em>*不关心列值是否为 NULL</em></em> </li>
<li>COUNT(expr) 用于<strong>统计列值非 NULL 的行记录数</strong> </li>
<li>COUNT(DISTINCT expr) 用于<strong>统计列值不同且非 NULL 的行记录数</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id, type, name, salary FROM worker; </span><br><span class="line">+----+------+--------+--------+ </span><br><span class="line">| id | type | name | salary | </span><br><span class="line">+----+------+--------+--------+ </span><br><span class="line">| 1 | A | tom | 1800 | </span><br><span class="line">| 2 | B | jack | 2100 | </span><br><span class="line">| 3 | C | pony | NULL | </span><br><span class="line">| 4 | B | tony | 3600 | </span><br><span class="line">| 5 | B | marry | 1900 | </span><br><span class="line">| 6 | C | tack | 1200 | </span><br><span class="line">| 7 | A | tick | NULL | </span><br><span class="line">| 8 | B | clock | 2000 | </span><br><span class="line">| 9 | C | noah | 1500 | </span><br><span class="line">| 10 | C | jarvis | 1800 | </span><br><span class="line">+----+------+--------+--------+</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary) FROMworker;</span><br><span class="line">SELECT AVG(salary) FROMworker WHERE id &lt; 3;</span><br><span class="line">SELECT COUNT(0), COUNT(1), COUNT(9.9), COUNT(*) FROMworker;</span><br><span class="line">SELECT COUNT(salary), COUNT(DISTINCT salary) FROMworker;</span><br><span class="line">SELECT MIN(salary), MAX(salary) FROMworker;</span><br><span class="line">SELECT SUM(salary) FROMworker WHERE id &lt; 5;</span><br><span class="line">SELECT SUM(1) FROMworker; #统计行数，但效率很差</span><br></pre></td></tr></table></figure>
<h2 id="33-分组聚合"><a href="#3-3-分组聚合" class="headerlink" title="3.3 分组聚合"></a>3.3 分组聚合</h2><p>分组的意思就是数据根据某一列或者某几列分类，MySQL 中可以使用 GROUP BY 子句实现这一功能。<strong>GROUP BY 结合聚合函数</strong>就可以实现将表数据分类再汇总的效果，这在报表型的数据统计任务中是非常常见的需求。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GROUP BY 子句语法</span><br><span class="line">SELECT &lt;列名1&gt;, &lt;列名2&gt;...... FROM &lt;表名&gt; WHERE ...... GROUP BY &lt;列名1&gt;, &lt;列名2&gt;......;</span><br></pre></td></tr></table></figure>
<h3 id="331-按照type分组对数据进行统计"><a href="#3-3-1-按照type分组对数据进行统计" class="headerlink" title="3.3.1 按照type分组对数据进行统计"></a>3.3.1 按照type分组对数据进行统计</h3><p>需要注意的是，出现在 SELECT 子句中的单独列（非聚合列，示例中的即为 type，<strong>必须出现在 GROUP BY 子 句中作为分组列</strong>。但是反过来，<strong>分组列是可以不出现在 SELECT 子句中的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT type, AVG(salary), COUNT(1), MIN(salary), MAX(salary), SUM(salary) FROM worker GROUP BY type; </span><br><span class="line"># 使用 GROUP BY 对 type 字段值进行分组，结果有三类：A、B、C。分组之后，AVG、COUNT 等聚合函数再按照自身的特性对每一组数据进行聚合统计，最后，打印结果。 </span><br><span class="line">+------+-------------+----------+-------------+-------------+-------------+ </span><br><span class="line">| type | AVG(salary) | COUNT(1) | MIN(salary) | MAX(salary) | SUM(salary) | </span><br><span class="line">+------+-------------+----------+-------------+-------------+-------------+ </span><br><span class="line">| A | 1800.0000 | 2 | 1800 | 1800 | 1800 | </span><br><span class="line">| B | 2400.0000 | 4 | 1900 | 3600 | 9600 | </span><br><span class="line">| C | 1500.0000 | 4 | 1200 | 1800 | 4500 | </span><br><span class="line">+------+-------------+----------+-------------+-------------+-------------+</span><br></pre></td></tr></table></figure>
<h3 id="332-对分组聚合结果进行排序"><a href="#3-3-2-对分组聚合结果进行排序" class="headerlink" title="3.3.2 对分组聚合结果进行排序"></a>3.3.2 对分组聚合结果进行排序</h3><p>指定排序的列可以是分组列，也可以不是分组列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按照SUM(salary)实现排序</span><br><span class="line">SELECT type, SUM(salary) as sum_s FROM worker GROUP BY type ORDER BY sum_s desc; </span><br><span class="line">+------+-------+ </span><br><span class="line">| type | sum_s | </span><br><span class="line">+------+-------+ </span><br><span class="line">| B | 9600 | </span><br><span class="line">| C | 4500 | </span><br><span class="line">| A | 1800 | </span><br><span class="line">+------+-------+ </span><br></pre></td></tr></table></figure>
<p>当<strong>排序列与分组列相同</strong>时，则可以合并 GROUP BY 和 ORDER BY 子句，即<strong>只需要在 GROUP BY 子句的后面添加 DESC 或 ASC</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT type, AVG(salary), COUNT(1), MIN(salary), MAX(salary), SUM(salary) FROM worker GROUP BY type DESC; </span><br><span class="line">+------+-------------+----------+-------------+-------------+-------------+ </span><br><span class="line">| type | AVG(salary) | COUNT(1) | MIN(salary) | MAX(salary) | SUM(salary) | </span><br><span class="line">+------+-------------+----------+-------------+-------------+-------------+ </span><br><span class="line">| C | 1500.0000 | 4 | 1200 | 1800 | 4500 | </span><br><span class="line">| B | 2400.0000 | 4 | 1900 | 3600 | 9600 | </span><br><span class="line">| A | 1800.0000 | 2 | 1800 | 1800 | 1800 | </span><br><span class="line">+------+-------------+----------+-------------+-------------+-------------+</span><br></pre></td></tr></table></figure>
<h3 id="333-对分组结果进行过滤"><a href="#3-3-3-对分组结果进行过滤" class="headerlink" title="3.3.3 对分组结果进行过滤"></a>3.3.3 对分组结果进行过滤</h3><p>过滤的是分组后的聚合结果，而不是数据表中的原始记录。</p>
<p>在 MySQL 中，使用 AVG、COUNT 等聚合函数对表记录进行统计操作后，可以使用 HAVING 子句对结果进行过滤，且 <strong>HAVING 子句需要写在 GROUP BY 子句之后</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT type, AVG(salary), COUNT(1), SUM(salary) FROM worker GROUP BY type HAVING SUM(salary) &gt; 4000; </span><br><span class="line">+------+-------------+----------+-------------+ </span><br><span class="line">| type | AVG(salary) | COUNT(1) | SUM(salary) | </span><br><span class="line">+------+-------------+----------+-------------+ </span><br><span class="line">| B | 2400.0000 | 4 | 9600 | </span><br><span class="line">| C | 1500.0000 | 4 | 4500 | </span><br><span class="line">+------+-------------+----------+-------------+ </span><br></pre></td></tr></table></figure>
<p>HAVING 的使用方法与 WHERE 是相似的，只是它们执行的时机不同。总结下来，它们有以下两个区别：</p>
<ol>
<li>WHERE 子句在分组前对记录进行过滤 </li>
<li>HAVING 子句在分组后对记录进行过滤 </li>
</ol>
<p>分组聚合的精髓在于数据分组，可以把每一个分组都认为是单独的数据表记录，最终的聚合结果则是将每一个单独数据表聚合之后 merge 而成的。另外，需要知道，聚合函数可以在 SELECT 、HAVING 和 ORDER BY 子句中使用，但是不能在 WHERE 子句中使用。 </p>
<h2 id="34-qampa"><a href="#3-4-Q-amp-A" class="headerlink" title="3.4 Q&amp;A"></a>3.4 Q&amp;A</h2><ul>
<li><p>为什么说 SUM(1) 的执行效率要比 COUNT(n) 或 COUNT(*) 低很多呢 ？ </p>
<p>sum的效率不足体现在cpu上，I/O完全一样。</p>
<p>在排序统计的时候<br>sum的算法为1+1+1+1+1+1=6，sum是未知的，需要额外的CPU每一步都需要计算<br>count是1+2+3=6，就是说count的计算公式是定的，发现一行，加1，那么就是1，下一次是从2开始加<br>显然sum的效率不如count。：SUM 操作会遍历整个表，遇到一条记录，就会执行一次加 N 的操作，最终返回累加和，即行记录数的 N 倍。 </p>
</li>
<li><p>COUNT(n) COUNT(*)</p>
<p>官方标准统计行数就是用count (*)，不建议写其他</p>
<p>目前基于磁盘的数据库或者搜索引擎（比如Lucene）的性能瓶颈主要都是在IO阶段，相比于CPU和RAM，IO操作实在太慢了，所以这类系统的优化方向也都都是类似的——尽一切可能减少IO的次数（所以很多用ES的程序在性能优化到极限的时候选择直接上SSD）。这里统计行数的操作，查询优化器的优化方向就是选择能够让IO次数最少的索引，也就是基于占用空间最小的字段所建的索引（每次IO读取的数据量是固定的，索引占用的空间越小所需的IO次数也就越少）。而Innodb的主键索引是聚簇索引（包含了KEY，除了KEY之外的其他字段值，事务ID和MVCC回滚指针）所以主键索引一定会比二级索引（包含KEY和对应的主键ID）大，也就是说在有二级索引的情况下，一般COUNT()都不会通过主键索引来统计行数，在有多个二级索引的情况下选择占用空间最小的。</p>
<p>如果说有张Innodb的表只有主键索引，而且记录还比较大（比如30K），则统计行的操作会非常慢，因为IO次数会很多（这里就不做实验截图了，有兴趣可以自己试一下）。一个优化方案就是预先建一个小字段并建二级索引专门用来统计行数，极端情况下这种优化速度提高上千倍也是正常的。</p>
<p>结论就是对于COUNT(1)和COUNT(<em>)执行优化器的优化是完全一样的，并没有COUNT(1)会比COUNT(</em>)快这个说法。</p>
</li>
<li><p>SELECT、FROM、WHERE、HAVING、GROUP BY、ORDER BY 这些子句的正确书写顺序应该是怎样的 </p>
<ol>
<li>FROM  </li>
<li>WHERE （先过滤单表／视图／结果集，再JOIN） </li>
<li>GROUP BY</li>
<li>HAVING （WHERE过滤的是行，HAVING过滤的是组，所以在GROUP之后）</li>
<li>ORDER BY</li>
</ol>
</li>
</ul>
<h1 id="4-条件判断函数与系统同函数"><a href="#4-条件判断函数与系统同函数" class="headerlink" title="4. 条件判断函数与系统同函数"></a>4. 条件判断函数与系统同函数</h1><p>MySQL 中的系统信息包含：<strong>数据库的版本号、当前登录用户、当前连接数、系统字符集等等</strong>。这些信息在特定的环境中非常有用，例如：<strong>查看连接数定位 MySQL 是否过载、查看字符集定位乱码原因</strong>等等。</p>
<h2 id="41-常用条件判断函数"><a href="#4-1-常用条件判断函数" class="headerlink" title="4.1 常用条件判断函数"></a>4.1 常用条件判断函数</h2><p>包括 <code>IF</code> <code>CASE</code> ;</p>
<p>单一条件对比 <code>IF</code>分为<code>IFNULL</code> <code>NULLIF</code></p>
<p>多条件对比 <code>CASE</code></p>
<h3 id="411-if条件判断函数"><a href="#4-1-1-IF条件判断函数" class="headerlink" title="4.1.1 IF条件判断函数"></a>4.1.1 IF条件判断函数</h3><p><code>IF (expr, v1, v2)</code> 函数。expr 是表达式的意思，它的含义是：如果 expr 为真（expr&lt;&gt;0 and expr&lt;&gt;NULL），则 IF 函数的返回值是 v1，否则，返回 v2。IF 函数的返回值是数字还是字符串，则视其所在语境而定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name, IF(type=&#x27;A&#x27;, &#x27;研发&#x27;, &#x27;非研发&#x27;) AS type FROM worker WHERE id IN (1, 2); </span><br><span class="line">+------+-----------+ </span><br><span class="line">| name | type | </span><br><span class="line">+------+-----------+ </span><br><span class="line">| tom | 研发 | </span><br><span class="line">| jack | 非研发 | </span><br><span class="line">+------+-----------+ </span><br></pre></td></tr></table></figure>
<p>如果把 NULL 显示为 0 是不是更好一些呢 ？此时，IFNULL(v1, v2) 函数可以解决这个问题。 </p>
<p><code>IFNULL (v1, v2)</code> 表达的语义是：如果 v1 不为 NULL，则返回 v1，否则，返回 v2。同样，IFNULL 函数的返回值是 数字还是字符串，则视其所在语境而定。我们可以<strong>利用 IFNULL 将 salary 是 NULL 的列值变成 0</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name, IFNULL(salary, 0) AS salary FROM worker WHERE id IN (1, 2, 3); </span><br><span class="line">+------+--------+ </span><br><span class="line">| name | salary | </span><br><span class="line">+------+--------+ </span><br><span class="line">| tom | 1800 | </span><br><span class="line">| jack | 2100 | </span><br><span class="line">| pony | 0 | </span><br><span class="line">+------+--------+</span><br></pre></td></tr></table></figure>
<p><code>NULLIF (v1, v2)</code>与IFNULL名称类似。表达的语义是：如果 v1 等于 v2，那么返回值是 NULL，否则返回值为 v1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id, name, NULLIF(salary, NULL) AS salary FROM worker WHERE id IN (1, 2, 3); </span><br><span class="line">+----+------+--------+ </span><br><span class="line">| id | name | salary | </span><br><span class="line">+----+------+--------+ </span><br><span class="line">| 1 | tom | 1800 | </span><br><span class="line">| 2 | jack | 2100 | </span><br><span class="line">| 3 | pony | NULL | </span><br><span class="line">+----+------+--------+ </span><br></pre></td></tr></table></figure>
<h3 id="412-case条件判断函数"><a href="#4-1-2-CASE条件判断函数" class="headerlink" title="4.1.2 CASE条件判断函数"></a>4.1.2 CASE条件判断函数</h3><p>IF 条件判断函数所表达的语义是非 A 即 B，也就是单个条件的判断；CASE 函数则能够实现多条件的匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE expr </span><br><span class="line"> WHEN v1 THEN r1 </span><br><span class="line"> ...... </span><br><span class="line"> WHEN vx THEN rx </span><br><span class="line"> ELSE rn </span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>“CASE WHEN THEN”：适用于一个条件判断有多种可能值的情况下分别去执行不同的操作，或返回不同的结果值。 </p>
<p>CASE 函数有两种写法：<strong>简单 CASE 函数写法</strong>、<strong>CASE 搜索函数写法</strong>，它们的区别在于： </p>
<ul>
<li>简单 CASE 函数写法只适合相等条件判断，不能用于大于、小于、不等于的判断 </li>
<li>CASE 搜索函数写法适合复杂条件判断，可用于大于、小于、不等于的判断 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简单case函数写法</span><br><span class="line">mysql&gt; SELECT </span><br><span class="line">-&gt; name, </span><br><span class="line">-&gt; (CASE type </span><br><span class="line">-&gt;  WHEN &#x27;A&#x27; THEN &#x27;研发&#x27; </span><br><span class="line">-&gt;  WHEN &#x27;B&#x27; THEN &#x27;测试&#x27; </span><br><span class="line">-&gt;  WHEN &#x27;C&#x27; THEN &#x27;运维&#x27; </span><br><span class="line">-&gt;  ELSE &#x27;其他&#x27; </span><br><span class="line">-&gt; END) AS type </span><br><span class="line">-&gt; FROM </span><br><span class="line">-&gt; worker </span><br><span class="line">-&gt; WHERE </span><br><span class="line">-&gt; id IN ( </span><br><span class="line">-&gt;  1, 2, 3 </span><br><span class="line">-&gt; ); </span><br><span class="line"></span><br><span class="line"># CASE搜索函数写法</span><br><span class="line">mysql&gt; SELECT </span><br><span class="line">-&gt; name, </span><br><span class="line">-&gt; (CASE </span><br><span class="line">-&gt;  WHEN type=&#x27;A&#x27; THEN &#x27;研发&#x27; </span><br><span class="line">-&gt;  WHEN type=&#x27;B&#x27; THEN &#x27;测试&#x27; </span><br><span class="line">-&gt;  WHEN type=&#x27;C&#x27; THEN &#x27;运维&#x27; </span><br><span class="line">-&gt;  ELSE &#x27;其他&#x27; </span><br><span class="line">-&gt; END) AS type </span><br><span class="line">-&gt; FROM </span><br><span class="line">-&gt; worker </span><br><span class="line">-&gt; WHERE </span><br><span class="line">-&gt; id IN ( </span><br><span class="line">-&gt;  1, 2, 3 </span><br><span class="line">-&gt; ); </span><br><span class="line">+------+--------+ </span><br><span class="line">| name | type | </span><br><span class="line">+------+--------+ </span><br><span class="line">| tom | 研发 | </span><br><span class="line">| jack | 测试 | </span><br><span class="line">| pony | 运维 | </span><br><span class="line">+------+--------+</span><br></pre></td></tr></table></figure>
<p>涉及<strong>数值范围判断</strong>等等类似的例子，则只能使用 CASE 搜索函数的写法。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">-&gt;(CASE </span><br><span class="line">-&gt; WHEN salary &gt;= 2000 THEN &#x27;高收入&#x27; </span><br><span class="line">-&gt; WHEN salary &lt;= 1500 THEN &#x27;低收入&#x27; </span><br><span class="line">-&gt; ELSE &#x27;中等收入&#x27; </span><br><span class="line">-&gt;END) AS salary </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="413-条件判断函数总结"><a href="#4-1-3-条件判断函数总结" class="headerlink" title="4.1.3 条件判断函数总结"></a>4.1.3 条件判断函数总结</h3><ul>
<li><p>CASE 是 SQL 标准定义的，而 IF 是数据库系统的扩展 </p>
</li>
<li><p>在高级语言中，CASE 可以使用 IF 来代替，但是 SQL 中却不行 </p>
</li>
<li><p>在 SQL 的存储过程和触发器中，用 IF 替代 CASE 的代价是非常高的，难以应用</p>
</li>
</ul>
<p><strong>CASE 语句可以让 SQL 变得简单高效，提高执行效率，且通常不会引起性能问题，所以，通常应该作为首选。</strong></p>
<h2 id="42-常用的系统函数"><a href="#4-2-常用的系统函数" class="headerlink" title="4.2 常用的系统函数"></a>4.2 常用的系统函数</h2><h3 id="421-mysql自身的基本信息"><a href="#4-2-1-MySQL自身的基本信息" class="headerlink" title="4.2.1 MySQL自身的基本信息"></a>4.2.1 MySQL自身的基本信息</h3><h3 id="422-当前用户信息"><a href="#4-2-2-当前用户信息" class="headerlink" title="4.2.2 当前用户信息"></a>4.2.2 当前用户信息</h3><h3 id="423-库和表相关信息"><a href="#4-2-3-库和表相关信息" class="headerlink" title="4.2.3 库和表相关信息"></a>4.2.3 库和表相关信息</h3><h2 id="43-qampa"><a href="#4-3-Q-amp-A" class="headerlink" title="4.3 Q&amp;A"></a>4.3 Q&amp;A</h2><ul>
<li><p>MySQL 的默认字符排列方式是大小写不敏感的，如果想要大小写敏感，怎么做 ？</p>
</li>
<li><p>mysql大小写敏感配置与两个参数相关 —— <strong>lower_case_file_system 和 lower_case_table_names</strong></p>
<p>lower_case_file_system：表示当前系统文件是否大小写敏感（ON为不敏感，OFF为敏感），只读参数，无法修改。<br>lower_case_table_names：表示表名是否大小写敏感，可以修改。<br>lower_case_table_names = 0时，mysql会根据表名直接操作，大小写敏感。<br>lower_case_table_names = 1时，mysql会先把表名转为小写，再执行操作。</p>
</li>
</ul>
<h1 id="5-用户与权限"><a href="#5-用户与权限" class="headerlink" title="5. 用户与权限"></a>5. 用户与权限</h1><h1 id="6-数据备份与恢复"><a href="#6-数据备份与恢复" class="headerlink" title="6. 数据备份与恢复"></a>6. 数据备份与恢复</h1><h1 id="7-事务隔离级别"><a href="#7-事务隔离级别" class="headerlink" title="7. 事务隔离级别"></a>7. 事务隔离级别</h1><p>参考 ：<a href="https://developer.aliyun.com/article/743691">彻底搞懂 MySQL 事务的隔离级别-阿里云开发者社区 (aliyun.com)</a></p>
<h2 id="71-事务是什么"><a href="#7-1-事务是什么" class="headerlink" title="7.1 事务是什么"></a>7.1 事务是什么</h2><p>事务是作为单个逻辑工作单元执行的一系列操作，它所表达的语义是：要么全部执行，要么全部不执行。</p>
<p>银行取款例子：取款事务=操作1+操作2</p>
<ul>
<li>操作1：将 A 的余额减少 100 元 </li>
<li>操作2：A 获得 100 元取款</li>
</ul>
<p>这两个操作就是一次事务，因为这两个操作<strong>只能全部成功或全部失败</strong>，任何一个部分成功或失败，将会是非常严重的系统漏洞。事务的目标是<strong>保证数据库的完整性</strong>，<strong>避免各种原因引起的数据库内容不一致</strong>的问题。所以，事务可以保证数据安全，事务控制实际上就是在控制数据的安全访问</p>
<h2 id="72-事务的四个属性-acid"><a href="#7-2-事务的四个属性-ACID" class="headerlink" title="7.2 事务的四个属性 ACID"></a>7.2 事务的四个属性 ACID</h2><p>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性 （Durability）</p>
<ul>
<li>原子性：原子本身是化学中的一个名词，它指的是构成化学元素的最小粒子，即不能再更细的分割了。事务操作必须是原子的，对于<strong>一个事务中的所有操作</strong>，<strong>要么全部执行（COMMIT），要么全部不执行（ROLLBACK）</strong> </li>
<li>一致性：一致性指的是数据的完整性，即执行事务的前后，<strong>数据整体应该是一致的</strong>。事务必须能够让数据库从一个一致性状态变换到另一个一致性状态。对于取款的案例来说，A 的数据总值就是一致的</li>
<li>隔离性：它指的是<strong>一个事务的执行不能被其他事务所干扰</strong>，这里又涉及到并发的概念。<strong>一个事务内部的操作对其他并发的事务是隔离的</strong>，简单的说，每个事务都认为是自己独占数据库</li>
<li>持久性：这个属性简单易懂，它是说一个事务一旦提交（COMMIT），它<strong>对数据库中数据的改变就是永久性的</strong>。任何操作甚至是系统故障都不应该对其产生影响 </li>
</ul>
<p>事务有着严格的判定标准，想要同时实现它们又要求有很高的性能，可谓是难上加难。所以，在各大数据库厂商的实现中，真正能够满足这四个特性的事务寥寥无几。例如：</p>
<p>InnoDB 存储引擎默认的事务隔离级别是可重复读，它不能满足隔离性要求；</p>
<p>而 MySQL 的 NDB Cluster 事务则不满足持久性和隔离性。</p>
<p>所以，与其说 ACID是事务必须满足的条件，不如说它们是<strong>衡量事务的严谨性标准</strong>。</p>
<h2 id="73-并发事务会引发的问题"><a href="#7-3-并发事务会引发的问题" class="headerlink" title="7.3 并发事务会引发的问题"></a>7.3 并发事务会引发的问题</h2><p>并发事务的概念是多个事务并发运行，那么，如果在并发运行的过程中对相同的数据进行了修改，就可能会引起一些问题：</p>
<ul>
<li><strong>脏读</strong>：事务 A 读取了事务 B 当前更新的数据，但是事务 B 出现了回滚或未提交修改，事务 A 读到的数据就被称为 “脏数据”。通常情况下，<strong>使用 “脏数据” 会造成系统数据不一致</strong>，出现错误 </li>
<li><img src="https://cdn.learnku.com/uploads/images/202002/04/32495/Wcv8DTijTL.png!large" alt="从根上理解MySQL事务的隔离级别" style="zoom:50%;"></li>
<li><strong>不可重复读</strong>：事务 A 在执行过程中多次读取同一数据，但是事务 B 在事务 A 的读取过程中对数据做了多次修改并提交，则会导致<strong>事务 A 多次读取的数据不一致</strong>，进而无法做出准确性判断 </li>
<li><img src="https://cdn.learnku.com/uploads/images/202002/05/32495/YdNemia6wc.png!large" alt="从根上理解 MySQL 事务的隔离级别" style="zoom:50%;"></li>
<li><strong>幻读</strong>：事务 A 在执行过程中读取了一些数据，但是事务 B 随即插入了一些数据，那么，事务 A 重新读取时，发现<strong>多了一些原本不存在的数据</strong>，就像是幻觉一样，称之为幻读</li>
<li><img src="https://cdn.learnku.com/uploads/images/202002/04/32495/0sCtxw1Jno.png" alt="从根上理解 MySQL 事务的隔离级别" style="zoom:50%;"></li>
<li>不可重复读指的是<strong>对原来存在的数据做修改</strong>；而幻读指的是<strong>新增或者删除数据</strong>。</li>
</ul>
<h2 id="74-四种隔离级别"><a href="#7-4-四种隔离级别" class="headerlink" title="7.4 四种隔离级别"></a>7.4 四种隔离级别</h2><p>由低到高依次为：</p>
<p>READ-UNCOMMITTED（未提交读）、READ-COMMITTED（提交读）、REPEATABLE-READ（可重复读）、SERIALIZABLE（串行化）。</p>
<p>它们可以逐个解决脏读、不可重复读、幻读这几类问题。 </p>
<ul>
<li><p><strong>READ-UNCOMMITTED</strong>：它是最低的隔离级别，正如它的名称一样，它<strong>允许一个事务读取其他事务未提交的 数据</strong>。这个隔离级别很少在工业环境中应用，因为它的性能并不会比其他高级别的性能好很多 </p>
<p><img src="https://cdn.learnku.com/uploads/images/202002/05/32495/iL6jfZxiHJ.png!large" alt="彻底搞懂 MySQL 事务的隔离级别" style="zoom:50%;"></p>
</li>
<li><p><strong>READ-COMMITTED</strong>：它可以<strong>保证一个事务修改的数据提交之后才能被其他的事务读取</strong>。这个隔离级别是大多 数数据库系统的默认隔离级别，但并不是 MySQL 默认的 </p>
</li>
<li><p><img src="https://cdn.learnku.com/uploads/images/202002/05/32495/BsMcuysaIB.png!large" alt="彻底搞懂 MySQL 事务的隔离级别" style="zoom:50%;"></p>
</li>
<li><p><strong>REPEATABLE-READ</strong>：它的核心在于 “可重复”，即<strong>在一个事务内，对同一字段的多次读取结果都是相同的</strong>， 也是 <strong>MySQL 的默认事务隔离级别</strong> </p>
</li>
<li><p><img src="https://cdn.learnku.com/uploads/images/202002/05/32495/yjRtVOpMBZ.png!large" alt="彻底搞懂 MySQL 事务的隔离级别" style="zoom:50%;"></p>
</li>
<li><p><strong>SERIALIZABLE</strong>：它是最高的隔离级别，花费的代价也是最高的，<strong>事务的处理是顺序执行的</strong>。在这个级别上， <strong>可能会导致大量的锁超时现象和锁竞争</strong>。同样，在工业级环境中，很少被使用。通过强制事务排序，并按顺序执行，使各个事务之间不可能会产生冲突，从而才能够解决脏读、不可重复读、幻读所有的问题。</p>
</li>
</ul>
<p>隔离级别越低，事务请求的锁也就越少，所以，可能出现的问题也就越多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>READ-UNCOMMITTED</strong> 未提交读</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td><strong>READ-COMMITTED</strong> 提交读</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td><strong>REPEATABLE-READ</strong> 可重复读</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong> 串行化</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
</tbody>
</table>
</div>
<p>具体选择哪一种隔离级别应该是多个维度的考虑，例如：事务请求锁的多少（性能问题）、能够解决什么问题、业务特点等等。<strong>一般情况下，使用 InnoDB 存储引擎，选择 READ-COMMITTED</strong>。 </p>
<h2 id="75-不同事务隔离级别对事务的影响"><a href="#7-5-不同事务隔离级别对事务的影响" class="headerlink" title="7.5 不同事务隔离级别对事务的影响"></a>7.5 不同事务隔离级别对事务的影响</h2><h2 id="76-mysql默认隔离级别可重复读实现原理"><a href="#7-6-MySQL默认隔离级别（可重复读）实现原理" class="headerlink" title="7.6 MySQL默认隔离级别（可重复读）实现原理"></a>7.6 MySQL默认隔离级别（可重复读）实现原理</h2><p>每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。</p>
<p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<p><img src="https://cdn.learnku.com/uploads/images/202002/05/32495/mfZfSEBBSn.png!large" alt="彻底搞懂 MySQL 事务的隔离级别" style="zoom:50%;"></p>
<p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是<strong>数据库的多版本并发控制（MVCC）</strong>。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p>
<p>回滚操作日志（undo log）什么时候删除？MySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。</p>
<p>什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。</p>
<h2 id="77-qampa"><a href="#7-7-Q-amp-A" class="headerlink" title="7.7 Q&amp;A"></a>7.7 Q&amp;A</h2><ul>
<li><p>修改系统级的隔离级别（SET global tx_isolation），验证对所有的会话都是生效的 ？</p>
<p> set tx_isolation=’read-committed’</p>
</li>
<li><p>挑选一个事务隔离级别，例如：READ-COMMITTED，演示并验证它可能会导致的问题 ？ </p>
</li>
<li><p>当会话处于 REPEATABLE-READ 隔离级别时，读取到的数据就一定是一样的吗 ？ </p>
</li>
</ul>
<h1 id="8-通过锁解决并发数据问题"><a href="#8-通过锁解决并发数据问题" class="headerlink" title="8. 通过锁解决并发数据问题"></a>8. 通过锁解决并发数据问题</h1><p>数据库的锁机制是并发控制的重要内容，是对程序控制数据一致性的重要补充</p>
<h2 id="81-行级锁-表级锁"><a href="#8-1-行级锁、表级锁" class="headerlink" title="8.1 行级锁、表级锁"></a>8.1 行级锁、表级锁</h2><p>从应用的角度来看，分为悲观锁与乐观锁的概念</p>
<p>从数据库（InnoDB 存储引擎）的角度看，数据库锁可以分为行级锁和表级锁（通常称为行锁和表锁）。</p>
<h3 id="811-什么是行级锁"><a href="#8-1-1-什么是行级锁" class="headerlink" title="8.1.1 什么是行级锁"></a>8.1.1 什么是行级锁</h3><p>InnoDB 存储引擎支持行级锁和表级锁，<strong>默认情况下，使用行级锁</strong>。行级锁是 MySQL 中锁定粒度最细的一种锁，它<strong>锁住的是行记录</strong>。行级锁可以大大减少数据库操作的冲突，但是<strong>加锁的开销也是非常大</strong>的。它具有如下特点：</p>
<ul>
<li>由于开销比较大，<strong>加锁会很慢</strong> </li>
<li>锁定粒度小，所以锁冲突的概率低，<strong>并发度高</strong> </li>
<li>可能会出现<strong>死锁</strong></li>
</ul>
<h3 id="812-什么是表级锁"><a href="#8-1-2-什么是表级锁" class="headerlink" title="8.1.2 什么是表级锁"></a>8.1.2 什么是表级锁</h3><ul>
<li>由于开销比较小，加锁会很快 </li>
<li>锁定粒度大，所以锁冲突的概率高，并发度低 </li>
<li>不会出现死锁</li>
</ul>
<h3 id="813-mysql内部如何选择行级锁-表级锁什么场景下会锁住行-什么场景下又会锁住表"><a href="#8-1-3-MySQL内部如何选择行级锁、表级锁？什么场景下会锁住行、什么场景下又会锁住表" class="headerlink" title="8.1.3 MySQL内部如何选择行级锁、表级锁？什么场景下会锁住行、什么场景下又会锁住表"></a>8.1.3 MySQL内部如何选择行级锁、表级锁？什么场景下会锁住行、什么场景下又会锁住表</h3><p>InnoDB 行级锁是通过<strong>给索引上的索引项加锁</strong>来实现的，所以，只有通过索引条件检索的数据，InnoDB 才会使用行级锁。否则，使用表级锁。</p>
<p>即 <strong>使用索引==行级锁</strong></p>
<ul>
<li>不通过索引条件查询时，InnoDB 一定会使用表锁，而不是行锁（因为没有索引只能全表扫描） </li>
<li>查询时，不论是使用主键索引、唯一索引或者普通的索引，InnoDB 都会使用行锁来对数据加锁 。特殊情况下不成立<ul>
<li>对于数据量很少的表，MySQL 会认为全表扫描更快，此时，即使使用索引字段查询，InnoDB 也会使用表锁，而不是行锁。</li>
<li>因此如果想确定当前使用 的是哪一种锁，检查下 SQL 的执行计划（EXPLAIN），确认是否在查询时使用了索引。</li>
</ul>
</li>
</ul>
<h2 id="82-悲观锁-乐观锁"><a href="#8-2-悲观锁、乐观锁" class="headerlink" title="8.2 悲观锁、乐观锁"></a>8.2 悲观锁、乐观锁</h2><p>参考：<a href="http://www.chinacion.cn/article/8215.html">Laravel中MySQL的乐观锁与悲观锁 技术指南 (chinacion.cn)</a></p>
<p>从应用的角度来说，乐观并发控制与悲观并发控制是并发场景下保证数据一致性的主要方法</p>
<h3 id="821-什么是悲观锁"><a href="#8-2-1-什么是悲观锁" class="headerlink" title="8.2.1 什么是悲观锁"></a>8.2.1 什么是悲观锁</h3><blockquote>
<p>当我们要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是<strong>直接对该数据进行加锁以防止并发</strong>。这种借助数据库锁机制在修改数据之前锁定，再修改的方式被称为悲观并发控制 （PCC）</p>
</blockquote>
<p>它会以悲观的态度去对待并发的数据控制，认为<strong>共享数据被并发修改的可能性较高，在修改之前先去加锁</strong>。在实现效率上，<strong>处理加锁的过程会让数据库产生额外的开销，降低并发度</strong>，同时，还可能会有<strong>死锁</strong>的可能</p>
<p>悲观锁的实现，依赖于数据库提供的锁机制，即行级锁、表级锁</p>
<ol>
<li>对数据操作之前，尝试获取锁 </li>
<li>获取锁成功，对数据进行修改、提交事务，最后释放锁 </li>
<li>获取锁失败，则锁正在被占用，等待或抛出异常</li>
</ol>
<p><img src="http://www.chinacion.cn/uploads/article/images/2020-05-15/7f8e130b8a48f7308fec21a21cc0f35d.png" alt="悲观锁示意图"></p>
<h3 id="822-什么是乐观锁"><a href="#8-2-2-什么是乐观锁" class="headerlink" title="8.2.2 什么是乐观锁"></a>8.2.2 什么是乐观锁</h3><blockquote>
<p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在<strong>数据进行提交更新的时候，才会正式对数据的冲突与否进行检测</strong>。 </p>
</blockquote>
<p><img src="http://www.chinacion.cn/uploads/article/images/2020-05-15/85ea61c4e055f0ff491a5c098c6703c7.png" alt="乐观锁示意图"></p>
<h2 id="83-悲观锁-乐观锁-实现原理和使用方法"><a href="#8-3-悲观锁、乐观锁-实现原理和使用方法" class="headerlink" title="8.3 悲观锁、乐观锁 实现原理和使用方法"></a>8.3 悲观锁、乐观锁 实现原理和使用方法</h2><h3 id="831-使用悲观锁"><a href="#8-3-1-使用悲观锁" class="headerlink" title="8.3.1 使用悲观锁"></a>8.3.1 使用悲观锁</h3><p>在 MySQL 中使用悲观锁，必须关闭 MySQL 的自动提交（MySQL 默认使用自动提交模式，即执行 INSERT、UPDATE、DELETE 时，结果自动生效）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># my关闭自动提交 </span><br><span class="line">mysql&gt; SET autocommit = off;</span><br></pre></td></tr></table></figure>
<p>MySQL 提供的悲观锁实现方式是：<code>SELECT … FOR UPDATE</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- “会话 A” 通过悲观锁语法锁住 id 为 1 的记录 </span><br><span class="line">mysql&gt; SELECT * FROMworker WHERE id = 1 FOR UPDATE; </span><br><span class="line">+----+------+------+--------+ </span><br><span class="line">| id | type | name | salary | </span><br><span class="line">+----+------+------+--------+ </span><br><span class="line">| 1 | A | tom | 1800 | </span><br><span class="line">+----+------+------+--------+ </span><br><span class="line"></span><br><span class="line">-- “会话 B” 也通过悲观锁语法锁住 id 为 1 的记录 </span><br><span class="line">-- 由于锁被 “会话 A” 占据，长时间获取不到锁，报了锁超时错误 </span><br><span class="line">mysql&gt; SELECT * FROMworker WHERE id = 1 FOR UPDATE; </span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction </span><br></pre></td></tr></table></figure>
<p>“会话 A” 更新被锁定记录的 salary 字段，并提交事务（在这个过程中，同时让 “会话 B” 尝试去获取锁），如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- “会话 A” 更新记录 </span><br><span class="line">mysql&gt; UPDATE worker SET salary = 2000 WHERE id = 1; </span><br><span class="line">Query OK, 1 row affected (0.01 sec) </span><br><span class="line">Rows matched: 1 Changed: 1 Warnings: 0 </span><br><span class="line"></span><br><span class="line">-- “会话 A” 提交事务 </span><br><span class="line">mysql&gt; commit; </span><br><span class="line">Query OK, 0 rows affected (0.02 sec) </span><br><span class="line"></span><br><span class="line">-- “会话 B” 在 “会话 A” 提交事务之后，获取锁成功（观察 SQL 语句执行耗时） </span><br><span class="line">mysql&gt; SELECT * FROMworker WHERE id = 1 FOR UPDATE; </span><br><span class="line">+----+------+------+--------+ </span><br><span class="line">| id | type | name | salary | </span><br><span class="line">+----+------+------+--------+ </span><br><span class="line">| 1 | A | tom | 2000 | </span><br><span class="line">+----+------+------+--------+ </span><br><span class="line">1 row in set (25.13 sec)</span><br></pre></td></tr></table></figure>
<h3 id="832-使用乐观锁"><a href="#8-3-2-使用乐观锁" class="headerlink" title="8.3.2 使用乐观锁"></a>8.3.2 使用乐观锁</h3><p>乐观锁其实是对 <strong>CAS（compare-and-swap）</strong>的实现：<strong>在做修改时，检查当前的环境是否与预定义的一致，如果一致则可以提交；否则，重试或抛异常</strong></p>
<p>如何判断当前环境一致：</p>
<ul>
<li>简单方法：对修改的值进行前后判断<ul>
<li>这里存在一个隐藏很深的问题：ABA。考虑这样一种情况：“线程 A” 在更新 salary 之前，“线程 B” 先将 salary 更新为2500，再将 salary 更新为 2000。此时，“线程 A” 则会认为 salary 没有发 生变化，而实际的情况是，“线程 B” 对此更新了两次。 </li>
</ul>
</li>
<li>进阶办法：加入一个不会重复修改的值数据来作为版本号，即 version参 数,用时间戳类型，<strong>version 只能增加，不能减少</strong>。乐观锁在每次执行数据修改时，都需要去<strong>比对 version，如果一致，则更新数据</strong> 的同时，<strong>也要更新 version</strong>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 给 worker 表添加 version 列 </span><br><span class="line">mysql&gt; ALTER TABLE `worker` ADD COLUMN `version` BIGINT(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;乐观锁版本号&#x27;; </span><br><span class="line"></span><br><span class="line">-- 读取数据，记录 version 的值 </span><br><span class="line">mysql&gt; SELECT * FROMworker WHERE id = 1; </span><br><span class="line">+----+------+------+--------+---------+ </span><br><span class="line">| id | type | name | salary | version | </span><br><span class="line">+----+------+------+--------+---------+ </span><br><span class="line">| 1 | A | tom | 1800 | 0 | </span><br><span class="line">+----+------+------+--------+---------+ </span><br><span class="line"></span><br><span class="line">-- 比对 version 是否符合预期，更新数据和 version </span><br><span class="line">mysql&gt; UPDATE worker SET salary = 2000, version = version + 1 WHERE id = 1 AND version = 0; </span><br><span class="line"></span><br><span class="line">-- 再次读取数据，校验是否符合预期 </span><br><span class="line">mysql&gt; SELECT * FROMworker WHERE id = 1; </span><br><span class="line">+----+------+------+--------+---------+ </span><br><span class="line">| id | type | name | salary | version | </span><br><span class="line">+----+------+------+--------+---------+ </span><br><span class="line">| 1 | A | tom | 2000 | 1 | </span><br><span class="line">+----+------+------+--------+---------+ </span><br></pre></td></tr></table></figure>
<p>乐观锁的思想比较简单，而且<strong>不会使用到真正的锁</strong>，实现效率很高。但是，乐观锁也并不是没有缺点的：当<strong>遇到高并发时，只可能会有一个线程修改成功，会造成大量的线程失败或重试</strong>。最后，补充一点，乐观锁同样可以使用时间戳来实现，一样的道理。 </p>
<h2 id="84-悲观锁-乐观锁-适用场景"><a href="#8-4-悲观锁、乐观锁-适用场景" class="headerlink" title="8.4 悲观锁、乐观锁 适用场景"></a>8.4 悲观锁、乐观锁 适用场景</h2><p>悲观锁是依赖于数据库（存储引擎）的，它的优缺点总结如下： </p>
<ul>
<li>优点：<strong>利用锁机制</strong>保证了数据的顺序执行，不需要自己控制，加锁、释放完全由数据库代劳 </li>
<li>缺点：一旦一个事务获取了锁，其他的事务必须等待，势必会<strong>影响系统的吞吐量</strong> </li>
<li>适用场景：<strong>写入操作比较频繁的场景</strong>，如果有大量的读取操作，每次读取都需要加锁，会增加锁开销，降低系统的吞吐量</li>
</ul>
<p>乐观锁不是真正的加锁，对其他事务友好，它的优缺点总结如下： </p>
<ul>
<li>优点：由于不需要加锁，其他的事务可以同时操作数据，相比于悲观锁，<strong>系统吞吐量会提高</strong> </li>
<li>缺点：需要自行控制，如果<strong>并发度较高，失败重试的情况会成为系统瓶颈</strong></li>
<li>适用场景： 读取操作比较频繁的场景，如果有大量的写入操作，冲突的可能性会剧增，降低系统的吞吐量 </li>
</ul>
<h2 id="85-qampa"><a href="#8-5-Q-amp-A" class="headerlink" title="8.5 Q&amp;A"></a>8.5 Q&amp;A</h2><ul>
<li>你能给出一个行级锁升级为表级锁的案例吗（使用 worker 表或者你定义的表都可以）？ </li>
<li>你能用 timestamp（时间戳）的方式实现乐观锁吗 ？ </li>
<li>除了我这里的讲解，你是怎样看待 MySQL 中的锁机制呢（可以从锁粒度、锁应用的角度去思考） </li>
</ul>
<h1 id="9-索引定义及其优化"><a href="#9-索引定义及其优化" class="headerlink" title="9. 索引定义及其优化"></a>9. 索引定义及其优化</h1><h2 id="91-何为索引"><a href="#9-1-何为索引" class="headerlink" title="9.1 何为索引"></a>9.1 何为索引</h2><blockquote>
<p>索引是存储引擎用于快速找到记录的一种数据结构 </p>
</blockquote>
<p>索引是一种数据结构，而数据结构是用来表示数据的特定规则。</p>
<p>如果我想要查询 salary = 2000 的员工有哪些，最简单的就是遍历所有的数据做比较，这样的时间复杂度是 O(n) 量 级。但是如果 MySQL 维护了一个 salary 的有序数组（MySQL 中使用的索引并不是有序数组)：[1200, 1500, 1800, 1800, 1900, 2000, 2100, 3600]，就可 以将查询过程优化为二分查找，此时的时间复杂度将降为 O(logn)。而这个有序数组也就对应到索引的概念了 </p>
<p>优点：</p>
<ul>
<li>减少扫描的数据量，<strong>加速查询</strong> </li>
<li><strong>减少或完全</strong>消除数据库的<strong>排序操作</strong>（ORDER BY），因为索引是有序的 </li>
<li>将服务器的<strong>随机 IO 变为顺序 IO</strong>，例如，想要查询 salary 处于 1500 ~ 2100 的员工，就可以按照索引顺序查询 </li>
</ul>
<p>缺点：</p>
<ul>
<li>索引会占<strong>据额外的存储空间（毕竟它是数据结构），包括磁盘和内存</strong> </li>
<li>由于<strong>对数据需要排序</strong>，自然会<strong>影响到数据更新（插入、更新、删除）的速度</strong></li>
</ul>
<h2 id="92-实现原理和分类"><a href="#9-2-实现原理和分类" class="headerlink" title="9.2 实现原理和分类"></a>9.2 实现原理和分类</h2><h3 id="921-实现原理"><a href="#9-2-1-实现原理" class="headerlink" title="9.2.1 实现原理"></a>9.2.1 实现原理</h3><p>对于 MySQL 来说，服务器层并不会实现索引，而是交给了存储引擎。所以，<strong>不同的存储引擎自然也就会有各自不同的实现</strong>。对于 InnoDB 而言，它的内部实现使用的是 <strong>B+ 树</strong></p>
<h4 id="m-阶-b-树"><a href="#M-阶-B-树" class="headerlink" title="M 阶 B 树"></a>M 阶 B 树</h4><p>B+ 树是对 B 树的改进得到的，而 B 树则是一棵多路平衡查找树（是平衡二叉树的变体，稍有不同的是 B 树属于多叉树，即查找路径不止两个）。所以，想要搞清楚 B+ 树，就一定要搞清楚 B 树。着重理解 M 的概念，M 阶代表一个节点最多有多少个查找路径</p>
<ul>
<li>根节点至少有两个子节点 </li>
<li>每个节点包含 k - 1 个元素和 k 个子节点，其中 m/2 &lt;= k &lt;= m（元素是存储的数据） </li>
<li>每个叶子节点都包含 k - 1 个元素，且位于同一层，其中 m/2 &lt;= k &lt;= m </li>
<li>每个节点中的元素从小到大排列，类似于一个有序数组 </li>
</ul>
<h4 id="m阶b-树"><a href="#M阶B-树" class="headerlink" title="M阶B+ 树"></a>M阶B+ 树</h4><p>添加了两项约束（完全包含 B 树的约束）：</p>
<ul>
<li>除叶子节点之外的其他节点都不保存数据，所以，数据在同一层 </li>
<li>叶子节点之间按照排列顺序链接在一起，形成了一个有序链表 </li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13586259-43e326b50b8aa57d.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1000/format/webp" alt="img" style="zoom:50%;"></p>
<h4 id="为什么-innodb-会选用-b-树作为索引数据结构呢"><a href="#为什么-InnoDB-会选用-B-树作为索引数据结构呢" class="headerlink" title="为什么 InnoDB 会选用 B+ 树作为索引数据结构呢"></a>为什么 InnoDB 会选用 B+ 树作为索引数据结构呢</h4><ul>
<li>中间节点不保存真实数据，就可以去存储更多的索引数据，以<strong>降低整体树的层级，减少磁盘 IO 的次数，提高 查询性能</strong> </li>
<li>所有的数据都保存在叶子节点，查询的次数也就是相同的，<strong>查询稳定性很高</strong> </li>
<li>叶子节点之间顺序链接在一起，<strong>范围查询的效率极高</strong></li>
</ul>
<h3 id="922-索引分类"><a href="#9-2-2-索引分类" class="headerlink" title="9.2.2 索引分类"></a>9.2.2 索引分类</h3><ul>
<li><strong>普通索引</strong>：针对于单个列创建的索引，之所以说它普通是因为它对列值没有什么限制，允许被索引的列包含重复的值 </li>
<li><strong>唯一索引</strong>：正如它的关键字一样，它要求列值是唯一的，这个索引保证了数据记录的唯一性 </li>
<li><strong>主键索引</strong>：它是一种特殊的唯一索引，在一张表中只能定义一个（但不是必须）主键索引 </li>
<li><strong>联合索引</strong>：也被称为复合索引，它是将多个列值绑定在一起作为索引 </li>
</ul>
<p>索引的分类是存在交叉的。唯一索引和主键索引也可以针对多个列做索引，即它们可以是联合索引。</p>
<h2 id="93-创建高性能索引"><a href="#9-3-创建高性能索引" class="headerlink" title="9.3 创建高性能索引"></a>9.3 创建高性能索引</h2><p>参考：[高性能索引策略——《高性能MySQL》第五章 | ]</p>
<h3 id="931-聚簇索引"><a href="#9-3-1-聚簇索引" class="headerlink" title="9.3.1 聚簇索引"></a>9.3.1 聚簇索引</h3><h3 id="932-联合索引"><a href="#9-3-2-联合索引" class="headerlink" title="9.3.2 联合索引"></a>9.3.2 联合索引</h3><h3 id="933-前缀索引"><a href="#9-3-3-前缀索引" class="headerlink" title="9.3.3 前缀索引"></a>9.3.3 前缀索引</h3><h3 id="934-覆盖索引"><a href="#9-3-4-覆盖索引" class="headerlink" title="9.3.4 覆盖索引"></a>9.3.4 覆盖索引</h3><h2 id="94-查看索引元数据"><a href="#9-4-查看索引元数据" class="headerlink" title="9.4 查看索引元数据"></a>9.4 查看索引元数据</h2><h2 id="95-qampa"><a href="#9-5-Q-amp-A" class="headerlink" title="9.5 Q&amp;A"></a>9.5 Q&amp;A</h2><ul>
<li>根据我对 B 树的描述，再加上你的理解，你知道图中的 B 树是几阶的吗 ？ </li>
<li>你能举一个联合索引建立 B+ 树的例子吗 ？ </li>
<li>根据你的理解，你能说说哪些列（不仅仅是数据类型需要是字符型，还要关注列值）适合前缀索引吗 ？ </li>
<li>你平时是怎样建立、使用索引的，为什么要这样做呢 ？</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>netty学习</title>
    <url>/post/494a0207/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="了解netty"><a href="#了解Netty" class="headerlink" title="了解Netty"></a>了解Netty</h2><ul>
<li>目前最流行的一款<strong>高性能 java 网络编程框架</strong>，被广泛使用在中间件、直播、社交、游戏等领域</li>
<li>将Netty作为底层框架的框架：Dubbo、RocketMQ、Elasticsearch、Hbase等</li>
<li><ol>
<li>netty高性能表现在哪些方便？有何启发？</li>
<li>有哪些重要组件？及其联系？</li>
<li>内存池、对象池如何设计的？</li>
<li>有哪些印象比较深刻的系统调优案例？</li>
<li>……</li>
</ol>
</li>
<li>Netty的设计原理<ul>
<li>对理解I/O模型、内存管理、线程模型、数据结构有帮助</li>
<li>对学习RocketMQ、Nginx、Redis等优秀框架有帮助</li>
<li>Netty的易用性和可靠性极大降低了心智负担</li>
</ul>
</li>
<li>Netty对java NIO进行高级封装，简化了网络应用的开发过程</li>
<li>对于<strong>拆包/黏包、数据编解码、TCP断线重连</strong>等问题，Netty提供了现成的解决方案，其可靠性和健壮性很强</li>
</ul>
<p>学习源码之前，首先要让自己成为一个<strong>熟练工</strong>，掌握基本理论</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li><p>为什么使用Netty</p>
<ul>
<li>I/O模型、线程模型、事件处理机制</li>
<li>易用性API接口</li>
<li>对数据协议、序列化的支持</li>
</ul>
</li>
<li><p>高性能、低延迟</p>
</li>
</ul>
<p>I/O模型基础知识：</p>
<ul>
<li><p>I/O请求</p>
<ul>
<li>I/O调用阶段：用户进程向内核发起系统调用</li>
<li>I/O执行阶段：内核等待I/O请求处理完成返回</li>
</ul>
</li>
<li><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/netty_learning/1.PNG" alt></p>
</li>
<li><p>Linux的五种IO模式</p>
<ol>
<li><p>同步阻塞I/O (BIO)</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/netty_learning/2.PNG" alt></p>
</li>
<li><p>同步非阻塞I/O (NIO)</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/netty_learning/3.PNG" alt></p>
</li>
<li><p>I/O多路复用</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/netty_learning/4.PNG" alt></p>
</li>
<li><p>信号驱动I/O</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/netty_learning/5.PNG" alt>3</p>
</li>
<li><p>异步I/O</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/netty_learning/6.PNG" alt></p>
</li>
</ol>
</li>
<li><p>Netty如何实现自己的I/O模型</p>
<ul>
<li>基于非阻塞IO实现</li>
<li>底层依赖于JDK NIO框架的多路复用器Selector</li>
<li>一个多路复用器Slector可以同时轮询多个Channel</li>
<li>事件分发器 Event Dispather<ul>
<li>负责将读写事件分发给对应的读写事件处理器 Event Handler</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN识别垃圾邮件</title>
    <url>/post/65e9fc1f/</url>
    <content><![CDATA[<h2 id="1-获取数据集及处理思路"><a href="#1-获取数据集及处理思路" class="headerlink" title="1. 获取数据集及处理思路"></a>1. 获取数据集及处理思路</h2><p><a href="https://www.kaggle.com/uciml/sms-spam-collection-dataset">SMS垃圾邮箱数据集</a></p>
<p>这个数据有两列，一列为标记，值为<code>ham</code> <code>spam</code>，第二列为邮件文本数据。</p>
<ul>
<li>判断邮件是否为垃圾邮件——分类问题</li>
<li>输出y可以设为0或1，1代表spam垃圾邮箱，0代表ham非垃圾邮箱</li>
<li>处理的输入数据x是文本数据、序列数据，可以建立一个多对一的RNN模型</li>
</ul>
<h2 id="2-训练神经网络"><a href="#2-训练神经网络" class="headerlink" title="2. 训练神经网络"></a>2. 训练神经网络</h2><h3 id="1-加载包"><a href="#1-加载包" class="headerlink" title="1. 加载包"></a>1. 加载包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> zipfile <span class="keyword">import</span> ZipFile</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line"></span><br><span class="line">ops.reset_default_graph() </span><br></pre></td></tr></table></figure>
<p>其中<code>ops.reset_default_graph()</code>是对default graph重新初始化，清空所有张量</p>
<h4 id="11-为graph建立会话"><a href="#1-1-为graph建立会话" class="headerlink" title="1.1 为graph建立会话"></a>1.1 为graph建立会话</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sess = tf.Session()</span><br></pre></td></tr></table></figure>
<h4 id="12-设定rnn模型的参数"><a href="#1-2-设定RNN模型的参数" class="headerlink" title="1.2 设定RNN模型的参数"></a>1.2 设定RNN模型的参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epochs = <span class="number">30</span> <span class="comment"># 执行30代</span></span><br><span class="line">batch_size = <span class="number">250</span> </span><br><span class="line">max_sequence_length = <span class="number">25</span> <span class="comment"># 考虑的每个文本的最大长度为25个单词，这样会将较长的文本剪切为25个，不足的用零填充</span></span><br><span class="line">rnn_size = <span class="number">10</span></span><br><span class="line">embedding_size = <span class="number">50</span></span><br><span class="line">min_word_frequency = <span class="number">10</span></span><br><span class="line">learning_rate = <span class="number">0.0005</span></span><br><span class="line">dropout_keep_prob = tf.placeholder(tf.float32)</span><br><span class="line"><span class="comment"># RNN 有 10 个单元， 每个单词都将被嵌入到一个长度为 50 的可训练向量中， 只考虑我们的 vocabulary 中出现 10 次以上的单词， 学习率设置为 0.0005 dropout 先由一个占位符定义，我们可以在训练时将其设置为 0.5， 或在评估时设置为 1.0</span></span><br></pre></td></tr></table></figure>
<h3 id="2-导入数据"><a href="#2-导入数据" class="headerlink" title="2. 导入数据"></a>2. 导入数据</h3><p>下载数据存为text_data.txt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设定路径</span></span><br><span class="line">data_dir = <span class="string">&#x27;temp&#x27;</span></span><br><span class="line">data_file = <span class="string">&#x27;text_data.txt&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(data_dir):</span><br><span class="line">    os.makedirs(data_dir)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 直接下载数据集</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(os.path.join(data_dir, data_file)):</span><br><span class="line">    zip_url = <span class="string">&#x27;http://archive.ics.uci.edu/ml/machine-learning-databases/00228/smsspamcollection.zip&#x27;</span></span><br><span class="line">    r = requests.get(zip_url)</span><br><span class="line">    z = ZipFile(io.BytesIO(r.content))</span><br><span class="line">    file = z.read(<span class="string">&#x27;SMSSpamCollection&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 格式化数据</span></span><br><span class="line">    text_data = file.decode()</span><br><span class="line">    text_data = text_data.encode(<span class="string">&#x27;ascii&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    text_data = text_data.decode().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将数据存储到 text 文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(data_dir, data_file), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_conn:</span><br><span class="line">        <span class="keyword">for</span> text <span class="keyword">in</span> text_data:</span><br><span class="line">            file_conn.write(<span class="string">&quot;&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(text))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 从 text 文件打开数据</span></span><br><span class="line">    text_data = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(data_dir, data_file), <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file_conn:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> file_conn:</span><br><span class="line">            text_data.append(row)</span><br><span class="line">    text_data = text_data[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="21-数据预处理"><a href="#2-1-数据预处理" class="headerlink" title="2.1 数据预处理"></a>2.1 数据预处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据中的标签和邮件文本分开</span></span><br><span class="line"><span class="comment"># 得到 text_data_target 和 text_data_train</span></span><br><span class="line">text_data = [x.split(<span class="string">&#x27;\t&#x27;</span>) <span class="keyword">for</span> x <span class="keyword">in</span> text_data <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt;= <span class="number">1</span>]</span><br><span class="line">[text_data_target, text_data_train] = [<span class="built_in">list</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(*text_data)]</span><br></pre></td></tr></table></figure>
<ul>
<li>为了减少vocabulary，先清理文本，移除特殊字符，删除多余空格，将文本换成小写</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个文本清理函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_text</span>(<span class="params">text_string</span>):</span></span><br><span class="line">    text_string = re.sub(<span class="string">r&#x27;([^\s\w]|_|[0-9])+&#x27;</span>, <span class="string">&#x27;&#x27;</span>, text_string)</span><br><span class="line">    text_string = <span class="string">&quot; &quot;</span>.join(text_string.split())</span><br><span class="line">    text_string = text_string.lower()</span><br><span class="line">    <span class="keyword">return</span> text_string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用clean_text 清理文本</span></span><br><span class="line">text_data_train = [clean_text(x) <span class="keyword">for</span> x <span class="keyword">in</span> text_data_train]</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来将文本转为词的ID序列</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用 TensorFlow 中一个内置的 VocabularyProcessor 函数来处理文本</span></span><br><span class="line"><span class="comment"># max_document_length: 是文本的最大长度。如果文本的长度大于这个值，就会被剪切，小于这个值的地方用 0 填充。 </span></span><br><span class="line"><span class="comment"># min_frequency: 是词频的最小值。当单词的出现次数小于这个词频，就不会被收录到词表中。</span></span><br><span class="line">vocab_processor = tf.contrib.learn.preprocessing.VocabularyProcessor(max_sequence_length, min_frequency=min_word_frequency)</span><br><span class="line">text_processed = np.array(<span class="built_in">list</span>(vocab_processor.fit_transform(text_data_train)))</span><br></pre></td></tr></table></figure>
<p>该方法的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给出以下数据</span></span><br><span class="line">max_document_length = <span class="number">4</span></span><br><span class="line">x_text =[</span><br><span class="line">    <span class="string">&#x27;i love you&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;me too&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果是</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="22-分为训练集和测试集"><a href="#2-2-分为训练集和测试集" class="headerlink" title="2.2 分为训练集和测试集"></a>2.2 分为训练集和测试集</h4><p>预处理后，将数据进行shuffle，再分为训练集和测试集</p>
<ul>
<li><p>shuffle打乱数据行序，使数据随机化。这样参数就不容易陷入局部最优，模型更容易达到收敛，<code>np.random.permutation()</code>来对行索引进行一次全排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text_processed = np.array(text_processed)</span><br><span class="line">text_data_target = np.array([<span class="number">1</span> <span class="keyword">if</span> x == <span class="string">&#x27;ham&#x27;</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> text_data_target])</span><br><span class="line">shuffled_ix = np.random.permutation(np.arange(<span class="built_in">len</span>(text_data_target)))</span><br><span class="line">x_shuffled = text_processed[shuffled_ix]</span><br><span class="line">y_shuffled = text_data_target[shuffled_ix]</span><br></pre></td></tr></table></figure>
</li>
<li><p>shuffle 数据后，将数据集分为 80% 训练集和 20% 测试集 如果想做交叉验证 cross-validation ，可以将 测试集 进一步分为测试集和验证集来调参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ix_cutoff = <span class="built_in">int</span>(<span class="built_in">len</span>(y_shuffled)*<span class="number">0.80</span>)</span><br><span class="line">x_train, x_test = x_shuffled[:ix_cutoff], x_shuffled[ix_cutoff:]</span><br><span class="line">y_train, y_test = y_shuffled[:ix_cutoff], y_shuffled[ix_cutoff:]</span><br><span class="line">vocab_size = <span class="built_in">len</span>(vocab_processor.vocabulary_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Vocabulary Size: &#123;:d&#125;&quot;</span>.<span class="built_in">format</span>(vocab_size))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;80-20 Train Test split: &#123;:d&#125; -- &#123;:d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(y_train), <span class="built_in">len</span>(y_test)))</span><br></pre></td></tr></table></figure>
<p>将会输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Vocabulary size: <span class="number">933</span></span><br><span class="line"><span class="number">80</span>-<span class="number">20</span> Train Test split: <span class="number">4459</span> -- <span class="number">1115</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="23-将输入数据做词嵌入embedding"><a href="#2-3-将输入数据做词嵌入Embedding" class="headerlink" title="2.3 将输入数据做词嵌入Embedding"></a>2.3 将输入数据做词嵌入Embedding</h4>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis命令总结</title>
    <url>/post/6c3cc871/</url>
    <content><![CDATA[<h1 id="redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><p>官方命令大全网址：<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<p>Redis中存储数据是通过key-value格式存储数据的，其中value可以定义五种数据类型：</p>
<ul>
<li>String（字符类型）</li>
<li>Hash（散列类型）</li>
<li>List（列表类型）</li>
<li>Set（集合类型）</li>
<li>SortedSet（有序集合类型，简称zset）</li>
</ul>
<p>注意：在redis中的命令语句中，<strong>命令是忽略大小写的，而key是不忽略大小写的。</strong></p>
<h2 id="11-string类型"><a href="#1-1-String类型" class="headerlink" title="1.1  String类型"></a>1.1  String类型</h2><h3 id="111-命令"><a href="#1-1-1-命令" class="headerlink" title="1.1.1 命令"></a>1.1.1 命令</h3><h4 id="1111-赋值"><a href="#1-1-1-1-赋值" class="headerlink" title="1.1.1.1    赋值"></a>1.1.1.1    赋值</h4><p>语法：<strong>SET key value</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set test 123  OK  </span><br></pre></td></tr></table></figure>
<h4 id="1112-取值"><a href="#1-1-1-2-取值" class="headerlink" title="1.1.1.2    取值"></a>1.1.1.2    取值</h4><p>语法：<strong>GET key</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get test  &quot;123“ </span><br></pre></td></tr></table></figure>
<h4 id="1113-取值并赋值"><a href="#1-1-1-3-取值并赋值" class="headerlink" title="1.1.1.3    取值并赋值"></a>1.1.1.3    取值并赋值</h4><p>语法：<strong>GETSET key value</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  getset s2 222  &quot;111&quot;  127.0.0.1:6379&gt;  get s2  &quot;222&quot;  </span><br></pre></td></tr></table></figure>
<h4 id="1114-数值增减"><a href="#1-1-1-4-数值增减" class="headerlink" title="1.1.1.4    数值增减"></a>1.1.1.4    数值增减</h4><p><strong>注意实现：</strong></p>
<p>1、 当value为整数数据时，才能使用以下命令操作数值的增减。</p>
<p>2、 数值递增都是<strong>原子</strong>操作。</p>
<p>​      非原子性操作示例：      int i = 1;      i++;      System.out.println(i)  </p>
<p><strong>递增数字</strong></p>
<p>语法：<strong>INCR key</strong></p>
<p>  127.0.0.1:6379&gt;  incr num  (integer)  1  127.0.0.1:6379&gt;  incr num  (integer)  2  127.0.0.1:6379&gt;  incr num  (integer)  3  </p>
<p><strong>增加指定的整数</strong></p>
<p>语法：<strong>INCRBY key increment</strong></p>
<p>  127.0.0.1:6379&gt;  incrby num 2  (integer)  5  127.0.0.1:6379&gt;  incrby num 2  (integer)  7  127.0.0.1:6379&gt;  incrby num 2  (integer)  9  </p>
<p><strong>递减数值</strong></p>
<p>语法：<strong>DECR key</strong></p>
<p>  127.0.0.1:6379&gt;  decr num  (integer)  9  127.0.0.1:6379&gt;  decr num  (integer)  8  </p>
<p><strong>减少指定的整数</strong></p>
<p>语法：<strong>DECRBY key decrement</strong></p>
<p>  127.0.0.1:6379&gt;  decr num  (integer)  6  127.0.0.1:6379&gt;  decr num  (integer)  5  127.0.0.1:6379&gt;  decrby num 3  (integer)  2  127.0.0.1:6379&gt;  decrby num 3  (integer)  -1  </p>
<h4 id="1115-仅当不存在时赋值"><a href="#1-1-1-5-仅当不存在时赋值" class="headerlink" title="1.1.1.5    仅当不存在时赋值"></a>1.1.1.5    仅当不存在时赋值</h4><p><strong>使用该命令可以实现分布式锁的功能，后续讲解！！！</strong></p>
<p><strong>语法：setnx key value</strong></p>
<p>redis&gt; EXISTS job        # job 不存在</p>
<p>(integer) 0</p>
<p>redis&gt; SETNX job “programmer”  # job 设置成功</p>
<p>(integer) 1</p>
<p>redis&gt; SETNX job “code-farmer”  # 尝试覆盖 job ，失败</p>
<p>(integer) 0</p>
<p>redis&gt; GET job          # 没有被覆盖</p>
<p>“programmer”</p>
<h4 id="1116-其它命令"><a href="#1-1-1-6-其它命令" class="headerlink" title="1.1.1.6    其它命令"></a>1.1.1.6    其它命令</h4><h5 id="11161-向尾部追加值"><a href="#1-1-1-6-1-向尾部追加值" class="headerlink" title="1.1.1.6.1 向尾部追加值"></a>1.1.1.6.1 向尾部追加值</h5><p>APPEND命令，向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。</p>
<p>语法：<strong>APPEND key value</strong></p>
<p>  127.0.0.1:6379&gt;  set str hello  OK  127.0.0.1:6379&gt;  append str “ world!”  (integer)  12  127.0.0.1:6379&gt;  get str   “hello  world!”  </p>
<h5 id="11162-获取字符串长度"><a href="#1-1-1-6-2-获取字符串长度" class="headerlink" title="1.1.1.6.2 获取字符串长度"></a>1.1.1.6.2 获取字符串长度</h5><p>STRLEN命令，返回键值的长度，如果键不存在则返回0。</p>
<p>语法：<strong>STRLEN key</strong></p>
<p>  127.0.0.1:6379&gt; strlen str   (integer) 0  127.0.0.1:6379&gt; set str hello  OK  127.0.0.1:6379&gt; strlen str   (integer) 5     </p>
<h5 id="11163-同时设置获取多个键值"><a href="#1-1-1-6-3-同时设置-获取多个键值" class="headerlink" title="1.1.1.6.3 同时设置/获取多个键值"></a>1.1.1.6.3 同时设置/获取多个键值</h5><p>语法：</p>
<p><strong>MSET key value [key value …]</strong></p>
<p><strong>MGET key [key …]</strong></p>
<p>  127.0.0.1:6379&gt;  mset k1 v1 k2 v2 k3 v3  OK  127.0.0.1:6379&gt;  get k1  “v1”  127.0.0.1:6379&gt;  mget k1 k3  1)  “v1”  2)  “v3”  </p>
<h3 id="112-应用场景之自增主键"><a href="#1-1-2-应用场景之自增主键" class="headerlink" title="1.1.2 应用场景之自增主键"></a>1.1.2 应用场景之自增主键</h3><p><strong>需求：商品编号、订单号采用INCR命令生成。</strong></p>
<p><strong>设计：</strong>key命名要有一定的设计</p>
<p><strong>实现：</strong>定义商品编号key：items:id</p>
<p>192.168.101.3:7003&gt; INCR items:id</p>
<p>(integer) 2</p>
<p>192.168.101.3:7003&gt; INCR items:id</p>
<p>(integer) 3</p>
<h2 id="12-hash类型"><a href="#1-2-Hash类型" class="headerlink" title="1.2  Hash类型"></a>1.2  Hash类型</h2><h3 id="121-hash介绍"><a href="#1-2-1-hash介绍" class="headerlink" title="1.2.1 hash介绍"></a>1.2.1 hash介绍</h3><p>hash叫<strong>散列类型</strong>，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下：</p>
<h3 id="122-命令"><a href="#1-2-2-命令" class="headerlink" title="1.2.2 命令"></a>1.2.2 命令</h3><h4 id="1221-赋值"><a href="#1-2-2-1-赋值" class="headerlink" title="1.2.2.1    赋值"></a>1.2.2.1    赋值</h4><p>HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。</p>
<p>Ø 一次只能设置一个字段值</p>
<p>语法：<strong>HSET key field value</strong>  </p>
<p>  127.0.0.1:6379&gt; hset user username zhangsan   (integer) 1  </p>
<p>Ø 一次可以设置多个字段值</p>
<p>语法：<strong>HMSET key field value [field value …]</strong>     </p>
<p>  127.0.0.1:6379&gt; hmset user age 20 username  lisi   OK  </p>
<p>Ø 当字段不存在时赋值，类似HSET，区别在于如果字段存在，该命令不执行任何操作</p>
<p>语法：<strong>HSETNX key field value</strong></p>
<p>  127.0.0.1:6379&gt; hsetnx user age 30   如果user中没有age字段则设置age值为30，否则不做任何操作  (integer) 0  </p>
<h4 id="1222-取值"><a href="#1-2-2-2-取值" class="headerlink" title="1.2.2.2    取值"></a>1.2.2.2    取值</h4><p>Ø 一次只能获取一个字段值</p>
<p><strong>语法：HGET key field</strong>          </p>
<p>  127.0.0.1:6379&gt; hget user username  “zhangsan“  </p>
<p>Ø 一次可以获取多个字段值</p>
<p><strong>语法：HMGET key field [field …]</strong>           </p>
<p>  127.0.0.1:6379&gt; hmget user age username  1) “20”  2) “lisi”  </p>
<p>Ø 获取所有字段值</p>
<p><strong>语法：HGETALL key</strong></p>
<p>  127.0.0.1:6379&gt; hgetall user  1) “age”  2) “20”  3) “username”  4) “lisi”  </p>
<h4 id="1223-删除字段"><a href="#1-2-2-3-删除字段" class="headerlink" title="1.2.2.3    删除字段"></a>1.2.2.3    删除字段</h4><p>可以删除一个或多个字段，返回值是被删除的字段个数 </p>
<p><strong>语法：HDEL key field [field …]</strong></p>
<p>  127.0.0.1:6379&gt; hdel user age  (integer) 1  127.0.0.1:6379&gt; hdel user age name  (integer) 0  127.0.0.1:6379&gt; hdel user age username  (integer) 1   </p>
<h4 id="1224-增加数字"><a href="#1-2-2-4-增加数字" class="headerlink" title="1.2.2.4    增加数字"></a>1.2.2.4    增加数字</h4><p><strong>语法：HINCRBY key field increment</strong></p>
<p>  127.0.0.1:6379&gt; hincrby user age 2   将用户的年龄加2  (integer) 22  127.0.0.1:6379&gt; hget user age       获取用户的年龄  “22“  </p>
<h4 id="1225-其它命令自学"><a href="#1-2-2-5-其它命令-自学" class="headerlink" title="1.2.2.5    其它命令(自学)"></a>1.2.2.5    其它命令(自学)</h4><h5 id="12251-判断字段是否存在"><a href="#1-2-2-5-1-判断字段是否存在" class="headerlink" title="1.2.2.5.1 判断字段是否存在"></a>1.2.2.5.1 判断字段是否存在</h5><p><strong>语法：HEXISTS key field</strong></p>
<p>  127.0.0.1:6379&gt; hexists user age     查看user中是否有age字段  (integer) 1  127.0.0.1:6379&gt; hexists user name   查看user中是否有name字段  (integer) 0  </p>
<h5 id="12252-只获取字段名或字段值"><a href="#1-2-2-5-2-只获取字段名或字段值" class="headerlink" title="1.2.2.5.2 只获取字段名或字段值"></a>1.2.2.5.2 只获取字段名或字段值</h5><p><strong>语法：</strong></p>
<p><strong>HKEYS key</strong></p>
<p><strong>HVALS key</strong></p>
<p>  127.0.0.1:6379&gt; hmset user age 20 name lisi   OK  127.0.0.1:6379&gt; hkeys user  1) “age”  2) “name”  127.0.0.1:6379&gt; hvals user  1) “20”  2) “lisi”  </p>
<h5 id="12253-获取字段数量"><a href="#1-2-2-5-3-获取字段数量" class="headerlink" title="1.2.2.5.3 获取字段数量"></a>1.2.2.5.3 获取字段数量</h5><p><strong>语法：HLEN key</strong></p>
<p>  127.0.0.1:6379&gt; hlen user  (integer) 2  </p>
<h5 id="12254-获取所有字段"><a href="#1-2-2-5-4-获取所有字段" class="headerlink" title="1.2.2.5.4 获取所有字段"></a>1.2.2.5.4 获取所有字段</h5><p><strong>作用：获得hash的所有信息，包括key和value</strong></p>
<p><strong>语法：hgetall key</strong></p>
<h3 id="123-应用之存储商品信息"><a href="#1-2-3-应用之存储商品信息" class="headerlink" title="1.2.3 应用之存储商品信息"></a>1.2.3 应用之存储商品信息</h3><p><strong>注意事项：存储那些对象数据，特别是对象属性经常发生增删改操作的数据。</strong></p>
<p>Ø 商品信息字段</p>
<p>【商品id、商品名称、商品描述、商品库存、商品好评】</p>
<p>Ø 定义商品信息的key</p>
<p>商品ID为1001的信息在 Redis中的key为：[items:1001]</p>
<p>Ø 存储商品信息</p>
<p>  192.168.101.3:7003&gt;  HMSET items:1001 id 3 name apple price 999.9  OK  </p>
<p>Ø 获取商品信息</p>
<p>  192.168.101.3:7003&gt;  HGET <strong>items:1001</strong>  id  “3”  192.168.101.3:7003&gt;  HGETALL items:1001  1)  “id”  2)  “3”  3)  “name”  4)  “apple”  5)  “price”  6)  “999.9”  </p>
<h2 id="13-list类型"><a href="#1-3-List类型" class="headerlink" title="1.3  List类型"></a>1.3  List类型</h2><h3 id="131-arraylist与linkedlist的区别"><a href="#1-3-1-ArrayList与LinkedList的区别" class="headerlink" title="1.3.1 ArrayList与LinkedList的区别"></a>1.3.1 ArrayList与LinkedList的区别</h3><p>​    ArrayList使用<strong>数组方式</strong>存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。 </p>
<p>​    LinkedList使用<strong>双向链表方式</strong>存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快。然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快。</p>
<h3 id="132-list介绍"><a href="#1-3-2-list介绍" class="headerlink" title="1.3.2 list介绍"></a>1.3.2 list介绍</h3><p>Redis的列表类型（list）可以存储一个有序的字符串列表，常用的操作是<strong>向列表两端添加元素，或者获得列表的某一个片段</strong>。</p>
<p>​    列表类型内部是使用<strong>双向链表（double linked list）实现</strong>的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越 快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。</p>
<h3 id="133-命令"><a href="#1-3-3-命令" class="headerlink" title="1.3.3 命令"></a>1.3.3 命令</h3><h4 id="1331-向列表两端增加元素"><a href="#1-3-3-1-向列表两端增加元素" class="headerlink" title="1.3.3.1    向列表两端增加元素"></a>1.3.3.1    向列表两端增加元素</h4><p>Ø 向列表左边增加元素</p>
<p><strong>语法：LPUSH key value [value …]</strong></p>
<p>  127.0.0.1:6379&gt; lpush list:1 1 2 3  (integer) 3  </p>
<p>Ø 向列表右边增加元素 </p>
<p><strong>语法：RPUSH key value [value …]</strong></p>
<p>  127.0.0.1:6379&gt; rpush list:1 4 5 6  (integer) 3  </p>
<h4 id="1332-查看列表"><a href="#1-3-3-2-查看列表" class="headerlink" title="1.3.3.2    查看列表"></a>1.3.3.2    查看列表</h4><p><strong>语法：LRANGE key start stop</strong></p>
<p>LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：<strong>“-1”代表最后边的一个元素。</strong></p>
<p>  127.0.0.1:6379&gt; lrange  list:1 0 2  1) “2”  2) “1”  3) “4”  </p>
<h4 id="1333-从列表两端弹出元素"><a href="#1-3-3-3-从列表两端弹出元素" class="headerlink" title="1.3.3.3    从列表两端弹出元素"></a>1.3.3.3    从列表两端弹出元素</h4><p>LPOP命令从列表左边弹出一个元素，会分两步完成：</p>
<p>l 第一步是将列表左边的元素从列表中移除</p>
<p>l 第二步是返回被移除的元素值。</p>
<p><strong>语法：</strong></p>
<p><strong>LPOP key</strong></p>
<p><strong>RPOP key</strong></p>
<p>  127.0.0.1:6379&gt;  lpop list:1  “3“  127.0.0.1:6379&gt;  rpop list:1  “6“  </p>
<h4 id="1334-获取列表中元素的个数"><a href="#1-3-3-4-获取列表中元素的个数" class="headerlink" title="1.3.3.4    获取列表中元素的个数"></a>1.3.3.4    获取列表中元素的个数</h4><p><strong>语法：LLEN key</strong></p>
<p>  127.0.0.1:6379&gt; llen list:1  (integer) 2  </p>
<h4 id="1335-其它命令自学"><a href="#1-3-3-5-其它命令-自学" class="headerlink" title="1.3.3.5    其它命令(自学)"></a>1.3.3.5    其它命令(自学)</h4><h5 id="13351-删除列表中指定个数的值"><a href="#1-3-3-5-1-删除列表中指定个数的值" class="headerlink" title="1.3.3.5.1 删除列表中指定个数的值"></a>1.3.3.5.1 删除列表中指定个数的值</h5><p>LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同：</p>
<p>l 当count&gt;0时， LREM会从列表左边开始删除。 </p>
<p>l 当count&lt;0时， LREM会从列表后边开始删除。 </p>
<p>l 当count=0时， LREM删除所有值为value的元素。 </p>
<p><strong>语法：LREM key count value</strong></p>
<h5 id="13352-获得设置指定索引的元素值"><a href="#1-3-3-5-2-获得-设置指定索引的元素值" class="headerlink" title="1.3.3.5.2 获得/设置指定索引的元素值"></a>1.3.3.5.2 获得/设置指定索引的元素值</h5><p>Ø 获得指定索引的元素值</p>
<p><strong>语法：LINDEX key index</strong></p>
<p>  127.0.0.1:6379&gt;  lindex l:list 2  “1”  </p>
<p>Ø 设置指定索引的元素值</p>
<p><strong>语法：LSET key index value</strong></p>
<p>  127.0.0.1:6379&gt;  lset l:list 2 2  OK  127.0.0.1:6379&gt;  lrange l:list 0 -1  1)  “6”  2)  “5”  3)  “2”  4)  “2”  </p>
<h5 id="13353-只保留列表指定片段"><a href="#1-3-3-5-3-只保留列表指定片段" class="headerlink" title="1.3.3.5.3 只保留列表指定片段"></a>1.3.3.5.3 只保留列表指定片段</h5><p>指定范围和LRANGE一致 </p>
<p><strong>语法：LTRIM key start stop</strong></p>
<p>  127.0.0.1:6379&gt; lrange l:list 0 -1  1) “6”  2) “5”  3) “0”  4) “2”  127.0.0.1:6379&gt; ltrim l:list 0 2  OK  127.0.0.1:6379&gt; lrange l:list 0 -1  1) “6”  2) “5”  3) “0”  </p>
<h5 id="13354-向列表中插入元素"><a href="#1-3-3-5-4-向列表中插入元素" class="headerlink" title="1.3.3.5.4 向列表中插入元素"></a>1.3.3.5.4 向列表中插入元素</h5><p>该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 </p>
<p><strong>语法：LINSERT key BEFORE|AFTER pivot value</strong></p>
<p>  127.0.0.1:6379&gt;  lrange list 0 -1  1)  “3”  2)  “2”  3)  “1”  127.0.0.1:6379&gt;  linsert list after 3 4  (integer)  4  127.0.0.1:6379&gt;  lrange list 0 -1  1)  “3”  2)  “4”  3)  “2”  4)  “1”  </p>
<h5 id="13355-将元素从一个列表转移到另一个列表中"><a href="#1-3-3-5-5-将元素从一个列表转移到另一个列表中" class="headerlink" title="1.3.3.5.5 将元素从一个列表转移到另一个列表中"></a>1.3.3.5.5 将元素从一个列表转移到另一个列表中</h5><p><strong>语法：RPOPLPUSH source destination</strong></p>
<p>  127.0.0.1:6379&gt; rpoplpush list newlist   “1”  127.0.0.1:6379&gt; lrange newlist 0 -1  1) “1”  127.0.0.1:6379&gt; lrange  list 0 -1  1) “3”  2) “4”  3) “2”  </p>
<h3 id="134-应用之商品评论列表"><a href="#1-3-4-应用之商品评论列表" class="headerlink" title="1.3.4 应用之商品评论列表"></a>1.3.4 应用之商品评论列表</h3><p>l 需求1：用户针对某一商品发布评论，一个商品会被不同的用户进行评论，存储商品评论时，要按时间顺序排序。</p>
<p>l 需求2：用户在前端页面查询该商品的评论，需要安装时间顺序降序排序。</p>
<p>思路：</p>
<p>​    使用list存储商品评论信息，KEY是该商品的ID，VALUE是商品评论信息列表</p>
<p>商品编号为1001的商品评论key【items: comment:1001】</p>
<p>  192.168.101.3:7001&gt;  LPUSH <strong>items:comment:1001</strong>  ‘{“id”:1,”name”:”商品不错，很好！！”,”date”:1430295077289}’  </p>
<h2 id="14-set类型"><a href="#1-4-Set类型" class="headerlink" title="1.4  Set类型"></a>1.4  Set类型</h2><h3 id="141-set介绍"><a href="#1-4-1-set介绍" class="headerlink" title="1.4.1 set介绍"></a>1.4.1 set介绍</h3><p>set类型即<strong>集合类型</strong>，其中的数据是<strong>不重复且没有顺序</strong>。</p>
<p>集合类型和列表类型的对比：</p>
<p>​    集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。</p>
<p>Redis还提供了多个集合之间的交集、并集、差集的运算。</p>
<h3 id="142-命令"><a href="#1-4-2-命令" class="headerlink" title="1.4.2 命令"></a>1.4.2 命令</h3><h4 id="1421-增加删除元素"><a href="#1-4-2-1-增加-删除元素" class="headerlink" title="1.4.2.1    增加/删除元素"></a>1.4.2.1    增加/删除元素</h4><p><strong>语法：SADD key member [member …]</strong></p>
<p>  127.0.0.1:6379&gt; sadd set a b c  (integer) 3  127.0.0.1:6379&gt; sadd set a  (integer) 0  </p>
<p><strong>语法：SREM key member [member …]</strong></p>
<p>  127.0.0.1:6379&gt; srem set c d  (integer) 1  </p>
<h4 id="1422-获得集合中的所有元素"><a href="#1-4-2-2-获得集合中的所有元素" class="headerlink" title="1.4.2.2    获得集合中的所有元素"></a>1.4.2.2    获得集合中的所有元素</h4><p><strong>语法：SMEMBERS key</strong></p>
<p>  127.0.0.1:6379&gt;  smembers set  1)  “b”  2)  “a”  </p>
<h4 id="1423-判断元素是否在集合中"><a href="#1-4-2-3-判断元素是否在集合中" class="headerlink" title="1.4.2.3    判断元素是否在集合中"></a>1.4.2.3    判断元素是否在集合中</h4><p><strong>语法：SISMEMBER key member</strong></p>
<p>  127.0.0.1:6379&gt;  sismember set a  (integer)  1  127.0.0.1:6379&gt;  sismember set h  (integer)  0  </p>
<h3 id="143-集合运算命令"><a href="#1-4-3-集合运算命令" class="headerlink" title="1.4.3 集合运算命令"></a>1.4.3 集合运算命令</h3><h4 id="1431-集合的差集运算-a-b"><a href="#1-4-3-1-集合的差集运算-A-B" class="headerlink" title="1.4.3.1    集合的差集运算 A-B"></a>1.4.3.1    集合的差集运算 A-B</h4><p>属于A并且不属于B的元素构成的集合。 </p>
<p><strong>语法：SDIFF key [key …]</strong></p>
<p>  127.0.0.1:6379&gt; sadd setA 1 2 3  (integer) 3  127.0.0.1:6379&gt; sadd setB 2 3 4  (integer) 3  127.0.0.1:6379&gt; sdiff setA setB   1) “1”  127.0.0.1:6379&gt; sdiff setB setA   1) “4”  </p>
<h4 id="1432-集合的交集运算-a-b"><a href="#1-4-3-2-集合的交集运算-A-∩-B" class="headerlink" title="1.4.3.2    集合的交集运算 A ∩ B"></a>1.4.3.2    集合的交集运算 A ∩ B</h4><p>属于A且属于B的元素构成的集合。 </p>
<p><strong>语法：SINTER key [key …]</strong></p>
<p>  127.0.0.1:6379&gt;  sinter setA setB   1)  “2”  2)  “3”  </p>
<h4 id="1433-集合的并集运算-a-b"><a href="#1-4-3-3-集合的并集运算-A-∪-B" class="headerlink" title="1.4.3.3    集合的并集运算 A ∪ B"></a>1.4.3.3    集合的并集运算 A ∪ B</h4><p>属于A或者属于B的元素构成的集合</p>
<p><strong>语法：SUNION key [key …]</strong></p>
<p>  127.0.0.1:6379&gt; sunion setA setB  1) “1”  2) “2”  3) “3”  4) “4”  </p>
<h3 id="144-其它命令自学"><a href="#1-4-4-其它命令-自学" class="headerlink" title="1.4.4 其它命令(自学)"></a>1.4.4 其它命令(自学)</h3><h4 id="1441-获得集合中元素的个数"><a href="#1-4-4-1-获得集合中元素的个数" class="headerlink" title="1.4.4.1    获得集合中元素的个数"></a>1.4.4.1    获得集合中元素的个数</h4><p><strong>语法：SCARD key</strong></p>
<p>  127.0.0.1:6379&gt;  smembers setA   1)  “1”  2)  “2”  3)  “3”  127.0.0.1:6379&gt;  scard setA   (integer)  3  </p>
<h4 id="1442-从集合中弹出一个元素"><a href="#1-4-4-2-从集合中弹出一个元素" class="headerlink" title="1.4.4.2    从集合中弹出一个元素"></a>1.4.4.2    从集合中弹出一个元素</h4><p>注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 </p>
<p><strong>语法：SPOP key</strong></p>
<p>  127.0.0.1:6379&gt; spop setA   “1“  </p>
<h2 id="15-sortedset类型zset"><a href="#1-5-SortedSet类型zset" class="headerlink" title="1.5  SortedSet类型zset"></a>1.5  SortedSet类型zset</h2><h3 id="151-sorted-set介绍"><a href="#1-5-1-sorted-set介绍" class="headerlink" title="1.5.1 sorted set介绍"></a>1.5.1 sorted set介绍</h3><p>​    在集合类型的基础上，有序集合类型为集合中的<strong>每个元素都关联一个分数</strong>，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 </p>
<p>在某些方面有序集合和列表类型有些相似。</p>
<p>1、二者都是有序的。 </p>
<p>2、二者都可以获得某一范围的元素。 </p>
<p>但是，二者有着很大区别：</p>
<p>1、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。</p>
<p>2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 </p>
<p>3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现）</p>
<p>4、有序集合要比列表类型更耗内存。 </p>
<h3 id="152-命令"><a href="#1-5-2-命令" class="headerlink" title="1.5.2 命令"></a>1.5.2 命令</h3><h4 id="1521-增加元素"><a href="#1-5-2-1-增加元素" class="headerlink" title="1.5.2.1    增加元素"></a>1.5.2.1    增加元素</h4><p>​    向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 </p>
<p><strong>语法：ZADD key score member [score member …]</strong></p>
<p>  127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89  lisi 94 wangwu   (integer) 3  127.0.0.1:6379&gt; zadd scoreboard 97 lisi   (integer) 0  </p>
<h4 id="1522-获得排名在某个范围的元素列表"><a href="#1-5-2-2-获得排名在某个范围的元素列表" class="headerlink" title="1.5.2.2    获得排名在某个范围的元素列表"></a>1.5.2.2    获得排名在某个范围的元素列表</h4><p>获得排名在某个范围的元素列表</p>
<p>Ø 按照元素分数<strong>从小到大的</strong>顺序返回索引从start到stop之间的所有元素（包含两端的元素）</p>
<p><strong>语法：ZRANGE key start stop [WITHSCORES]</strong>           </p>
<p>  127.0.0.1:6379&gt;  zrange scoreboard 0 2  1)  “zhangsan”  2)  “wangwu”  3)  “lisi“  </p>
<p>Ø 按照元素分数<strong>从大到小</strong>的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</p>
<p><strong>语法：ZREVRANGE key start stop [WITHSCORES]</strong>       </p>
<p>  127.0.0.1:6379&gt;  zrevrange scoreboard 0 2  1)  “ lisi “  2)  “wangwu”  3)  “ zhangsan “  </p>
<p>如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 </p>
<p>  127.0.0.1:6379&gt;  zrange scoreboard 0 1 WITHSCORES  1)  “zhangsan”  2)  “80”  3)  “wangwu”  4)  “94”  </p>
<h4 id="1523-获取元素的分数"><a href="#1-5-2-3-获取元素的分数" class="headerlink" title="1.5.2.3    获取元素的分数"></a>1.5.2.3    获取元素的分数</h4><p><strong>语法：ZSCORE key member</strong></p>
<p>  127.0.0.1:6379&gt;  zscore scoreboard lisi   “97”  </p>
<h4 id="1524-删除元素"><a href="#1-5-2-4-删除元素" class="headerlink" title="1.5.2.4    删除元素"></a>1.5.2.4    删除元素</h4><p>移除有序集key中的一个或多个成员，不存在的成员将被忽略。</p>
<p>当key存在但不是有序集类型时，返回一个错误。</p>
<p><strong>语法：ZREM key member [member …]</strong></p>
<p>  127.0.0.1:6379&gt;  zrem scoreboard lisi  (integer)  1  </p>
<h4 id="1525-其它命令自学"><a href="#1-5-2-5-其它命令-自学" class="headerlink" title="1.5.2.5    其它命令(自学)"></a>1.5.2.5    其它命令(自学)</h4><h5 id="15251-获得指定分数范围的元素"><a href="#1-5-2-5-1-获得指定分数范围的元素" class="headerlink" title="1.5.2.5.1 获得指定分数范围的元素"></a>1.5.2.5.1 获得指定分数范围的元素</h5><p><strong>语法：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</strong></p>
<p>  127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97  WITHSCORES  1) “wangwu”  2) “94”  3) “lisi”  4) “97”  127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70  100 limit 1 2  1) “wangwu”  2) “lisi”  </p>
<h5 id="15252-增加某个元素的分数"><a href="#1-5-2-5-2-增加某个元素的分数" class="headerlink" title="1.5.2.5.2 增加某个元素的分数"></a>1.5.2.5.2 增加某个元素的分数</h5><p>返回值是更改后的分数</p>
<p><strong>语法：ZINCRBY key increment member</strong></p>
<p>  127.0.0.1:6379&gt;  ZINCRBY scoreboard 4 lisi   “101“  </p>
<h5 id="15253-获得集合中元素的数量"><a href="#1-5-2-5-3-获得集合中元素的数量" class="headerlink" title="1.5.2.5.3 获得集合中元素的数量"></a>1.5.2.5.3 获得集合中元素的数量</h5><p><strong>语法：ZCARD key</strong></p>
<p>  127.0.0.1:6379&gt;  ZCARD scoreboard  (integer)  3  </p>
<h5 id="15254-获得指定分数范围内的元素个数"><a href="#1-5-2-5-4-获得指定分数范围内的元素个数" class="headerlink" title="1.5.2.5.4 获得指定分数范围内的元素个数"></a>1.5.2.5.4 获得指定分数范围内的元素个数</h5><p><strong>语法：ZCOUNT key min max</strong></p>
<p>  127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90  (integer) 1  </p>
<h5 id="15255-按照排名范围删除元素"><a href="#1-5-2-5-5-按照排名范围删除元素" class="headerlink" title="1.5.2.5.5 按照排名范围删除元素"></a>1.5.2.5.5 按照排名范围删除元素</h5><p><strong>语法：ZREMRANGEBYRANK key start stop</strong></p>
<p>  127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1  (integer) 2   127.0.0.1:6379&gt; ZRANGE scoreboard 0 -1  1) “lisi”  </p>
<h5 id="15256-按照分数范围删除元素"><a href="#1-5-2-5-6-按照分数范围删除元素" class="headerlink" title="1.5.2.5.6 按照分数范围删除元素"></a>1.5.2.5.6 按照分数范围删除元素</h5><p><strong>语法：ZREMRANGEBYSCORE key min max</strong></p>
<p>  127.0.0.1:6379&gt;  zadd scoreboard 84 zhangsan      (integer)  1  127.0.0.1:6379&gt;  ZREMRANGEBYSCORE scoreboard 80 100  (integer)  1  </p>
<h5 id="15257-获取元素的排名"><a href="#1-5-2-5-7-获取元素的排名" class="headerlink" title="1.5.2.5.7 获取元素的排名"></a>1.5.2.5.7 获取元素的排名</h5><p>Ø 从小到大</p>
<p><strong>语法：ZRANK key member</strong></p>
<p>  127.0.0.1:6379&gt;  ZRANK scoreboard lisi   (integer)  0  </p>
<p>Ø 从大到小</p>
<p><strong>语法：ZREVRANK key member</strong></p>
<p>  127.0.0.1:6379&gt;  ZREVRANK scoreboard zhangsan   (integer)  1  </p>
<h3 id="153-应用之商品销售排行榜"><a href="#1-5-3-应用之商品销售排行榜" class="headerlink" title="1.5.3 应用之商品销售排行榜"></a>1.5.3 应用之商品销售排行榜</h3><p>l 需求：根据商品销售量对商品进行排行显示</p>
<p>l 思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。</p>
<p>写入商品销售量：</p>
<p>Ø 商品编号1001的销量是9，商品编号1002的销量是10</p>
<p>  192.168.101.3:7007&gt;  ZADD items:sellsort 9 1001 10 1002  </p>
<p>Ø 商品编号1001的销量加1</p>
<p>  192.168.101.3:7001&gt;  ZINCRBY items:sellsort 1 1001  </p>
<p>Ø 商品销量前10名：</p>
<p>  192.168.101.3:7001&gt;  ZRANGE items:sellsort 0 9 withscores  </p>
<h2 id="16-通用命令"><a href="#1-6-通用命令" class="headerlink" title="1.6  通用命令"></a>1.6  通用命令</h2><h3 id="161-keys"><a href="#1-6-1-keys" class="headerlink" title="1.6.1 keys"></a>1.6.1 keys</h3><p>返回满足给定pattern 的所有key</p>
<p>语法：<strong>keys pattern</strong></p>
<p>  redis  127.0.0.1:6379&gt; keys mylist*  1)  “mylist”  2)  “mylist5”  3)  “mylist6”  4)  “mylist7”  5)  “mylist8”  </p>
<h3 id="162-del"><a href="#1-6-2-del" class="headerlink" title="1.6.2 del"></a>1.6.2 del</h3><p><strong>语法：**</strong>DEL key**</p>
<p>  127.0.0.1:6379&gt; del test  (integer)  1  </p>
<h3 id="163-exists"><a href="#1-6-3-exists" class="headerlink" title="1.6.3 exists"></a>1.6.3 exists</h3><p><strong>作用：确认一个key 是否存在</strong></p>
<p><strong>语法：exists key</strong></p>
<p>示例：从结果来看，数据库中不存在HongWan 这个key，但是age 这个key 是存在的</p>
<p>  redis  127.0.0.1:6379&gt; exists HongWan  (integer)  0  redis  127.0.0.1:6379&gt; exists age  (integer)  1  redis  127.0.0.1:6379&gt;  </p>
<h3 id="164-expire-常用"><a href="#1-6-4-expire-常用" class="headerlink" title="1.6.4 expire 常用"></a>1.6.4 expire 常用</h3><p>Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。</p>
<p>  <strong>EXPIRE key seconds</strong>         设置key的生存时间（单位：秒）key在多少秒后会自动删除  <strong>TTL key</strong>                  查看key生于的生存时间  <strong>PERSIST key</strong>              清除生存时间    PEXPIRE key milliseconds   生存时间设置单位为：毫秒  </p>
<p>例子：</p>
<p>  192.168.101.3:7002&gt; set test 1       设置test的值为1  OK  192.168.101.3:7002&gt; get test        获取test的值  “1”  192.168.101.3:7002&gt; EXPIRE test 5    设置test的生存时间为5秒  (integer) 1  192.168.101.3:7002&gt; TTL test        查看test的生于生成时间还有1秒删除  (integer) 1  192.168.101.3:7002&gt; TTL test  (integer) -2  192.168.101.3:7002&gt; get test        获取test的值，已经删除  (nil)     </p>
<h3 id="165-rename"><a href="#1-6-5-rename" class="headerlink" title="1.6.5 rename"></a>1.6.5 rename</h3><p><strong>作用：重命名key</strong></p>
<p><strong>语法：rename oldkey newkey</strong></p>
<p>示例：age 成功的被我们改名为age_new 了</p>
<p>  redis  127.0.0.1:6379[1]&gt; keys <em>  1)  “age”  redis  127.0.0.1:6379[1]&gt; rename age age_new  OK  redis  127.0.0.1:6379[1]&gt; keys </em>  1)  “age_new”  redis  127.0.0.1:6379[1]&gt;  </p>
<h3 id="166-type"><a href="#1-6-6-type" class="headerlink" title="1.6.6 type"></a>1.6.6 type</h3><p><strong>作用：显示指定key的数据类型</strong></p>
<p><strong>语法：type key</strong></p>
<p>示例：这个方法可以非常简单的判断出值的类型</p>
<p>  redis  127.0.0.1:6379&gt; type addr  string  redis  127.0.0.1:6379&gt; type myzset2  zset  redis  127.0.0.1:6379&gt; type mylist  list  redis  127.0.0.1:6379&gt;  </p>
<h1 id="2-redis事务"><a href="#2-Redis事务" class="headerlink" title="2  Redis事务"></a>2  Redis事务</h1><h2 id="21-redis事务介绍"><a href="#2-1-Redis事务介绍" class="headerlink" title="2.1  Redis事务介绍"></a>2.1  Redis事务介绍</h2><p>l Redis的事务是通过<strong>MULTI，EXEC，DISCARD和WATCH</strong>这四个命令来完成的。</p>
<p>l Redis的单个命令都是<strong>原子性</strong>的，所以这里确保事务性的对象是<strong>命令集合</strong>。</p>
<p>l Redis将命令集合序列化并确保处于同一事务的<strong>命令集合连续且不被打断</strong>的执行</p>
<p>l Redis不支持回滚操作</p>
<h2 id="22-相关命令"><a href="#2-2-相关命令" class="headerlink" title="2.2  相关命令"></a>2.2  相关命令</h2><p>l <strong>MULTI</strong></p>
<p>​    <strong>用于标记事务块的开始</strong>。</p>
<p>​    Redis会将后续的命令逐个放入队列中，然后使用EXEC命令原子化地执行这个命令序列。</p>
<p>​    <strong>语法：multi</strong></p>
<p>l <strong>EXEC</strong></p>
<p>​    <strong>在一个事务中执行所有先前放入队列的命令</strong>，然后恢复正常的连接状态</p>
<p>​    <strong>语法：exec</strong></p>
<p>l <strong>DISCARD</strong></p>
<p>​    <strong>清除所有先前在一个事务中放入队列的命令</strong>，然后恢复正常的连接状态。</p>
<p>​    <strong>语法：discard</strong></p>
<p>l <strong>WATCH</strong></p>
<p>​    当某个<strong>事务需要按条件执行</strong>时，就要使用这个命令将给定的<strong>键设置为受监控</strong>的状态。</p>
<p>​    <strong>语法：watch key [key…]</strong></p>
<p>​    <strong>注意事项：</strong>使用该命令可以实现redis的<strong>乐观锁</strong>。</p>
<p>l <strong>UNWATCH</strong></p>
<p>​    清除所有先前为一个事务监控的键。</p>
<p>​    <strong>语法：unwatch</strong></p>
<h2 id="23-事务失败处理"><a href="#2-3-事务失败处理" class="headerlink" title="2.3  事务失败处理"></a>2.3  事务失败处理</h2><p>l Redis语法错误（可以理解为编译期错误）</p>
<p>l Redis类型错误（可以理解为运行期错误）</p>
<p>l <strong>Redis**</strong>不支持事务回滚**</p>
<p><strong>为什么redis不支持事务回滚？</strong></p>
<p>1、 大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，在开发阶段都是可以预见的</p>
<p>2、 redis为了<strong>性能方面</strong>就忽略了事务回滚</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis核心技术</title>
    <url>/post/14b69b66/</url>
    <content><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/79/e7/79da7093ed998a99d9abe91e610b74e7.jpg?wh=2001*1126" alt="img" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>Study Less Study Smart —— 高效学习</title>
    <url>/post/9bea2a94/</url>
    <content><![CDATA[<p>学习内容：<a href="https://www.youtube.com/watch?v=IlU-zDU6aQ0">Marty Lobdell - Study Less Study Smart - YouTube</a></p>
<ul>
<li>适当休息</li>
<li>寻求可以学习空间</li>
<li>理解优于记忆</li>
<li>组团学习优于单打独斗</li>
<li>别盲目划重点</li>
<li>多做笔记，并且时常回顾</li>
<li>尝试教会别人 Teaching is the best way of learning. </li>
<li>保证睡眠，有助于长期记忆的形成</li>
<li>SQ3R(survey, question, recite, read, review)方法</li>
<li>Mnemonics方法</li>
</ul>
<ol>
<li>Don’t study for too long if you are not enjoying it. Take short breaks after 20-30 minutes. </li>
<li>Don’t study in the living room, bedroom, etc. Study in a separate place dedicated to studying. </li>
<li>Don’t try to memorize without understanding. Try to understand the concept first. </li>
<li>Don’t always study alone. Studying in groups helps a lot. </li>
<li>Don’t highlight text blindly. Highlighting doesn’t help that much. It only indicates Recognization not Recollection of the topic. </li>
<li>Always take notes. Reviewing the notes after a short time helps a lot. </li>
<li>Always try to teach others what you have learned. Teaching is the best way of learning. </li>
<li>Sleep is so much important for pushing something into your long-term memory. Get at least 7-8 hours of sound sleep. </li>
<li>Use the SQ3R(survey, question, recite, read, review) method while studying. </li>
<li>Use Mnemonics. It’s the best way to memorize facts.</li>
</ol>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>psychology</tag>
      </tags>
  </entry>
  <entry>
    <title>cs224n笔记</title>
    <url>/post/25b610a6/</url>
    <content><![CDATA[<h2 id="二-词的向量表示"><a href="#二、词的向量表示" class="headerlink" title="二、词的向量表示"></a>二、词的向量表示</h2><h3 id="计算机如何处理词语的意思"><a href="#计算机如何处理词语的意思" class="headerlink" title="计算机如何处理词语的意思"></a>计算机如何处理词语的意思</h3><h4 id="distributional-similarity-based-representations"><a href="#Distributional-similarity-based-representations" class="headerlink" title="Distributional similarity based representations"></a>Distributional similarity based representations</h4><p>语言学家J. R. Firth提出，通过一个单词的上下文可以得到它的意思。J. R. Firth甚至建议，如果你能把单词放到正确的上下文中去，才说明你掌握了它的意义。</p>
<p>这是现代统计自然语言处理最成功的思想之一</p>
<h4 id="通过向量定义词语的含义"><a href="#通过向量定义词语的含义" class="headerlink" title="通过向量定义词语的含义"></a>通过向量定义词语的含义</h4><p>通过调整一个单词及其上下文单词的向量，使得根据两个向量可以推测两个词语的相似度；或根据向量可以预测词语的上下文。</p>
<p><strong>递归</strong>，根据向量来调整向量，与词典中意项的定义相似。</p>
<h4 id="学习神经网络word-embedding的基本思路"><a href="#学习神经网络word-embedding的基本思路" class="headerlink" title="学习神经网络word embedding的基本思路"></a>学习神经网络word embedding的基本思路</h4><p>定义一个以预测某个单词的上下文的模型：</p>
<script type="math/tex; mode=display">
p(context |w_t) = x</script><p>损失函数定义如下：</p>
<script type="math/tex; mode=display">
J=1−p(w_{−t}|w_t)</script><p>这里的$w_{−t}$表示$w_t$的上下文（负号通常表示除了某某之外），如果完美预测，损失函数为零。</p>
<p>然后在一个大型语料库中的不同位置得到训练实例，调整词向量，最小化损失函数。</p>
<h4 id="直接学习低维词向量"><a href="#直接学习低维词向量" class="headerlink" title="直接学习低维词向量"></a>直接学习低维词向量</h4><p>论文如下</p>
<p>• Learning representations by back-propagating errors (Rumelhart et al., 1986)</p>
<p>• <strong>A neural probabilistic language model (Bengio et al., 2003)</strong></p>
<p>• NLP (almost) from Scratch (Collobert &amp; Weston, 2008)</p>
<p>• A recent, even simpler and faster model: word2vec (Mikolov et al. 2013) </p>
<h3 id="word2vec的主要思路"><a href="#word2vec的主要思路" class="headerlink" title="word2vec的主要思路"></a>word2vec的主要思路</h3><p>word2vec——神经概率语言模型的输入，是为了通过神经网络学习<strong>某个分类模型（“CBOW”和“Skip-gram”）</strong>而产生的中间结果，而这个具体学习过程会用到<strong>两个降低复杂度的近似方法（Hierarchical Softmax或Negative Sampling）</strong></p>
<p>两个语言模型</p>
<p><img src="https://ww3.sinaimg.cn/large/6cbb8645gw1f5to6e5d9lj216c0qkwhk.jpg" alt="屏幕快照 2016-07-14 下午7.27.35.png"></p>
<h4 id="hierarchical-softmax"><a href="#Hierarchical-softmax" class="headerlink" title="Hierarchical softmax"></a>Hierarchical softmax</h4><h5 id="continuous-bag-of-words-cbow"><a href="#Continuous-Bag-of-Words-CBOW" class="headerlink" title="Continuous Bag of Words (CBOW)"></a>Continuous Bag of Words (CBOW)</h5><p>预测目标单词，根据上下文的词语预测当前词语的出现概率的模型。已知上下文，估算当前词语的语言模型。</p>
<p>其学习目标是<strong>最大化对数似然函数</strong></p>
<p><strong>输入层 INPUT</strong>：上下文的词语的词向量（不训练词向量；而是训练CBOW模型，词向量是CBOW模型的一个参数，训练开始时，词向量是一个输入的随机值，随着训练的进行不断被更新）</p>
<p><strong>投影层 PROJECTION</strong>：求和，简单的向量加法</p>
<p><strong>输出层 OUTPUT</strong>：输出最可能的w——这个过程算是<strong>多分类</strong>问题，给定特征，从|C|个分类中挑一个？</p>
<p>对于神经网络模型多分类，最朴素的做法是<strong>softmax回归</strong></p>
<p><img src="https://ww2.sinaimg.cn/large/6cbb8645gw1exxdsuugv1j20cl033jrj.jpg" alt="神经网络依存句法分析29.png"></p>
<p>另有方法 <strong>SVM的多分类</strong>的二叉树结构应用到word2vec 即是<strong>Hierarchical Softmax算法</strong></p>
<p>树状结构（用于CBOW的输出层）</p>
<p><img src="https://ww1.sinaimg.cn/large/6cbb8645gw1f5wmvf9tbrg20bf08mq30.gif" alt="svm_多分类.gif"></p>
<p><img src="https://ww3.sinaimg.cn/large/6cbb8645gw1f5wmy4jdnwj214w12a42v.jpg" alt="屏幕快照 2016-07-17 上午9.13.40.png"></p>
<p>复杂的数学计算……</p>
<p><img src="https://ww1.sinaimg.cn/large/6cbb8645gw1f5wqgz0elqj20pm0qaq5a.jpg" alt="屏幕快照 2016-07-17 上午11.15.50.png"></p>
<h5 id="skip-grams-sg"><a href="#Skip-grams-SG" class="headerlink" title="Skip-grams (SG)"></a>Skip-grams (SG)</h5><p>预测上下文</p>
<p>Skip-gram只是逆转了CBOW的因果关系而已，即已知当前词语，预测上下文。</p>
<p><img src="https://ww1.sinaimg.cn/large/6cbb8645gw1f5wqzg68u0j214a120wij.jpg" alt="屏幕快照 2016-07-17 上午11.33.31.png"></p>
<ul>
<li>输入层不再是多个词向量，而是一个词向量</li>
<li>投影层其实什么事情都没干，直接将输入层的词向量传递给输出层</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>无论是CBOW还是Skip-gram模型，其实都是分类模型。对于机器学习中的分类任务，在训练的时候不但要给正例，还要给负例。对于Hierarchical Softmax，负例是二叉树的其他路径。对于Negative Sampling，负例是随机挑选出来的。</p>
<h4 id="negative-sampling"><a href="#Negative-sampling" class="headerlink" title="Negative sampling"></a>Negative sampling</h4><h5 id="cbow"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h5><p><img src="https://ww4.sinaimg.cn/large/6cbb8645gw1f5wv2jzxnfj20oe0ncdhp.jpg" alt="屏幕快照 2016-07-17 下午1.55.05.png"></p>
<h5 id="skip-gram"><a href="#Skip-gram" class="headerlink" title="Skip-gram"></a>Skip-gram</h5><p><img src="https://ww4.sinaimg.cn/large/6cbb8645gw1f5wwegdnryj20oi0q00v3.jpg" alt="屏幕快照 2016-07-17 下午2.40.41.png"></p>
<h2 id="三-高级词向量表示"><a href="#三、高级词向量表示" class="headerlink" title="三、高级词向量表示"></a>三、高级词向量表示</h2><h4 id="总结"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>遍历整个语料库的每个词</li>
<li>预测每个词的上下文</li>
<li><img src="https://wx1.sinaimg.cn/large/006Fmjmcly1fgdtp2e4e2j30uy0bmn6v.jpg" alt="hankcs.com 2017-06-08 下午3.25.31.png"></li>
<li>每个窗口中计算梯度做SGD</li>
</ul>
<p>每个窗口最多2m+1个单词，所以<script type="math/tex">∇_θJ_t(θ)</script>会非常稀疏</p>
<p><img src="https://wx2.sinaimg.cn/large/006Fmjmcly1fgdtx6wu43j30ta0qegnj.jpg" alt="hankcs.com 2017-06-08 下午3.33.16.png"></p>
<p>实际上有正确答案需要去对比的，只有<strong>窗口中的词语</strong>。</p>
<p>所以每次更新只更新WW矩阵中的少数列，或者为每个词语建立到词向量的哈希映射：<img src="https://wx3.sinaimg.cn/large/006Fmjmcly1fgdu3xf2phj30qo09a755.jpg" alt="hankcs.com 2017-06-08 下午3.39.45.png"></p>
<p>另一个难点在于，词表V的量级非常大，以至于分母很难计算<img src="https://wx1.sinaimg.cn/large/006Fmjmcly1fgdtp2e4e2j30uy0bmn6v.jpg" alt="hankcs.com 2017-06-08 下午3.25.31.png"></p>
<p>因此assignment 1用negative sampling实现skip-gram，这是一种采样子集简化运算的方法。</p>
<p>具体做法是，<strong>对每个正例（中央词语及上下文中的一个词语）采样几个负例（中央词语和其他随机词语），训练binary logistic regression（也就是二分类器）</strong>。</p>
<p> 目标函数：<script type="math/tex">J_t(\theta) = \log \sigma\left(u_o^Tv_c\right)+\sum_{i=1}^k\mathbb{E}_{j \sim P(w)}\left [\log\sigma \left(-u^T_jv_c\right) \right]</script></p>
<p>这里t是某个窗口，k是采样个数，P(w)是一个unigram分布，σ是sigmoid函数</p>
<p><img src="https://wx4.sinaimg.cn/large/006Fmjmcly1fgdvx2wor0j30f90ai0t5.jpg" alt="sigmoid.png"></p>
]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/post/3e225941/</url>
    <content><![CDATA[<h1 id="一-概念"><a href="#一、-概念" class="headerlink" title="一、 概念"></a>一、 概念</h1><ul>
<li><p>并发： 多个线程操作相同的资源，保证线程安全，合理使用资源</p>
<p>同时拥有两个或者多个线程，如果程序在<em>单核处理器</em>上运行，多个线程将交替地换入或者换出内存，<strong>这些线程是同时“存在”的</strong>，<strong>每个线程都处于执行过程中的某个状态</strong>，如果运行在<em>多核处理器</em>上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行</p>
</li>
<li><p>高并发：  服务能同时处理很多请求，提高程序性能</p>
<p>高并发(High Concurrency)是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p>
</li>
<li><p>高并发处理的思路和方法</p>
<ul>
<li>扩容：水平扩容、垂直扩容</li>
<li>缓存：redis、memcache、guava、cache等</li>
<li>队列：kafka、rabbitmq、rocketmq等队列特性</li>
<li>应用拆分：服务化dubbo与微服务、Spring Cloud</li>
<li>限流：guava ratelimiter的介绍与适用、常用限流算法、自实现分布式限流</li>
<li>服务降级与服务熔断：服务降级的多种选择、hystrix</li>
<li>数据库切库、分库、分表：</li>
<li>高可用的一些手段：任务调度分布式elastic-job、主备curator的实现、监控报警机制等</li>
</ul>
</li>
<li><p>◆总体架构：Spring Boot、.Maven、JDK8、MySQL<br>◆基础组件：Mybatis、Guava、Lombok、Redis、.Kafka<br>◆高级组件（类）：Joda-Time、Atomic包、J.U.C、AQS、ThreadLocal、RateLimiter、Hystrix、threadPool、shardbatis、curator、elastic-job.…</p>
</li>
</ul>
<h1 id="二-并发编程的基础"><a href="#二、并发编程的基础" class="headerlink" title="二、并发编程的基础"></a>二、并发编程的基础</h1><h2 id="1-cpu多级缓存"><a href="#1-CPU多级缓存" class="headerlink" title="1. CPU多级缓存"></a>1. CPU多级缓存</h2><h3 id="11-cpu-cache"><a href="#1-1-CPU-cache" class="headerlink" title="1.1 CPU cache"></a>1.1 CPU cache</h3><ul>
<li><p>问：为什么需要CPU cache:</p>
<p>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题(结构：<strong>cpu-&gt;cache-&gt;memory</strong>).</p>
</li>
<li><p>问：CPU cache有什么意义：</p>
<p>1)时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问<br>2)空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问；</p>
</li>
</ul>
<h3 id="12-缓存一致性mesi"><a href="#1-2-缓存一致性-MESI" class="headerlink" title="1.2 缓存一致性(MESI)"></a>1.2 缓存一致性(MESI)</h3><p>可见 <a href="https://developer.aliyun.com/article/46661">缓存一致性协议-阿里云开发者社区 (aliyun.com)</a></p>
<ul>
<li>用于保证多个CPU cache之间缓存共享数据的一致</li>
<li>四种 数据状态（MESI)、四种 转换状态操作<ul>
<li>M: Modify，修改缓存，当前CPU的缓存已经被修改了，即与内存中数据已经不一致了</li>
<li>E: Exclusive，独占缓存，当前CPU的缓存和内存中数据保持一致，而且其他处理器并没有可使用的缓存数据</li>
<li>S: Share，共享缓存，和内存保持一致的一份拷贝，多组缓存可以同时拥有针对同一内存地址的共享缓存段</li>
<li>I: Invalid，实效缓存，这个说明CPU中的缓存已经不能使用了</li>
</ul>
</li>
</ul>
<h3 id="13-乱序执行优化"><a href="#1-3-乱序执行优化" class="headerlink" title="1.3 乱序执行优化"></a>1.3 乱序执行优化</h3><p>处理器为提高运算速度而做出<strong>违背代码原有顺序的优化</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">200</span>;</span><br><span class="line">result = a*b;</span><br><span class="line"><span class="comment">// 优化可能</span></span><br><span class="line">a = <span class="number">10</span>; b = <span class="number">200</span>; result = a*b;</span><br><span class="line">b = <span class="number">200</span>; a = <span class="number">10</span>; result = a*b;</span><br></pre></td></tr></table></figure>
<h2 id="2-java内存模型-java-memory-mode-jmm"><a href="#2-JAVA内存模型-Java-Memory-Mode-JMM" class="headerlink" title="2. JAVA内存模型 (Java Memory Mode, JMM)"></a>2. JAVA内存模型 (Java Memory Mode, JMM)</h2><p>可参考<a href="https://songzi.info/post/f0242a65/">JVM学习 | 毫末室 (songzi.info)</a></p>
<p><strong>需要重新学习</strong></p>
<h2 id="3-并发的优势和风险"><a href="#3-并发的优势和风险" class="headerlink" title="3. 并发的优势和风险"></a>3. 并发的优势和风险</h2><p>优势：</p>
<ol>
<li>速度：同时处理多个请求，响应更快：复杂的操作可以分成多个进程同时进行</li>
<li>设计：程序设计在某些情况下复简单，也可以有更多的选择</li>
<li>资源利用：CPU能够在等待IO的时候做一些其他的事情</li>
</ol>
<p>风险</p>
<ol>
<li>安全性：多个线程共享数据时可能会产生于<strong>期望不相符</strong>的结果</li>
<li>活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如<strong>死锁、饥饿</strong>等问题</li>
<li>性能：线程过多时会使得：<strong>CPU频繁切换，调度时间增多；同步机制：消耗过多内存</strong></li>
</ol>
<h2 id="disruptor核心原理与源码"><a href="#Disruptor核心原理与源码" class="headerlink" title="Disruptor核心原理与源码"></a>Disruptor核心原理与源码</h2><p>LMAX架构：很低的延迟产生大量交易；建立在JVM上，核心是业务逻辑处理器</p>
<ul>
<li>一个线程里每秒处理六百万订单</li>
<li>业务逻辑处理器完全是运行在内存中，使用<strong>事件源驱动</strong>方式</li>
<li>业务逻辑处理器的核心是disruptor</li>
</ul>
<p>disruptor创建步骤</p>
<ul>
<li>建立一个工厂Event类，用于创建Event类实例对象</li>
<li>需要有一个监听事件类，用于处理数据（Event类）</li>
<li>实例化Disruptor实例，配置一系列参数，编写Disruptor核心组件</li>
<li>编写生产者组件，向Disruptor容器中投递数据（最复杂）</li>
</ul>
<h3 id="ringbuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><p>生产者生产产品放到容器里面，消费者监听然后获取event数据</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/ringbuffer.PNG" alt="ringbuffer"></p>
<ul>
<li>环形结构（首尾相连）</li>
<li>用作在不用上下文（线程）间传递数据的buffer</li>
<li>RingBuffer拥有一个<strong>序号sequence</strong>，这个序号指向数组中<strong>下一个可用元素</strong>，或者说空的元素</li>
</ul>
<p>生产者扔芝麻、消费者捡芝麻需要考虑速度问题</p>
<ul>
<li>随着不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码——ArrayList</title>
    <url>/post/771d1ebd/</url>
    <content><![CDATA[<p>ArrayList 动态数组，可动态扩展，是<strong>数组</strong>实现的list。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>ArrayList实现了List，提供了list的的<strong>添加</strong>、<strong>删除</strong>、<strong>遍历</strong>等操作。</li>
<li>ArrayList实现了RandomAccess，提供了<strong>随机访问</strong>的能力。</li>
<li>ArrayList实现了Cloneable，可以被<strong>克隆</strong>。</li>
<li>ArrayList实现了Serializable，可以被<strong>序列化</strong>。</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量10,通过new ArrayList()创建时的默认容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空数组，如果传入的容量为0时使用，即new ArrayList(0)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空数组，传传入容量时使用，添加第一个元素的时候会重新初始为默认容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正存储元素的数组，使用transient修饰是为了不序列化这个字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正存储元素的个数，而不是elementData的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><hr>
<p>构造方法一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*传入初始容量，如果大于0就初始化elementData为对应大小，如果等于0就使用EMPTY_ELEMENTDATA空数组，如果小于0则异常*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//新建一个数组存储元素</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//使用空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>构造方法二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*默认构造方法，初始化为DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空数组，会在添加第一个元素的时候扩容为默认大小，即10*/</span>	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>构造方法三</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*传入集合的构造方法，用拷贝，把传入集合的元素拷贝进elementData数组，如果元素为0，则初始化EMPTY_ELEMENTDATA空数组*/</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>c.toArray();</code>返回的可能不是Object[]类型</p>
<h3 id="add系列方法"><a href="#add系列方法" class="headerlink" title="add系列方法"></a>add系列方法</h3><hr>
<h4 id="adde-e方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h4><p>新增单个元素，时间复杂度O(1)</p>
<ol>
<li>检查是否需要扩容；</li>
<li>如果elementData等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA则初始化容量大小为DEFAULT_CAPACITY；</li>
<li>新容量是老容量的1.5倍（oldCapacity + (oldCapacity &gt;&gt; 1)），如果加了这么多容量发现比需要的容量还小，则以需要的容量为准；</li>
<li>创建新容量的数组并把老数组拷贝到新数组；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果是空数组，直接初始化默认大小为10</span></span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> minCapacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//再用ensureExplicitCapacity方法</span></span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// overflow-conscious code。扩容代码</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**arrayList的扩容方法*/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//新容量为旧容量的1.5倍</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//新容量比需要的容量还小，则以需要的容量为准</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="comment">//新容量比最大容量还大，则使用最大容量</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       <span class="comment">//以新容量拷贝出来一个新数组</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查是否需要扩容</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       <span class="comment">//把元素插入到最后一位</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="addint-index-e-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element) 方法"></a>add(int index, E element) 方法</h4><p>添加元素到指定位置，时间复杂度O(n)</p>
<p>步骤</p>
<ol>
<li>检查index是否越界</li>
<li>检查是否需要扩容</li>
<li>把传入索引位置后的元素往后移</li>
<li>在插入索引位置放置插入的元素</li>
<li>大小+1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="addallcollectionlt-extends-egt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a>addAll(Collection&lt;? extends E&gt; c)</h4><p>两个集合的并集</p>
<p>步骤</p>
<ol>
<li>拷贝c中的元素到数组a中</li>
<li>检查是否需要扩容</li>
<li>把数据a中的元素拷贝到elementData的尾部</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">           rangeCheckForAdd(index);</span><br><span class="line">           <span class="keyword">int</span> cSize = c.size();</span><br><span class="line">           <span class="keyword">if</span> (cSize==<span class="number">0</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">           checkForComodification();</span><br><span class="line">           parent.addAll(parentOffset + index, c);</span><br><span class="line">           <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">           <span class="keyword">this</span>.size += cSize;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-remove等方法"><a href="#get-remove等方法" class="headerlink" title="get remove等方法"></a>get remove等方法</h3><hr>
<h4 id="getint-index方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h4><p>时间复杂度O(1)</p>
<ol>
<li>检查索引是否越界，越上界抛出IndexOutOfBoundsException异常，越下界抛出的是ArrayIndexOutOfBoundsException异常。</li>
<li>返回索引位置处的元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> elementData(index);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="removeint-index方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h4><p><strong>删除指定索引位置的元素</strong>，时间复杂度O(n)</p>
<ol>
<li>检查索引是否越界</li>
<li>获取指定索引位置的元素</li>
<li>如果删除的不是最后一位，则其他元素前移一位</li>
<li>将最后一位设为null，<strong>方便gc回收</strong></li>
<li>返回删除的元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       Objects.checkIndex(index, size);</span><br><span class="line">       <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E oldValue = (E) es[index];</span><br><span class="line">       fastRemove(es, index);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">       <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">           System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">       es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="retainallcollection-c方法"><a href="#retainAll-Collection-c-方法" class="headerlink" title="retainAll(Collection c)方法"></a>retainAll(Collection c)方法</h4><p>两个集合的交集</p>
<ol>
<li>遍历elementData数组</li>
<li>如果元素在c中，则把这个元素添加到elementData数组的w位置并将w位置往后移一位</li>
<li>遍历完之后，w之前的元素都是两者共有的，w之后（包含）的元素不是两者共有的</li>
<li>将w之后（包含）的元素置为null，方便GC回收</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="removeallcollectionltgt-c"><a href="#removeAll-Collection-lt-gt-c" class="headerlink" title="removeAll(Collection&lt;?&gt; c)"></a>removeAll(Collection&lt;?&gt; c)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合c不能为空</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="comment">// 同样调用批量删除方法，这时complement传入false，表示删除包含在c中的元素</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此</p>
<ul>
<li>ArrayList支持求并集，调用addAll(Collection&lt;? extends E&gt; c)方法即可；</li>
<li>ArrayList支持求交集，调用retainAll(Collection&lt;? extends E&gt; c)方法即可；</li>
<li>ArrayList支持求单向差集，调用removeAll(Collection&lt;? extends E&gt; c)方法即可；</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li><p>elementData设置成了transient，则ArrayList怎么序列化元素？</p>
</li>
<li><p>查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。</p>
<p>一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。</p>
<p>在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。</p>
<p>elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// 防止序列化期间有修改</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 写出非transient非static属性（会写出size属性）</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次写出元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有修改，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 声明为空数组</span></span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入非transient非static属性（会读取size属性）</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算容量</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line">        </span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/post/aeafbee0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在我们学习Java的IO流之前，我们都要了解几个关键词</p>
<ul>
<li>同步与异步（synchronous/asynchronous）：<strong>同步</strong>是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而<strong>异步</strong>则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系</li>
<li>阻塞与非阻塞：在进行<strong>阻塞</strong>操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如ServerSocket新连接建立完毕，或者数据读取、写入操作完成；而<strong>非阻塞</strong>则是不管IO操作是否结束，直接返回，相应操作在后台继续处理</li>
</ul>
<p>同步和异步的概念：实际的I/O操作</p>
<p>同步是用户线程发起I/O请求后需要等待或者轮询内核I/O操作完成后才能继续执行</p>
<p>异步是用户线程发起I/O请求后仍需要继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数</p>
<p>阻塞和非阻塞的概念：发起I/O请求</p>
<p>阻塞是指I/O操作需要彻底完成后才能返回用户空间</p>
<p>非阻塞是指I/O操作被调用后立即返回一个状态值，无需等I/O操作彻底完成</p>
<h2 id="bio-nio-aio的概述"><a href="#BIO、NIO、AIO的概述" class="headerlink" title="BIO、NIO、AIO的概述"></a>BIO、NIO、AIO的概述</h2><p>首先，传统的 java.io包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p>
<p>java.io包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p>
<p>很多时候，人们也把 java.net下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p>
<p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p>
<p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
<p><a href="https://www.cnblogs.com/sxkgeek/p/9488703.html#_labelTop">回到顶部</a></p>
<h1 id="一-io流同步-阻塞"><a href="#一、IO流（同步、阻塞）" class="headerlink" title="一、IO流（同步、阻塞）"></a>一、IO流（同步、阻塞）</h1><h2 id="1-概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>IO流简单来说就是input和output流，IO流主要是用来处理设备之间的数据传输，Java IO对于数据的操作都是通过流实现的，而java用于操作流的对象都在IO包中。</p>
<h2 id="2-分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h2><p>按操作数据分为：字节流（InputStream、OutputStream）和字符流（Reader、Writer）</p>
<p>按流向分：输入流（Reader、InputStream）和输出流（Writer、OutputStream）<br><img src="https://images2018.cnblogs.com/blog/1302135/201808/1302135-20180816173529402-760533731.png" alt="img"></p>
<h2 id="3-字符流"><a href="#3、字符流" class="headerlink" title="3、字符流"></a>3、字符流</h2><h3 id="概述"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>只用来处理文本数据</p>
<p>数据最常见的表现形式是文件，字符流用来操作文件的子类一般是FileReader和FileWriter</p>
<p>字符流读写文件注意事项：</p>
<ul>
<li>写入文件必须要用flush()刷新</li>
<li>用完流记得要关闭流</li>
<li>使用流对象要抛出IO异常</li>
<li>定义文件路径时，可以用”/“或者”\”</li>
<li>在创建一个文件时，如果目录下有同名文件将被覆盖</li>
<li>在读取文件时，必须保证该文件已存在，否则抛出异常</li>
</ul>
<h3 id="字符流的缓冲区"><a href="#字符流的缓冲区" class="headerlink" title="字符流的缓冲区"></a>字符流的缓冲区</h3><ul>
<li>缓冲区的出现是为了提高流的操作效率而出现的</li>
<li>需要被提高效率的流作为参数传递给缓冲区的构造函数</li>
<li>在缓冲区中封装了一个数组，存入数据后一次取出</li>
</ul>
<h2 id="4-字节流"><a href="#4、字节流" class="headerlink" title="4、字节流"></a>4、字节流</h2><h3 id="概述"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>用来处理媒体数据</p>
<p>字节流读写文件注意事项：</p>
<ul>
<li>字节流和字符流的基本操作是相同的，但是想要操作媒体流就需要用到字节流</li>
<li>字节流因为操作的是字节，所以可以用来操作媒体文件（媒体文件也是以字节存储的）</li>
<li>输入流（InputStream）、输出流（OutputStream）</li>
<li>字节流操作可以不用刷新流操作</li>
<li>InputStream特有方法：int available()（返回文件中的字节个数）</li>
</ul>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4><p>字节流的缓冲区<br>字节流缓冲区跟字符流缓冲区一样，也是为了提高效率</p>
<h2 id="5-java-scanner类"><a href="#5、Java-Scanner类" class="headerlink" title="5、Java Scanner类"></a>5、Java Scanner类</h2><p>Java 5添加了java.util.Scanner类，这是一个用于扫描输入文本的新的实用程序</p>
<h3 id="关于nextint-next-nextline的理解"><a href="#关于nextInt-、next-、nextLine-的理解" class="headerlink" title="关于nextInt()、next()、nextLine()的理解"></a>关于nextInt()、next()、nextLine()的理解</h3><p>nextInt()：只能读取数值，若是格式不对，会抛出java.util.InputMismatchException异常</p>
<p>next()：遇见第一个有效字符（非空格，非换行符）时，开始扫描，当遇见第一个分隔符或结束符（空格或换行符）时，结束扫描，获取扫描到的内容</p>
<p>nextLine()：可以扫描到一行内容并作为字符串而被捕获到</p>
<h3 id="关于hasnext-hasnextline-hasnextxxx的理解"><a href="#关于hasNext-、hasNextLine-、hasNextxxx-的理解" class="headerlink" title="关于hasNext()、hasNextLine()、hasNextxxx()的理解"></a>关于hasNext()、hasNextLine()、hasNextxxx()的理解</h3><p>就是为了判断输入行中是否还存在xxx的意思</p>
<h3 id="与delimiter有关的方法"><a href="#与delimiter-有关的方法" class="headerlink" title="与delimiter()有关的方法"></a>与delimiter()有关的方法</h3><p>应该是输入内容的分隔符设置，</p>
<p><a href="https://www.cnblogs.com/sxkgeek/p/9488703.html#_labelTop">回到顶部</a></p>
<h1 id="二-nio同步-非阻塞"><a href="#二、NIO（同步、非阻塞）" class="headerlink" title="二、NIO（同步、非阻塞）"></a>二、NIO（同步、非阻塞）</h1><p><strong>NIO之所以是同步，是因为它的accept/read/write方法的内核I/O操作都会阻塞当前线程</strong></p>
<p>首先，我们要先了解一下NIO的三个主要组成部分：Channel（通道）、Buffer（缓冲区）、Selector（选择器）</p>
<h2 id="1channel通道"><a href="#（1）Channel（通道）" class="headerlink" title="（1）Channel（通道）"></a>（1）Channel（通道）</h2><p>Channel（通道）：Channel是一个对象，可以通过它读取和写入数据。可以把它看做是IO中的流，不同的是：</p>
<ul>
<li>Channel是双向的，既可以读又可以写，而流是单向的</li>
<li>Channel可以进行异步的读写</li>
<li>对Channel的读写必须通过buffer对象</li>
</ul>
<p>正如上面提到的，所有数据都通过Buffer对象处理，所以，您永远不会将字节直接写入到Channel中，相反，您是将数据写入到Buffer中；同样，您也不会从Channel中读取字节，而是将数据从Channel读入Buffer，再从Buffer获取这个字节。</p>
<p>因为Channel是双向的，所以Channel可以比流更好地反映出底层操作系统的真实情况。特别是在Unix模型中，底层操作系统通常都是双向的。</p>
<p>在Java NIO中的Channel主要有如下几种类型：</p>
<ul>
<li>FileChannel：从文件读取数据的</li>
<li>DatagramChannel：读写UDP网络协议数据</li>
<li>SocketChannel：读写TCP网络协议数据</li>
<li>ServerSocketChannel：可以监听TCP连接</li>
</ul>
<h2 id="2buffer"><a href="#（2）Buffer" class="headerlink" title="（2）Buffer"></a>（2）Buffer</h2><p>Buffer是一个对象，它包含一些要写入或者读到Stream对象的。应用程序不能直接对 Channel 进行读写操作，而必须通过 Buffer 来进行，即 Channel 是通过 Buffer 来读写数据的。</p>
<p>在NIO中，所有的数据都是用Buffer处理的，它是NIO读写数据的中转池。Buffer实质上是一个数组，通常是一个字节数据，但也可以是其他类型的数组。但一个缓冲区不仅仅是一个数组，重要的是它提供了对数据的结构化访问，而且还可以跟踪系统的读写进程。</p>
<p>使用 Buffer 读写数据一般遵循以下四个步骤：</p>
<p>1.写入数据到 Buffer；</p>
<p>2.调用 flip() 方法；</p>
<p>3.从 Buffer 中读取数据；</p>
<p>4.调用 clear() 方法或者 compact() 方法。</p>
<p>当向 Buffer 写入数据时，Buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 Buffer 的所有数据。</p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact() 方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
<p>Buffer主要有如下几种：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<h3 id="copyfile实例nio"><a href="#copyFile实例（NIO）" class="headerlink" title="copyFile实例（NIO）"></a>copyFile实例（NIO）</h3><p>CopyFile是一个非常好的读写结合的例子，我们将通过CopyFile这个实力让大家体会NIO的操作过程。CopyFile执行三个基本的操作：创建一个Buffer，然后从源文件读取数据到缓冲区，然后再将缓冲区写入目标文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void copyFileUseNIO(String src,String dst) throws IOException&#123;</span><br><span class="line">//声明源文件和目标文件</span><br><span class="line">        FileInputStream fi=new FileInputStream(new File(src));</span><br><span class="line">        FileOutputStream fo=new FileOutputStream(new File(dst));</span><br><span class="line">        //获得传输通道channel</span><br><span class="line">        FileChannel inChannel=fi.getChannel();</span><br><span class="line">        FileChannel outChannel=fo.getChannel();</span><br><span class="line">        //获得容器buffer</span><br><span class="line">        ByteBuffer buffer=ByteBuffer.allocate(1024);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //判断是否读完文件</span><br><span class="line">            int eof =inChannel.read(buffer);</span><br><span class="line">            if(eof==-1)&#123;</span><br><span class="line">                break;  </span><br><span class="line">            &#125;</span><br><span class="line">            //重设一下buffer的position=0，limit=position</span><br><span class="line">            buffer.flip();</span><br><span class="line">            //开始写</span><br><span class="line">            outChannel.write(buffer);</span><br><span class="line">            //写完要重置buffer，重设position=0,limit=capacity</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        inChannel.close();</span><br><span class="line">        outChannel.close();</span><br><span class="line">        fi.close();</span><br><span class="line">        fo.close();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="三selector选择器对象"><a href="#（三）Selector（选择器对象）" class="headerlink" title="（三）Selector（选择器对象）"></a>（三）Selector（选择器对象）</h2><p>首先需要了解一件事情就是线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势。</p>
<p>Selector是一个对象，它可以注册到很多个Channel上，监听各个Channel上发生的事件，并且能够根据事件情况决定Channel读写。这样，通过一个线程管理多个Channel，就可以处理大量网络连接了。</p>
<h3 id="selector优点"><a href="#selector优点" class="headerlink" title="selector优点"></a>selector优点</h3><p>有了Selector，我们就可以利用一个线程来处理所有的channels。线程之间的切换对操作系统来说代价是很高的，并且每个线程也会占用一定的系统资源。所以，对系统来说使用的线程越少越好。</p>
<h3 id="1如何创建一个selector"><a href="#1-如何创建一个Selector" class="headerlink" title="1.如何创建一个Selector"></a>1.如何创建一个Selector</h3><p>Selector 就是您注册对各种 I/O 事件兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<h3 id="2注册channel到selector"><a href="#2-注册Channel到Selector" class="headerlink" title="2.注册Channel到Selector"></a>2.注册Channel到Selector</h3><p>为了能让Channel和Selector配合使用，我们需要把Channel注册到Selector上。通过调用 channel.register（）方法来实现注册：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(false);</span><br><span class="line">SelectionKey key =channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>注意，注册的Channel 必须设置成异步模式 才可以,否则异步IO就无法工作，这就意味着我们不能把一个FileChannel注册到Selector，因为FileChannel没有异步模式，但是网络编程中的SocketChannel是可以的。</p>
<h3 id="3关于selectionkey"><a href="#3-关于SelectionKey" class="headerlink" title="3.关于SelectionKey"></a>3.关于SelectionKey</h3><p>请注意对register()的调用的返回值是一个SelectionKey。 SelectionKey 代表这个通道在此 Selector 上注册。当某个 Selector 通知您某个传入事件时，它是通过提供对应于该事件的 SelectionKey 来进行的。SelectionKey 还可以用于取消通道的注册。</p>
<p>SelectionKey中包含如下属性：</p>
<ul>
<li>The interest set</li>
<li>The ready set</li>
<li>The Channel</li>
<li>The Selector</li>
<li>An attached object (optional)</li>
</ul>
<h4 id="1interest-set"><a href="#（1）Interest-set" class="headerlink" title="（1）Interest set"></a>（1）Interest set</h4><p>就像我们在前面讲到的把Channel注册到Selector来监听感兴趣的事件，interest set就是你要选择的感兴趣的事件的集合。你可以通过SelectionKey对象来读写interest set:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int interestSet = selectionKey.interestOps();</span><br><span class="line">boolean isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line">boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line">boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line">boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE; </span><br></pre></td></tr></table></figure>
<p>通过上面例子可以看到，我们可以通过用AND 和SelectionKey 中的常量做运算，从SelectionKey中找到我们感兴趣的事件。</p>
<h4 id="2ready-set"><a href="#（2）Ready-Set" class="headerlink" title="（2）Ready Set"></a>（2）Ready Set</h4><p>ready set 是通道已经准备就绪的操作的集合。在一次选Selection之后，你应该会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>
<p>可以用像检测interest集合那样的方法，来检测Channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<h4 id="3channel-和-selector"><a href="#（3）Channel-和-Selector" class="headerlink" title="（3）Channel 和 Selector"></a>（3）Channel 和 Selector</h4><p>我们可以通过SelectionKey获得Selector和注册的Channel：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector(); </span><br></pre></td></tr></table></figure>
<h4 id="4attach一个对象"><a href="#（4）Attach一个对象" class="headerlink" title="（4）Attach一个对象"></a>（4）Attach一个对象</h4><p>可以将一个对象或者更多信息attach 到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>
<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>
<h3 id="4关于selectedkeys"><a href="#4-关于SelectedKeys" class="headerlink" title="4.关于SelectedKeys()"></a>4.关于SelectedKeys()</h3><p><strong>生产系统中一般会额外进行就绪状态检查</strong></p>
<p>一旦调用了select()方法，它就会返回一个数值，表示一个或多个通道已经就绪，然后你就可以通过调用selector.selectedKeys()方法返回的SelectionKey集合来获得就绪的Channel。请看演示方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>当你通过Selector注册一个Channel时，channel.register()方法会返回一个SelectionKey对象，这个对象就代表了你注册的Channel。这些对象可以通过selectedKeys()方法获得。你可以通过迭代这些selected key来获得就绪的Channel，下面是演示代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">while(keyIterator.hasNext()) &#123; </span><br><span class="line">SelectionKey key = keyIterator.next();</span><br><span class="line">if(key.isAcceptable()) &#123;</span><br><span class="line">// a connection was accepted by a ServerSocketChannel.</span><br><span class="line">&#125; else if (key.isConnectable()) &#123;</span><br><span class="line">// a connection was established with a remote server.</span><br><span class="line">&#125; else if (key.isReadable()) &#123;</span><br><span class="line">// a channel is ready for reading</span><br><span class="line">&#125; else if (key.isWritable()) &#123;</span><br><span class="line">// a channel is ready for writing</span><br><span class="line">&#125;</span><br><span class="line">keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环遍历selected key的集合中的每个key，并对每个key做测试来判断哪个Channel已经就绪。</p>
<p>请注意循环中最后的keyIterator.remove()方法。Selector对象并不会从自己的selected key集合中自动移除SelectionKey实例。我们需要在处理完一个Channel的时候自己去移除。当下一次Channel就绪的时候，Selector会再次把它添加到selected key集合中。</p>
<p>SelectionKey.channel()方法返回的Channel需要转换成你具体要处理的类型，比如是ServerSocketChannel或者SocketChannel等等。</p>
<h2 id="4nio多路复用"><a href="#（4）NIO多路复用" class="headerlink" title="（4）NIO多路复用"></a>（4）NIO多路复用</h2><p>主要步骤和元素：</p>
<ul>
<li>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。</li>
<li>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。</li>
<li>注意，为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出 IllegalBlockingModeException 异常。</li>
<li>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</li>
<li>在 具体的 方法中，通过 SocketChannel 和 Buffer 进行数据操作</li>
</ul>
<p>IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。而 NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高</p>
<p><a href="https://www.cnblogs.com/sxkgeek/p/9488703.html#_labelTop">回到顶部</a></p>
<h1 id="三-nio2异步-非阻塞"><a href="#三、NIO2-异步、非阻塞" class="headerlink" title="三、NIO2(异步、非阻塞)"></a>三、NIO2(异步、非阻塞)</h1><p>AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。</p>
<p>但是对AIO来说，则更加进了一步，它不是在IO准备好时再通知线程，而是在IO操作已经完成后，再给线程发出通知。因此AIO是不会阻塞的，此时我们的业务逻辑将变成一个回调函数，等待IO操作完成后，由系统自动触发。</p>
<p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 在JDK1.7中，这部分内容被称作NIO.2，主要在Java.nio.channels包下增加了下面四个异步通道：</p>
<ul>
<li>AsynchronousSocketChannel</li>
<li>AsynchronousServerSocketChannel</li>
<li>AsynchronousFileChannel</li>
<li>AsynchronousDatagramChannel</li>
</ul>
<p>在AIO socket编程中，服务端通道是AsynchronousServerSocketChannel，这个类提供了一个open()静态工厂，一个bind()方法用于绑定服务端IP地址（还有端口号），另外还提供了accept()用于接收用户连接请求。在客户端使用的通道是AsynchronousSocketChannel,这个通道处理提供open静态工厂方法外，还提供了read和write方法。</p>
<p>在AIO编程中，发出一个事件（accept read write等）之后要指定事件处理类（回调函数），AIO中的事件处理类是CompletionHandler<v,a>，这个接口定义了如下两个方法，分别在异步操作成功和失败时被回调。</v,a></p>
<p>void completed(V result, A attachment);</p>
<p>void failed(Throwable exc, A attachment);</p>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码——LinkedHashMap</title>
    <url>/post/3f21cf60/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqldump导入导出方法</title>
    <url>/post/d36196a7/</url>
    <content><![CDATA[<p><a href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html">官方文档</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题整理</title>
    <url>/post/dabc0faf/</url>
    <content><![CDATA[<h1 id="leetcode-没维护链接"><a href="#Leetcode-没维护链接" class="headerlink" title="Leetcode 没维护链接"></a>Leetcode 没维护链接</h1><div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>Title</th>
<th>Difficulty</th>
<th>Java</th>
<th>Python</th>
<th>C++</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Two Sum</td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/LeetCode/0001. Two Sum/Solution.java">YES</a></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/LeetCode/0001. Two Sum/Solution.py">YES</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>Add Two Numbers</td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0002.%20Add%20Two%20Numbers/Solution.java">YES</a></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0002.%20Add%20Two%20Numbers/Solution.py">YES</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Longest Substring Without Repeating Characters</td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0003.%20Longest%20Substring%20Without%20Repeating%20Characters/Solution.java">YES</a></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0003.%20Longest%20Substring%20Without%20Repeating%20Characters/Solution.py">YES</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>Median of Two Sorted Arrays</td>
<td>Hard</td>
<td><a href>YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Longest Palindromic Substring</td>
<td>Medium</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>ZigZag Conversion</td>
<td>Medium</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>Reverse Integer</td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0007.%20Reverse%20Integer/Solution.java">YES</a></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0007.%20Reverse%20Integer/Solution.py">YES</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>String to Integer (atoi)</td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0008.%20String%20to%20Integer%20(atoi">YES</a>/Solution.java)</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0008.%20String%20to%20Integer%20(atoi">YES</a>/Solution.py)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>Palindrome Number</td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0009.%20Palindrome%20Number/Solution.java">YES</a></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0009.%20Palindrome%20Number/Solution.py">YES</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>Regular Expression Matching</td>
<td>Hard</td>
<td></td>
<td></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0010.%20Regular%20Expression%20Matching/Solution.cpp">YES</a></td>
<td></td>
</tr>
<tr>
<td>132 *</td>
<td>Palindrome Partitioning II</td>
<td>Hard</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0132.%20Palindrome%20Partitioning%20II/Solution.java">YES</a></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0132.%20Palindrome%20Partitioning%20II/Solution.py">YES</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>176</td>
<td>Second Highest Salary</td>
<td>Easy</td>
<td></td>
<td></td>
<td></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0176.%20Second%20Highest%20Salary/Solution.sql">YES</a></td>
</tr>
<tr>
<td>183</td>
<td>Customers Who Never Order</td>
<td>Easy</td>
<td></td>
<td></td>
<td></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0183.%20Customers%20Who%20Never%20Order/Solution.sql">YES</a></td>
</tr>
<tr>
<td>344</td>
<td>Reverse String</td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0344.%20Reverse%20String/Solution.java">YES</a></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0344.%20Reverse%20String/Solution.py">YES</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>437</td>
<td>Path Sum III</td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0437.%20Path%20Sum%20III/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>532</td>
<td>K-diff Pairs in an Array</td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0532.%20K-diff%20Pairs%20in%20an%20Array/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>620</td>
<td>Not Boring Movies</td>
<td>Easy</td>
<td></td>
<td></td>
<td></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0620.%20Not%20Boring%20Movies/Solution.sql">YES</a></td>
</tr>
<tr>
<td>677</td>
<td>Map Sum Pairs</td>
<td>Medium</td>
<td></td>
<td></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0677.%20Map%20Sum%20Pairs/Solution.cpp">YES</a></td>
<td></td>
</tr>
<tr>
<td>729</td>
<td>My Calendar I</td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0729.%20My%20Calendar%20I/Solution.java">YES</a></td>
<td></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0729.%20My%20Calendar%20I/Solution.cpp">YES</a></td>
<td></td>
</tr>
<tr>
<td>907</td>
<td>Sum of Subarray Minimums</td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0907.%20Sum%20of%20Subarray%20Minimums/Solution.java">YES</a></td>
<td></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0907.%20Sum%20of%20Subarray%20Minimums/Solution.cpp">YES</a></td>
<td></td>
</tr>
<tr>
<td>917</td>
<td>Reverse Only Letters</td>
<td>Easy</td>
<td></td>
<td></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0917.%20Reverse%20Only%20Letters/Solution.cpp">YES</a></td>
<td></td>
</tr>
<tr>
<td>985</td>
<td>Sum of Even Numbers After Queries</td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0985.%20Sum%20of%20Even%20Numbers%20After%20Queries/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>994</td>
<td>Rotting Oranges</td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/0994.%20Rotting%20Oranges/Solution.cpp">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1262</td>
<td>Greatest Sum Divisible by Three</td>
<td>Medium</td>
<td></td>
<td></td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/1262.%20Greatest%20Sum%20Divisible%20by%20Three/Solution.cpp">YES</a></td>
</tr>
</tbody>
</table>
</div>
<h1 id="剑指"><a href="#剑指" class="headerlink" title="剑指"></a>剑指</h1><div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>Difficulty</th>
<th>Java</th>
<th>Python</th>
<th>C++</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>JZ3</strong> <strong>数组中重复的数字</strong></td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ3/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ4</strong> <strong>二维数组中的查找</strong></td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ4/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ5</strong> <strong>替换空格</strong></td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ5/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ6</strong> <strong>从尾到头打印链表</strong></td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ6/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ7</strong> <strong>重建二叉树</strong></td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ7/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ8</strong> <strong>二叉树的下一个结点</strong></td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ8/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ9</strong> <strong>用两个栈实现队列</strong></td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ9/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ10</strong> <strong>斐波那契数列</strong></td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ10/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ11</strong> <strong>旋转数组的最小数字</strong></td>
<td>Easy</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ11/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ12</strong> <strong>矩阵中的路径</strong></td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ12/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ13</strong> <strong>机器人的运动范围</strong></td>
<td>Hard</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ13/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ14</strong> <strong>剪绳子</strong></td>
<td>Medium</td>
<td><a href="https://github.com/ShortPupil/Leetcode_questions/blob/master/main/JZ/JZ14/Solution.java">YES</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>JZ15</strong> <strong>二进制中1的个数</strong></td>
<td>Easy</td>
<td>YES</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>第4题</p>
<p>这道题让我们求两个有序数组的中位数，而且限制了时间复杂度为O(log (m+n))，看到这个时间复杂度，自然而然的想到了应该使用二分查找法来求解。那么回顾一下中位数的定义，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。</p>
<p>这里我们需要定义一个函数来在两个有序数组中找到第K个元素，下面重点来看如何实现找到第K个元素。首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组nums1和nums2的起始位置。然后来处理一些边界问题，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果K=1的话，那么我们只要比较nums1和nums2的起始位置i和j上的数字就可以了。难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，对K二分，意思是我们需要分别在nums1和nums2中查找第K/2个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第K/2个数字，所以我们需要先检查一下，数组中到底存不存在第K/2个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第K/2个数字，那么我们就淘汰另一个数字的前K/2个数字即可。有没有可能两个数组都不存在第K/2个数字呢，这道题里是不可能的，因为我们的K不是任意给的，而是给的m+n的中间值，所以必定至少会有一个数组是存在第K/2个数字的。最后就是二分法的核心啦，比较这两个数组的第K/2小的数字midVal1和midVal2的大小，如果第一个数组的第K/2个数字小的话，那么说明我们要找的数字肯定不在nums1中的前K/2个数字，所以我们可以将其淘汰，将nums1的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归。反之，我们淘汰nums2中的前K/2个数字，并将nums2的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归即可。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法一览</title>
    <url>/post/99bc858a/</url>
    <content><![CDATA[<p>用typora多了，markdown源码模式看的少，需要整理一下，以便查看</p>
<hr>
<h1 id="数学公式待补充"><a href="#数学公式待补充" class="headerlink" title="数学公式待补充"></a>数学公式待补充</h1><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>行首加井号表示不同级别的标题 (H1-H6),例如：# H1, ## H2, ### H3，#### H4.</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr>
<p> 也可以使用在文字下放加 === 表示一级标题,使用 —- 表示二级标题. </p>
<h1 id="一级标题"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><ul>
<li><p>普通文本</p>
<p>直接输入的文字就是普通文本。需要注意的是要换行的时候不<br>能直接通过回车来换行，需要使用\<br\>.也就是html里面的标签. 注意第三行的<code>&lt;br&gt;</code>前加了反斜杠 \\ .目的就是像其他语言那样实现转义，也就是 \&lt;  的转义.</br\></p>
</li>
<li><p>单行文本</p>
<pre><code>  使用两个Tab符实现单行文本.
</code></pre></li>
<li><p>多行文本</p>
<pre><code>  多行文本和
  单行文本异曲同工，只要在
  每行行首加两个Tab.
</code></pre></li>
<li>文字高亮</li>
</ul>
<p>如果你想使一段话中部分文字高亮显示，来起到突出强调的作用，那么可以把它用 `  ` 包围起来.<code>注意</code>这不是单引号，而是<code>Tab</code>上方，<code>数字1</code>左边的按键（注意使用<code>英文</code>输入法).<br>​        </p>
<h1 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h1><p>使用 <em> 和 *</em> 表示斜体和粗体.</p>
<p>这是 <em>斜体</em>,这是 <strong>粗体</strong>.</p>
<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p><del>使用~~表示删除线.</del></p>
<h1 id="外链接"><a href="#外链接" class="headerlink" title="外链接"></a>外链接</h1><p>使用 [描述](链接地址) 为文字增加外链接。</p>
<p>这是去往 <a href="https://gnipbao.github.io/h5-test/3dtag.html">有趣的HTML5和CSS3特效在线演示地址</a> 的链接。</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>使用 *，+，- 表示无序列表。</p>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三</li>
</ul>
<p>二级三级原点</p>
<ul>
<li>编程语言<ul>
<li>脚本语言<ul>
<li>Python</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用数字和点表示有序列表。</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<h1 id="数字列表自动排序"><a href="#数字列表自动排序" class="headerlink" title="数字列表自动排序"></a>数字列表自动排序</h1><p>也可以在第一行指定<code>1.</code>，而接下来的几行用星号<code>*</code>（或者继续用数字1. ）就可以了，它会自动显示成2、3、4……<br>面向对象的七大原则：<br>​      </p>
<ol>
<li>开闭原则</li>
</ol>
<ul>
<li>里氏转换原则</li>
<li>依赖倒转原则</li>
</ul>
<ol>
<li>接口隔离原则</li>
<li>组合聚合复用原则</li>
<li>迪米特法则</li>
<li>单一直则原则 </li>
</ol>
<h1 id="多级数字列表"><a href="#多级数字列表" class="headerlink" title="多级数字列表"></a>多级数字列表</h1><p>和圆点的列表一样，数字列表也有多级结构：  </p>
<ol>
<li>这是一级的数字列表，数字1还是1<ol>
<li>这是二级的数字列表，阿拉伯数字在显示的时候变成了罗马数字<ol>
<li>这是三级的数字列表，数字在显示的时候变成了英文字母<ol>
<li>四级的数字列表显示效果，就不再变化了，依旧是英文字母</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="复选框列表"><a href="#复选框列表" class="headerlink" title="复选框列表"></a>复选框列表</h1><ul>
<li>[x] C</li>
<li>[x] C++</li>
<li>[x] Java</li>
<li>[x] Qt</li>
<li>[x] Android</li>
<li>[ ] C#</li>
<li>[ ] .NET</li>
</ul>
<h1 id="文字引用"><a href="#文字引用" class="headerlink" title="文字引用"></a>文字引用</h1><p>使用 &gt; 表示文字引用。</p>
<p>单个引用：</p>
<blockquote>
<p>1111</p>
</blockquote>
<p>字符包围：</p>
<blockquote>
<p>数据结构</p>
<blockquote>
<p>树</p>
<blockquote>
<p>二叉树</p>
<blockquote>
<p>平衡二叉树</p>
<blockquote>
<p>满二叉树</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>使用 四个缩进空格 表示代码块。</p>
<p>示例：</p>
<pre><code>这是一个代码块，此行左侧有四个不可见的空格。
</code></pre><h1 id="加强的代码块"><a href="#加强的代码块" class="headerlink" title="加强的代码块"></a>加强的代码块</h1><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p>
<p>非代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo npm install </span><br></pre></td></tr></table></figure>
<p>Python 示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>n &gt;= 0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return </span>the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(fib(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<h1 id="插入图像"><a href="#插入图像" class="headerlink" title="插入图像"></a>插入图像</h1><p>使用 ![描述](图片链接地址) 插入图像。</p>
<p>插入图片示例：</p>
<p><img src="https://github.com/gnipbao/gnipbao.github.io/blob/master/images/markdown.jpg" alt="Markdown"></p>
<p>给图片添加链接:</p>
<p><a href="http://gnipbao.github.io/css3-test/src/Funny-demo/Button/index.html"><img src="https://github.com/gnipbao/gnipbao.github.io/blob/master/images/markdown.jpg" alt="V"></a></p>
<h1 id="显示表格"><a href="#显示表格" class="headerlink" title="显示表格"></a>显示表格</h1><pre><code>表头1  | 表头2
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell
</code></pre><div class="table-container">
<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>名字</th>
<th>描述          </th>
</tr>
</thead>
<tbody>
<tr>
<td>Help</td>
<td>Display the help window.</td>
</tr>
<tr>
<td>Close</td>
<td>Closes a window</td>
</tr>
</tbody>
</table>
</div>
<p>​<br>表格中也可以使用普通文本的删除线，斜体等效果<br>​<br>| 名字  | 描述                         |<br>| ——- | —————————————— |<br>| Help  | <del>Display the</del> help window. |<br>| Close | _Closes_ a window            |</p>
<p>表格可以指定对齐方式<br>​<br>| 左对齐        |      居中       | 右对齐 |<br>| :—————— | :——————-: | ——-: |<br>| col 3 is      | some wordy text |  $1600 |<br>| col 2 is      |    centered     |    $12 |<br>| zebra stripes |    are neat     |     $1 |</p>
<p>表格中嵌入图片</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>图片</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://github.com/gnipbao/gnipbao.github.io/blob/master/images/markdown.jpg" alt="Markdown"> |图片</p>
<h1 id="html-标签"><a href="#Html-标签" class="headerlink" title="Html 标签"></a>Html 标签</h1><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>

<h1 id="待办事宜-todo-列表"><a href="#待办事宜-Todo-列表" class="headerlink" title="待办事宜 Todo 列表"></a>待办事宜 Todo 列表</h1><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>
<pre><code>- [ ] **Cmd Markdown 开发**
    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
    - [ ] 支持以 PDF 格式导出文稿
    - [x] 新增Todo列表功能 
    - [x] 改进 LaTex 功能
        - [x] 修复 LaTex 公式渲染问题
        - [x] 新增 LaTex 公式编号功能 
- [ ] **七月旅行准备**
    - [ ] 准备邮轮上需要携带的物品
    - [ ] 浏览日本免税店的物品
    - [x] 购买蓝宝石公主号七月一日的船票
</code></pre><p>对应显示如下待办事宜 Todo 列表：<br>​        </p>
<ul>
<li>[ ] <strong>Cm Markdown 开发</strong><ul>
<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li>[ ] 支持以 PDF 格式导出文稿</li>
<li>[x] 新增Todo列表功能 </li>
<li>[x] 改进 LaTex 功能<ul>
<li>[x] 修复 LaTex 公式渲染问题</li>
<li>[x] 新增 LaTex 公式编号功能 </li>
</ul>
</li>
</ul>
</li>
<li>[ ] <strong>七月旅行准备</strong><ul>
<li>[ ] 准备邮轮上需要携带的物品</li>
<li>[ ] 浏览日本免税店的物品</li>
<li>[x] 购买蓝宝石公主号七月一日的船票</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>文本排版</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>shell一些小坑</title>
    <url>/post/7d0c07d3/</url>
    <content><![CDATA[<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul>
<li>按着书上的输入都出了问题 if [] then  这些中间都要加空格</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 判断式 ]; then</span><br><span class="line">else </span><br><span class="line">fi </span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>||</code>和<code>&amp;&amp;</code>要用两个独立的<code>[]</code>,如下</p>
</li>
<li><p>如果a&gt;b且a&lt;c </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [[ $a &gt; $b ]] &amp;&amp; [[ $a &lt; $c ]] </span><br><span class="line"></span><br><span class="line">if [ $a -gt $b -a $a -lt $c ]     </span><br></pre></td></tr></table></figure>
</li>
<li><p>如果a&gt;b或a&lt;c</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [[ $a &gt; $b ]] || [[ $a &lt; $c ]] </span><br><span class="line"></span><br><span class="line">if [ $a -gt $b -o $a -lt $c ] </span><br></pre></td></tr></table></figure>
</li>
<li><p>别忘了<strong>-o = or , -a = and</strong></p>
</li>
</ul>
<p>后续慢慢加</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>python翻转字符串</title>
    <url>/post/49164d1a/</url>
    <content><![CDATA[<p>将s = “abcd” 反转为 “dcba”</p>
<h4 id="第一种-字符串切片"><a href="#第一种-字符串切片" class="headerlink" title="第一种 字符串切片"></a>第一种 字符串切片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="第二种-列表的reverse方法"><a href="#第二种-列表的reverse方法" class="headerlink" title="第二种 列表的reverse方法"></a>第二种 列表的reverse方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = <span class="built_in">list</span>(s)</span><br><span class="line">result = <span class="string">&quot;&quot;</span>.join(l.reverse())</span><br></pre></td></tr></table></figure>
<h4 id="第三种-for循环"><a href="#第三种-for循环" class="headerlink" title="第三种 for循环"></a>第三种 for循环</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">s</span>):</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    max_index = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        result += s[max_index-index]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">result = func(s)</span><br></pre></td></tr></table></figure>
<h4 id="第四种-栈"><a href="#第四种-栈" class="headerlink" title="第四种 栈"></a>第四种 栈</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">s</span>):</span></span><br><span class="line">    l = <span class="built_in">list</span>(s) <span class="comment">#全部入栈</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(l)&gt;<span class="number">0</span>:</span><br><span class="line">        result += l.pop() <span class="comment">#出栈</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">result = func(s)</span><br></pre></td></tr></table></figure>
<h4 id="第五种-递归"><a href="#第五种-递归" class="headerlink" title="第五种 递归"></a>第五种 递归</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> func(s[<span class="number">1</span>:])+s[<span class="number">0</span>]</span><br><span class="line">result = func(s)</span><br></pre></td></tr></table></figure>
<h4 id="第六种-reduce方法"><a href="#第六种-reduce方法" class="headerlink" title="第六种 reduce方法"></a>第六种 reduce方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = reduce(<span class="keyword">lambda</span> x,y:y+x,s)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot学习</title>
    <url>/post/2f959504/</url>
    <content><![CDATA[<hr>
<p>根据spring boot的历史，有以下几个问题</p>
<ul>
<li>Spring Boot 是如何基于 Spring Framework 逐步走向自动装配？</li>
<li>SpringApplication 是怎样掌控 Spring 应用生命周期？</li>
<li>Spring Boot 外部化配置与 Spring Environment 抽象之间是什么关系？</li>
<li>Spring Web MVC 向 Spring Reactive WebFlux 过渡的真实价值和意义？</li>
</ul>
<p>有关实践</p>
<ul>
<li>场景分析</li>
<li>系统学习</li>
<li>重视规范</li>
<li>源码解读</li>
<li>实战演练</li>
</ul>
<p>官方网站</p>
<ul>
<li>Spring 全栈技术和实现原理</li>
<li>Spring Boot 核心技术</li>
<li>BAT大规模微服务基础设施开发与生产实施经验</li>
</ul>
<p>运行环境</p>
<ul>
<li>java：8</li>
<li>ide：idea community 2018</li>
<li>多记api、多写代码</li>
</ul>
<hr>
<p>spring boot易学</p>
<ul>
<li>组件自动装配：规约大于配置，专注核心业务</li>
<li>外部化配置：一次构建、按需调配、到处运行</li>
<li>嵌入式容器：内置容器、无需部署、独立运行</li>
<li>spring boot starter：简化依赖、按需装配、自我包含</li>
<li>production-ready：一站式运维、生态无缝整合</li>
</ul>
<p>spring boot难精</p>
<ul>
<li>组件自动装配：模式注解、@Enable模块、条件装配、加载机制</li>
<li>外部化配置：Environment抽象、生命周期、破坏性变更</li>
<li>嵌入式容器：Servlet Web容器、Reactive Web容器</li>
<li>spring boot starter：依赖管理（二方库、三方库）、装配条件、装配顺序</li>
<li>production-ready：健康检查、数据指标、@Endpoint管控</li>
</ul>
<p>spring boot 与 java ee 规范</p>
<ul>
<li>web：servlet</li>
<li>sql：jdbc</li>
<li>数据校验：bean validation</li>
<li>缓存：java caching api</li>
<li>websockets：java api for websocket</li>
<li>web service：jax-ws</li>
<li>java管理：jmx</li>
<li>消息：jms</li>
</ul>
<hr>
<p>内容</p>
<ul>
<li>核心特性</li>
<li>web应用</li>
<li>数据相关</li>
<li>功能扩展</li>
<li>运维管理</li>
<li>课堂总结</li>
</ul>
<hr>
<h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><ul>
<li>组件自动装配：web mvc、web flux、jdbc等<ul>
<li>如何激活：@EnableAutoConfiguration</li>
<li>如何配置：/META-INF/spring.factories</li>
<li>如何实现：XXXAutoConfiguration</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>嵌入式web容器：tomcat、jetty、undertow等<ul>
<li>web servlet：Tomcat、Jetty、Undertow</li>
<li>web reactive：Netty Web Server</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>生产准备特性：指标、健康检查、外部化配置等<ul>
<li>指标：/actuator/metrics</li>
<li>健康检查：/actuator/health</li>
<li>外部化配置：/actuator/configprops</li>
</ul>
</li>
</ul>
<hr>
<h3 id="web应用"><a href="#web应用" class="headerlink" title="web应用"></a>web应用</h3><p>传统servlet应用</p>
<ul>
<li>servlet主键：servlet、filter、listener</li>
<li>servlet注册：servlet注册、spring bean、RegistrationBean</li>
<li>异步非阻塞：异步servlet、非阻塞servlet</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot集成jsp</title>
    <url>/post/2ec52564/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring boot本身是不推荐使用jsp的，虽然本身兼容做得蛮好的。主要原因还是springboot 是内嵌web容器的，推荐打成jar包不是war包，而。并且前后端分工日益细化，更符合现代前段思想和注重用户体验的各种框架才是主流。</p>
<p>但是如果像我这种没写过前端的，想使用jsp也可以，只需要自建web.xml即可。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>gradle为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api</span><br><span class="line">   compile group: &#x27;javax.xml.bind&#x27;, name: &#x27;jaxb-api&#x27;, version: &#x27;2.3.1&#x27;</span><br><span class="line"></span><br><span class="line">   // https://mvnrepository.com/artifact/javax.activation/javax.activation-api</span><br><span class="line">   compile group: &#x27;javax.activation&#x27;, name: &#x27;javax.activation-api&#x27;, version: &#x27;1.2</span><br><span class="line">// https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper</span><br><span class="line">   compile group: &#x27;org.apache.tomcat.embed&#x27;, name: &#x27;tomcat-embed-jasper&#x27;, version: &#x27;9.0.12&#x27;</span><br><span class="line"></span><br><span class="line">   // https://mvnrepository.com/artifact/javax.servlet/jstl</span><br><span class="line">   compile group: &#x27;javax.servlet&#x27;, name: &#x27;jstl&#x27;, version: &#x27;1.2&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="改造程序主入口"><a href="#改造程序主入口" class="headerlink" title="改造程序主入口"></a>改造程序主入口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YummyApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(YummyApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(YummyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增配置项"><a href="#新增配置项" class="headerlink" title="新增配置项"></a>新增配置项</h3><p>application.properties文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure>
<h3 id="webxml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">		  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Session失效时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 首页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 编码过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- PUT请求过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HttpPutFormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HttpPutFormContentFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HttpPutFormContentFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发生错误时页面处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/WEB-INF/view/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/WEB-INF/view/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Throwable<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/WEB-INF/view/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="工程截图"><a href="#工程截图" class="headerlink" title="工程截图"></a>工程截图</h3><p><img src="https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/springboot_cut.png" alt></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>vim命令一览</title>
    <url>/post/91cb7c20/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h3 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h3><ul>
<li>打开单个文件<code>vim file</code> </li>
<li>同时打开多个文件<code>vim file1 file2 file3 ...</code> </li>
<li>在vim窗口中打开一个新文件<code>:open file</code> </li>
<li>在新窗口中打开文件<code>:split file</code> </li>
<li>切换到下一个文件<code>:bn</code> </li>
<li>切换到上一个文件<code>:bp</code> </li>
<li>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。<code>:args</code> </li>
<li>打开远程文件，比如ftp或者share folder<code>:e ftp://192.168.10.76/abc.txt</code>或者<code>:e \\qadrive\test\1.txt</code></li>
</ul>
<h4 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h4><ul>
<li><code>^</code>:移动光标到行首；</li>
<li><code>$</code>:移动光标到行尾；</li>
<li><code>ctrl-b</code>:类似于键盘上的”PgUp”(b为backword)</li>
<li><code>ctrl-f</code>：类似于键盘上的”PgDn”(f为forword)</li>
<li><code>G</code>：移动到末行；</li>
<li><code>1G</code>：移动到首行；</li>
<li><code>50G</code>：移动到50行；</li>
<li><code>H</code>：移动到当前窗口的首行；</li>
<li><code>M</code>：移动到当前窗口的中间位置；</li>
<li><code>L</code>：移动光标到当前窗口的最后一行；</li>
<li><code>w</code>:光标移动到下一个单词的词首；注：对于中文，连续的多个汉字作为一个word。</li>
<li><code>2w</code>:重复执行w操作2次；</li>
<li><code>e</code>:光标移动到下一个单词的词尾；</li>
<li><code>5e</code>:重复执行e操作5次；</li>
<li><code>b</code>：向前移动光标，移动到前一个单词的词首；</li>
</ul>
<h4 id="句字sentences直接移动操作"><a href="#句字-sentences-直接移动操作：" class="headerlink" title="句字(sentences)直接移动操作："></a>句字(sentences)直接移动操作：</h4><ul>
<li><code>)</code>:光标移动到下一句；</li>
<li><code>(</code>:光标移动到上一句；</li>
<li><code>3)</code>:光标移动到向下3句</li>
</ul>
<h4 id="段落paragraphs直接移动操作"><a href="#段落（paragraphs）直接移动操作：" class="headerlink" title="段落（paragraphs）直接移动操作："></a>段落（paragraphs）直接移动操作：</h4><ul>
<li><code>&#123;</code>:向上移动一个段落；</li>
<li><code>&#125;</code>:向下移动一个段落</li>
<li><code>3&#125;</code>:向下移动3个段落</li>
</ul>
<p>更多操作在vim Normal模式下输入 <code>:help cursor-motions</code></p>
<h3 id="vim-快速选中并复制粘贴替换一个单词"><a href="#vim-快速选中并复制粘贴替换一个单词" class="headerlink" title="vim 快速选中并复制粘贴替换一个单词"></a>vim 快速选中并复制粘贴替换一个单词</h3><ol>
<li>光标移动到aaa的开头，按 v 按e 按y</li>
<li>光标移动到bbb的开头，按 v 按e 按p<br> 也就说，快速选中一个单词，按v按e即可。</li>
</ol>
<ul>
<li>复制一个单词: <code>yaw</code> </li>
<li>复制一行: <code>yim</code> 光标在中间</li>
</ul>
<h3 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h3><ul>
<li><code>i</code> 在当前位置生前插入</li>
<li><code>I</code> 在当前行首插入</li>
<li><code>a</code> 在当前位置后插入</li>
<li><code>A</code> 在当前行尾插入</li>
<li><code>o</code> 在当前行之后插入一行</li>
<li><code>O</code> 在当前行之前插入一行</li>
</ul>
<h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><ul>
<li><code>/text</code>　　查找text，按n健查找下一个，按N健查找前一个。</li>
<li><code>?text</code>　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</li>
<li>vim中有一些特殊字符在查找时需要转义　　<code>.*[]^%/?~$</code> </li>
<li><code>:set ignorecase</code>　　忽略大小写的查找</li>
<li><code>:set noignorecase</code>　　不忽略大小写的查找</li>
<li>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按<code>*</code>或<code>#</code>键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</li>
<li><code>:set hlsearch</code>　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</li>
<li><code>:set nohlsearch</code>　　关闭高亮搜索显示</li>
<li><code>:nohlsearch</code>　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</li>
<li><code>:set incsearch</code>　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</li>
<li><code>:set wrapscan</code>　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</li>
</ul>
<h3 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h3><ul>
<li><code>ra</code> 将当前字符替换为a，当期字符即光标所在字符。</li>
<li><code>s/old/new/</code> 用old替换new，替换当前行的第一个匹配</li>
<li><code>s/old/new/g</code> 用old替换new，替换当前行的所有匹配</li>
<li><code>%s/old/new/</code> 用old替换new，替换所有行的第一个匹配</li>
<li><code>%s/old/new/g</code> 用old替换new，替换整个文件的所有匹配</li>
<li><code>:10,20 s/^/ /g</code> 在第10行知第20行每行前面加四个空格，用于缩进。</li>
<li><code>ddp</code> 交换光标所在行和其下紧邻的一行。</li>
</ul>
<h3 id="移动命令"><a href="#移动命令-1" class="headerlink" title="移动命令"></a>移动命令</h3><ul>
<li><code>h</code> 左移一个字符</li>
<li><code>l</code> 右移一个字符，这个命令很少用，一般用w代替。</li>
<li><code>k</code> 上移一个字符</li>
<li><code>j</code> 下移一个字符</li>
<li>以上四个命令可以配合数字使用，比如<code>20j</code>就是向下移动20行，<code>5h</code>就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符<code>10x</code>，在当前位置后插入3个！，<code>3a！&lt;Esc&gt;</code>，这里的Esc是必须的，否则命令不生效。</li>
<li><code>w</code> 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</li>
<li><code>b</code> 向后移动一个单词 <code>2b</code> 向后移动2个单词</li>
<li><code>e</code>，同w，只不过是光标停在单词尾部</li>
<li><code>ge</code>，同b，光标停在单词尾部。</li>
<li><code>^</code> 移动到本行第一个非空白字符上。</li>
<li><code>0</code>（数字0）移动到本行第一个字符上，</li>
<li><code>&lt;HOME&gt;</code> 移动到本行第一个字符。同0健。</li>
<li><script type="math/tex">` 移动到行尾 `3</script> 移动到下面3行的行尾</li>
<li><code>gg</code> 移动到文件头。 = [[</li>
<li><code>G</code>（shift + g） 移动到文件尾。 = ]]</li>
<li><code>f</code>（find）命令也可以用于移动，<code>fx</code>将找到光标后第一个为x的字符，<code>3fd</code>将找到第三个为d的字符。</li>
<li><code>F</code> 同f，反向查找。</li>
<li>跳到指定行，<code>:n</code>，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。</li>
<li><code>Ctrl + e</code> 向下滚动一行</li>
<li><code>Ctrl + y</code> 向上滚动一行</li>
<li><code>Ctrl + d</code> 向下滚动半屏</li>
<li><code>Ctrl + u</code> 向上滚动半屏</li>
<li><code>Ctrl + f</code> 向下滚动一屏</li>
<li><code>Ctrl + b</code> 向上滚动一屏</li>
</ul>
<h3 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h3><ul>
<li><code>u</code> 撤销（Undo）</li>
<li><code>U</code> 撤销对整行的操作</li>
<li><code>Ctrl + r</code> 重做（Redo），即撤销的撤销。</li>
</ul>
<h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><ul>
<li><code>x</code> 删除当前字符</li>
<li><code>3x</code> 删除当前光标开始向后三个字符</li>
<li><code>X</code> 删除当前字符的前一个字符。X=dh</li>
<li><code>dl</code> 删除当前字符， dl=x</li>
<li><code>dh</code> 删除前一个字符</li>
<li><code>dd</code> 删除当前行</li>
<li><code>dj</code> 删除上一行</li>
<li><code>dk</code> 删除下一行</li>
<li><code>10d</code> 删除当前行开始的10行。</li>
<li><code>D</code> 删除当前字符至行尾。D=d$</li>
<li><code>d$</code> 删除当前字符之后的所有字符（本行）</li>
<li><code>kdgg</code> 删除当前行之前所有行（不包括当前行）</li>
<li><code>jdG</code>（jd shift + g）   删除当前行之后所有行（不包括当前行）</li>
<li><code>:1,10d</code> 删除1-10行</li>
<li><code>:11,$d</code> 删除11行及以后所有的行</li>
<li><code>:1,$d</code> 删除所有行</li>
<li><code>J</code>(shift + j)　　删除两行之间的空行，实际上是合并两行。</li>
</ul>
<h3 id="拷贝和粘贴"><a href="#拷贝和粘贴" class="headerlink" title="拷贝和粘贴"></a>拷贝和粘贴</h3><ul>
<li><code>yy</code> 拷贝当前行</li>
<li><code>nyy</code> 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</li>
<li><code>p</code>  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</li>
<li><code>shift+p</code> 在当前行前粘贴</li>
<li><code>:1,10 co 20</code> 将1-10行插入到第20行之后。</li>
<li><code>:1,$ co $</code> 将整个文件复制一份并添加到文件尾部。</li>
<li>正常模式下按<code>v</code>（逐字）或<code>V</code>（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按<code>y</code>即可复制</li>
<li><code>ddp</code>交换当前行和其下一行</li>
<li><code>xp</code>交换当前字符和其后一个字符</li>
</ul>
<h3 id="剪切命令"><a href="#剪切命令" class="headerlink" title="剪切命令"></a>剪切命令</h3><ul>
<li>正常模式下按<code>v</code>（逐字）或<code>V</code>（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按<code>d</code>即可剪切</li>
<li><code>ndd</code> 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</li>
<li><code>:1,10d</code> 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</li>
<li><code>:1, 10 m 20</code> 将第1-10行移动到第20行之后。</li>
</ul>
<h3 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h3><ul>
<li><code>:wq</code> 保存并退出</li>
<li><code>ZZ</code> 保存并退出</li>
<li><code>:q!</code> 强制退出并忽略所有更改</li>
<li><code>:e!</code> 放弃所有修改，并打开原来文件。</li>
</ul>
<h3 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h3><ul>
<li><code>:split</code>或<code>:new</code> 打开一个新窗口，光标停在顶层的窗口上</li>
<li><code>:split file</code>或<code>:new file</code> 用新窗口打开文件</li>
<li><code>split</code>打开的窗口都是横向的，使用<code>vsplit</code>可以纵向打开窗口。</li>
<li><code>Ctrl+ww</code> 移动到下一个窗口</li>
<li><code>Ctrl+wj</code> 移动到下方的窗口</li>
<li><code>Ctrl+wk</code> 移动到上方的窗口</li>
</ul>
<h3 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h3><ul>
<li><code>:close</code> 最后一个窗口不能使用此命令，可以防止意外退出vim。</li>
<li><code>:q</code> 如果是最后一个被关闭的窗口，那么将退出vim。</li>
<li><code>ZZ</code> 保存并退出。</li>
<li>关闭所有窗口，只保留当前窗口<code>:only</code> </li>
</ul>
<h3 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h3><ul>
<li>按<code>q</code>键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，<code>@a</code>使用这个宏。</li>
</ul>
<h3 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h3><ul>
<li><code>:!command</code></li>
<li><code>:!ls 列出当前目录下文件</code></li>
<li><code>:!perl -c script.pl</code> 检查perl脚本语法，可以不用退出vim，非常方便。</li>
<li><code>:!perl script.pl</code> 执行perl脚本，可以不用退出vim，非常方便。</li>
<li><code>:suspend</code>或<code>Ctrl - Z</code> 挂起vim，回到shell，按<code>fg</code>可以返回vim。</li>
</ul>
<h3 id="注释命令"><a href="#注释命令" class="headerlink" title="注释命令"></a>注释命令</h3><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</p>
<ul>
<li><code>3,5 s/^/#/g</code> 注释第3-5行</li>
<li><code>3,5 s/^#//g</code> 解除3-5行的注释</li>
<li><code>1,$ s/^/#/g</code> 注释整个文档。</li>
<li><code>:%s/^/#/g</code> 注释整个文档，此法更快。</li>
</ul>
<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><ul>
<li><code>:help</code> or F1 显示整个帮助</li>
<li><code>:help xxx</code> 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。</li>
<li><code>:help &#39;number&#39;</code> Vim选项的帮助用单引号括起</li>
<li><code>:help &lt;Esc&gt;</code> 特殊键的帮助用&lt;&gt;扩起</li>
<li><code>:help -t</code> Vim启动参数的帮助用-</li>
<li><code>：help i_&lt;Esc&gt;</code> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回<br>其他非编辑命令</li>
</ul>
<p><a href="http://https://www.jianshu.com/p/117253829581">参考：vim命令全集</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>《伯恩斯新情绪疗法》1 认知扭曲</title>
    <url>/post/f6e86d6c/</url>
    <content><![CDATA[<h1 id="来源伯恩斯新情绪疗法"><a href="#来源《伯恩斯新情绪疗法》" class="headerlink" title="来源《伯恩斯新情绪疗法》"></a>来源《伯恩斯新情绪疗法》</h1><p>链接：<a href="https://pan.baidu.com/s/1V4CrTz9TfEUvePTPL2586w">https://pan.baidu.com/s/1V4CrTz9TfEUvePTPL2586w</a><br>提取码：76a3 </p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>处于抑郁状态的病患会感到情绪低落，或烦躁不安，对平常喜欢的事提不起兴趣、注意力不集中、记忆力减退、思维迟缓，有时还自责内疚，严重时甚至有自杀想法和行为。抑郁状态严重影响生活质量，但我国抑郁症的就医率不足10%。</p>
<p>对于抑郁的一些认识误区：</p>
<ul>
<li>抑郁症会被更努力的工作或学习消灭</li>
<li>抑郁症不是病，只是正常的悲伤或某些人的无病呻吟而已</li>
<li>抑郁症患者需要吃一辈子借助药物</li>
<li>抑郁症患者总会哭</li>
<li>不该将自己的抑郁症说出来，那样只会更麻烦</li>
<li>抑郁症治不好</li>
<li>悲观内向的人才会患抑郁症</li>
<li>……</li>
</ul>
<p>正如风寒感冒需要药物或是就诊重回健康状态，心理感冒也需要早发现、早治疗，让其重回健康状态。</p>
<p>对于有轻度或中度抑郁倾向的人来说，学习这本书，有病治病，没病防身。</p>
<h1 id="十种认知扭曲"><a href="#十种认知扭曲" class="headerlink" title="十种认知扭曲"></a>十种认知扭曲</h1><p>思维陷阱会影响身心健康，所以需要识别和改变这些思维陷阱。</p>
<p>思维陷阱的问题在于，你的感觉并不是事实！事实上，你的感觉自身甚至不能算数——它只不过是你想问题的方式的一面镜子。但是这种不正常的情绪感觉就和没被扭曲的思想所创造出来的真正感觉一样真实，所以你会自动地认为它们也是真实的。</p>
<p>而改变这种认知的方法，是认识到——你的思想创造了你的情绪，你的情绪不能证明你的思想是正确的。不愉快的感受仅仅表明你在消极地思考某些事情。因此，先学习改正自己在伤心时愚弄自己的扭曲思想。同时，你将有机会重新评价一些使你情感脆弱，并使你的情绪产生破坏性波动的价值观念和假设。</p>
<h2 id="1-非黑即白全有全无你以黑白分明的范畴来看待事物如果你的表现不够完美你就会认为自己彻底失败"><a href="#1-非黑即白-全有全无：你以黑白分明的范畴来看待事物，如果你的表现不够完美，你就会认为自己彻底失败。" class="headerlink" title="1. 非黑即白/全有全无：你以黑白分明的范畴来看待事物，如果你的表现不够完美，你就会认为自己彻底失败。"></a><strong>1. 非黑即白/全有全无</strong>：你以黑白分明的范畴来看待事物，如果你的表现不够完美，你就会认为自己彻底失败。</h2><p>你倾向于用一种极端的、黑白分明的标准来评价你自己。其思想基础是<strong>完美主义</strong>。它使你害怕任何错误与不完美，因为那时你会认为自己完全输了，你会感觉自身不足，没有价值。</p>
<p>这种评价事物的方法是不现实的，因为生活很少是绝对的非此即彼。比如说，没有一个人是绝对的优秀或绝对的愚蠢。同样的，也没有人会是绝对的光彩照人或绝对的丑陋无比。</p>
<p>在宇宙中，<strong>绝对肯定是不存在的</strong>。如果你总是想用绝对的范畴来套自己，那你会一直很抑郁，因为你的知觉与现实是不吻合的。你会一直不信任自己，因为，不管你做了什么，都永远不会符合你那夸张了的期望。</p>
<p><em>例子：政治家说：“我输掉了州长竞选，所以我现在成了零。”。一位成绩一直A的学生在一次考试中得了B之后说：“现在我算是全输了。”</em></p>
<h2 id="2-过于概括以偏概全你把一个孤立的消极事件看做是一个永远会持续下去的失败模式"><a href="#2-过于概括-以偏概全：你把一个孤立的消极事件看做是一个永远会持续下去的失败模式。" class="headerlink" title="2. 过于概括/以偏概全：你把一个孤立的消极事件看做是一个永远会持续下去的失败模式。"></a><strong>2. 过于概括/以偏概全</strong>：你把一个孤立的消极事件看做是一个永远会持续下去的失败模式。</h2><p>如果你极度地概括这种情况，你会武断地认为，一件事一旦发生了，它就会像黑桃J一样在你身上反复发生。由于要发生的事不可避免地是不愉快的，所以你就会感到难过。</p>
<p><strong>拒绝之痛</strong>几乎全是由于过于概括引起的。当这种事情发生时，一个人遇到的不过是短时的失望，而不应该是严重的烦乱。</p>
<p><em>例子：一位害羞的年轻人鼓足勇气约一个女孩。这位女孩由于有约在先，于是就礼貌地拒绝了。于是这位男孩就对自己说：“我再也不约人了。没有女孩愿意和我约会。我的一生都会孤独而悲惨。”在他扭曲的认知里，他的推论就是，因为她拒绝过他一次，所以她永远都会这么做，而既然所有女人都100%具有相同品位，那么地球上任何一位合格的女士都会反复不断地拒绝他。</em></p>
<h2 id="3-心灵过滤选择性吸收你选择一段消极细节反复思考这段细节-结果在你眼里整个现实都变得黑暗起来就像一滴墨水染黑了整杯水一样"><a href="#3-心灵过滤-选择性吸收：你选择一段消极细节，反复思考这段细节。结果，在你眼里，整个现实都变得黑暗起来，就像一滴墨水染黑了整杯水一样。" class="headerlink" title="3. 心灵过滤/选择性吸收：你选择一段消极细节，反复思考这段细节。结果，在你眼里，整个现实都变得黑暗起来，就像一滴墨水染黑了整杯水一样。"></a><strong>3. 心灵过滤/选择性吸收</strong>：你选择一段消极细节，反复思考这段细节。结果，在你眼里，整个现实都变得黑暗起来，就像一滴墨水染黑了整杯水一样。</h2><p>当你抑郁时，你就戴上了一副特别的有色眼镜，经过它的过滤，什么东西都变得消极。<strong>你只让消极的东西进入你的思想意识里。</strong>由于你还不了解这一“过滤程序”，所以你得出结论说什么事情都是消极的。术语将这一过程称做“选择性吸收”。这是一种坏习惯，它会让你承受不必要的痛苦。</p>
<p><em>例子：有一位患抑郁症的大学生听到有人在取笑她的好友。她感到很愤怒，因为她想：“人类就是这样——残忍而又无情！”她忽略了这样一个事实，那就是，在此前的日子里，很少有人——如果有的话——对她残酷无情！还有一次，在她第一次期中考试后，她确信在满分一百分中她丢了大约有十七分。她对这十七个问题耿耿于怀，于是就得出结论说她会因为这次考试的失败而退学。当试卷发回来后，上边粘了一个纸条：“你得了一百分的八十三分。这是今年学生里边的最高分。A+。”</em></p>
<h2 id="4-贬损积极颠覆积极体验你拒绝承认积极的经验你会找这样那样的理由认为它们不算数-这样你就可以坚持和你日常经验相矛盾的消极信念了"><a href="#4-贬损积极-颠覆积极体验：你拒绝承认积极的经验，你会找这样那样的理由认为它们“不算数”。这样你就可以坚持和你日常经验相矛盾的消极信念了。" class="headerlink" title="4. 贬损积极/颠覆积极体验：你拒绝承认积极的经验，你会找这样那样的理由认为它们“不算数”。这样你就可以坚持和你日常经验相矛盾的消极信念了。"></a><strong>4. 贬损积极/颠覆积极体验</strong>：你拒绝承认积极的经验，你会找这样那样的理由认为它们“不算数”。这样你就可以坚持和你日常经验相矛盾的消极信念了。</h2><p>一种更为特别的心理幻想是<strong>某些抑郁病人总是倾向于把中性的甚至是积极的体验转化成消极的体验</strong>。你不仅是无视积极体验，事实上你又快又准地把积极体验转化成了噩梦般的消极体验。假如你处于一种抑郁状态，你可能<strong>会迅速地把金子般的快乐转化成低落的情绪。不过你并不是有意识的——或许你甚至还没有意识到自己到底在做什么。</strong></p>
<p>贬损积极的东西是认知扭曲中最具破坏性的一种形式。你就像一位科学家一样极力发现证据支持自己的烦恼假设。支配你消极想法的这些假设通常会表现为“我是二流的”这种形式。每当你有一种消极体验，你就会反复考虑这件事情，然后得出结论：“这证明了我早就知道的东西。”相反，如果你有一种积极体验，你就会告诉自己：“纯属侥幸，不算数的。”</p>
<p>你的消极想法或许没有那么极端，不过可能你还是<strong>每天数次在不经意间忽略掉了发生在你身上的许多真正积极的东西。这种行为使生活逊色不少，并使事情变得不必要的黯淡。</strong></p>
<p><em>例子：假如有人恭维你的外貌或工作，你或许会下意识地告诉自己：“可真是好话。”念头轻轻一转，你就否定了他们的恭维。当你告诉他们：“噢，没什么，真的”时，你也是在做同样的事情。假如你不断地对所发生的事情泼冷水，也就难怪你的生活那么阴冷了！</em></p>
<h2 id="5-跳跃式结论先知错误即便没有确定的事实令人信服地支持你的结论你也会对事情作出一个消极的解释"><a href="#5-跳跃式结论-先知错误：即便没有确定的事实令人信服地支持你的结论，你也会对事情作出一个消极的解释。" class="headerlink" title="5. 跳跃式结论/先知错误：即便没有确定的事实令人信服地支持你的结论，你也会对事情作出一个消极的解释。"></a><strong>5. 跳跃式结论/先知错误</strong>：即便没有确定的事实令人信服地支持你的结论，你也会对事情作出一个消极的解释。</h2><p>武断地跳到一个不被周围事实所支持的消极结论上来。包括“测心术” “先知错误”</p>
<p>测心术：你假定其他人都瞧不起你，你对此深信不疑，甚至不愿去检验一下。</p>
<p>先知错误：就好像你有一颗只预言不幸的水晶球一样。你猜想某些事情要发生，然后你就把这个预言当做一个事实，尽管这并不是真实的。</p>
<p><em>例子：假如你打电话给一个朋友，而他又没有能够按时回电话，你可能就会变得抑郁，你会认为他可能其实已经收到了，但是没有什么兴趣给你回（测心术。）于是你会感到心痛，决定不再打电话看看是怎么回事，你会对自己说：“如果我再回电话的话，他会认为我很讨厌。我只好装傻算了。”由于这一消极推测（先知错误），你会回避你的朋友，并且认为受到了羞辱。三周后，你了解到你的朋友根本没有收到你的信息。事实证明，所有的煎熬都不过是自己营造的一堆假象。</em></p>
<h2 id="6-夸张双目镜把戏你夸大了事情的重要性比如你弄糟了的事情或者别人的成绩或者不合适地夸小事情直到它们显得很小你个人的优良品质或者别人的不足"><a href="#6-夸张-双目镜把戏：你夸大了事情的重要性（比如你弄糟了的事情或者别人的成绩），或者不合适地夸小事情，直到它们显得很小（你个人的优良品质或者别人的不足）。" class="headerlink" title="6. 夸张/双目镜把戏：你夸大了事情的重要性（比如你弄糟了的事情或者别人的成绩），或者不合适地夸小事情，直到它们显得很小（你个人的优良品质或者别人的不足）。"></a><strong>6. 夸张/双目镜把戏</strong>：你夸大了事情的重要性（比如你弄糟了的事情或者别人的成绩），或者不合适地夸小事情，直到它们显得很小（你个人的优良品质或者别人的不足）。</h2><p>要么不合比例地夸大事情，要么又不合比例地缩小事情。</p>
<p><strong>夸大通常发生在你看待自己的错误、恐惧或不完美之处时，你夸大了它们的重要性</strong>.你通过双目望远镜的末端来看你的错误，使它们看起来又大又怪。这又可以称做<strong>“灾难化”，因为你把一件普通的消极事件看成了吓人的怪物</strong>。</p>
<p>当你考虑自己的力量时，你又会反着去做——你通过双目镜的另外一端去看待事情，这样事情就显得既微小又不重要。<strong>如果你夸大你的不足，缩小你的优点，你肯定会觉得自己卑贱</strong>。不过问题不在你——而在于你所戴的可恶的透镜上！</p>
<h2 id="7-情绪推理假定自己的消极情绪必然反映了事情的真实状况"><a href="#7-情绪推理：假定自己的消极情绪必然反映了事情的真实状况" class="headerlink" title="7. 情绪推理：假定自己的消极情绪必然反映了事情的真实状况"></a><strong>7. 情绪推理</strong>：假定自己的消极情绪必然反映了事情的真实状况</h2><p><strong>把自己的情绪当做真理的证据</strong>。</p>
<p>你的逻辑是：<em>“我觉得自己像一颗哑火的臭弹，所以我就是一颗臭弹。”</em>这种推理是一种误导，因为你的感情反映了你的思想和信念。如果它们被扭曲了——许多情况下都是这样，你的情绪就没有了合理性。</p>
<p><strong>情绪推理的一个常见后果就是拖延</strong>。你回避擦桌子，因为你告诉自己：“我一想起脏兮兮的桌子就恶心，擦桌子是不可能的。”六个月后，你终于做了这件事。事实证明这件事是很让人满意的，并没有那么艰苦。<strong>你一直在愚弄你自己，因为你养成了一种让消极感情指导你行为方式的习惯。</strong></p>
<p><em>例子：“我觉得有罪，所以我肯定干过坏事。”“我感到灭顶般的无望，所以我的问题肯定不可能解决。”“我感到有欠缺，所以，我一定是一个无价值的人。”“我没心情做事情，所以我最好躺在床上。”或“我很恼你，这表明你做得不好，而且总是想利用我。”</em></p>
<h2 id="8-应当如此必须强迫症你试图用应该或不应该来激发自己就好像在期望你做什么事之前应该先鞭笞你或惩罚你一样-必须和本该同样也是罪魁祸首-这种情绪的结果是一种负罪感-当你用应该陈述来要求别人时你会体会到愤怒-灰心和怨恨"><a href="#8-应当如此-”必须“强迫症：你试图用应该或不应该来激发自己，就好像在期望你做什么事之前应该先鞭笞你或惩罚你一样。“必须”和“本该”同样也是罪魁祸首。这种情绪的结果是一种负罪感。当你用应该陈述来要求别人时，你会体会到愤怒、灰心和怨恨。" class="headerlink" title="8. 应当如此/”必须“强迫症：你试图用应该或不应该来激发自己，就好像在期望你做什么事之前应该先鞭笞你或惩罚你一样。“必须”和“本该”同样也是罪魁祸首。这种情绪的结果是一种负罪感。当你用应该陈述来要求别人时，你会体会到愤怒、灰心和怨恨。"></a><strong>8. 应当如此/”必须“强迫症</strong>：你试图用应该或不应该来激发自己，就好像在期望你做什么事之前应该先鞭笞你或惩罚你一样。“必须”和“本该”同样也是罪魁祸首。这种情绪的结果是一种负罪感。当你用应该陈述来要求别人时，你会体会到愤怒、灰心和怨恨。</h2><p>你试图通过说“我应该做这个”、“我必须做这个”来激发自己。这种陈述会让你感到有一种压力和怨恨。矛盾的是，你最终会感到冷淡和缺乏动力。</p>
<p>在日常生活中，应该陈述为你带来了许多不必要的情绪紊乱。<strong>当你自己的行为在现实中没有达到标准时，你的应该陈述就会使你讨厌自己，让自己感到羞耻和内疚。</strong>当其他所有人的行为没有达到你的期望时——这种情况经常发生，你会感到痛苦，并认为自己才是对的。<strong>你要么改变自己的期望以接近现实，要么永远被人们的行为搞得情绪沮丧。</strong></p>
<h2 id="9-贴标签刻板印象贴标签是过于概括的一种极端形式-你不再描述你的错误而是为你自己贴上一个消极的标签我是一个失败者-当别人的行为以一种不当的方式与你发生关系时你也会给他贴上一个标签他是一个该死的讨厌鬼-标签不当是指用高度主观的语言或高度情绪化的语言来描述一件事情"><a href="#9-贴标签-刻板印象：贴标签是过于概括的一种极端形式。你不再描述你的错误，而是为你自己贴上一个消极的标签：“我是一个失败者。”当别人的行为以一种不当的方式与你发生关系时，你也会给他贴上一个标签：“他是一个该死的讨厌鬼。”-标签不当是指用高度主观的语言或高度情绪化的语言来描述一件事情。" class="headerlink" title="9. 贴标签/刻板印象：贴标签是过于概括的一种极端形式。你不再描述你的错误，而是为你自己贴上一个消极的标签：“我是一个失败者。”当别人的行为以一种不当的方式与你发生关系时，你也会给他贴上一个标签：“他是一个该死的讨厌鬼。” 标签不当是指用高度主观的语言或高度情绪化的语言来描述一件事情。"></a><strong>9. 贴标签/刻板印象</strong>：贴标签是过于概括的一种极端形式。你不再描述你的错误，而是为你自己贴上一个消极的标签：“我是一个失败者。”当别人的行为以一种不当的方式与你发生关系时，你也会给他贴上一个标签：“他是一个该死的讨厌鬼。” 标签不当是指用高度主观的语言或高度情绪化的语言来描述一件事情。</h2><p>为自己贴标签意味着你<strong>基于个人所犯的错误为自己创造了一个完全消极的自我形象</strong>。贴标签是过于概括的一种极端形式。其背后的哲学是“衡量一个人的标准就是看他所犯的错误。”</p>
<p>给自己贴标签不仅是自己打击了自己，而且是非理性的。你的自我不能够和任何你做的某件事情相等同。你的生命是一系列复杂的，永远变动着的思想、情感和行为之流。换句话说，你更像一条河而不是一尊雕像。别再试图用消极的标签定义自己了，它们是非常简单、非常错误的。</p>
<p>当你给别人贴标签时，你难免会产生敌意。一个常见的例子就是老板会把他不时会发怒的秘书称做“一个不合作的婊子”。由于贴上了这种标签，他会憎恨她，不时会跳起来指责她。反过来，她也会把他称做“感觉迟钝的沙文主义者”，而且一有机会就抱怨他。长此以往，他们就互相掌握了对方的要害，<strong>把对方的每一个缺点或不当之处都看做是对方没有价值的表现。</strong></p>
<p><strong>标签不当是指用不准确的言辞或过于情绪化的言辞来描述一件事情</strong>。<em>比如，一位正在节食的妇女吃了一碟冰淇淋，然后她就想：“我是多么讨厌，多么恶心自己呀。我是猪。”这种想法让她感到难过，于是她就吃下了整夸脱冰淇淋！</em></p>
<p><em>比如，当你在第十八洞失球时，你可能会说：“我生就是个失败者”而不说“这一洞我打坏了。”同样地，当你投资的股票只跌不涨时，你或许会想：“我是一个失败者”而不说“我投资错了。”</em></p>
<h2 id="10-归己化你会把自己看作是许多外界消极事件的原因事实上你并不应该为这些事负主要责任"><a href="#10-归己化：你会把自己看作是许多外界消极事件的原因，事实上你并不应该为这些事负主要责任。" class="headerlink" title="10. 归己化：你会把自己看作是许多外界消极事件的原因，事实上你并不应该为这些事负主要责任。"></a><strong>10. 归己化</strong>：你会把自己看作是许多外界消极事件的原因，事实上你并不应该为这些事负主要责任。</h2><p>即便毫无根据，你也会假定自己应该为某一消极事件负责。你武断地认为事情的发生是你的过错，或反映了你的不足，即便在这件事上你并无责任。</p>
<p>归己化使你充满负罪感。你深受责任的麻痹与重负之苦，责任会迫使你把整个世界都压到自己肩上。你会在影响别人还是控制别人之间困惑。作为一名教师、顾问、家长、医生、销售员、经理，你肯定会影响和你交往的其他人，但是没有人会期望你控制他们。别人的所作所为最终是他们自己的责任，而不是你的责任。</p>
<h2 id="关于保持专注的一些记录"><a href="#关于保持专注的一些记录" class="headerlink" title="关于保持专注的一些记录"></a>关于保持专注的一些记录</h2><p>不能专注的原因：<br>1、压力<br>2、做不喜欢的事情<br>3、短期易获的快乐</p>
<p>解决问题的方法<br>1、处理压力源<br>2、做有价值的事情</p>
<p>3、戒除（部分）短期易获快乐源<br>戒除方法<br>a,冥想<br>b,深度工作状态<br>c,不做清单</p>
<p>4、控制快乐的摄取方式<br>a,少玩手机（对，说的就是你）<br>b,定义结束时间<br>c，建立工作时间段（番茄时间）<br>d,优先事项清单（遵循2/8法则）</p>
<p>1.Tell your mind what you want;<br>告诉你的大脑你想要什么<br>2.Link massive pleasure to going there and pain<br>to not going there;<br>把达到目标的强烈快乐感与停滞不前的痛苦联系起来<br>3.Change the picture,change the words;<br>改变大脑中画面和语言<br>4.Make the familiar , unfamiliar and unfamiliar ,familiar.<br>把熟悉的东西变陌生，把陌生东西变熟悉</p>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>psychology</tag>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>《伯恩斯新情绪疗法》2 建立自尊</title>
    <url>/post/283c93cb/</url>
    <content><![CDATA[<p>前文：</p>
<p><a target="_blank" href="https://songzi.info/post/f6e86d6c/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">《伯恩斯新情绪疗法》1 认知扭曲 | 毫末室 (songzi.info)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://songzi.info/post/f6e86d6c/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<h1 id="认识抑郁状态"><a href="#认识抑郁状态" class="headerlink" title="认识抑郁状态"></a>认识抑郁状态</h1><p>概括而言四个词描述——被打败、有缺陷、遭遗弃、被剥夺</p>
<p>几乎所有此类的消极情绪反应所造成的破坏最终都导致一个结果，那就是缺乏自信。它会把一些细小的错误或缺陷放大成为一个巨大的个人失败的象征。</p>
<p>某些抑郁患者的完美主义冲动，在他人眼中，是一种打击自己的不现实行为。但在其本人看来，这种自我毁灭式的冲动既真实又合理。即对于身处其中的本人而言，很难看清这种思维的<strong>非逻辑性</strong>。从而导致，你会坚信自己是非常差的，是没有价值的。任何与这种想法相悖的看法听起来都是不真实的。</p>
<p>对于这种心理状态，应当回答以下问题：</p>
<ul>
<li>人天生就是有缺陷的吗？</li>
<li>抑郁病人事实上面对的是有关他们自己的真象吗？</li>
<li>什么才是自尊的真正源泉？</li>
</ul>
<h1 id="建立自尊认知治疗的方式"><a href="#建立自尊（认知治疗的方式）" class="headerlink" title="建立自尊（认知治疗的方式）"></a>建立自尊（认知治疗的方式）</h1><ol>
<li><p>认识到<strong>你的价值不能等同于你所做的事情</strong>。成就令人满足，但并非幸福之所在。<strong>基于成绩的自我价值是一种“虚假的自尊”，而不是真实的东西。</strong>我有许多病人，他们非常成功，但是却抑郁，他们都同意这一点。有效的自我价值感同样也不基于你的相貌、天赋、名声和财富。同样，爱情、赞同、友谊、拉近人际关系的能力等也都不能证明你的内在价值。许多抑郁病人事实上并不缺少爱，但是没用，<strong>因为他们的自爱和自尊全都丧失了。</strong></p>
<p>归根结底，<strong>只有你的自我价值感才能决定你的真实感受</strong>。</p>
</li>
<li><p><strong>始终拒绝接受这种无价值感</strong>。系统地重新评估他们心目中的消极自我形象。</p>
<p>“你坚持说你内在的某些方面是失败的，你有没有想过，你真的是对的吗？”</p>
</li>
<li><p><strong>仔细审视对自己的评价</strong>。你用来证明自己没有价值的那些证据通常是没有意义的。</p>
<p>在你陷于抑郁状态时，你清晰思考的能力有所丧失；你不能很准确地观察事情。<strong>消极事件变得越来越重要，最终完全支配了你——你搞不明白在所发生的事情中哪些是扭曲的。</strong>对你来说，这些扭曲的东西是非常真实的，你所创造的幻觉地狱是非常可信的。因此，你越是觉得抑郁和悲惨，你的思想就会越扭曲。反过来，假如你的心智不扭曲，你就不可能体验到自我价值不足的抑郁情绪。</p>
</li>
<li><p>对于来自外在环境的评价，需要进行筛选和识别，切不可将其直接作为内在评价标准。这种类似的带有攻击性的情感控制机制，值得警惕。</p>
</li>
</ol>
<h2 id="增进自信的方法需要实践与练习"><a href="#增进自信的方法（需要实践与练习）" class="headerlink" title="增进自信的方法（需要实践与练习）"></a>增进自信的方法（需要实践与练习）</h2><p>在处理无价值感问题上要完成三个目标：</p>
<p>快速而又根本性地改变你的<strong>思考方式</strong>、<strong>感受方式</strong>和<strong>行为方式</strong>。</p>
<h3 id="1-反驳内在批评"><a href="#1-反驳内在批评" class="headerlink" title="1. 反驳内在批评"></a>1. 反驳内在批评</h3><p>无价值感是由于<strong>你内在的自我批评性对话造成的</strong>。是像“我真不好”“我一文不值”“我比别人要低上一等”这样的自贬性陈述导致了你的绝望感受和自尊心的降低。</p>
<p>如何进行对内在批评的反驳</p>
<ol>
<li>一旦你头脑里有了自我批评的想法，要马上理清这些想法并把它们记录下来；</li>
<li>明白为什么这些想法是扭曲的；</li>
<li>对这些想法反唇相讥，以便培养一个更为现实的自我评价体系。</li>
</ol>
<p>具体实践： 三栏法/<strong>记情绪账</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>事实场景</th>
<th>下意识想法（自我批评）</th>
<th>认知扭曲</th>
<th>理性反应（自我辩护）</th>
</tr>
</thead>
<tbody>
<tr>
<td>重要会议将要迟到</td>
<td>“我从来没有做对过事情”&lt;/br&gt;”我总是迟到”</td>
<td>过度概括、贴标签、夸张</td>
<td>过去一年内我实际迟到次数屈指可数，这次迟到是个正常的意外。&lt;/br&gt;</td>
</tr>
<tr>
<td>给朋友打电话ta没有接</td>
<td>“他可能其实已经收到了，但是没有什么兴趣回电话”&lt;/br&gt;“我被羞辱了“&lt;/br&gt;”如果我再回电话的话，他会认为我很讨厌。我只好装傻算了。”</td>
<td>夸张、心灵过滤、过于概括</td>
<td>他可能在忙别的事情，并没有必要为了一个电话而影响心情。我们之间并没有矛盾，不回复我并不代表着对我的羞辱。</td>
</tr>
<tr>
<td>领导批评你的工作</td>
<td>“我像奴隶一样卖命工作，我得到的就是这样的回报！混蛋！”&lt;/br&gt;”我总是出错，我从没有做对过事情”</td>
<td>过度概括、贴标签、夸张…</td>
<td>领导的批评有中肯的内容，即使存在人身攻击的内容，但他不是混蛋，他只是急躁了一点，有点不理智。这次的问题并不能反映我自身的价值，我不会因为一个项目的几个纰漏就失去工作价值（甚至存活于世的价值）。给自己贴上奴隶的标签也是愚蠢的。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-心理生物反馈"><a href="#2-心理生物反馈" class="headerlink" title="2. 心理生物反馈"></a>2. 心理生物反馈</h2><p>用一个计数器来即时记录/监控你的消极想法，这种方法非常有用。</p>
<p>你大脑里只要一有消极想法就马上进行记录1分，记住要一直对类似想法保持警觉。每天休息前，<strong>记下你一天所得的总分</strong>，把它写进日记本里。</p>
<p>开始的时候你会发现数字在上升，这种情况要持续几天，因为你越来越知道怎样辨别你的批判性想法了。随后你会发现你每天的分数会爬升到一个平台，稳定一周到十天左右，然后就会下降。这表明你的有害思想在渐渐减少，你开始好起来。这种方法通常需要三周时间。</p>
<h2 id="3-处理问题不要闷闷不乐"><a href="#3-处理问题不要闷闷不乐" class="headerlink" title="3. 处理问题不要闷闷不乐"></a>3. 处理问题不要闷闷不乐</h2><p>给自己贴负面标签的做法：以一种总体的眼光看待自己，对自己做了一个道德判断，说自己是一个坏人/坏员工/坏父母/坏孩子……这种批评使人感到无能为力<strong>，因为它给人一种印象，好像本人出了一个这么坏的大问题，没有人能够改变它。她为这个标签而难过，这使得她不能认清问题的真实所在，也使得她不能够把问题分解成不同的部分，因而也就不能找到合适的解决方法。</strong></p>
<p>当你看不起自己时，你要问一问自己到底是什么思想在起作用，因为这时你是试图在用像“蠢人”、“次货”、“傻帽”这样的消极标签来定义真实的自我。<strong>一旦你撕下这些破坏性的标签，你会发现它们是很任意的，也是毫无意义的。它们事实上遮掩了问题，制造了假相和让人悲观的气氛。一旦去掉它们，你就可以理清并处理实际存在的任何问题了。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Q：如何做到消灭无意义感、无价值感</p>
<p>A：你必须认识到人的生命是一个持续的过程，期间既有身体方面的持续变化，又有思想、感受和行为的一系列快速变化。因而，<strong>你的生命是一种经验的演进，是一种持续的流动</strong>。<strong>你不是一个物品，所以标签过于局限，很不准确，过于概括。</strong>像“没有价值”、“低贱”等这样一些抽象标签与什么也联系不上，因而什么意义也没有。</p>
<p>Q：仍然相信自己“低人一等”</p>
<p>A：这个错误正是出在<strong>情绪推理</strong>上。<strong>你的感受确实决定不了你的价值，它只能决定你舒服或不舒服这种相对状态。</strong>虚弱无用、痛苦悲惨的内在状态并不能表明你是一个虚弱的、没有价值的人，只是你认为你是这样的；因为你暂时处于抑郁情绪中，所以你在毫无逻辑地、不合常理地思考你自己。</p>
<p>Q：怎样才能建立起自尊呢？</p>
<p>A：你不必一定要去做什么事情！你不必去做特别有价值的事来创造或保有你的自尊，<strong>你需要做的只是关掉内心批判指责的声音。</strong>批判性的内在声音是错误的！<strong>你的内在自虐起源于非逻辑的、扭曲的思想。你的无价值感不是基于真理，它只是抑郁病症核心中生长出来的脓疮。</strong></p>
<p>以上做法的关键步骤可以概括为：</p>
<ol>
<li>让下意识消极想法化解，并把它们记下来。不要让它们在你头脑中嗡嗡作响。捕捉这些想法，把它们记在纸上。　　</li>
<li>读一遍认知的十个扭曲。明白你到底在哪里绕进去了，然后相应地把它们分解掉。</li>
<li>用更客观的想法来代替让你瞧不起自己的想法。当你这么做时，你就会开始感觉好起来。你的自尊心将大大提高，你的无价值感（当然，包括你的抑郁）将会消散。</li>
</ol>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>psychology</tag>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>《伯恩斯新情绪疗法》4 语言柔道</title>
    <url>/post/177f0c34/</url>
    <content><![CDATA[<p>前文：</p>
<p><a target="_blank" href="https://songzi.info/post/f6e86d6c/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">《伯恩斯新情绪疗法》1 认知扭曲 | 毫末室 (songzi.info)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://songzi.info/post/f6e86d6c/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<p><a target="_blank" href="https://songzi.info/post/283c93cb" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">《伯恩斯新情绪疗法》2 建立自尊 | 毫末室 (songzi.info)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://songzi.info/post/283c93cb</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<p><a target="_blank" href="http://songzi.info/post/3a21ee98" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">《伯恩斯新情绪疗法》3 克服拖延 | 毫末室 (songzi.info)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>http://songzi.info/post/3a21ee98</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<h1 id="处理语言滥用的技巧"><a href="#处理语言滥用的技巧" class="headerlink" title="处理语言滥用的技巧"></a>处理语言滥用的技巧</h1><h2 id="对批评敏感"><a href="#对批评敏感" class="headerlink" title="对批评敏感"></a>对批评敏感</h2><p>许多抑郁事件都是由<strong>外在批评</strong>引起的。</p>
<p>如何能够无畏地面对批评的秘密及具体步骤，从而帮助克服并消除对批评的异常敏感。</p>
<h3 id="为什么对批评敏感"><a href="#为什么对批评敏感？" class="headerlink" title="为什么对批评敏感？"></a>为什么对批评敏感？</h3><ul>
<li>不是其他人、或他人作出的批评性意见让你难过。</li>
</ul>
<blockquote>
<p>在你一生中，没有任何一个时刻单是他人的批评性意见自身会让你难过——即便是在最小程度上。不管这一种批评是多么的恶毒，多么的无情或多么的残忍，它们都没有能力扰乱你，或者制造哪怕很小一点的不适。</p>
</blockquote>
<ul>
<li>在这个世界上，只有一个人有能力将你达到——这个人就是你自己。</li>
<li>当别人批评你时，某些消极的想法就会自动的在你脑中产生。你的情绪反应是由这些想法引起的，而不是由别人说了什么引起的。让你烦恼的这些想法总是既有第三章所描述的同样的心智错误类型：过于概括，要么全有要么全无思想，心灵过滤，贴标签。</li>
</ul>
<p>克服对批评的恐惧要做到</p>
<ul>
<li><p>关注你的心理过程：学会识别你在受到批评时所具有的消极想法<strong>（使用双栏法）</strong></p>
</li>
<li><p>如果别人批评你，他们的评论或对或错。如果评论是错误的，事实上没有什么可烦恼的。</p>
</li>
<li>就算批评是对的，你仍然没有理由受打击。你并不期望完美。你只需要承认错误，采取力所能及的步骤改进就可以了。它听起来很简单（也确实很简单！），但是需要付出努力把这一洞见变成情感现实。</li>
<li>只有你自己的想法才会让你烦恼，如果你学会更现实地思考问题，你就不会那么烦恼。</li>
</ul>
<h2 id="面对批评做法技巧"><a href="#面对批评做法-技巧" class="headerlink" title="面对批评做法/技巧"></a>面对批评做法/技巧</h2><h3 id="一-移情"><a href="#一、移情" class="headerlink" title="一、移情"></a>一、移情</h3><ul>
<li>需要避免：立刻纠结于批评的动机（帮助/伤害）、批评的对错</li>
<li>应该问这个人一连串的问题，以发现他到底是什么意思<ul>
<li>问问题是要避免下判断或做反驳</li>
<li>要不断地问更多特别的东西，从批评者的角度看待世界</li>
<li>如果这个人是非常模糊的，以贴标签的方式攻击你，那你就更详细地追问他或她，希望能够准确地指出这个人到底在批评你哪一点</li>
</ul>
</li>
<li>即便是你受到完全不公正的批评，也要通过<strong>问一些具体的问题以移情的方式</strong>对此做出反应。准确的弄清你所受到的批评的含义。</li>
</ul>
<p>例子：</p>
<blockquote>
<p>你（扮演一个愤怒的批评者的角色）：伯恩斯博士，你是狗屁。　　</p>
<p>戴维：我哪一点是狗屁？　　</p>
<p>你：你所说的和所做的一切都是狗屁。你感觉迟钝，自我中心，低级无能。　　</p>
<p>戴维：咱们说详细一点吧。我希望你能再具体一些。很显然，我肯定做了或说了一些让你感到难过的事情。我说的哪些听起来是感觉迟钝的呢？我做了什么给你一种我是以自我为中心的印象？我做了什么让你觉得我低级无能？　　</p>
<p>你：我打电话要换个约会时间，你听起来匆忙急躁，似乎你是一个大忙人，不屑于和我聊。　　</p>
<p>戴维：噢，我碰巧在电话里显得有些匆忙，对你不够关心。那我又做了什么让你感到恼怒呢？　　</p>
<p>你：你每次治疗结束总是匆匆忙忙赶我走——就好像这是一个用来赚钱的大生产线一样。　　</p>
<p>戴维：噢，你是觉得我在治疗期间一直反应迟钝。我或许已经给了你一种我更关心你的钱而不是更关心你的印象。我还做了什么呢？能不能想一想我还有其他什么地方做错了，或者还有什么事冒犯了你？</p>
</blockquote>
<h3 id="二-解除批评者的武装"><a href="#二、解除批评者的武装" class="headerlink" title="二、解除批评者的武装"></a>二、解除批评者的武装</h3><ul>
<li>不管批评你的人是对还是错，先要找到办法同意他或她的看法。</li>
<li>我必须：（1）找到某种办法，同意你所说的话；（2）避免讽刺或辩护；（3）永远说真话。</li>
<li>你会注意到当你受到不公正指控时，你总有一种深层的、几乎是无可抗拒的倾向要为自己辩护。这正是最主要的错误！如果你向这种倾向屈服，你就会发现你对手的还击强度大增！<strong>每次当你为自己辩护时，你都会矛盾地在为对手的军械库增加子弹。</strong></li>
</ul>
<h3 id="三-反馈与协商"><a href="#三、反馈与协商" class="headerlink" title="三、反馈与协商"></a>三、反馈与协商</h3><ul>
<li>你可以客观地表达你的观点，承认你或许错了。要基于事实承认冲突，而不要进行人身攻击或表现得很傲慢。避免给你的批评贴上具有破坏性的标签。</li>
<li>有时，你和批评者的分歧<strong>不是在事实上而是在体验上</strong>。这一次，如果你用外交方式表达你的观点的话，你还是一个赢家。</li>
</ul>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>psychology</tag>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>《学会提问》笔记</title>
    <url>/post/ead403b1/</url>
    <content><![CDATA[<h1 id="本书内容-批判性思维简化为-ct"><a href="#本书内容-（批判性思维简化为-CT）" class="headerlink" title="本书内容  （批判性思维简化为 CT）"></a>本书内容  （批判性思维简化为 <span style="color:#00868B;">CT</span>）</h1><ul>
<li>提出关键问题</li>
<li>做出理性判断</li>
<li>组织论点论据</li>
<li>识别谬误操纵</li>
</ul>
<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul>
<li>锻炼批判性思维</li>
<li>学会提问</li>
</ul>
<p>和<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">How-To-Ask-Questions-The-Smart-Way/README-zh_CN.md at main · ryanhanwu/How-To-Ask-Questions-The-Smart-Way (github.com)</a>结合学习</p>
<h1 id="1-学会提出好问题"><a href="#1-学会提出好问题" class="headerlink" title="1. 学会提出好问题"></a>1. 学会提出好问题</h1><p>批判性思维的三个方面：</p>
<ol>
<li>积极主动地利用关键问题的强烈愿望</li>
<li>有一套相互关联、环环相扣的关键问题的意识</li>
<li>恰如其分地利用关键问题的强烈愿望</li>
</ol>
<h2 id="11-海绵式思维-淘金式思维"><a href="#1-1-海绵式思维、淘金式思维" class="headerlink" title="1.1 海绵式思维、淘金式思维"></a>1.1 海绵式思维、淘金式思维</h2><p>海绵式思维</p>
<ul>
<li>吸收信息越多，越能体会世界的复杂，为下一步思考打下坚实的基础</li>
<li>被动的思维方式，不需要苦想</li>
<li>难以对各种信息和观点进行取舍</li>
<li>单纯的获取</li>
</ul>
<p>淘金式思维</p>
<ul>
<li>掌握主动权，对内容做取舍</li>
<li>保持积极互动</li>
<li>书中列举的淘金思维问题清单</li>
</ul>
<div class="note success"><p>我有没有问“为什么”别人要我相信其观点</p>
<p>在我想到别人的说法可能有问题时有没有将它记下来</p>
<p>我对别人说的话有没有进行客观评价</p>
<p>针对某一特定主体我有没有在别人的合理说法基础上形成自己的结论</p></div>
<p><strong>批判性的提问是检索信息和搜寻答案的最好方法</strong></p>
<h2 id="12-破除正确答案的迷信"><a href="#1-2-破除正确答案的迷信" class="headerlink" title="1.2 破除正确答案的迷信"></a>1.2 破除正确答案的迷信</h2><p>关于物质世界的科学难题，有可能找到准确的解答。</p>
<p>但涉及人类的行为和行为的意义，情况比较复杂。因为人类行为的动因太过复杂且充满正义，所谓“正确答案”则具有极大的或然性。</p>
<p>最需要细致研究的往往是与那些“开明通达人士”看法不一致的问题、存在严重分歧是争论的价值所在。</p>
<h2 id="13-精力管理"><a href="#1-3-精力管理" class="headerlink" title="1.3 精力管理"></a>1.3 精力管理</h2><p>一寸光阴一寸金，决定花时间和精力评估一件事之前，最好先问问自己“这个问题关我什么事？”</p>
<h2 id="14-强势批判性思维-弱势批判性思维"><a href="#1-4-强势批判性思维、弱势批判性思维" class="headerlink" title="1.4 强势批判性思维、弱势批判性思维"></a>1.4 强势批判性思维、弱势批判性思维</h2><p>弱势CT：利用CT捍卫自己现有的立场和看法</p>
<div class="note danger"><ul>
<li>目的是抵制和驳倒与自己不一致的观点</li>
<li>但也摧毁了进步</li>
</ul></div>
<p>强势CT：利用CT评估所有断言和看法，尤其是自己的看法</p>
<div class="note success"><ul>
<li>用关键性问题一视同仁地质疑一切主张，包括自己的</li>
<li>并不迫使自己改弦易辙，也可以为我们进一步坚实自己的看法提供坚实的基础</li>
</ul></div>
<h2 id="15-关键问题有哪些本文需要厘清的主要内容"><a href="#1-5-关键问题有哪些（本文需要厘清的主要内容）" class="headerlink" title="1.5 关键问题有哪些（本文需要厘清的主要内容）"></a>1.5 关键问题有哪些（本文需要厘清的主要内容）</h2><div class="note info"><p>论点和结论是什么<br>理由是什么<br>意义不明的词语有哪些<br>区分价值观假设、描述性假设<br>推理谬误是否存在<br>是否存在<a href="https://songzi.info/post/b9b1da5a/">逻辑错误</a><br>证据的效力如何<br>有没有替代原因<br>数据可靠性如何<br>有哪些重要信息被遗漏<br>能得出哪些合理结论</p></div>
<h2 id="16-价值观与互动"><a href="#1-6-价值观与互动" class="headerlink" title="1.6 价值观与互动"></a>1.6 价值观与互动</h2><p>将别人作为你最有价值的资料库</p>
<p>CT应具有的主要价值观</p>
<ul>
<li>自主性</li>
<li>好奇心</li>
<li>谦恭有礼</li>
<li>以理服人</li>
</ul>
<h2 id="17-理智思考-感情用事"><a href="#1-7-理智思考、感情用事" class="headerlink" title="1.7 理智思考、感情用事"></a>1.7 理智思考、感情用事</h2><p>思考时应当有明确的目标：这目标并非始终捍卫自己的观点。<br>一旦思考，目的就是要<strong>让我们的思想更有深度、更加精确</strong>。<br>无论接受或拒绝一个观点，感情上的依恋决不应该成为你最重要的基础。<strong>最理想的做法是，经过分立推理以后仍笃信不疑才可以加大感情投入的力度。</strong></p>
<h2 id="18-让谈话继续下去的策略"><a href="#1-8-让谈话继续下去的策略" class="headerlink" title="1.8 让谈话继续下去的策略"></a>1.8 让谈话继续下去的策略</h2><p>我们所进行的论证或争辩，目的是是彼此的思考更为精准明确，因此需要采取一些必要的策略，形成一些必要的共识</p>
<div class="note success"><p>尽量阐明你对别人言论的理解</p>
<p>问一下别人，有没有证据让他改变自己的观点</p>
<p>中场休息，以便尽量找到支撑自己结论的最佳证据</p>
<p>为什么他认为你形成结论的那些证据缺乏说服力</p>
<p>尽量弥合分歧</p>
<p>寻求意志价值观或一致统一的结论</p>
<p>情绪、表情、体态控制。即使反对或好奇，也要表现得体贴和不温不火。学习是目的，而不是驳倒所有人。</p>
<p>总得来说，需要营造良好的交流回话的氛围，始终避免一厢情愿</p></div>
<h1 id="2-关键问题论题和结论是什么"><a href="#2-关键问题：论题和结论是什么" class="headerlink" title="2. 关键问题：论题和结论是什么"></a>2. 关键问题：<span style="color:white;background:black;font-size:25px;">论题和结论是什么</span></h1><h2 id="21-关于论题"><a href="#2-1-关于论题" class="headerlink" title="2.1 关于论题"></a>2.1 关于论题</h2><h3 id="211-是什么问题-应不应该问题"><a href="#2-1-1-“是什么”问题、“应不应该”问题" class="headerlink" title="2.1.1 “是什么”问题、“应不应该”问题"></a>2.1.1 “是什么”问题、“应不应该”问题</h3><p>是什么问题 == 描述性论题（descriptive issues）== 关于世界过去、现在、未来是什么样的问题</p>
<blockquote>
<p>学音乐是不是能提高智力？<br>家庭暴力的诱因是什么？<br>服用Paxil是不是治疗抑郁的有效手段？</p>
</blockquote>
<p>应不应该问题 == 规定性问题（prescriptive issues）== 关于世界应当是什么样的问题</p>
<blockquote>
<p>我们应该立法禁止克隆技术吗？<br>学校应不应该将计算机作为必修科目？</p>
</blockquote>
<h3 id="212-明确论题"><a href="#2-1-2-明确论题" class="headerlink" title="2.1.2 明确论题"></a>2.1.2 明确论题</h3><p>有时论题是直接了当地说出来，注意以下用词：</p>
<ul>
<li><strong>我要问的问题是</strong>：我们应当禁烟吗？</li>
<li>降低法定饮酒年龄：<strong>是不是一件正当的事情？</strong></li>
<li>学校<strong>应不应当</strong>提供性教育？</li>
</ul>
<p>有时论题并非直接提出来，而应当从其他暗示中进行推断：<br>一个比较好的线索是了解作者的背景、感兴趣的领域<br>辨认论题是要<em>警惕</em>这种思想：陈述这个论题的正确方法只有一种，其他都是错误的。<br>对于这类模糊的论题，最有效的方法是<strong>先找准结论</strong>。</p>
<h2 id="22-关于结论"><a href="#2-2-关于结论" class="headerlink" title="2.2 关于结论"></a>2.2 关于结论</h2><h3 id="221-他希望证明什么"><a href="#2-2-1-他希望证明什么？" class="headerlink" title="2.2.1 他希望证明什么？"></a>2.2.1 他希望证明什么？</h3><p>有说服力的观点的基本结构：<strong>甲之所以成立是因为乙</strong>。作为结论的观点有其他观点进行支撑。<br>相应地、没有观点进行支撑的断言，不应当作为结论，而是 <strong>纯观点（mere opinion）</strong><br><strong>你相信一个陈述（结论）是因为你认为它由其他看法所支撑，这就是在进行推理。</strong></p>
<p>基于其论证，我是否应当接受其结论？</p>
<h3 id="222-寻找结论的方法"><a href="#2-2-2-寻找结论的方法" class="headerlink" title="2.2.2 寻找结论的方法"></a>2.2.2 寻找结论的方法</h3><ol>
<li>问问论题是什么。</li>
<li><p>寻找指示词(indicator word)</p>
<blockquote>
<p>因此、表明、由此而知、因此可以断定、我要说的重点是、显示出、证明、告诉我们、问题的实质是</p>
</blockquote>
</li>
<li>在可能的位置（开头或结尾）查看</li>
<li><p>记住不可能作为结论的内容</p>
<blockquote>
<p>例句、数据、定义、背景资料、证据</p>
</blockquote>
</li>
<li>检察交流的语境与作者的背景</li>
<li>问一问“so what?”</li>
</ol>
<h3 id="223-明确结论的写作经验"><a href="#2-2-3-明确结论的写作经验" class="headerlink" title="2.2.3 明确结论的写作经验"></a>2.2.3 明确结论的写作经验</h3><p><code>CT</code>的一个最大障碍即是无法建立起沟通的桥梁</p>
<ol>
<li>写作之前将论题的范围尽量缩小</li>
<li>引导读者得出你的结论<br>关键在于：必须竭力组织好自己的思想，然后明白无误地表达出来。</li>
</ol>
<h1 id="3-关键问题理由是什么"><a href="#3-关键问题：理由是什么" class="headerlink" title="3. 关键问题：理由是什么"></a>3. 关键问题：<span style="color:white;background:black;font-size:25px;">理由是什么</span></h1><p><strong>只有当你找到支撑结论的理由时你才能判定一个结论的价值。</strong>理由+结论 = 论证</p>
<p>理由的定义：我们为什么要相信某个结论的解释说明或逻辑依据</p>
<p>注意论证的几个特点：</p>
<ul>
<li>论证必有目的</li>
<li>论证的质量有高有低：因此需要CT来判定</li>
<li>论证由两个明显的必要构成：结论及其支撑理由</li>
</ul>
<h2 id="31-他的理由是什么"><a href="#3-1-他的理由是什么" class="headerlink" title="3.1 他的理由是什么"></a>3.1 他的理由是什么</h2><p>厘清结构，找到理由；寻找理由的关键词</p>
<blockquote>
<p>由于、鉴于、由以下材料支撑、由于这个原因、研究显示、第一…第二…第三…</p>
</blockquote>
<h2 id="32-用理由浇筑结论"><a href="#3-2-用‘理由’浇筑‘结论’" class="headerlink" title="3.2 用‘理由’浇筑‘结论’"></a>3.2 用‘理由’浇筑‘结论’</h2><p>结论本身不是证据，而是一个有证据或其他观点支撑起来的观点。<br>薄弱的理由必然导致薄弱的结论。</p>
<h2 id="33-明确理由的写作经验"><a href="#3-3-明确理由的写作经验" class="headerlink" title="3.3 明确理由的写作经验"></a>3.3 明确理由的写作经验</h2><ul>
<li>作出结论前要探究种种可能存在的理由<ul>
<li>不要用“逆向逻辑”或“反向推理”，不要先得出结论再找理由</li>
<li>要考虑可能存在的种种理由并掂量其分量，最后作出结论</li>
<li>寻找涵盖你的论题的主要信息（刊物、书籍、影音资料等）</li>
<li>帮助读者确定你的理由</li>
</ul>
</li>
</ul>
<h1 id="4-关键问题寻找含义暧昧的词语"><a href="#4-关键问题：寻找含义暧昧的词语" class="headerlink" title="4. 关键问题：寻找含义暧昧的词语"></a>4. 关键问题：<span style="color:white;background:black;font-size:25px;">寻找含义暧昧的词语</span></h1><p>只有<strong><span style="color:#68d4ed;">理解</span>了关键术语和词组的意思（无论是直接的还是含蓄的意思）</strong>，才能对一个论证进行评价。</p>
<h2 id="41-辨析多义词"><a href="#4-1-辨析多义词" class="headerlink" title="4.1 辨析多义词"></a>4.1 辨析多义词</h2><p>多义词的含义往往于讲演或文章的<strong>主旨</strong>息息相关，抓住了主旨便容易理解作者所表达的一些多义词的真实含义。</p>
<p>同样地，在读书与听讲的时候，一定要强迫自己去寻找那些意思模糊的词语，否则可能对主旨造成误解。</p>
<h3 id="411-寻找关键词"><a href="#4-1-1-寻找关键词" class="headerlink" title="4.1.1 寻找关键词"></a>4.1.1 寻找关键词</h3><p>寻找关键词的线索：</p>
<div class="note info"><p>检查论题有没有关键词</p>
<p>在结论和理由中查找关键词和短语</p>
<p>留意抽象的词语</p>
<p>通过反串(reverse role-playing)作者来判断特定词语的定义</p></div>
<h3 id="412-检查歧义"><a href="#4-1-2-检查歧义" class="headerlink" title="4.1.2 检查歧义"></a>4.1.2 检查歧义</h3><p>明确词语是否存在歧义需要解决两个障碍</p>
<ol>
<li><div class="note danger"><p>你自认为与作者表达的意思相同，“我知道你是这个意思”</p></div>
<div class="note success"><p>避免与作者心心相印的想法，养成不断追问的习惯，不停地问“你这么说是什么意思”</p></div>
</li>
<li><div class="note danger"><p>你自认为术语存在一个明显的定义，或者是不同领域的相同词语视作只存在同一个解释</p></div>
<div class="note success"><p>打破刻板印象，时常自我提醒，这个词有没有其他含义？</p></div>
</li>
</ol>
<h2 id="42-结合语境"><a href="#4-2-结合语境" class="headerlink" title="4.2 结合语境"></a>4.2 结合语境</h2><p>语境（context）是指作者或演讲者的背景，应当梳理清楚语境再下判断</p>
<h2 id="43-小心情感色彩浓厚的词"><a href="#4-3-小心情感色彩浓厚的词" class="headerlink" title="4.3 小心情感色彩浓厚的词"></a>4.3 小心情感色彩浓厚的词</h2><p>那些激发强烈情感反应的术语被称为<strong>附加感情色彩的术语（loaded terms）</strong>它们感动我们的能力远远超过了其本身的描述性含义，这些术语会让思维短路，通过直接连接情感线路来绕过描述性意义通道，从而欺骗我们的思想。</p>
<p>这在政治语言中表现得尤为突出，下面列举一些政治术语及其希望取得的感情效果</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">术语</th>
<th style="text-align:center">感情效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">恢复(restoring)</td>
<td style="text-align:center">同意征税提案</td>
</tr>
<tr>
<td style="text-align:center">公平(fairness)</td>
<td style="text-align:center">改变</td>
</tr>
<tr>
<td style="text-align:center">恐怖分子(terrorist)</td>
<td style="text-align:center">野蛮、疯狂、未开化</td>
</tr>
<tr>
<td style="text-align:center">改革(reform)</td>
<td style="text-align:center">被人期望的改变</td>
</tr>
</tbody>
</table>
</div>
<h2 id="44-轮到自己写时的经验时刻留意歧义"><a href="#4-4-轮到自己写时的经验：时刻留意歧义" class="headerlink" title="4.4 轮到自己写时的经验：时刻留意歧义"></a>4.4 轮到自己写时的经验：时刻留意歧义</h2><h1 id="5-关键问题明确价值观假设和描述性假设"><a href="#5-关键问题：明确价值观假设和描述性假设" class="headerlink" title="5. 关键问题：明确价值观假设和描述性假设"></a>5. 关键问题：<span style="color:white;background:black;font-size:25px;">明确价值观假设和描述性假设</span></h1><h1 id="6-关键问题推理过程的谬误"><a href="#6-关键问题：推理过程的谬误" class="headerlink" title="6. 关键问题：推理过程的谬误"></a>6. 关键问题：<span style="color:white;background:black;font-size:25px;">推理过程的谬误</span></h1><h1 id="7-关键问题明确证据的效力"><a href="#7-关键问题：明确证据的效力" class="headerlink" title="7. 关键问题：明确证据的效力"></a>7. 关键问题：<span style="color:white;background:black;font-size:25px;">明确证据的效力</span></h1><h1 id="8-关键问题有没有替代原因"><a href="#8-关键问题：有没有替代原因" class="headerlink" title="8. 关键问题：有没有替代原因"></a>8. 关键问题：<span style="color:white;background:black;font-size:25px;">有没有替代原因</span></h1><h1 id="9-关键问题数据有没有欺骗性"><a href="#9-关键问题：数据有没有欺骗性" class="headerlink" title="9. 关键问题：数据有没有欺骗性"></a>9. 关键问题：<span style="color:white;background:black;font-size:25px;">数据有没有欺骗性</span></h1><h1 id="10-关键问题有没有重要信息被忽略"><a href="#10-关键问题：有没有重要信息被忽略" class="headerlink" title="10. 关键问题：有没有重要信息被忽略"></a>10. 关键问题：<span style="color:white;background:black;font-size:25px;">有没有重要信息被忽略</span></h1><h1 id="11-关键问题能得出哪些合理的结论"><a href="#11-关键问题：能得出哪些合理的结论" class="headerlink" title="11. 关键问题：能得出哪些合理的结论"></a>11. 关键问题：<span style="color:white;background:black;font-size:25px;">能得出哪些合理的结论</span></h1>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>《伯恩斯新情绪疗法》3 克服拖延</title>
    <url>/post/3a21ee98/</url>
    <content><![CDATA[<p>前文：</p>
<p><a target="_blank" href="https://songzi.info/post/f6e86d6c/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">《伯恩斯新情绪疗法》1 认知扭曲 | 毫末室 (songzi.info)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://songzi.info/post/f6e86d6c/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<p><a target="_blank" href="https://songzi.info/post/283c93cb" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">《伯恩斯新情绪疗法》2 建立自尊 | 毫末室 (songzi.info)</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://songzi.info/post/283c93cb</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<h1 id="认识拖延什么都不做主义"><a href="#认识拖延——什么都不做主义" class="headerlink" title="认识拖延——什么都不做主义"></a>认识拖延——什么都不做主义</h1><p>抑郁症最具摧毁性的一个方面就是麻痹了你的意志。在它表现较轻时，不过是影响日常事务，但久而久之你做任何事都感到困难，你强烈地暗示自己什么也不做了。因为你做成的很少，所以你感到越来越糟糕。<strong>你不仅切断了常有的刺激与快乐之源泉，而且由于缺乏成果使你更加憎恨自己，进而进一步把自己孤立，更加认为自己没有能力。</strong><br>只要病人自己有心改变自己的状况，他们的进步都非常之快。只要你怀着自救的心理去行事，有时根本不在乎你具体做的到底是什么。不过许多病人会坚持某种说法，顽固地拒绝做实际事情来帮助自己。一旦这一关键的动机问题被解决，典型的抑郁症状就会开始消失。你也就会明白为什么我们大部分的研究针对的是<strong>意志瘫痪</strong>的原因了。</p>
<h2 id="几种人类自挫行为理论"><a href="#几种人类自挫行为理论" class="headerlink" title="几种人类自挫行为理论"></a>几种人类自挫行为理论</h2><ol>
<li>你是懒惰的，这是你的本性<br> 特点型：你的行为好像是一种固定不变的人格特点，是从你的“懒惰纹理”中延伸出来的。<br> 这种理论的问题是它只给问题贴上了标签，而没有对它加以解释。仅仅给你贴上“懒惰”的标签是没用的，而且会打击你自己，因为它给人创造了一种错误的印象，好像你的动机缺乏是不可逆转的，是你天性的一个组成部分。这种思维方式不代表一种科学有效的理论，但是却是认知扭曲的一种（贴标签）。</li>
<li>你希望伤害自己，承受痛苦。你要么是喜欢感受抑郁，要么就有一种自毁冲动，一种“死亡意愿”。因为在拖延中有一些东西是令人愉快的或是值得的。</li>
<li>你是被动进攻，希望通过无所作为来挫败你周围的人。<br> 抑郁行为可以基于“内在愤怒”得以解释。你的不做为可以看作是被幽闭了的敌意的一种表达，因为它通常会让你周围的人感到恼怒。</li>
<li>你肯定会从拖延和无所作为中得到某些“好处”，当你抑郁时，你在享受着关注。<br> 你的情绪和行为被看做是来自于你环境的奖惩。如果你觉得抑郁，并且什么也没做，那么你的这种行为就会以某种方式得到回报。</li>
</ol>
<h2 id="拖延者的典型心理定式"><a href="#拖延者的典型心理定式" class="headerlink" title="拖延者的典型心理定式"></a>拖延者的典型心理定式</h2><h3 id="1-无望"><a href="#1-无望" class="headerlink" title="1. 无望"></a>1. 无望</h3><p>深陷当前痛苦，忘了过去的良好感觉，难以想象自己以后会积极起来。因此，任何行动似乎都没有意义，因为<strong>你绝对相信——你自身做事动机的缺乏和自身的压迫感是永远存在，不可逆转的</strong></p>
<p>因此，劝慰无望之人，就像鼓励一个将死之人欢呼一样，没有意义。</p>
<h3 id="2-无助"><a href="#2-无助" class="headerlink" title="2. 无助"></a>2. 无助</h3><p>你不在做任何让自己感觉舒服一点的事情。</p>
<p>因为<strong>你深信自己的情绪是由一些你不能控制的因素所引起的</strong>，包括命运、运气、他人的评价。</p>
<h3 id="3-吓唬自己"><a href="#3-吓唬自己" class="headerlink" title="3. 吓唬自己"></a>3. 吓唬自己</h3><p>将某项任务夸大到不可企及的程度。有时假设自己必须同时完成全部的事情，从而被无数的事情困扰，无法专注手头的工作。</p>
<p><em>例如：设想每次在你坐下来吃东西时，你都开始去想你一辈子不得不吃的所有食物。花上一段时间去想想成吨的食物堆在你面前！现在，假定每顿饭前你都对自己说：“我怎样才能把饭全部吃完呢？今晚只吃那么一点点肯定是不行的。”你感到作呕，感到发懵，你的胃口会消失</em></p>
<h3 id="4-跳跃式结论"><a href="#4-跳跃式结论" class="headerlink" title="4. 跳跃式结论"></a>4. 跳跃式结论</h3><p>你觉得能否通过有效的行动达到有效的结果不在你的能力范围内，因为<strong>你有一种说“我不能”或者说“我想……但是……”的习惯。</strong></p>
<p>所以当我建议一位抑郁妇女烤苹果派时，她回答说：“我再也不会做饭了。”她事实上意思是说：<strong>“我觉得我不喜欢做饭，做这件事情我感觉异常困难。”</strong>她决定去检验这种假设，于是就试着烤派，她惊奇地发现自己对此很满意，一点也没有觉得困难。</p>
<h3 id="5-给自己贴标签"><a href="#5-给自己贴标签" class="headerlink" title="5. 给自己贴标签"></a>5. 给自己贴标签</h3><p>你越拖延，你越看不起自己，从而进一步减弱自己的自信。</p>
<p>心理滚雪球：当你给自己贴上“拖延症患者”“超级懒汉！”的标签，你会觉得此时缺乏效率就是“真正的你”，御史你会下意识更看不起自己、对自己绝望。</p>
<h3 id="6-快感缺乏回报不足"><a href="#6-快感缺乏-回报不足" class="headerlink" title="6. 快感缺乏/回报不足"></a>6. 快感缺乏/回报不足</h3><p>在你抑郁时，你不愿意做任何有益的行动，不仅是因为你认为任何任务都是非常难以完成的，而且因为你觉得回报不及所付出的努力。通常的思维错误——<strong>“否认积极因素”的倾向</strong>——其根源可能就是出在这一问题上。你能想起来这种思维错误是由什么构成的吗？</p>
<p><em>例如：考试很成功，但却对自己说：“这是我应该做的/一次考试不算数”。这是典型的缺乏满足感，因为你总是能发现一种办法贬低自己的努力，你的思维惯性“那不算数”成功地破坏了自己的满足感。</em></p>
<h3 id="7-完美主义"><a href="#7-完美主义" class="headerlink" title="7. 完美主义"></a>7. 完美主义</h3><p>用不适合的目标/标准打击自己。</p>
<p>这与“快感缺乏”、“自我憎恨“联系密切——<strong>你所做的任何事情，尽管有非常辉煌的成绩，你也会认为什么也不是。</strong>所以你经常会以一个词结束：”这没什么“。</p>
<h3 id="8-害怕失败"><a href="#8-害怕失败" class="headerlink" title="8. 害怕失败"></a>8. 害怕失败</h3><ol>
<li>恐惧失败。<strong>认为付出巨大的努力却没有成功是一种巨大的个人失败，所以你根本就拒绝尝试。</strong></li>
<li><strong>评价自己的成绩时完全依据结果而不依据个人的努力。</strong></li>
</ol>
<h3 id="9-害怕成功"><a href="#9-害怕成功" class="headerlink" title="9. 害怕成功"></a>9. 害怕成功</h3><p>由于<strong>缺乏自信</strong>，所以有时成功会比失败更危险，因为你确信这完全是靠运气。因此，<strong>你深信你不能保持成功，你会觉得自己的成功会错误地抬高别人的期望</strong>。于是当你事实上是“一个失败者”这一可怕的真相暴露出来时，失望、排拒和痛苦的情绪会更加苦涩。<strong>既然你确信自己会不可避免地跌落悬崖，那么根本就不往山上爬看来就是最安全的。</strong></p>
<p>换句话说，<strong>在你眼里，成功就会把你带入一个危险的不可能的境地。因此你极力保持克制，避免做什么，也避免介入什么。</strong></p>
<h3 id="10-害怕别人不赞成害怕批评"><a href="#10-害怕别人不赞成-害怕批评" class="headerlink" title="10. 害怕别人不赞成/害怕批评"></a>10. 害怕别人不赞成/害怕批评</h3><p>设想如果你尝试做新鲜事物，<strong>任何失误或错误都会招来强烈的批评或反对</strong>。</p>
<p>因此，<strong>为了保护自己</strong>，你就尽可能保持低调。但如果你不做任何努力的话，你就不可能把事情做好。</p>
<h3 id="11-强迫与憎恨"><a href="#11-强迫与憎恨" class="headerlink" title="11. 强迫与憎恨"></a>11. 强迫与憎恨</h3><p>动机的一个死敌就是强迫感。你觉得<strong>做事情会有一种很大的压力，特别是你用伦理词汇“应该”“本该”来激励自己时，这种事情就会发生</strong>。你对自己说：“我应该做这件事”“我不得不做这件事。”于是你就感觉到了责任、压力、紧张、憎恨、罪过。你的感觉就像是一个有士兵面对一个异常严格的指挥官一样。<strong>每一项任务都染上了这种不愉快的色彩，你几乎不能正视它。由于你的因循拖延，你会谴责自己是一个懒惰的、没有优点可言的、差劲的人。这就会更加消耗你的精力。</strong></p>
<h3 id="12-抗挫折能力低"><a href="#12-抗挫折能力低" class="headerlink" title="12. 抗挫折能力低"></a>12. 抗挫折能力低</h3><p>与“自我强迫”密切相关——你<strong>假定你应该能够很快地、也很容易地解决你的问题</strong>，所以当你在生活中遇到麻烦时，你就会陷入痛苦与狂怒状态。</p>
<p><strong>你的挫折感来自于你经常用头脑中的理想与外在现实对比这种习惯。当二者不匹配时，你就谴责现实。你没想到改变期望要比让现实屈就自己容易得多。</strong></p>
<p><em>例：参加考试时，你可能会抱怨：“已经学了这么久了，我的成绩应该会提高的。”是这样吗？<strong>为什么你应该？你或许有一种错觉，认为这种惩罚、命令的表述会驱动你付出更大的努力。不过这种办法很少会奏效。挫折只会增加你的无用感，促使你放弃，什么也不做。</strong></em></p>
<h3 id="13-罪感与自责"><a href="#13-罪感与自责" class="headerlink" title="13. 罪感与自责"></a>13. 罪感与自责</h3><p>如果你<strong>一味地认为自己不好，或者认为别人瞧不起你</strong>，你自然就会缺乏动力去过好自己的生活。</p>
<p>你知道为什么事实上任何一件有意义的活动都可以为你的情绪好转提供一个像样的机会吗？如果你什么也不做，你就会满脑子都是消极的破坏性的想法。如果你做点什么，你就会暂时从自贬性的内在对话中脱离出来。更重要的是，<strong>掌握自我这样一种感觉体验会证明你许多的扭曲想法都是错误的</strong>。</p>
<h1 id="走出拖延自我激活选择两个-坚持一两周"><a href="#走出拖延：自我激活（选择两个、坚持一两周）" class="headerlink" title="走出拖延：自我激活（选择两个、坚持一两周）"></a>走出拖延：自我激活（选择两个、坚持一两周）</h1><h2 id="每日活动时间表"><a href="#每日活动时间表" class="headerlink" title="每日活动时间表"></a>每日活动时间表</h2><p>做法</p>
<p>表由两部分组成。</p>
<ul>
<li>展望栏：逐小时写下一天里你希望完成的事情。即便你事实上只完成了计划的一部分，每天都在想办法去行动本身都会非常有益。计划不必写得过细，寥寥数语就可以了，比如“穿衣”“吃午饭”“准备简历”等等。整个写计划的时间不要超过五分钟。</li>
<li>回顾栏：跟踪记录一下你每天这些时间里实际做了什么。或许你一切按计划进行了，或许你没有完全按计划进行，不过，即便你是在盯着墙看，也把这件事写下来。<ul>
<li>每项活动贴上标签，字母M表示掌握，字母P表示快乐。掌握活动指那些已经完成的活动，如刷牙、做饭、开车上班等，快乐活动包括读书、吃饭、看电影等。在</li>
<li>每项活动后边写完M或P后，估计一下每项活动实际的快乐程度或难易程度，用0到5之间的数字表示出来。比如，你可以给穿衣服这样特别容易的事情一个M和1的分数，而M-4或M-5则表示你所做的事情非常难或非常具有挑战性，比如说吃得太少，没申请到工作。你可以用同样的办法标出快乐活动。如果哪一项活动很快乐，你也不抑郁了，但是你全天不很快乐或根本不快乐，就给一个P-1/2或P-0的分数。有些活动，像做饭，就可以贴上M和P。</li>
</ul>
</li>
</ul>
<p>好处</p>
<ul>
<li>首先，它会打断你无休止地为各种活动是否有价值而迷惑的倾向和毫无结果地讨论是否应该做某件事情的倾向。哪怕只完成时间表里的部分活动也会有可能让你感到满足，并会与你的抑郁作斗争。</li>
<li>当你安排每天的计划时，<strong>注意要使日程安排保持平衡，既要能够工作，又要有充分享受的休闲活动</strong>。如果你感到忧郁，你或许特别希望快乐，即便你怀疑自己能否像平时那样享受这些欢乐，你或许已经疲于追问自己，你的“付出与所得”系统或许已经失衡。如果是这样的话，给自己放上几天假，然后再规划你希望做的事情。　</li>
<li>如果你坚持规划自己的生活的话，你就会发现你的动力不断增强。当你开始做事情时，你就会开始怀疑自己原有的信念，不相信自己不能有效地工作。一个曾经很拖拉的人这样描述说：“自<strong>从我开始规划自己的每日生活，并且对比自己的实际履行情况后，我已经开始意识到应该如何度过自己的时间了。这一活动帮助我重新主宰了我的生活。我意识到只要我愿意，我就可以很好地控制自己。</strong>”</li>
<li>每日活动时间表可能对常见的我称作<strong>“周末/假日忧郁”综合症</strong>的情况非常有益。你的计划不必过于精细，你可以计划去理发，去购物，去参观美术馆，读一本书，或者到公园逛逛。你会发现为每天制订一个简单的计划并坚持完成计划可以大大地提高你的情绪。</li>
</ul>
<h2 id="抗拖延清单"><a href="#抗拖延清单" class="headerlink" title="抗拖延清单"></a>抗拖延清单</h2><h2 id="不良想法日常记录"><a href="#不良想法日常记录" class="headerlink" title="不良想法日常记录"></a>不良想法日常记录</h2><h2 id="快乐预测清单"><a href="#快乐预测清单" class="headerlink" title="快乐预测清单"></a>快乐预测清单</h2><h2 id="但是反驳法"><a href="#但是反驳法" class="headerlink" title="但是反驳法"></a>但是反驳法</h2><h2 id="学会认可自己"><a href="#学会认可自己" class="headerlink" title="学会认可自己"></a>学会认可自己</h2><h2 id="tictoc法"><a href="#TIC-TOC法" class="headerlink" title="TIC/TOC法"></a>TIC/TOC法</h2><h2 id="小步快跑碎步跟进"><a href="#小步快跑-碎步跟进" class="headerlink" title="小步快跑/碎步跟进"></a>小步快跑/碎步跟进</h2><h2 id="没有强迫的激励"><a href="#没有强迫的激励" class="headerlink" title="没有强迫的激励"></a>没有强迫的激励</h2><h2 id="解除武装法"><a href="#解除武装法" class="headerlink" title="解除武装法"></a>解除武装法</h2><h2 id="可见的成功"><a href="#可见的成功" class="headerlink" title="可见的成功"></a>可见的成功</h2><p>列出有成效行为的优点清单</p>
<p>例子：戒烟——<strong>通过积极的暗示来完成自我调整</strong>，这种习惯管理法非常有效。它能使我和许多其他病人通过一个简单的疗程就戒了烟。你可以很容易地去这么做，而且你发现值得你这么努力。它可以用来帮助你改进减肥、定期剪草、早上按时起床、坚持跑步或其他你愿意改善的事情。</p>
<blockquote>
<p>第一步：列出所有戒烟的积极后果</p>
<ol>
<li>增进健康。　　</li>
<li>尊敬自我。　　</li>
<li>更加自律。重新恢复自信后，或许可以再开始做许多已经被放置了很久的事情。　</li>
<li>又能够又蹦又跳了，会感觉自己的身体很好。精力异常充沛。</li>
<li>我的心肺会强壮起来，我的血压也会降下来。</li>
<li>我的呼吸将会清新。</li>
<li>我会有更多的零花钱。</li>
<li>我会活得长一些。</li>
<li>我周围的空气将会清洁。</li>
<li>我可以告诉别人我不再抽烟了。</li>
</ol>
<p>第二步：每晚睡觉前，想象你最惬意的事情，让你的身体随意放松。注意你的肌肉是怎样开始变软变松的。注意你的心情是怎样的平静。</p>
<p>第三步：<strong>想象你仍然在这些场景中，不过你已经不吸烟了。</strong>回顾你的戒烟益处清单，用以下方法重复其中的每一项内容：“现在我的健康状况已经有了改善，我喜欢这样。我可以沿着沙滩奔跑，我也希望这样。我周围的空气很清新，我自己感觉很好。我尊敬我自己。现在，我更加自律了，如果必要的话，我还可以接受其他挑战。我零花钱也多了。”等等。</p>
</blockquote>
<h2 id="记下你所记录的东西"><a href="#记下你所记录的东西" class="headerlink" title="记下你所记录的东西"></a>记下你所记录的东西</h2><h2 id="测试你的不能"><a href="#测试你的“不能”" class="headerlink" title="测试你的“不能”"></a>测试你的“不能”</h2><h2 id="不能输体系"><a href="#“不能输”体系" class="headerlink" title="　“不能输”体系"></a>　“不能输”体系</h2>]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>psychology</tag>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>《成功、动机与目标》实践性总结</title>
    <url>/post/1148d9d6/</url>
    <content><![CDATA[<h1 id="前言本书话题"><a href="#前言：本书话题" class="headerlink" title="前言：本书话题"></a>前言：本书话题</h1><ul>
<li>制定目标的原则</li>
<li>制定目标的种类</li>
<li>如何选择最适合个人情况的目标</li>
<li>最常见的失败原因，以及如何避免</li>
</ul>
<h1 id="制定具体而艰巨的目标"><a href="#制定具体而艰巨的目标" class="headerlink" title="制定具体而艰巨的目标"></a>制定具体而艰巨的目标</h1><ul>
<li><strong>目标困难化。</strong></li>
</ul>
<p>把目标在可行的基础上设立得难一点也很重要。你需要用高标准挑战自己，因为挑战能激发斗志一一但与此同时要避免“不可能的任务”。要记得如果标准设置得太低，你虽能达到但不太可能超越一一大多数人达到最初目标后就松懈了。没人会在设定减5磅肉的目标下最终减掉20磅。</p>
<ul>
<li><strong>“为什么”思维或“是什么”思维</strong></li>
</ul>
<p>目标可以被理解为较抽象的“为什么”做这件事，或比较具体的一一行动“是什么”。比如说，清理衣柜里的一团混乱可以被理解为“整理出条理”（为什么）或者“扔掉不穿的衣服”（是什么）。当你想得到更多精力和动力或避免诱惑时，请用“为什么”方式思考。当你在做一件困难、生疏或耗时间的事时，请用“是什么”方式思考。</p>
<ul>
<li><strong>请考虑价值和可行性</strong></li>
</ul>
<p>记住当我们想象较远期的计划时，我们都更倾向于用“为什么”式思考。这就让我们太过重视目标诱人的部分（比如去迪斯尼乐园将会多好玩），而太少考虑可行性（我怎么付得起这趟旅行的钱）。另一方面，我们又自然而然地用“是什么”来考虑近期目标，这样就容易太注重于实际操作而没有充分体会到生活要带给我们的东西。最佳的目标往往是在人们权衡“合意度”和“可行度”之后做出的没有偏见的选择。</p>
<ul>
<li><strong>正面思考但不要轻敌</strong></li>
</ul>
<p>当你树立目标时，请尽管正面、积极地想象目标的实现，相信自己成事的能力对保持动力有极大的帮助。但无论你做什么，别低估了成功之路的艰辛，大多数值得奋斗的目标都需要时间、规划、努力和毅力来实现，想象着能轻而易举地实现目标只会让你在未来的路上措手不及。轻敌是失败的配方。</p>
<ul>
<li><strong>运用心理对照法制定目标</strong></li>
</ul>
<p>当你在考虑制定新目标时，一定要同时想到成功的情景和路上的障碍。这种心理对照不仅能帮助你对目标的采用做出正确的决定，还能自然地启动你的动力系统，使你最大限度地致力于想要实现的目标。</p>
<h1 id="你能变聪明吗"><a href="#你能变聪明吗" class="headerlink" title="你能变聪明吗"></a>你能变聪明吗</h1><ul>
<li><strong>懂得什么影响你</strong></li>
</ul>
<p>如果你想做出更好的目标选择，懂得是什么在暗中影响着你做这样或那样的选择，这样会对你有益。跟自己摊牌、分析对与错，如果有必要，试图去削减某种影响。</p>
<ul>
<li><strong>懂得如何判断自己的能力</strong></li>
</ul>
<p>我们的目标在很大程度上取决于对自身能力的信念。如果你习惯性地对某些极具吸引力的目标说不，就该问问为什么了。你对自己的信念有多确定？是否还有其他看待问题的方式？</p>
<ul>
<li><strong>拥抱改变的机会</strong></li>
</ul>
<p>相信自己有能力达到目标是重要的，而相信自己可以获取这种能力也同样重要。很多人认为，我们的智力、个性和体质是固定不变的一一无论我们做什么都无法提高。这些“实体”信念使人把精力集中放在试图证明自己的目标上，而忽略了发展和成长。好在几十年的调查研究证明这种信念是完全错误的。<strong>持“渐进论”者则相信我们的各种特征是可以逐渐改变的。这个理论是被科学证明所支持的。所以假如你相信自己某方面无法改变，而这种信念又左右着你一生中对目标的选择，那么是时候抛开这个观点了。去相信自己能够改变，这个（正确的）信仰能让你做出更好的选择，发挥更大的潜力。</strong></p>
<ul>
<li><strong>营造正确的环境</strong></li>
</ul>
<p>另一个影响目标的因素是环境，而环境往往对潜意识产生着影响。我们读到的字眼、看到的物件、打交道的人——我们所接触的万物无不触发着潜意识对目标的追求。榜样在很大程度上是通过“目标感染”鼓舞着我们。换言之，我们会采纳他人追求的目标——在我们认同的前提下。</p>
<ul>
<li><strong>利用触发点进入潜意识</strong></li>
</ul>
<p>若想保持动力，让你的环境里充满提示和触发点。它们能使你的潜意识为达到目标而努力工作，即便你的有意识思维已被其他事情占领。</p>
<h1 id="你注重出色表现还是成长进步"><a href="#你注重出色表现还是成长进步" class="headerlink" title="你注重出色表现还是成长进步"></a>你注重出色表现还是成长进步</h1><ul>
<li><strong>聚焦“表现”，带来成绩</strong></li>
</ul>
<p>对表现的追求能带给人很大的动力，也能带来优异的成绩，不过这都是在事情不复杂的情况下。可惜，当路变得坎坷时，注重证明自己的人容易得出自己不行的结论而过早放弃。</p>
<ul>
<li><strong>聚焦“进步”，提高成绩</strong></li>
</ul>
<p>专注于“进步”的我们能在困难中大步前行一一把经验当作进步的燃料。追求成长的人通常能交出最好的成绩，因为面对困难时他们最坚韧不拔。</p>
<ul>
<li><strong>聚焦“进步”，享受旅途</strong></li>
</ul>
<p>当“进步”是你的目标时，你更容易享受正在做的事情，从中找到乐趣。换言之，你对旅途和目的地同样欣赏。你会更深入更有意义地对信息进行处理，更好地为未来做打算。你甚至更容易在需要的时刻寻求帮助，从中切实受益。</p>
<ul>
<li><strong>聚焦“进步”，抵抗抑郁</strong></li>
</ul>
<p>个人成长目标比自我证明的目标更能使人从容、有效地面对抑郁和焦虑。失落的心情能激励他们起身行动、解决问题，而不是纵容自己藏在窝里为自己哀叹。不出意料，和那些整日试图证明自己的能力与价值的人比起来，他们的抑郁症状更轻，延续时间也更短。</p>
<ul>
<li><strong>聚焦“进步”，收获更多</strong></li>
</ul>
<p>说到底，请尽可能地把“表现”目标转换成“进步”目标。与其哀叹一段人际关系的不完美，不如把注意力集中在能改善的方面。在工作中，与其让人对你的聪明智慧刮目相看，不如专注于扩展技能、接受新挑战。当你把重点从“能证明什么”转为“能学到什么”时，你会拥有更多快乐更多收获。</p>
<h1 id="进攻与防御"><a href="#进攻与防御" class="headerlink" title="进攻与防御"></a>进攻与防御</h1><ul>
<li><strong>“进取”为了获得，“防御”为了不失去</strong></li>
</ul>
<p>当你的目标以“进取”为主时，你是从“成就”的角度看待它一一它是你理想中希望获取的东西。当你的目标以“防御”为主时，你考虑最多的是安危一一这个目标是你觉得必须实现的。总的来说，“进取”目标是有关收益最大化的，而“防御”目标是有关避免损失的。</p>
<ul>
<li><strong>乐观精神适合“进取”目标</strong></li>
</ul>
<p>如果你是个“进取”型思维方式的人，或是正在追求“进取”型目标，那么自信和积极乐观的思维方式能助你一臂之力。乐观能在你追求“进取”目标时给予你极强的动力——它会使你势不可当地挑战万难。</p>
<ul>
<li><strong>乐观精神不适合“防御”目标</strong></li>
</ul>
<p>如果你是“防御”型思维的人，或正在追求“防御”式目标，过多的乐观反而会坏事。自信会削弱动力与警惕。实际上，一丝悲观对你来讲或许是最有用的一一没什么比察觉到失败与危险的可能性更能使人加以防备了。</p>
<ul>
<li><strong>“进取”使人热血沸腾，“防御”使人如释重负</strong></li>
</ul>
<p>我们在实现“进取”目标时感到欢欣鼓舞(“哈！我真棒！”)，在失败时则垂头丧气(“唉，我真没用。”)。当我们达成“防御”目标时，我们感到平和放松(终于松了口气：“我躲开了子弹。”)，而没有达成这种目标后我们会焦虑紧张(“哦不！这下完了！”)。</p>
<ul>
<li><strong>“进取”目标偏爱风险</strong></li>
</ul>
<p>“进取”目标会导致“风险偏好”，使我们什么都想试试，不容错过任何机会。这带来的是更多想象力以及创造性思维。“进取”型的人爱想新点子、新方式。他们注重速度多于准确性。他们是谈判高手因为他们不怕迈出冒险的第一步。他们放眼全景，抓住当下。</p>
<ul>
<li><strong>“防御”目标偏爱谨慎</strong></li>
</ul>
<p>“防御”目标会导致“保守偏好”，使我们更害怕犯错，更爱说“不”，更少尝试新鲜事物或用新方法实现目标，不过它也使我们做出更好的计划，更少拖延。这一类人很注重细节，他们注重准确率多于速度，在诱惑和干扰面前表现极佳，不会有漏网之鱼。</p>
<ul>
<li><strong>合适的策略</strong></li>
</ul>
<p>“进取”与“防御”都能带来成功，重点是识别目标的种类然后运用合适的策略去实行。合适的策略不但能带来更大成就，还能让你“感觉对”一一使你的成功之路更愉悦，更令人满足。</p>
<ul>
<li><strong>视情况而定</strong></li>
</ul>
<p>虽然大多数时候我们处理目标的思维方式是固定的非“进取”即“防御”，但有时境遇决定了目标，所以你需要注意到目标性质的不同从而适时转换策略以获得成功。</p>
<h1 id="不闪光的金子"><a href="#不闪光的金子" class="headerlink" title="不闪光的金子"></a>不闪光的金子</h1><ul>
<li><strong>人类的三种基本需求</strong></li>
</ul>
<p>不是所有目标都能带来长久的快乐和幸福，不论你是否能实现它。那些能满足人类对关联感、胜任力与自主权这三种基本需求的目标才能带来我们想要的快乐与幸福。</p>
<ul>
<li><strong>“关联感”增强人际关系</strong></li>
</ul>
<p>当你追求的目标是建立或巩固人际关系以及回报社会时，你对关联感的需求就会得到满足。你的人生中有类似的目标吗？</p>
<ul>
<li><strong>“胜任力”开发新技能</strong></li>
</ul>
<p>为了满足对胜任力的需求，你追求的目标应与个人成长、从经验中学习以及开发新技能有关。你正在追求的目标满足了这个需求吗？</p>
<ul>
<li><strong>“自主权”反映出热情之所在</strong></li>
</ul>
<p>追求符合兴趣爱好、个人天性及核心价值的目标能满足你对自主权的需求。你多数时间追求的目标符合这样的形容吗？你在做你想做的事吗？</p>
<ul>
<li><strong>闪光的不一定是金子</strong></li>
</ul>
<p>追求受欢迎度、名誉、财富等关乎自我价值外在肯定的目标不仅不会使你快乐，还会干扰你对真正有益目标的追求，从而降低你的幸福感。如果你有类似的目标，现在便是弃暗投明的时候了。</p>
<ul>
<li><strong>内在动力可以燎原</strong></li>
</ul>
<p>自由选择的目标能够生成内在动力一一一种通往更大快乐、更久耐力、更强创造力以及更好表现的动力。这种动力能被任何管制性因素破坏一一包括奖励、惩罚、期限以及过多监控。当你想激励别人时，请仔细考虑方式问题。</p>
<ul>
<li><strong>自主权是动力的燃料</strong></li>
</ul>
<p>当我们觉得自己拥有“自主支持”的环境时，内在动力便被呵护甚至修复了。当我们觉得内心世界被承认，而且拥有选择（不论这选择多么微不足道甚至虚幻）时，我们对自主权的需求便能得到满足，我们的动力和幸福感也便增强了。当你在给孩子、学生或员工布置任务时可以运用这些因素。这也是帮助他人将目标“内化”的最佳方式，因为最大的成就来源于我们认为属于自己的目标。</p>
<h1 id="实现目标需要思维转换"><a href="#实现目标需要思维转换" class="headerlink" title="实现目标需要思维转换"></a>实现目标需要思维转换</h1><p>请记住，尽可能地根据你正在着手的具体事宜决定相应的目标型，这是至关重要的。</p>
<ul>
<li><strong>事情容易时，用“进取”目标</strong></li>
</ul>
<p>把注意力集中在展示你的能力以及实现“进取”型目标上。聚焦于成功带来的好处。</p>
<ul>
<li><strong>没有动力时，多想想大局</strong></li>
</ul>
<p>提醒自己目标为何重要。选择“防御”型目标，聚焦于失败带来的损失。</p>
<ul>
<li><strong>事情困难（或陌生）时，目标要具体</strong></li>
</ul>
<p>告诉自己达标需要完成的任务步骤“是什么”。选择“防御”型、 “进步”型目标，把注意力从“表现”转移到“进步”。</p>
<ul>
<li><strong>诱惑横行时，多用“为什么”思考</strong></li>
</ul>
<p>同时选择侧重于避免损失的“防御”目标，这样能帮助你抵抗哪怕是最具魅力的诱惑。</p>
<ul>
<li><p><strong>如果你需要速度，选择侧重于收益的“进取”目标。</strong></p>
</li>
<li><p><strong>如果你需要准确，选择侧重于避免损失的“防御”目标。</strong></p>
</li>
<li><p><strong>如果你需要创造力，选择“进取”目标。</strong></p>
</li>
</ul>
<p>同时还要确保你追求的目标是发自内心的。自主权的感受能点燃创造力的火种。</p>
<ul>
<li><strong>如果你希望奋斗的过程是愉悦的，选择“进步”目标，同时确保目标为自主选择。</strong></li>
</ul>
<p>当我们注重进步（而不是表现）并有很强的内在动力时，我们更会让自己快乐。</p>
<ul>
<li><strong>如果你想拥有真实、长久的幸福，选择满足“关联感”、“胜任力”和“自主权”这三个基本需求的目标。</strong></li>
</ul>
<p>避免过多关注名声、威望和财富一一即便你能得到这些也无法得到长久的幸福。</p>
<h1 id="行动之前的准备了解目标破坏者"><a href="#行动之前的准备——了解目标破坏者" class="headerlink" title="行动之前的准备——了解目标破坏者"></a>行动之前的准备——了解目标破坏者</h1><ul>
<li><strong>行动最重要。</strong>大多数时候我们都知道达标需要做什么，但就是无法付诸行动。聚焦于行动是成功的要素。</li>
<li><strong>抓住当下。</strong>我们每天都过得忙忙碌碌，追寻着很多目标，所以时常错过行动机会。有的机会就是被我们忽视了一一这没什么好惊奇的。若想达到目标，你需要在机会溜走前抓住它。</li>
<li><strong>知道做什么。</strong>当我们抓住了时机时，你要清楚地知道如何运用时机。你若不能敏捷地行动便有可能浪费机会。</li>
<li><strong>拿起盾牌。</strong>目标需要我们的保卫。干扰、诱惑以及相互矛盾的目标都会偷走你的注意力和精力，削弱你的动力。</li>
<li><strong>了解现状。</strong>若想成功你需要认真地监控。如果你不知道自己的进度如何便无法对行为或策略加以调整。要经常检查自己的进度。</li>
</ul>
<h1 id="用如果就-制定简单有效的计划"><a href="#用”如果……就……“-制定简单有效的计划" class="headerlink" title="用”如果……就……“ 制定简单有效的计划"></a>用”如果……就……“ 制定简单有效的计划</h1><ul>
<li><strong>制订计划。</strong>我们在为目标打拼的途中遇到的很多问题都能被简单的“如果…就…”计划解决。不论你是想抓住当前的机会、抵抗诱惑、应对焦虑与自我怀疑，还是在困难中坚持不懈，这种计划都能助你一臂之力。</li>
<li><strong>决定具体行动。</strong>你首先要决定达标所需的具体步骤。避免模糊不清的内容，例如“少吃点”“多学点”一一你需要清晰、精确的目标。建立类似于“每晚至少学习四个小时”的清晰计划，你便对自己需要做什么以及达标与否一目了然了。</li>
<li><strong>决定时间和地点。</strong>接下来，决定做每个步骤的时间和地点。请尽可能做到详细。这可以帮助你的大脑探测并抓住行动时机一一即便是在你的意识无暇顾及时。</li>
<li><strong>整理出“如果…就…”计划。</strong>把上述几步整理成一句“如果…就…”式的陈述。“如果是平日晚上，我就在我的房间里学习至少四个小时。”如果你愿意，可以把这些陈述写在笔记本里，或者重复说给自己听，让自己消化它。</li>
<li><strong>瞄准障碍。</strong>想想达标路上有可能出现的障碍与诱惑。你要如何应对？为你想到的每一点制订一条“如果…就…”计划。(“如果平日晚上朋友叫我出去玩，我就拒绝并告诉他们周末见。”)这使你提早制订出最佳计划，不论遇到何种情况都能保证你不偏离达标的轨道。</li>
</ul>
<h1 id="自制肌的疲劳和保养"><a href="#“自制肌”的疲劳和保养" class="headerlink" title="“自制肌”的疲劳和保养"></a>“自制肌”的疲劳和保养</h1><ul>
<li><strong>不进则退。</strong>你的“自制肌”与身体肌肉一样，得不到锻炼就会逐渐萎缩。当你常常得当地运用它，使它得到锻炼，它就会茁壮成长，并帮助你实现目标。</li>
<li><strong>启动自制力。</strong>为了锻炼自制力，你可以接受一些平常不愿接触的挑战，比如放弃高热量零食、每天做100个仰卧起坐、挺直腰板、学一门新技能。当你想让步、放弃或不再在乎时，请别这样做。就从很小的一个行动做起，为有可能面临的困难做出应对计划(如果我馋零食了，就吃一片新鲜水果或三片水果干)。刚开始会有些难，但慢慢就好了。你变强大了，能接受的挑战便多了，对自制力的锻炼也能更上<br>一层楼了。</li>
<li><strong>休息必不可少。</strong>肌肉会疲劳。自制力用了太多就会耗尽。刚刚运用过自制力的你面对诱惑、干扰和其他陷阱时尤为脆弱，也尤其容易误入歧途。如果可能的话，在自制力有所恢复之前，别对自己要求太多。</li>
<li><strong>自制力感染。</strong>当你需要给自制力提提神时，不妨运用“目标感染”的方式。观察或想象他人发挥自制力能使你感染上这种能量。(但记住保持心理距离，过多地感同身受也会消耗你的自制力！)好心情也能提升自制力，所以给自己找些舒缓神经的事物（酒精除外）来补充自制力储备吧。</li>
<li><strong>来点甜食。</strong>自制力能量至少一部分取决于体内的血糖量。长期维持体内血糖量的最佳方式是摄取蛋白质和复合碳水化合物。当你临时需要快速有效的方式时，不妨吃块点心或是喝杯含糖饮料(不过要注意：代糖不是糖，不能带来同样的效果)。摄取的糖分通过体内循环抵达大脑需要大约十分钟，所以请耐心等待。记住这种糖分是单一碳水化合物，很快就会被消耗，所以别指望它的效力能持续多久。</li>
<li><strong>停止于开始前。</strong>当自制力的库存低时，学会运用策略降低对它的需求是很重要的。请记住，彻底不做一件事永远比开始后再停止它要容易，也不需要那么强的意志。(彻底不碰薯片比只吃两三片要容易得多。)其他可以帮助你的策略包括“为什么”式思维，强力度的“自我监控”（以确认自己没有偏离目标），以及鼓励措施（比如报酬或奖赏），它们都能激发你的动力。</li>
<li><strong>别冒无畏的险。</strong>很重要的一点是：无论你的“自制肌”多强大，请永远尊重它的局限性。自制力用了很多后就会暂时耗尽。在你所能控制的范围内，别试图同时接受两个挑战（比如同时戒烟和减肥）。也别把自己推向危险地带一一很多人对自己的抗诱惑能力过于乐观，于是他们使自己处于充满诱惑的境地。为什么要给自己添没必要的麻烦呢？</li>
</ul>
<h1 id="聪明地乐观着让信心切合实际"><a href="#聪明地乐观着——让信心切合实际" class="headerlink" title="聪明地乐观着——让信心切合实际"></a>聪明地乐观着——让信心切合实际</h1><p><strong>如何让信心切合实际</strong></p>
<ol>
<li>问问自己为何乐观。假设你要去面试，而你觉得自己比其他应聘者更具优势，请思考你为何具有优势。或许你可以一条条地写下来，这样能使你更充分地阐述原因。</li>
<li>其他人同样也具有优势的可能性有多大？例如，如果你觉得自己聪明或是以好成绩毕业于好学校，因此很有可能应聘成功，那么请想想是不是有其他拥有同样条件的应聘者。你真的能脱颖而出吗？这样想实际吗？</li>
<li>现在该思考你如何控制成败了。你能做什么来提高录用概率？如何准备面试以呈现最佳状态？做什么才能使成功变成现实？采取措施确保成功，这样你才能拥有真实、现实、应有的乐观，以助你展示最好的自己。我还想说两点乐观的危害一一之前都提到过，但我觉得值得重申。首先，记住当你在追求“防御”目标时，请避免乐观。每当你面对与安危有关的目标、当你最想避免损失时，你最好常常想着哪里会出错，以此来获取动力，而不要信心十足地告诉自己一切都会很好。</li>
</ol>
<ul>
<li><strong>适度乐观是有益的。</strong>乐观精神能带来很多好处，它能增强动力，帮助你更好地对目标做出优先选择，也能让你处变不惊。</li>
<li><strong>有时乐观是危险的。</strong>乐观也能让你付出惨痛的代价一一对后果考虑不周，准备不充分，冒不必要的险。乐观者更有可能选择使人自我感觉良好的心态应对挫折，而不去分析哪里可以改善、下次如何做得更好。</li>
<li><strong>了解乐观的种类。</strong>了解不切实际的乐观与基于现实的乐观是关键。不切实际的乐观是对于无法掌控的情景表示乐观一一例如命运、幸运或固定能力。如果你相信自己生来聪慧过人、被幸运环绕或是“有明星气质”，你只是在自找麻烦。不切实际的乐观者不会为实现目标做出必要的行动，遇到困难便束手无策。</li>
<li><p><strong>保持清醒。</strong>基于现实的乐观是因事态在掌握之中而产生的信心。你相信自己能成功是因为你会努力、会保持动力、会使用适当策略来<br>确保目标的达成。这种现实的乐观者很少犯代价重大的错误，最终更容易成功。</p>
</li>
<li><p><strong>如果不真实，使它变真实。</strong>当你追求目标时，请确保自己的乐观感受是现实的。若有怀疑，请运用我在此章中列出的方式来自我检测。(指出乐观的原因，挑战不切实际的假设，用成事所需的具体计划和步骤来代替一切不切实际的想法。)</p>
</li>
<li><strong>把注意力从能力上转移。</strong>如果你怀疑自己的能力，那么请把注意力转移到努力、坚持与计划上来，因为这些往往才是成功的关键。想想曾实现相同目标的榜样也会有所帮助。高成就者往往努力又聪明地工作，这点是值得每个人学习的。</li>
<li><strong>翻开过去的一页。</strong>回想自己过去的成就是另一种增强乐观精神的方式。提醒自己具备能力对增强自信有奇效。</li>
<li><strong>别构想成功画面。</strong>取而代之，去构想成功所需的步骤。仅仅想象自己冲过终点线的瞬间并不会带你到达那里，但是想象跑步的战略、可能遇到的障碍和应对的方案不仅能使你更加自信，还能帮助你更好地准备。这便是现实的乐观了。</li>
</ul>
<h1 id="打持久战懂得坚持适时放弃"><a href="#打持久战——懂得坚持，适时放弃" class="headerlink" title="打持久战——懂得坚持，适时放弃"></a>打持久战——懂得坚持，适时放弃</h1><p>何时放弃？</p>
<ol>
<li><p>我为什么觉得达成这个目标有困难？哪个因素能使我更加成功？</p>
<ul>
<li>更多的时间、更多的努力、新的策略、专家的帮助、更强的自制力、更好的计划</li>
<li>如果答案是“我不行，我做不到”，那么你错了，请再回答一次。</li>
</ul>
</li>
<li>我能做到达标所需的行动吗？有足够的时间和精力，能得到需要的帮助吗？如果答案是否定的，你需要考虑放弃目标了。</li>
<li>做这一切行动是否代价太大？我是否会因此闷闷不乐？是否需要放弃其他重要的目标？如果答案是肯定的，你需要考虑放弃目标了。</li>
</ol>
<ul>
<li><strong>你坚韧吗？</strong>愿意为目标长期投入、在困难面前也不退缩的人比没有坚韧精神的人更易成功。</li>
<li><strong>坚韧起来。</strong>你可以通过选择合适的目标来增强坚韧度：“进步”型以及自主选择的目标能使人保持长期投入的状态。</li>
<li><strong>怪你不努力，不怪你笨。</strong>如果你相信达不成目标是因为缺乏必要的能力，你也就不会做出有建树的改变了。勤奋、计划、坚持以及好的策略是实现目标的真正关键。认识到这点不仅能帮助你更好地看清自己和自己的目标，还能增强你的坚韧度。</li>
<li><strong>你无法拥有一切。</strong>认为自己能力不够而放弃目标永远是不理智的选择，但这并不意味着你必须坚持所有的目标。要认识到每天的可用时间与精力是有限的，这很重要，有时你必须有所放弃。当实现目标并不现实时，别害怕放手。</li>
<li><strong>有的代价不必付出。</strong>当你能实现很想要的目标但代价太大时，放弃也是完全没有问题的选择。有些牺牲是不值得的一一太痛苦或是需要我们放弃太多其他东西。</li>
<li><strong>旧的不去，新的不来。</strong>若想当一个健康、知足的人，知道何时放弃太困难或代价太高的目标是关键。为了让这个过程更容易也更有收获，请找个新的目标来替代旧的，从而使你保持参与感和使命感，在人生的道路上一路前行。</li>
</ul>
<h1 id="适当反馈批评和表扬的策略"><a href="#适当反馈——批评和表扬的策略" class="headerlink" title="适当反馈——批评和表扬的策略"></a>适当反馈——批评和表扬的策略</h1><ul>
<li><strong>真诚地反馈。</strong>不能因为顾及对方的感受而回避实话。告诉别人“不是你的错”或者“你己经努力了”也许能让他们好过些，但同时会使他们觉得束手无策、斗志涣散。人们要为自己缺少勤奋和用错策略而负责，只有这样才能激励自己在未来的日子里做得更好。</li>
<li><strong>正面、实用的建议。</strong>给予批评时很重要的一点是要传达这样一个信息：对方一旦做出正确的行动就能有所成就。要具体提出问题的本质以及解决的方法。</li>
<li><strong>真诚的赞美。</strong>若想增强而不是削弱他人的动力，你的赞美必须听上去是真诚的。过于“奔放”、笼统或频率太高的表扬都会听起来不真诚。把表扬留给真实、执行到位、令你真心赞叹的成就。</li>
<li><strong>表扬请对事不对人。</strong>表扬应侧重于对方可控的行为。强调勤奋、正确的方式、决心与毅力，避免赞扬天生的或人们觉得难以改变的能力。</li>
<li><strong>避免比较。</strong>请避免直接在学生、职员或孩子间进行比较。你不如用他们过去与现在的表现做比较，这样便强调了进步的价值，从而把他们的注意力集中到进展中去。</li>
<li><strong>得到表扬不是目的。</strong>别让表扬与奖励削弱了他人的自主权。承认别人的选择与感受，这样能使他们专注于所做的事情中。珍贵的内在动力需要被呵护才能有所成就。</li>
<li>再次强调：<strong>请务实。</strong>赞扬（和批评）始终应该反映真实、可达到的标准和期望值。小心别让夸张的语言（比如“你可以成为最好的！”）把你淹没在太想完美的压力中。</li>
</ul>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>psychology</tag>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>《西方正典》卡夫卡</title>
    <url>/post/64ac8222/</url>
    <content><![CDATA[<h1 id="正典耐性与无可摧毁性"><a href="#正典耐性与“无可摧毁性”" class="headerlink" title="正典耐性与“无可摧毁性”"></a>正典耐性与“无可摧毁性”</h1><p><strong>《审判》和《城堡》无法和《追忆》《尤利西斯》《守灵》相提并论，然而他的小故事、格言却超出了普鲁斯特、乔伊斯的水平。</strong></p>
<p>也许到22世纪，卡夫卡成为但丁，弗洛伊德成为蒙田。基督教救不了卡夫卡，犹太复国主义他也没上车，他没有任何正面因素可继承。</p>
<h2 id="卡夫卡是属于我们这个时代的独特精神体"><a href="#卡夫卡是属于我们这个时代的独特精神体" class="headerlink" title="卡夫卡是属于我们这个时代的独特精神体"></a>卡夫卡是属于我们这个时代的独特精神体</h2><p><strong>“卡夫卡风格”(Kafkaesques)</strong> 或许已经成了弗洛伊德所谓的“诡奇者”(the uncanny)，一种与我们如此亲近有如此疏隔的东西。</p>
<p>卡夫卡不是短篇小说家，他的精彩想象体现在某些片段中，而非整个故事。《煤桶骑士》《乡村医生》《猎人格拉古》《中国长城》是最有名完整片段。</p>
<p>想要了解二十世纪的经典文学天才的深层自我，必须在他试图以最客观、最不具个人色彩的面貌出现时吸纳之。</p>
<h2 id="卡夫卡在其作品和谈话里不断劝人要有耐性"><a href="#卡夫卡在其作品和谈话里不断劝人要有耐性" class="headerlink" title="卡夫卡在其作品和谈话里不断劝人要有耐性"></a>卡夫卡在其作品和谈话里不断劝人要有耐性</h2><p><strong>了解深层次的自我而非片段的精神状态，是卡夫卡极为独特的负向模式</strong></p>
<p>卡夫卡自认为是犹太神秘主义者，《圣经》中的上帝十分焦躁，卡夫卡的使命是让这个上帝变得更有耐心。深受卡夫卡影响的沃尔特·本雅明等人也如卡夫卡一样对时间感到焦躁不安，在作品和谈话中，<strong>卡夫卡一直告诉人们耐心高于一切。</strong></p>
<p>耐性，是卡夫卡的求知之道，但它无法引导出卡夫卡的<strong>二元负向性</strong>或卡夫卡的<strong>犹太神秘哲学(Kabbalah</strong>)， 我们常常把<strong>神秘灵知(gnosis)</strong>和<strong>神秘论知思想(gnosticism)</strong>连在一起，但卡夫卡将二者分离开。<br>卡夫卡称神秘灵知为<strong>“耐性”</strong>，称神秘论知思想为<strong>“负向物”(the negative)</strong>。前者极为缓慢，后者快得吓人。因为后者（负向物）包含卡夫卡在一切人事物的核心所察觉到的二元现象。<br>以下是卡夫卡式的“耐性”的代表句子：</p>
<blockquote>
<p>你不必离开住所。坐在桌旁倾听。甚至不必去听，只要等待。或者连等待也不必，只要<strong>完全静默</strong>，一人独守。<strong>世界会在你面前揭开面纱</strong>；非此不行。这世界在狂喜中自会在你眼前扭动。</p>
</blockquote>
<p>犹太人如弗洛伊德的‘压抑’，一切都已经发生，太阳底下无新鲜事，但卡夫卡认为一切尚未发生，无胜无败。卡夫卡对自己的家庭罗曼司十分忧虑，但他笔耕不辍，因为‘什么都尚未发生过。<br>’亚伯拉罕的立约‘是头等大事，然而卡夫卡认为亚伯拉罕是个不能信赖的人，而这种思考与犹太传统是背道而驰的。在精神层面上，“亚伯拉罕”具现了<strong>律法(the law)</strong>或<strong>正向犹太教(positive Judaism)</strong>。抛弃律法而侍奉自己的负向哲学的卡夫卡，同时也舍弃了对世界有所误解的亚伯拉罕：</p>
<blockquote>
<p>亚伯拉罕成了下述幻觉的受害者：<strong>他无法忍受世界的一体性</strong>。现今这世界异乎寻常地千变万化，这一点只要任何时候仔细端详一小块世界就可证实。所以，对世界一体性的抱怨实际上是抱怨没有和这多样的世界深刻地融合。</p>
</blockquote>
<p><strong>卡夫卡是个聪明的讥讽家，他不相信自己的艺术和生活能和多样的世界充分结合，他批评亚伯拉罕实际表明了他的自我和他的逃避行为。卡夫卡口中的“耐性”和”逃避“，正是他实践写作艺术的预备譬喻或隐喻。</strong></p>
<p><strong>忍耐一词就是他的逃避。乔伊斯欢迎别人的阐释且会引导，卡夫卡却不欢迎评论</strong>。他对可阐释性特意回避。《一条狗的身世》我们看了一个精彩高潮的故事，却不知道其中猎犬代表什么。卡夫卡在小说中对神性无暗示也无表现。卡夫卡故事中许多魔鬼装扮成天使和神祗，上帝却不在此处。他连犹太诺斯替和犹太神秘主义都不是，他对任何人不抱希望，对自己也是。</p>
<p>卡夫卡的作品中<strong>一切带有超越意味的东西事实上都是嘲弄</strong>，但这并非简单的嘲讽，它源自一种<strong>精神上的甘甜(sweetness of spirit)</strong>。卡夫卡所写的许多东西都包含了酷烈的事实、语调、困厄——可怕的事情即将发生。</p>
<blockquote>
<p>米莱娜太太，许久没与你通信，今日动笔也纯属偶然。实际上我不必为此而愧疚，因为毕竟你知道我是多么讨厌写信。<strong>我生活中的一切不幸</strong>——虽然我无意抱怨而只想说点有教益的话——<strong>可以说都源自书信或是写信的可能</strong>。人们很难欺骗我，但书信总是让我上当，这其实包括了他人和我自己的书信。就我说来，我实在不想对这特别的不幸多说一句，但这同时也是普遍现象。随便写信的可能必然给世界带来可怕的灵魂解体，仅从理论上讲也是这样。<strong>事实上写信是和鬼魂交往</strong>，不仅是收信人而且是写信人自己的鬼魂。<strong>这鬼魂在信件的字里行间中生成</strong>，更在一连串的信件往来中生成，这些信件中的每一封都与另一封合作，并把它作为见证人。这世上究竟是谁想出的主意让人们通过信件互相沟通！人们可以想到远方之人，也可抓住近旁之人，其他一切皆非人力可及。然而<strong>写信却让人在鬼魂面前袒露自我，而鬼魂也在翘首以待</strong>。写下的亲吻不会到达目的地，相反鬼魂在半途中即已将它们啜饮。正是这丰富的养分使鬼魂数量大增。人类感受到它并加以反抗。为了消除人们之间的鬼魂因素和创造心灵平静的自然沟通，人类发明了铁路、汽车和飞机。但这已不再有效，因为这些发明显然都出现在衰落之际。与之对立的一方更为沉静而强大，它在发明了邮政以后又发明了电报、电话和无线电。鬼魂们不会挨饿，而我们却会毁灭。</p>
</blockquote>
<h2 id="卡夫卡所写的东西几乎都和犹太人-犹太人传统有某种联系"><a href="#卡夫卡所写的东西，几乎都和犹太人、犹太人传统有某种联系" class="headerlink" title="卡夫卡所写的东西，几乎都和犹太人、犹太人传统有某种联系"></a>卡夫卡所写的东西，几乎都和犹太人、犹太人传统有某种联系</h2><p>卡夫卡在心中对自己犹太人的自我憎恨是明显的，不过只是一种表面的无奈。卡夫卡所写的东西，几乎都和犹太人、犹太人传统有某种剪不断、理还乱的联系。</p>
<p>卡夫卡拥有无比细腻的宗教感知，但他不相信上帝，也不相信诺斯替光明，普鲁斯特、弗洛伊德、乔伊斯、伍尔夫、博尔赫斯、贝克特都是如此。但这些人都没有卡夫卡身上的精神特质，即使是即使受卡夫卡影响最深的贝克特。</p>
<p>卡夫卡书中人物若有上帝，一定是海涅所说的阿里斯托芬，一个备受折磨的信仰者。</p>
<p>里奇罗伯逊说卡夫卡：</p>
<blockquote>
<p>宗教的意象宜乎表达宗教的冲动，但不宜诠释这一冲动。<br>(因为卡夫卡总是避免诠释这一冲动，也不愿为任何一种既定的诠释背书，读者只能独子面对卡夫卡所呈现的那份冲动。卡夫卡的这一呈现，有时采用熟悉的意象，有时则不然。因此，<strong>在可能的范围之内去了解卡夫卡自己的立场</strong>显得格外重要)</p>
</blockquote>
<p>卡夫卡否认他作品是犹太式，卡夫卡认为他是犹太之终或犹太之始，或许两者皆是。卡夫卡的否定和黑格尔的否定不同，卡夫卡承认事实的首要性，卡夫卡并非唯心主义者。卡夫卡重视经验，尽管其幻想力强大。</p>
<p><strong>无可毁灭性(inde-structibilty)的概念是卡夫卡最核心的精神元素</strong></p>
<blockquote>
<p>信念即意味着解放自身中不可摧毁的因素，或更确切地说，变得不可摧毁，再确切地说，就是存在。<br><strong>一个人相信自身有不可摧毁的因素，他才能存在。这种因素和相信都是他无法察觉的。</strong><br>不可摧毁者就是：它是每一个个体存在，同时又属于众人，因此它就是人与人之间存在的不可分割的连结。如果应在天堂里被摧毁的东西是能够毁灭的，那它就不具有决定性；而如果它是不可摧毁的，那我们就是活在一个虚假的信仰之中。</p>
</blockquote>
<h2 id="存在于意识之间的缝隙是卡夫卡真正关心的主题"><a href="#存在于意识之间的缝隙是卡夫卡真正关心的主题" class="headerlink" title="存在于意识之间的缝隙是卡夫卡真正关心的主题"></a>存在于意识之间的缝隙是卡夫卡真正关心的主题</h2><p>卡夫卡另一个概念 <strong>tikkun——吾人存在之破容器的复原</strong>：</p>
<blockquote>
<p>精神世界之外一无所有，我们所称的感官世界是精神世界里的邪恶因子，而我们称为邪恶的只是我们永恒进化过程中一个必要时刻。</p>
</blockquote>
<p>这段话十分神秘主义。但卡夫卡并非如此充满希望</p>
<blockquote>
<p>上帝多的是希望，但我们则不然。希望属于能被摧毁的意识，而不属于不可摧毁的存在。</p>
</blockquote>
<p>卡夫卡已经成为二十世纪最具有经典性的作家，因为在我们每个人身上，都可以找到存在与意识之间的缝隙，而这正是他真正关心的主体，他将者主体与身位犹太人，或至少是身为漂泊的犹太人联结在一起。</p>
<p>弗洛伊德、尼采、卡夫卡都相信：最深处的自我是可以被强化的，爱欲可以成为对抗死亡驱力的堡垒。他们也都认为意识是错谬的、充满了谬误的希望。<br>虽然弗洛伊德拒绝接受有关存在的神秘性概念(弗洛伊德说这是大海一般的感受)，他用善良的权威提供给我们治疗虚假意识的方法。<br>与之相对的，卡夫卡绝斥所有的权威，他从来没有为自己或我们提供任何治疗方法。然而，卡夫卡总是叙说着存在，叙说着无可毁灭者，为不可摧毁性辩护：</p>
<blockquote>
<p>就我所知，我自身并不带有任何生命所需之物，却只有普遍的人性弱点。在这方面它的力量巨大，借此我已强健地吸收了自己时代的<strong>否定因素</strong>，这时代当然离我很近，我也<strong>无权反抗它，而只是有权表现它</strong>。对那些不多的积极因素，或由极端否定而转向肯定的因素，我丝毫没有继承。和克尔凯郭尔不一样，我没有受那如今已公认松垮弛废的基督教引导而进入生命；也没有像犹太复国主义者那样抓住犹太祈祷披肩下摆，而这下摆如今正在飘离我们。我是终点，或是开端。</p>
</blockquote>
<p><strong>“反转成正面的极端负面质素”必然是一种饱满的负向神学。</strong><br>也许在寓言他那时代、当地犹太人的处境，或者一个作家的处境。他的否定中有对压抑的发泄，医生的命运是犹太人式的。<br>村医的故事中缺乏关爱，从头到尾压抑，卡夫卡作品里没有可爱可怜的人物，所有人物无一例外令人不悦。医生与我们的处境差不多，我们却不太同情他。正如没有人同情我们。</p>
<p><strong>诡异色彩的作品是成功的必然，尼采用痛苦令人难忘，卡夫卡用怪异，他的人物缺乏情感。</strong><br>卡夫卡告诉我们，人的意志在信仰和意识形态之外也有不可摧毁的，乔伊斯、普鲁斯特不会认同。卡夫卡的宗教式光晕某天会消褪，然而如今存在。<strong>他以精神探求为使命。</strong></p>
<h2 id="无可毁灭性直指人们最深处-最私密的生命质素"><a href="#无可毁灭性直指人们最深处、最私密的生命质素" class="headerlink" title="无可毁灭性直指人们最深处、最私密的生命质素"></a>无可毁灭性直指人们最深处、最私密的生命质素</h2><p>如果无可毁灭性既非永生、也非福佑，那它是什么？</p>
<p>卡夫卡从未说清楚“无可毁灭性”是什么概念，但他感受到了这种“无可毁灭性”，这份感受实实在在，绝非个人的迷情遐思。在他心目中，这是人与人之间真正的连接，直指人们最深处、最私密的生命质素。除了神秘灵知以外，不知该如何描述“无可毁灭性”，但它拒斥任何有关上帝概念。<br>卡夫卡所肯定的是一种人类原初的属性，它具有神的气质但仍属于世俗：它是一切知晓，无可毁灭性是其中的已知。<br>卡夫卡与生命核心中感觉到一种无可毁灭性，这份感觉对他而言是一件事实，等同于他的作家志向。或许这就是为什么他会在这个时代，成为散发浓厚精神气息的经典标杆：<strong>卡夫卡不是宗教作家，但他让写作变成了一门宗教。</strong></p>
<p>卡夫卡世界法则在于莎士比亚的无意识的负罪感，<strong>我们之所以有罪，正是因为我们最深层的自我是无可毁灭的。卡夫卡忍耐，逃避，回避，隐喻，这都是为了承载他对不可摧毁性的感受。</strong></p>
<p>贝克特的最好的作品——《终局》《克拉普的最后磁带》《马龙之死》《如此情况》等都有这种感觉遗留。<br>贝克特看来，不可摧毁之物，是当你无法持续下去时仍然持续下去的作。可在卡夫卡的作品中，“持续下去”总是以反讽的形式进行。</p>
<p>我们内在的“无可毁灭性”是一种希望或探求，但是正在卡夫卡之罪阴暗的吊诡底下，这种努力所显现出来的是无可避免的毁灭性、尤其是自我毁灭性。与其说耐性是卡夫卡心目中的首要美德，不如说它是继续存活下去的唯一凭借。</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>booknote</tag>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>《法理学 法律哲学与法律方法》读书笔记</title>
    <url>/post/aeb5411/</url>
    <content><![CDATA[<h1 id="第一部分-法哲学的历史沿革"><a href="#第一部分-法哲学的历史沿革" class="headerlink" title="第一部分 法哲学的历史沿革"></a>第一部分 法哲学的历史沿革</h1><h2 id="第一章-希腊和罗马的法学理论"><a href="#第一章-希腊和罗马的法学理论" class="headerlink" title="第一章 希腊和罗马的法学理论"></a>第一章 希腊和罗马的法学理论</h2><h3 id="第一节-早期希腊的理论"><a href="#第一节-早期希腊的理论" class="headerlink" title="第一节 早期希腊的理论"></a>第一节 早期希腊的理论</h3><ul>
<li><p>神意论，法律被认为是由神颁布的，而人则是通过神意的启示才得知法律</p>
</li>
<li><p>海希奥德：法律乃是建立在公平基础之上的一种和平秩序，它强迫人们戒除暴力，把争议提交仲裁。</p>
</li>
<li>智者运动：哲学开始与宗教分立，希腊古老传统的生活方式也受到了彻底的批判。<ul>
<li>法律不再是神授命令，完全是人造物，为权宜和便利而制定，并可以根据人的意志而更改</li>
<li>否认正义概念中的形而上特性，并开始根据人的心理特征或社会利益对其进行分析</li>
</ul>
</li>
<li>实现上述价值观转变的诡辩派：<ul>
<li>普罗塔高勒斯：作为个体的人是一切事物的尺度。每个问题至少存在两种观点，把弱势的论点辩为强势的论点正是诡辩的功能所在。</li>
<li>安提弗：自然命令不可抗拒，法则的命令则是人类专断制定，变化、偶然、人为的安排。人所约定的惯例，实际上还是对自然“权利”设定的一种桎梏。</li>
<li>卡里克利斯：“强者之权利”宣称为与“约定”法相对的“自然”法的基本原理。法律试图使人人平等，然而人本质上根本不平等，如果强者摆脱非自然的法律限制，实际上是在安自然法则行事</li>
<li>斯拉雪麦格：强权即公理</li>
</ul>
</li>
</ul>
<h3 id="第二节-柏拉图的法律观点"><a href="#第二节-柏拉图的法律观点" class="headerlink" title="第二节 柏拉图的法律观点"></a>第二节 柏拉图的法律观点</h3><ul>
<li>苏格拉底：确立克服诡辩派的主观主义和相对主义、建立一套以那种在客观上得到证明的价值理论为基础的实质性伦理体系的使命。</li>
<li>明确区分柏拉图的正义论和法律观：<ul>
<li>正义意味着”一个人应该做他的能力使他所处的生活地位中的工作”，人生来就是不平等的，在”理想国”中，每个等级都必须将其活动严格限制于适当履行本等级的特殊职责。</li>
<li>法律原则上是由抽象的、过分简单的观念构成的，然而，简单的原则是不可能用来解决纷繁复杂的事务状况的，所以正义的执行不需要法律——“最佳的方法不是给予法律以最高权威，而是给予明晓统治艺术、有大智大慧的人以最高权威”</li>
<li>“法律国家”是人进行统治的次优选择。这种国家统治当局在没有成文法典和法律规定的情形下已不再享有随意司法的权利。他们成为法律的仆人。</li>
</ul>
</li>
</ul>
<h3 id="第三节-亚里士多德的法律理论"><a href="#第三节-亚里士多德的法律理论" class="headerlink" title="第三节 亚里士多德的法律理论"></a>第三节 亚里士多德的法律理论</h3><ul>
<li>把以法律为基础的国家作为达到“善生活”的唯一可行手段。达至善生活乃是政治组织的主要目标。</li>
<li>以正当方法制定的法律应当具有终极性的最高权威。<ul>
<li>唯有神祇和理性应当行使统治，法律可以被定义为”不受主观愿望影响的理性”。</li>
</ul>
</li>
<li>法律规则的一般性和刚性可能会使法官无法将该规则适用于个别案件的解决——提出“衡平原则”</li>
<li>分配正义、矫正正义</li>
</ul>
<h3 id="第四节-斯多葛派的自然法"><a href="#第四节-斯多葛派的自然法" class="headerlink" title="第四节 斯多葛派的自然法"></a>第四节 斯多葛派的自然法</h3><ul>
<li>整个宇宙是由作为实体的理性组成的，自然法就是理性法。</li>
<li>理性是法律和正义的基础，存在一种基于理性的普遍的自然法，它在整个宇宙中都是普遍有效的。</li>
<li>斯多葛派自然法观念中的一个重要因素乃是平等原则；奴隶地位有所改善。</li>
<li>自然法和平观念影响了罗马家庭法律制度的发展：妇女从夫权中解放；父母与子女法律关系更为人道。</li>
</ul>
<h2 id="第二章-中世纪的法律哲学"><a href="#第二章-中世纪的法律哲学" class="headerlink" title="第二章 中世纪的法律哲学"></a>第二章 中世纪的法律哲学</h2><h3 id="第五节-早期基督教教义"><a href="#第五节-早期基督教教义" class="headerlink" title="第五节 早期基督教教义"></a>第五节 早期基督教教义</h3><ul>
<li>奥古斯丁认为世俗法律必须努力满足永恒法的要求，教会作为上帝永恒法的保护者对国家拥有绝对的权威。</li>
</ul>
<h3 id="第六节-托马斯的法律哲学"><a href="#第六节-托马斯的法律哲学" class="headerlink" title="第六节 托马斯的法律哲学"></a>第六节 托马斯的法律哲学</h3><ul>
<li>托马斯·阿奎纳的思想体系是基督教圣经教义与亚里士多德哲学的结合。</li>
<li>将法律划分为四种类型：永恒法、自然法、神法、人法。</li>
<li>正义是一种习惯，依据这种习惯，一个人根据一种永恒不变的意志使每个人获得其应得的东西。正义由两部分组成：分配正义；交换或矫正正义。</li>
</ul>
<h3 id="第七节-中世纪唯名论者"><a href="#第七节-中世纪唯名论者" class="headerlink" title="第七节 中世纪唯名论者"></a>第七节 中世纪唯名论者</h3><ul>
<li>对一般概念的性质以及这些概念与现实中存在的特定客体的关系的问题的争论，产生了两个思想学派即唯名论者和唯实论者。<ul>
<li>唯实论者：在人类思想的世界与外部现实的世界之间存在着一种严格的对应。</li>
<li>唯名论者：否定一般概念的实在性，自然界中唯一实在的物质就是人们通过观察而认识的那些单个的事物和对人之感觉的认知。</li>
</ul>
</li>
<li>法律的颁布及实施明确要求人们执行统治当局的意志，前提是这种意志是”正义的、正直的”，具有唯理主义倾向。</li>
</ul>
<h2 id="第三章-古典时代的自然法"><a href="#第三章-古典时代的自然法" class="headerlink" title="第三章   古典时代的自然法"></a>第三章   古典时代的自然法</h2><h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><ul>
<li>中世纪欧洲，天主教会是生活的中心。16世纪时，天主教会对精神生活的支配地位受到了来自新教的打击，许多国家对天主教的精神秩序和封建主义的世俗秩序发起攻击。</li>
<li>在法律领域，盛行于17、18世纪的古典自然法哲学占据支配地位。其完成了法学与神学的分离；主张理性的力量普遍适用于所有的人、国家和时代；带有强烈的个人主义倾向和诉求。</li>
<li><p>马基雅维利：国家理由原则，为君主提供了一种压制其国民的武器，客观上推动了民族国家的兴起。</p>
</li>
<li><p>古典自然法哲学的三个发展时段：</p>
<ul>
<li>第一阶段——文艺复兴和宗教改革以后从中世纪神学和封建主义中求解放的过程；标志是宗教中新教的兴起、政治上开明专制主义、经济重商主义；认为自然法得以实施的最终保障要靠统治者自身素质。关注安全</li>
<li>第二阶段——始于1649英国清教改革；以经济自由资本主义、政治及哲学自由主义为标志；主张天赋人权、三权分立、保障个人权利。关注自由</li>
<li>第三阶段——启蒙运动；标志是对人民主权和民主的信奉；认为自然法取决于人民的”公意”和多数的决定。</li>
</ul>
</li>
</ul>
<h3 id="第九节-格劳秀斯和普芬道夫"><a href="#第九节-格劳秀斯和普芬道夫" class="headerlink" title="第九节  格劳秀斯和普芬道夫"></a>第九节  格劳秀斯和普芬道夫</h3><ul>
<li>格劳秀斯认为，人有对社会生活的欲求，即与同类过和平而有组织的生活。他把自然法建立在一种遍及宇宙的永恒理性的基础上，为世俗的和理性主义的现代自然法观奠定了基础。</li>
<li>格劳秀斯指出演绎法和归纳法是证明判断某事是否符合自然法的两种方法。</li>
<li>普芬道夫：人同时受自私本性和社会生活冲动的影响，要求保护自身生命财产安全的同时也要遵守社会秩序。——任何人都不能挤压他人，以至他人不能控诉其权利的平等受到了侵犯。</li>
<li>普芬道夫认为，为确保自然法和国家法的实施，需要缔结两个契约：人们之间结成社会共同体的契约、公民和政府的契约。</li>
</ul>
<h3 id="第十节-霍布斯和斯宾诺莎"><a href="#第十节-霍布斯和斯宾诺莎" class="headerlink" title="第十节   霍布斯和斯宾诺莎"></a>第十节   霍布斯和斯宾诺莎</h3><ul>
<li>17、18世纪思想家努力在自然法的要求与国家理由的需要之间维持平衡。霍布斯与斯宾诺莎更倾向后者——国家理由原则</li>
<li>霍布斯：自然状态下人性的自私自利，利益是唯一合法的尺度。而由于人也具有在战争与和平之间更倾向于后者的激情，这种激情在自然状态下无法得到满足，所以理性就位人们提供了”自然法则”——寻求和平、缔结并履行契约等。</li>
<li>霍布斯：<ul>
<li>为使主权者充分履行职责，其应有至高无上之权力。</li>
<li>主权者把其意志强加于人民之主要工具为”国内法”——总之即”开明专制”理论，实质上是一种把法律等实施委托给”开明”专制君主的自由主义。</li>
</ul>
</li>
<li>斯宾诺莎：<ul>
<li>自然状态中欲望与权力意志的力量压制了理性，在自然状态中，个人权利之范围取决于其力量之大小。</li>
<li>自然状态导致斗争与失序，人之内在理性驱使其放弃自然状态，故合作组成国家、建立政府。</li>
<li>主张自然法对主权者权力具有限制与约束。此限制源于大众力量、政府对其自身利益的理性认识。因此，民主制或温和贵族立宪制比君主制更可取。</li>
</ul>
</li>
</ul>
<h3 id="第十一节-洛克和孟德斯鸠"><a href="#第十一节-洛克和孟德斯鸠" class="headerlink" title="第十一节   洛克和孟德斯鸠"></a>第十一节   洛克和孟德斯鸠</h3><ul>
<li>古典自然法学发展的第二阶段是以试图确立防止政府违反自然法的有效措施为标志的，法律被认为是一种防止专制独裁的工具。</li>
<li><p>洛克：</p>
<ul>
<li>人的自然状态是完全自由、平等的，按自己的意志行事并无需服从他人意志或权威。但这种状态也充满缺陷、不便和危险。为终止伴随自然状态而在的混乱与无序，人们缔结契约组成共同体并建立国家，国家的最高目标是实现人的自由。</li>
<li>与霍布斯认为的社会契约是公民完全服从专制君主的条约不同，洛克认为人们在建立政权时仍保留自然状态下其拥有的基本权利（生命权、财产权等）。基于此，洛克反对君主专制，主张有限权力的政府。</li>
<li>立法权和行政权相分离。但必要时行政机关可为增进社会利益使用特权，甚至法律本身也可能不得不让位于行政特权。</li>
<li>立法权与行政权的分离无法构成预防侵犯个人权利的充分有效措施，因此，自然法的最终保护者当为全体人民。</li>
</ul>
</li>
<li><p>孟德斯鸠：</p>
<ul>
<li>法律是由事物的性质产生出来的必然关系。其他”相对的偶然关系”如地理环境、宗教、国家政治结构也是构成法律基础之重要因素。</li>
<li>法律一般来说是”人之理性”；一些正义关系先存在于实在法而存在。</li>
<li>孟德斯鸠的声誉主要以其权力分立政治理论为基础。立法、行政、司法三权分立。</li>
</ul>
</li>
</ul>
<h3 id="第十二节-美国的自然权利哲学"><a href="#第十二节-美国的自然权利哲学" class="headerlink" title="第十二节   美国的自然权利哲学"></a>第十二节   美国的自然权利哲学</h3><ul>
<li>洛克的自然法理论与孟德斯鸠权力分立原则的结合，构成了美国政府制度的哲学基础。二者思想在美国政府制度中的连结点主要是司法审查原则。</li>
<li>詹姆士·威尔逊是美国自然法哲学的代表人物，认为存在一种源自上帝的自然法，认定法欲得到最终承认，就必须依凭这一永恒不变的自然法。他把自然法原则同人民主权论结合起来，认为国家是根据其成员的契约、为了共同利益而建立的。每个人对其财产、人格、自由及安全都拥有自然权利，确保这些自然权利免遭政府的侵犯乃是法律之职能所在。为了维护法治，就必须把分权制衡原则引入政府制度之中。——法律和自由在威尔逊的哲学中紧密结合在一起了。</li>
</ul>
<h3 id="第十三节-卢梭及其影响"><a href="#第十三节-卢梭及其影响" class="headerlink" title="第十三节   卢梭及其影响"></a>第十三节   卢梭及其影响</h3><p>●卢梭认为，政治的根本问题就是”要寻找出一种结合形式，使它能以全部共同的力量来护卫和保障每个结合者的人身和财富，并且由于这一结合而使每一个与全体相联合的人不过是在服从自己的意志，并像往常一样自由。”为了实现这个目标，每个个人必须通过缔结社会契约，毫无保留地把他的全部自然权利让渡给整个社会。</p>
<p>●卢梭否认公民全部自然权利之让渡会导致自由的丧失。”每个人既然是向全体奉献出自己，那么他实际上并没有向任何人奉献出自己；而且，既然从任何一个结合者那里人们都可以获得自己本身所让渡给他人的同样的权利，所以人们也就得到了自己所失去的一切东西的等价物，而且也得到了更大的力量来保全自己已由的东西。”——因此，所有的人既是一群被动的国民，同时又是一群主动的主权者，这个由公民组成的主权者群体，将保证个人及公民自由的形式在私有财产获得保障的过程中复得因让渡自然权利而失去的东西。</p>
<p>●在市民社会，个人只服从”公意”，每个人在服从公意的同时也就是服从他自己，因为个人的意志已经消融在公意之中。公意的表现形式是经由多数决策的方式达致的。</p>
<p>●反对代议制和代表机构，”一旦某个民族同意被代表，那么它就不再是自由的了。”</p>
<p>●法律必须具有一般性，并在其命令所及的范围内，对全体人民平等适用。</p>
<p>●影响：卢梭的思想对法国大革命的政治理论产生了强烈影响。其公意概念对19th、20th上半叶法兰西共和国的宪政制度也产生了影响。</p>
<h3 id="第十四节-古典自然法学派的实际成就"><a href="#第十四节-古典自然法学派的实际成就" class="headerlink" title="第十四节  古典自然法学派的实际成就"></a>第十四节  古典自然法学派的实际成就</h3><p>●古典自然法学家对法律调整的某些要素和原则进行了详尽的阐释，而这些原则和要素则是一个成熟的法律制度的基本先决条件。——这样，他们就为现代文明的法律秩序奠定了基础。</p>
<p>●古典自然法学派在法律与自由及平等价值之间发现了某种联系，而这种联系至少表明，对人施以压制性的和专横的统治实与法律的概念不相融合。</p>
<p>●法律不仅是抑制无政府状态而且也是抵御专制主义的有力武器。——反抗专制统治，推动资产阶级民主革命运动等。</p>
<p>●推动解放思想、刑罚人道化、资本主义发展等。</p>
<p>●掀起了一场强有力的立法运动。自然法的倡导者认为，通过运用理性的力量，人们能够发现一个理想的法律制度。1804《拿破仑法典》1896《德国民法典》1907《瑞士民法典》。</p>
<p>●不足：简单化、程式化、任意假设，比如毫无根据地认为理性能够设计出普遍有效的法律制度的全部细节。</p>
<h2 id="第四章-德国的先验唯心主义"><a href="#第四章-德国的先验唯心主义" class="headerlink" title="第四章 德国的先验唯心主义"></a>第四章 德国的先验唯心主义</h2><h3 id="第十五节-康德的法律哲学"><a href="#第十五节-康德的法律哲学" class="headerlink" title="第十五节  康德的法律哲学"></a>第十五节  康德的法律哲学</h3><p>●先验唯心主义是一种哲学态度，认为由人之心智形成的观念和概念具有自主存在的性质，并且否认这些观念和概念只是人们对不断变化的经验世界的反映。</p>
<p>●康德哲学的主要目的在于试图调和唯心主义的唯理论（其特点在于思想之于经验的首位性）与经验主义的感觉论（以那种认为所有人类知识都依附于感觉认知的观点为指导）。</p>
<p>●自由是康德的道德和法律哲学的核心。将自由划分成两种，一是伦理道德上之自由：人之意志的自主性和自决，遵循被其称为”绝对命令”的道德律；二是法律上之自由：个人对他人专断意志和控制的独立，任何人都没有权利仅把他人作为实现自己主观目的的工具，人即是目的本身。</p>
<p>●康德把法律定义为”那些能使一个人的专断意志按照一般的自由律与他人的专断意志相协调的全部条件的综合”。</p>
<p>●康德的国家理论与卢梭一致，认为国家的唯一职能便是制定和执行法律，因此他把国家定义为”众人依据法律而组织起来的联合体”。由于康德认为只有实在法才具有强制力，所以他为法律理论中的实证主义的兴起铺平了道路。</p>
<h3 id="第十六节-费希特的法律哲学"><a href="#第十六节-费希特的法律哲学" class="headerlink" title="第十六节  费希特的法律哲学"></a>第十六节  费希特的法律哲学</h3><p>●费希特认为所有哲学思想的出发点和核心都是而且必须是理智人的自我。主观唯心主义。</p>
<p>●法律是确保自由的个人得以相互共存的一种手段，每个个体都必须在一定的范围内行使自由，而这种范围是由其他个人所平等享有的自由加以确定的。</p>
<h3 id="第十七节-黑格尔的国家和法律哲学"><a href="#第十七节-黑格尔的国家和法律哲学" class="headerlink" title="第十七节 黑格尔的国家和法律哲学"></a>第十七节 黑格尔的国家和法律哲学</h3><p>●在黑格尔的哲学中，德国的先验唯心主义从主观唯理论转变为客观唯理论，宣传那种在历史和文明发展中不断展现的”客观精神”才是理性的主要载体。</p>
<p>●黑格尔提出了进化的观念，在法律哲学的历史上产生了深远的影响。认为社会生活的种种表现形式，都是一个能动的、进化的过程的产物。这个过程呈现为一种辩证的形式：它呈现在正题、反题和合题之中。人类精神确立了一个在某个特定时代成为主要观念的正题，为了反对这个正题，又确立了一个反题。然后在这二者的较量中，又发展出一个合题，因此这种合题是在一个更高的水平上对正题和反题的因素进行调和和吸收的结果。这个过程在历史中一次又一次地反复展开。辩证法，否定之否定。</p>
<p>●历史运动的终极目标是实现自由。在这一历史进程中，法律和国家起着至关重要的作用。</p>
<p>●法律制度是用来从外部形式方面实现自由理想的，自由并不意味着拥有为所欲为的权利，而是要受理性支配。理性的基本要求之一就是尊重他人的人格和权利，法律就是增强和保护这种尊重的主要手段之一。</p>
<p>●黑格尔把国家定义为”伦理世界”和”伦理理想的现实”，国家不仅是一个制定和执行法律的机构，还是展现一个民族伦理生活的有机体。因此国家被认为是民族精神和社会伦理的整体体现。</p>
<p>●黑格尔认为国家应当为人的精神利益服务，而且从国家最深刻的本质来看，它乃是精神力量的体现。国家应当赋予公民以拥有私人财产的权利；肯定家庭制；用法律确定权利义务关系。</p>
<p>●凡是合理的就是现实的，凡是现实的就是合理的。——其实对黑格尔来说，只有理念才是真正现实的，其是一个彻底的唯心主义者。他认为，在通向其目标的逐渐的、不懈的过程中，只要历史事件可以表明是在向着自由理念迈进，即使特定的、也许是无关紧要的事件表现出相当程度的不合理性，那么历史就是现实和合理的。类似整体与部分之辩证关系。</p>
<h2 id="第五章-历史法学与进化论法学"><a href="#第五章-历史法学与进化论法学" class="headerlink" title="第五章 历史法学与进化论法学"></a>第五章 历史法学与进化论法学</h2><h3 id="第十八节-萨维尼与德国的历史学派"><a href="#第十八节-萨维尼与德国的历史学派" class="headerlink" title="第十八节 萨维尼与德国的历史学派"></a>第十八节 萨维尼与德国的历史学派</h3><p>●17、18世纪的自然法哲学家都把理性看作是鉴别最理想、最完美的法律形式的指导。他们关注的是法律的目的和意图，而非其历史和发展过程。他们试图在某些自由和平等的原则的基础上建构一种新的法律秩序，并且宣传这些原则乃是理性和正义的永恒要求。</p>
<p>●法国大革命后的混乱与无序使得人们对”理性王国”失望，基于历史和传统的保守思想开始盛行。在这一时期。对于促使法律形成的各种因素的科学研究，开始取代对法律的理想性质、意图和社会目标的理性探求。德国反对法国大革命的理性主义原则和世界主义思想的运动，在法学领域的代表正是历史法学派。</p>
<p>●萨维尼《论立法和法理学在当代的使命》：法律乃是”那些内在地、默默地起作用的力量”的产物。它植根于民族之历史，源于普遍信念、习惯和”民族的共同意识”，决定于”民族精神”。</p>
<p>●习惯法乃是一个民族共同信念的最真实的表示，因此其高于制定法。而制定法也只有在它体现了普遍民族习惯和特性时才有效。</p>
<p>●要联系人物身份，萨维尼是一个憎恨法国大革命平等理性主义的保守贵族，一个反对反对法兰西世界主义理论的日耳曼民主主义者。</p>
<h3 id="第十九节-英国和美国的历史法学派"><a href="#第十九节-英国和美国的历史法学派" class="headerlink" title="第十九节  英国和美国的历史法学派"></a>第十九节  英国和美国的历史法学派</h3><p>●英国历史法学派奠基人、代表者亨利·梅因《古代法》：迄今为止的进步社会运动，乃是一个从身份到契约的运动。原始身份为受家庭网络和群体关系束缚的社会秩序的表征，随着文明进步，这种状态让位于一种基于契约之上的社会制度。——一种进步的文明，其标志乃是独立的、自由的和自决的个人作为社会生活的基本单位出现。个体通过缔结契约联合结成社会生活的共同体，类似自由人的联合/社会中人的原子化？</p>
<p>●法律的历史发展阶段：统治者个人命令-习惯法-由社会冲突引起的习惯法的法典化-修正古代严苛的法律-最后是用科学的法理学把上述所有法律形式编制成一个连贯而系统的整体。</p>
<p>●美国历史法学者卡特：习惯和惯例提供了调整人们行为的规则，司法先例不过是”被赋予了权威性的惯例”。法院并不制定法律，而只是从一些既有事实——即得到社会承认的惯例——中发现和探寻法律。</p>
<h3 id="第二十节-斯宾塞的法律进化理论"><a href="#第二十节-斯宾塞的法律进化理论" class="headerlink" title="第二十节 斯宾塞的法律进化理论"></a>第二十节 斯宾塞的法律进化理论</h3><p>●斯宾塞认为，文明和法律乃是生物的和有机的进化的结果，而生存竞争、自然选择、”适者生存”则是这一进化过程的主要决定因素。进化表现在分化、个体化、复杂化的劳动分工中。</p>
<p>●文明是社会生活由简单的同质形式渐进到复杂的异质形式的过程。分为两个阶段：一是原始的或军事的社会形态，其特征是以战争、强制和身份作为规范社会的手段；二是较高的或工业的社会形态，其特征是以和平、自由和契约作为支配因素。而发展到第二阶段的标志，是增加对政府职能之限制以增进个人自由。</p>
<p>●正义就是每个人的自由只受任何他人享有的相同自由的限制。我有言论自由，但我的言论自由不能侵害他人同样拥有的言论自由。</p>
<p>●信奉强势个人主义，认为只有国家才能保证和行使的社会”权利”（如社会抚养权）并不具有权利的性质；信奉自由放任主义，对多数统治所具有的政治后果（大阶级牺牲小阶级利益）担忧。</p>
<h3 id="第二十一节-马克思主义的法律理论"><a href="#第二十一节-马克思主义的法律理论" class="headerlink" title="第二十一节 马克思主义的法律理论"></a>第二十一节 马克思主义的法律理论</h3><p>●三个假设：</p>
<p>●法律是不断发展的经济力量的产物</p>
<p>●法律是统治阶级用以维护其统治较低阶层的权力的工具</p>
<p>●在共产主义社会，作为社会控制工具之法律会最终衰落、消亡。</p>
<p>●第六章 功利主义</p>
<p>●第二十二节 边沁和穆勒</p>
<p>●功利主义是一场风行于19世纪英国的哲学运动。</p>
<p>●边沁的理论始于这样一个公理：自然把人类置于苦与乐两种状态的统治之下。应当根据某一行为本身所引起的苦与乐的大小程度来衡量该行为的善与恶。</p>
<p>●边沁对功利的定义：这样一种原则，即根据每一行为本身是能够增加还是减少与其利益相关的当事人的幸福这样一种趋势，来决定赞成还是反对这种行为。如果该当事人是个人，那功利原则就旨在增进该个人的幸福；而若是社会，那么功利原则便关注该社会的幸福。但由于社会利益只是”组成社会的各个成员的利益之总和”，所以社会所具有的利益不能独立于或对抗于个人的利益。政府的职责就是通过避苦求乐来增进社会的幸福，”最大多数人的最大幸福乃是判断是非的标准”。</p>
<p>●立法者要努力达到四个目标：保证公民的生计、富裕、平等和安全。安全为首要和基本的目标，必要时可以牺牲自由。平等仅次于安全，这种平等不是条件平等，而是机会平等。同时保护私有财产，鼓励经济上的个人主义，国家法律创造条件以刺激和奖励人们去努力生产和占有更多财富。</p>
<p>●穆勒赞同边沁的功利原则，但驳斥把功利主义指责为粗鲁的享乐主义的观点——智力的快乐、情感与想象的快乐以及道德情操的快乐，比感官的快乐具有更高价值。他还坚持认为，功利主义的幸福原则是利他的，因为它的理想是”所有相关之人的幸福”。</p>
<p>●正义的标准应当建立在功利之上，但正义感的渊源必须到自卫的冲动和同情感这两种原则当中去寻找。正义感乃是对恶进行报复的欲望。——如果遭受恶意的是我？这就是对同类联想到自身的同理心、同情心。</p>
<h3 id="第二十三节-耶林"><a href="#第二十三节-耶林" class="headerlink" title="第二十三节 耶林"></a>第二十三节 耶林</h3><p>●保护个人自由并不是法律的唯一目的。耶林反对任何试图用一抽象的、无所不包的公式来解决控制个人自由问题的做法。他认为，法律的目的是在个人原则与社会原则之间形成一种平衡。-“社会功利主义者”</p>
<p>●法律乃是国家通过外部强制手段而加以保护的社会生活条件的总和。</p>
<p>●耶林法律哲学的核心概念是目的，法律在很大程度上是国家为了有意识地达到某个特定目的而制定的。（区别于自然法学派观点）；法律的形式是国家确保人们遵循法律规范而强制实施。”没有强制力的法律规则是一把不燃烧的火，一缕不发亮的光”。</p>
<h2 id="第七章-分析实证主义"><a href="#第七章-分析实证主义" class="headerlink" title="第七章 分析实证主义"></a>第七章 分析实证主义</h2><h3 id="第二十四节-何谓实证主义"><a href="#第二十四节-何谓实证主义" class="headerlink" title="第二十四节 何谓实证主义"></a>第二十四节 何谓实证主义</h3><p>●现代实证主义的哲学奠基人孔德把人类思想的进化划分成三大阶段：</p>
<p>●神学阶段，人们用超自然的原因和神的干预来解释所有的现象</p>
<p>●形而上学阶段，求助于终极的原则和理念，其存在于事物表象的背后并被认为是构成了人类进化的真正驱动力</p>
<p>●实证的阶段，人们在自然科学所使用的方法指导下，否弃了哲学、历史学和科学中的一切假设性建构，仅关注经验性的考察和事实的联系。</p>
<p>●实证主义作为一种科学的态度，它反对先验的思辨，并力图将其自身限定在经验经验材料的范围之内。19世纪上半叶自然科学领域取得的自然科学所取得的巨大成就为实证主义奠定了基础。</p>
<p>●法律实证主义试图将价值考虑排除在法理学科学研究的范围之外，并把法理学的任务限定为在分析和剖析实在法律制度的范围之内。法律实证主义者认为，只有实在法—国家确立的法律规范才是法律。</p>
<p>●法律实证主义者认为要把法与伦理规范和社会政策严格区分开来，并倾向于认为正义就是合法律性，亦即服从国家所制定的规则。完全以经验的态度看待法律，不赞同研究和寻求法律制度的终极价值。</p>
<h3 id="第二十五节-约翰奥斯丁与分析法学派"><a href="#第二十五节-约翰•奥斯丁与分析法学派" class="headerlink" title="第二十五节 约翰•奥斯丁与分析法学派"></a>第二十五节 约翰•奥斯丁与分析法学派</h3><p>●与边沁一样，奥斯丁也信奉功利的生活哲学，功利原则是检验法律的最终标准。</p>
<p>●奥斯丁严格区分了法理学与伦理科学。法理学是一种独立而自足的关于实在法的理论，不考虑法的善恶；但立法科学则是伦理学的一个分支。—法学家只关注“实然”的法律，立法者或伦理哲学家关注“应然”的法律。</p>
<p>●法理学的任务是对从实在法制度中抽象出来的一般概念和原则予以阐释。</p>
<p>●实在法最为本质的特征乃是它的强制性或命令性。法律被认为是主权者的一种命令。但并非任何命令都是法律，只有一般性的命令（对某类行为的规定）才具有法律效力。</p>
<h3 id="第二十六节-纯粹法学理论"><a href="#第二十六节-纯粹法学理论" class="headerlink" title="第二十六节 纯粹法学理论"></a>第二十六节 纯粹法学理论</h3><p>●凯尔森认为，应当把所有评价标准和意识形态因素从法律学科中清除出去，并进一步希望使法律理论摆脱一切外部的因素和非法律的因素，以实现法律”纯粹”之目标。</p>
<p>●纯粹法学理论认为：法律是一种有关人的行为的强制性秩序。</p>
<p>●基本规范：人对人的强制，应当根据历史上第一部宪法所确定的方式与条件来执行。基本规范是同一法律体系中所有规范得以有效的终极渊源。</p>
<p>●区分了法律规范的有效性和实效：实效意指一条规范实际上被遵守和适用，而有效性则意指一条法律规范应当被遵守和适用。</p>
<p>●法律是社会组织所特有的一种具体技术，国家和法律是同一的。作为一种政治组织，国家就是一种法律秩序并根据法律加以统治。</p>
<h3 id="第二十七节-新分析法学和语言学法学"><a href="#第二十七节-新分析法学和语言学法学" class="headerlink" title="第二十七节 新分析法学和语言学法学"></a>第二十七节 新分析法学和语言学法学</h3><p>●20世纪下半叶兴起的新分析法学运动 ，否弃早期分析法学家试图把法理学的任务限制在对基本的法律观念和概念进行注释的单一做法，接受社会学的解释方法和自然法哲学的方法，并运用尖端逻辑工具与语言科学，对司法程序进行了更深入的分析和研究。</p>
<p>●哈特认为法理学科学的关键问题在于两种规则的结合。首位规则是源于社会需要、以被大多数人接受为约束力基础、用来保证满意生活方式的一种行为的标准方式；次位规则是为承认和执行首位规则而确立的一种法定手段。</p>
<p>●分析法学家的目标就是通过辨识法律概念并将它们分解成构成它们的基本成分来阐明法律的概念。</p>
<h2 id="第八章-社会学法学和法律现实主义"><a href="#第八章-社会学法学和法律现实主义" class="headerlink" title="第八章 社会学法学和法律现实主义"></a>第八章 社会学法学和法律现实主义</h2><h3 id="第二十八节-欧洲的社会学法学和心理学法学"><a href="#第二十八节-欧洲的社会学法学和心理学法学" class="headerlink" title="第二十八节 欧洲的社会学法学和心理学法学"></a>第二十八节 欧洲的社会学法学和心理学法学</h3><p>●贡布洛维奇认为，法律是从具有不同力量的不同社会族群之间的冲突中产生的一种社会生活的形式，法律的指导思想是维持和巩固政治、社会和经济上的不平等，法律的目的是通过运用国家权力来确立和维护强者对弱者的统治。</p>
<p>●马克斯·韦伯对法学理论最重要的贡献之一是他详尽阐释了理性的与非理性的立法方法之间的区别以及他从历史学和社会学的角度出发对这两种方法所做的详尽分析。</p>
<p>●科勒认为法律乃是通过确使现存价值得到保护并使新的价值得到增进而在人类文化生活的进化中发挥重要作用的，法律必须与日益变化的文明状况相适应。在法律的控制中，个人主义应与集体主义相综合、和谐。</p>
<p>●埃利希认为”活法”即与由国家实施的法律相对的由社会实践的法律，是支配社会生活的法律。他的法律理论中带有一种心理学的成分：他认为习惯在法律生活中具有非常重要的分量。</p>
<p>●彼得拉日茨基认为法律现象是由独特的心理过程构成的，而只有通过运用内省的方法才能观察到这种过程；提出了”直觉法律”理论，该理论认为个人的法律意识和人的内在经验在解释法律现象和社会现象的时候具有重大作用。</p>
<h3 id="第二十九节-利益法学和自由法运动"><a href="#第二十九节-利益法学和自由法运动" class="headerlink" title="第二十九节 利益法学和自由法运动"></a>第二十九节 利益法学和自由法运动</h3><p>●概念主义法理学的假设：实在法律制度是无缺陷的，因此只要通过适当的逻辑分析，便能从现存的实在法制度中得出正确的判决。</p>
<p>●利益法学家对概念主义法学家的假设提出质疑：任何一种实在的法律制度必然都是不完整的和有缺陷的，而且根据逻辑推理的过程，也并不总能现存法律规范中得出令人满意的判决。</p>
<p>●利益法学所提出的司法审判之方法是以这样一个前提为基础的，即法律规范构成了立法者为解决种种利益冲突而制定的原则和原理。从这种意义上讲，我们必须把法律规范看成是价值判断。为了做出一个正义的判决，法官必须确定立法者通过某条特定的法律规则所旨在保护的利益。</p>
<p>●惹尼主张法官具有自由裁量权，为了使利益得到正当的平衡，法官必须仔细考量占支配地位的道德情感和探究当时当地的社会经济条件。</p>
<p>●自由法运动强调审判过程中的直觉因素和情感因素，并要求法官根据正义与衡平去发现法律，法官具有广泛的司法自由裁量权。</p>
<h3 id="第三十节-庞德的社会学法学"><a href="#第三十节-庞德的社会学法学" class="headerlink" title="第三十节 庞德的社会学法学"></a>第三十节 庞德的社会学法学</h3><p>●庞德主要是从最大限度地满足需求的角度来思考法律目的的。他把法律秩序所应保护的利益划分成个人利益、公共利益、社会利益。庞德指出，可以据法司法，也可以不据法司法，今后的问题是在司法中如何实现司法因素与行政因素之间的有效平衡。</p>
<p>●庞德认为法律是实施社会控制的工具，合理控制各方利益、限制个人利益过于膨胀，从而更好地促进整体社会的发展</p>
<h3 id="第三十一节-卡多佐和霍姆斯"><a href="#第三十一节-卡多佐和霍姆斯" class="headerlink" title="第三十一节 卡多佐和霍姆斯"></a>第三十一节 卡多佐和霍姆斯</h3><p>●卡多佐强调司法必须与社会现实相适应。信奉先例应当是司法中的一项规则而不应当是例外，但在遵奉先例会明显不符合正义感和社会福利的情形下，法官可以不受遵循先例这项规则的约束。卡多佐确信存在着公认的社会标准和客观的价值模式，这使法律具有一定程度的统一性和自洽性，即使在审理案件的情形中仍不可能避免法官个人的和主观的判断。</p>
<p>●霍姆斯强调经验是法律的生命，蔑视逻辑推理在审判中的作用：只有熟悉法律的历史、社会和经济因素的法官和律师，才能够适当地履行其职责；作为一个伦理怀疑论者，他主要把法律看成是代表社会中占支配地位的利益群体的意志、并以强力作为后盾的法规集合体，倾向于把道德看成是日益变化的社会权力集团的旨趣和价值偏好；霍姆斯的伦理不可知论使他认为，实用主义的法律观必须从”坏人（人性恶）”的观点来认识法律。</p>
<h3 id="第三十二节-美国的法律现实主义"><a href="#第三十二节-美国的法律现实主义" class="headerlink" title="第三十二节 美国的法律现实主义"></a>第三十二节 美国的法律现实主义</h3><p>●法律现实主义者认为，法官、律师、警察、监狱官员实际上在法律事务中的所作所为，实质上就是法律本身。</p>
<h3 id="第三十三节-斯堪的纳维亚国家的法律现实主义"><a href="#第三十三节-斯堪的纳维亚国家的法律现实主义" class="headerlink" title="第三十三节 斯堪的纳维亚国家的法律现实主义"></a>第三十三节 斯堪的纳维亚国家的法律现实主义</h3><h2 id="第九章-自然法的复兴和价值取向法理学"><a href="#第九章-自然法的复兴和价值取向法理学" class="headerlink" title="第九章 自然法的复兴和价值取向法理学"></a>第九章 自然法的复兴和价值取向法理学</h2><h3 id="第三十四节-新康德自然法"><a href="#第三十四节-新康德自然法" class="headerlink" title="第三十四节 新康德自然法"></a>第三十四节 新康德自然法</h3><p>●施塔姆勒率先试图根据先验的推论创立一种现代的自然法哲学，他把法律观念分解为法律概念和法律理念，并将法律定义为是”不可违反的、独断的集体意志”。其中法律理念乃是正义的实现，正义要求所有的法律努力实现个人目的与社会目的的和谐。</p>
<p>●韦基奥认为法律的根本特征有二：一是按照某种伦理原则客观地协调不同个人的行动，二是其具有双边性、命令性和可强制性。他认为法律理想就是自然法的观念。</p>
<p>●拉德布鲁赫是从新康德主义的价值哲学出发的，这种哲学在”实然”和”应然”之间设立了强大的屏障，并且否认能从现实的观察和感觉中得出任何关于何谓”正当”的判断。</p>
<h3 id="第三十五节-新经院主义自然法"><a href="#第三十五节-新经院主义自然法" class="headerlink" title="第三十五节 新经院主义自然法"></a>第三十五节 新经院主义自然法</h3><p>●自然法优于实在法并且高于实在法，其”自然法”区别于古典自然法，主要源于中世纪天主教的经院思想——特别是托马斯·阿奎那的法律哲学。托马斯的自然法是由非常广泛的和一般性的原则组成的，而古典自然法学家则提出了非常具体和细致的自然法体系。</p>
<p>●新经院主义自然法学家达班非常重视法律中的规则因素和作为实在法制度的实质要素的强制性，另一方面，他也详尽分析了那些根据正义和公共利益而设定的法律控制的目的。与道德相矛盾的东西不能包含在公共利益之内——达班似乎把自然法看成了某些为理性所规定的最低限度的伦理要求。</p>
<p>●达班讨论了三种不同形式的正义：矫正（校正）正义、分配正义和法律正义。矫正正义指的是对涉及被侵害的财富、荣誉、权利的恢复和补偿；分配正义确定集体成员应从集体得到什么；法律正义所关注的则是集体成员应该给予集体什么。</p>
<h3 id="第三十六节-狄骥的法律哲学"><a href="#第三十六节-狄骥的法律哲学" class="headerlink" title="第三十六节 狄骥的法律哲学"></a>第三十六节 狄骥的法律哲学</h3><p>●根据狄骥的观点，法律的社会功能乃是实现社会连带，而社会连带关系不是道德义务，而是客观存在的事实。这种关系包括：①同求的连带关系，即人们有共同需要，只能通过共同生活以满足这种需要；②分工的连带关系，即人们有不同的能力和需要，必须通过相互交换服务以满足这些需要。</p>
<h3 id="第三十七节-拉斯维尔和麦克杜格尔的政策科学"><a href="#第三十七节-拉斯维尔和麦克杜格尔的政策科学" class="headerlink" title="第三十七节 拉斯维尔和麦克杜格尔的政策科学"></a>第三十七节 拉斯维尔和麦克杜格尔的政策科学</h3><p>●两人的目的同狄骥一样，乃是要构建一种否弃了形而上思辨的经验法学理论。然而，与狄骥不同，他们公开承认，他们研究法律的进路所代表的乃是一种价值理论，而并不只是一种对社会事实的描述。</p>
<p>●拉斯韦尔和麦克杜格尔的价值体系是从这样一个假设出发的，即一种价值是一种“为人们所欲求的事”。因此，由于人们欲求权力（权力被定义为参与制定重要决策的权力），所以“从权力是所欲求的（或很可能为人们所欲求的）意义上来讲，权力毫无疑问是一种价值。拉斯韦尔和麦克杜格尔认为，法律是一种权力价值的形式，而且“是社会中权力决策的总和”。</p>
<p>●这两位学者认为，法律科学欲在全球范围内促进价值的民主化和致力于创造一个自由而富裕的社会，就应当最大限度地降低技术性法律原则—它被称为“权威的神话”—的作用，并在很大程度上用一种”政策”的研究进路加以补充，应当根据民主生活的目标和重要问题来阐释关键的法律术语。法律原则应当被归结为”象征的作用，它们的功能就是为使用它们的人的全部政策服务。</p>
<h3 id="第三十八节-价值取向法学"><a href="#第三十八节-价值取向法学" class="headerlink" title="第三十八节 价值取向法学"></a>第三十八节 价值取向法学</h3><p>●略。</p>
<h3 id="第三十九节-结论"><a href="#第三十九节-结论" class="headerlink" title="第三十九节 结论"></a>第三十九节 结论</h3><p>●历史法学派在丰富法律知识方面做出了重大贡献，因为它指出，一个民族的精神在创建一个伟大的法律制度时会发挥它的作用。但当历史法学派把民族意识和民族特性提升到法律进化的主要动力的地位时，它便误入了歧途。中起到令人满意的作用。历史法学派之所以会有上述缺陷，乃是因为它未能充分地认到法律中的理性因素，亦即使一个国家利用另一个国家的法律制度成为可能的因素，如果这个制度制定得很好。而且能够服务于采纳它的国家的经济和社会的需要。一个真正伟大的法律制度将具有这种性质，即它能使法律制度超越民族性的局限，而且至少在某种程度上它能使该法律制度在精神价值和实践价值方面具有普遍的意义。</p>
<p>●马克思主义法律理论认为社会的生产方式构成了法律制度的基础，并且论证了存在于经济与法律之间的密切关系但是这种理论对法律进化中的其他因素却没有子以充分的关注。在对法律制度进行充分的社会学分析过程中实际上还必须对权力关系本的生物事实、人类学材料、宗教信仰、意识形态和价值体系以及明确的理性命令做适当的考虑，再者，马克思的法律理论将其侧重点完全放在了法律控制的阶级性方面，而未能足够重视这样一个事实，即法律常常调节和调整的乃是相互冲突的群体利益。</p>
<p>●法律实证主义把法律定义为主权者的命令由此揭示了现代民族国家的法律所具有的一个不容忽视的特征。实证主义的分析还使我们意识到了这样一一个事实，即从技术教条的角度出发对法律概念进行仔细的解释，会大大有助于法律制度的明确性和一致性。但在另一方面，分析实证主义把法律同心理、伦理、经济和社会等基础切割开来的趋势（汉斯·凯尔森在这方面表现得尤为突出）则使我们对法律制度所能达到的自主性和自足性的程度产生了一种误识。我们必须承认，法律在一个孤立封闭的容器中不可能得到健康发展，而且我们也不能把法律同其周围的并对它无害的非法律生活隔离开来。</p>
<p>●此外，分析实证主义，尤其是在凯尔森的纯粹法学中，极大地夸大了法律作为一种外在强制体系的特点。这种观点对德国公法教师赫尔曼·赫勒的意见未能给予充分的认识，赫勒指出，“为了保护社会秩序的基础和维护政府的权力，任何政府都不能只依靠它所拥有的强制工具。政府必须始终追求合法化，即它必须设法把公民结合在尊重致府对权力的要求的价值权力要求的正当性，并且努力使国民以承认规范性义务的方式在内心中认可这种要求当法律社会学家N·S·格玛谢夫把法律看作是“道德和命令的协调”时，他所指的乃是这样一个事实，即在任何切实可行的法律体系中，为了确保有效地实现一定的行为模式，有组织的权力必须与群体信念相结合）过分强调法律中的权力因素而轻视其中的道和社会成份，则是极为错误的。</p>
<p>●现实主义在纠正分析法学片面强调规范和概念的取向方面作出了贡献，它使我们注意到主观感情因素和环境所产生的先为主倾向常常会侵入审判过程之中。但是，法律现实主义对法律规则和法学理论在实际的法律生活中的作用却没有以足够的重视，它有时给我们呈现的是一种过分强调司法专断的民事法官判决的图景，却未能给我们提供一幅人类在其能力所能达到的范围内维持法律理性和一致性的蓝图。</p>
<h1 id="第二部分-法律的性质和作用"><a href="#第二部分-法律的性质和作用" class="headerlink" title="第二部分 法律的性质和作用"></a>第二部分 法律的性质和作用</h1><h2 id="第十章-秩序需求"><a href="#第十章-秩序需求" class="headerlink" title="第十章 秩序需求"></a>第十章 秩序需求</h2><h3 id="第四十节-导言"><a href="#第四十节-导言" class="headerlink" title="第四十节 导言"></a>第四十节 导言</h3><p>●在下述章节中，秩序将被用来描述法律制度的形式结构，特别是在履行其调整人类事务的任务时运用的一般性规则、标准和原则的法律倾向；另一方面，安全则被视为一种实质性价值，亦即社会关系中的正义所必须设法增进的东西。</p>
<p>●第四十一节 自然界中有序模式的普遍性</p>
<p>●自然界表现的是意义重大的组织一致性和模式化，秩序压倒了无序，规则压倒了例外。自然进程所具有的占支配地位的规则性对人类生活大有益处。</p>
<p>●第四十二节 个人生活与社会生活中的秩序</p>
<p>●随着社会进步、人口繁殖、生活方式多样化、问题愈趋复杂，规范性社会控制程度愈趋提高。</p>
<p>●对历史的研究证明，有序生活方式要比杂乱生活方式占优势，“只要有社会就会有法律”。</p>
<p>●第四十三节 对秩序之需求的心理根源</p>
<p>●两种欲望或冲动：第一，人具有重复早期经验或安排的倾向—一种源于过去的权威性渊源，会以一种重复的方式来指导人的行为，遵循规则化的行为方式为社会生活提供了高度的有序性和稳定性；第二是一种将社会交往置于规则支配之下的倾向，其心理基础植根于人们在受到他人专横待遇时所会产生的反感之中。</p>
<p>●用规则管理人际社会关系，其本身并不能自动提供某种预防压制性统治形式的措施。</p>
<p>●第四十四节 无政府状态与专制政体</p>
<p>●无政府主义的哲学基础：人的首要责任就是自主，亦即拒绝被统治。在无政府状态中，任何人都不受他人或群体的权力和命令的支配。</p>
<p>●个人主义的无政府理论：主张完全利己的个人，权利不受限制，亦即按照其冲动为所欲为。</p>
<p>●社会群体的无政府理论：人性本善，只是国家及其制度机构腐蚀了他们。由于人的社会性，人们可以在不存在有组织的政府的情况下建立起不受干扰的和睦融洽的联合。</p>
<p>●从社会学的角度看，把愈来愈多的、模糊的、极为弹性宽泛的规定引入法律制度（特别是政治性的刑法领域）之中，无异于对法律的否弃和对某种形式的专制统治的肯定。——法律方法可以预防这种专制状况的发生。</p>
<p>●第四十五节 法律的普遍性要素</p>
<p>●法律在本质上是对专断权力之行使的一种限制。一个好的法律制度，居于无政府状态和专制政治中间。</p>
<p>●普遍性要素的构成：</p>
<p>●规范：一种调整人的行为的概括性声明、指令。</p>
<p>●普遍性：要具有普遍的约束力，对象也具有普遍性。</p>
<p>●连续一致性：类似于确定性、稳定性，以及由此引申出的可预期性。</p>
<p>●强制性：具体执行法律规范。</p>
<p>●第四十六节 力求独立与自主的法律</p>
<p>●赋予法律以自主学科地位的努力是值得称道的，只要这种做法没有超出某些许可的范围。</p>
<p>●法律最终是要受制于人们社会生活的需要并为之服务的，法律的自主性只是相对的。</p>
<h2 id="第十一章-正义的探索"><a href="#第十一章-正义的探索" class="headerlink" title="第十一章 正义的探索"></a>第十一章 正义的探索</h2><p>●第四十七节 普罗透斯似的正义之面</p>
<p>●满足个人的合理需要和主张、促进生产进步和提高社会凝聚力就是正义的目标。但是正义有着一张Protean face，变幻无常。</p>
<p>●柏拉图的正义观—每个阶级的成员各司其职；</p>
<p>●亚里士多德的正义观—平等是正义的尺度，尤其是比例平等；</p>
<p>●Lester Ward的正义观—平均主义，最大限度的机会平等；</p>
<p>●马克思恩格斯的正义观—缩小贫富差距，实现资源与经济地位的平等化；</p>
<p>●斯宾塞的正义观—自由才是正义的尺度，“每个人都可以自由等干他所想干的事，但这是以他没有侵犯任何其他人所享有的相同的自由为条件的”。</p>
<p>●康德的正义观—正义是“一些条件之总和，在那些条件下，一个人的意志能够按照普遍的自由法则同另一人的意志结合起来”。</p>
<p>●索利的正义观—试图将自由与平等协调统一起来：（1）用一种普遍的教育制度来发展和指导人的精神力量与物质力量；（2）提供种种达致生产资料与工具的途径，以使人们得到适当的职业；以及（3）创设有助于而不是有碍于个人发展的物质环境和社会环境。</p>
<p>●罗尔斯的正义观—由两个基本原则构成:（1）每个人对与其他人所享有的类似自由相一致的最广泛的基本自由都应有一种平等的权利；（2）社会的和经济的不平等将被安排得使人们能够合理地期望它们对每个人都有利，并使它们所依系的地位与职务向所有的人都开放。其中第一个原则优先于第二个原则。</p>
<p>●怀疑论者认为，正义观念完全是一个个人取向或瞬变的社会舆论的问题。第四十八节将对此进行批驳。</p>
<p>●第四十八节 正义与理性</p>
<p>●采用更广义的理性观念更可取：第一，广义的理性是同日常语言用法相一致的，因为它拒绝把理性判断的范围局限于那些在准数理逻辑的帮助下才能得到的东西。第二，对理性概念所作的狭义理解，把读多判断和结论都归入了感觉、情感和那些专断取向的范围之中，但严格地说，这些判断和结论实属理性范畴。</p>
<p>●当人们就正义问题发生分歧时，其解决往往是以能否正确确定和评价经验性事实为转移的。正义的第二类争议中疑难问题的解决取决于价值判断</p>
<p>●结论：社会秩序中的正义问题在相当广泛的程度上可以进行理性讨论和公正思考，而这理性指的是广义的理性，当然非理性因素的影响不能完全排除。</p>
<p>●第四十九节 正义的概念和范围</p>
<p>●早期的正义观：正义被认为是人类精神上的某种态度、一种公平的意愿和一种承认他人的要求和想法的意向。</p>
<p>●后期的正义观：在强调主观性的基础上，还要有实际举措来推行和保障正义。</p>
<p>●正义的引申含义：在个人行为领域，一个人对另一个人所采取的违反、不公平的行为即非正义。正义的要求，除了包括其他东西以外，还包括了防止不合理的歧视待遇、禁止伤害他人、承认基本人权、提供在职业上自我实现的机会、设定义务以确保普遍安全和有效履行必要的政府职责、确立一个公正的奖惩制度等。所有上述要求，在某种程度上都同人类的共同需要有关系。</p>
<p>●第五十节 正义与自然法</p>
<p>●大多数自然法哲学家的一致性：自然法是由应当得到承认的原则和准则构成的，不论它们在一个国家或其他共同体的实在法中是否得到了正式表达。</p>
<p>●的确存在一些植根于人的生理和心理需要中的最低限度的正义要求，其独立于实在法制定者的意志而存在，并且需要在任何可行的社会秩序中予以承认。</p>
<p>●自然法乃是一个正义制度的最为根本的基础，它是由那些最低限度的公平和合理的标准组成的；另一方面，正义概念则包括了被一个特定的政治和社会制度认为是正义的规范和原则，不论其是否得到正式承认。</p>
<p>●第五十一节 正义与自由</p>
<p>●要求自由的欲望植根于人的本性之中</p>
<p>●在日趋复杂的当今社会，为增进公共福利，自由必须受到一定限制</p>
<p>●第五十二节 正义与平等</p>
<p>●法律对平等具有双重作用；平等的含义具有多样性，在不同历史时期内其具体内涵的解读也具有较大差异</p>
<p>●法律上的平等主要指的是不同法律主体之间权利义务关系的和谐一致性；交换对等之平等</p>
<p>●人和人平等的心理根源是人希望得到尊重的欲望，自尊—同理，对歧视之反感则处于平等要求之核心，正义感由此被激发出来</p>
<p>●为正义而斗争往往是为反对法律或现有社会习惯中的不平等。</p>
<p>●第五十三节 正义与安全</p>
<p>●安全在法律秩序中的作用之一是具有从属性和派生性，其概念内含于“法律秩序”之中</p>
<p>●在当代社会，安全已经成为了人自身发展、社会运转的必需品</p>
<p>●对安全也要辩证看待：一种合理的稳定生活是必要的，它避免了社会的分裂；但稳定性必须常常为调整留出空间，必要的变革是为了更好的安全。</p>
<p>●第五十四节 正义与共同福利</p>
<p>●正义要求促进植根于人性欲望中的自由、平等和安全，但这三者在社会生活中往往相冲突—一个良好法律制度应当是平衡自由、平等和安全，达到“三位一体”</p>
<p>●于是，为解决三者之冲突，正义提出了这样一个要求，即赋予人的自由、平等和安全应当在最大程度上与共同福利相一致</p>
<p>●注意：共同福利不等于个人欲望之总和，更类似于卢梭之“公意”；共同利益不能与政府之政策决定等同</p>
<h2 id="第十二章-法律秩序与正义的综合体"><a href="#第十二章-法律——秩序与正义的综合体" class="headerlink" title="第十二章 法律——秩序与正义的综合体"></a>第十二章 法律——秩序与正义的综合体</h2><p>●第五十五节 秩序与正义的关系</p>
<p>●正义指导法律，法律促进正义。法律旨在创设一种正义的社会秩序</p>
<p>●实现正义和维护秩序会在具体社会生活中产生冲突，要把握平衡</p>
<p>●第五十六节 法律的稳定与变化</p>
<p>●法律必须是稳定的，但不可一成不变。</p>
<p>●为适应社会生活的变化和满足文明发展进步的要求，必须对法律进行适当的调整与革新</p>
<p>●第五十七节 法律的命令因素与社会因素</p>
<p>●以奥斯丁为代表的“命令说”与埃里希为代表的“社会原则说“相冲突</p>
<p>●法律应当是政府性与社会性的协调和统一，尽管这两种因素很难实现完全对等</p>
<p>●第五十八节 法律规范的有效性</p>
<p>●法律规范的有效性植根于其实施过程之中</p>
<p>●国家的强制力是保证法律规范的有效性的重要工具</p>
<p>●法律规范的有效性在于其：不与其他法律相冲突；法定的制定主体；符合该社会的普遍正义标准；大多数人的认同</p>
<p>●第五十九节 制裁的意义</p>
<p>●制裁关系到法律实效。制裁的目的在于强迫法律命令得到遵守与执行。</p>
<p>●就整体而言，强制力乃是法律制度的“一个必要的不可分割的部分”。</p>
<p>●法律制裁问题，总体来看是同法律的秩序作用及其增进正义的目的联系在一起的。</p>
<h2 id="第十三章-法律与其他社会控制力量的区别"><a href="#第十三章-法律——与其他社会控制力量的区别" class="headerlink" title="第十三章 法律——与其他社会控制力量的区别"></a>第十三章 法律——与其他社会控制力量的区别</h2><p>●第六十节 法律与权力</p>
<p>●马克斯·韦伯认为，权力乃是“这样一种可能性，即处于某种社会关系内的一个行动者能够不顾抵制而实现其个人意志的可能性，而不论这一可能性所依赖的基础是什么。”</p>
<p>●纯粹权力是旨在实现对人的绝对统治，在这一层面上约束、限制这种权力乃是法律的职责所在。</p>
<p>法律制度最重要的意义之一，就是它可以被视为是一种限制和约束人们的权力欲的一个工具。</p>
<p>●权力与法律往往是互动的、相互渗透的</p>
<p>一个被授予权力的人，总是面临着滥用权力的诱惑，面临着逾越正义和道德底线的诱惑。</p>
<p>●第六十一节 法律与行政</p>
<p>●行政乃是为实现某个私人目的或公共目的而在具体情形中对权力的行使。</p>
<p>●国家的纯粹行政活动如创设行政机关、对国家官员发布命令和指示等并不适于归入法律范畴之中。</p>
<p>●法律不同于纯粹的社会技术规则，法律存在于“对特定的国民相互之间的权利和义务加以确定的领域之中：就其本质而言，法律以众多会发生冲突的人为先决条件。”</p>
<p>●行政法所主要关心的乃是法律制度对政府官员和行政机构行使这种自由裁量权所作的约束。</p>
<p>●第六十二节 法律与道德</p>
<p>●康德式理论：法律不考虑潜在的动机问题，只要求人们从外部行为上服从现行的法律法规；而道德则诉诸于人的良知，要求人们根据高尚的意图——首先是伦理责任感——而行事。</p>
<p>●法律与道德并非彼此独立：首先，法通常所关注的是一个行动应受法律规范审判的人的心智倾向；此外，在法律中动机与精神状况是很重要的，而道德也并非不关注行为；道德观念可以转化成具有强制约束力的法律规定，法律可以促进道德规则的遵守。</p>
<p>●第六十三节 法律与习惯</p>
<p>●习惯法意指那些已经具有法律性质的规则或安排的习惯，尽管它们尚未得到立法机关或司法机关的正式颁布。</p>
<p>●早期的习惯法多数是适应了人们社会生活的需要的。</p>
<h2 id="第十四章-法治的利弊"><a href="#第十四章-法治的利弊" class="headerlink" title="第十四章 法治的利弊"></a>第十四章 法治的利弊</h2><p>●第六十四节 人的创造力的开发</p>
<p>●一个社会制度的成功，在很大程度上取决于它是否能够将人们在经济追求与性追求方面未被耗尽的剩余精力引入合乎社会需要的渠道。</p>
<p>●法律促进人与社会的创造力、潜力的开发：</p>
<p>●法律在某些基本的生活条件方面为个人创制并维续了一个安全领域</p>
<p>●法律所建构的制度性框架，为人们执行满足进步社会的成员要求的政治、经济、文化方面的多重任务提供了手段和适当环境。</p>
<p>●第六十五节 促进和平</p>
<p>●第六十六节 相互冲突的利益之调整</p>
<p>●第六十七节 法律的弊端</p>
<p>●法律具有一种保守的倾向，是一不可朝令夕改的规则体系。在社会发生危机时，法律常常陷于瘫痪，因为它不得不为断裂性调整让路。</p>
<p>●法律规范框架中固有某种僵化性，这源于法律一般性规则的形式结构。</p>
<p>●规范控制的限度容易失控，演变成把管理变成强制、把控制变成压制。</p>
<p>●只有那些以某种具体的和妥切的方式将刚性与灵活性完美结合在一起的法律制度，才是真正伟大的法律制度。</p>
]]></content>
      <categories>
        <category>法律</category>
      </categories>
      <tags>
        <tag>booknote</tag>
        <tag>law</tag>
      </tags>
  </entry>
  <entry>
    <title>《苦闷的象征》1 创作与鉴赏</title>
    <url>/post/b231ea19/</url>
    <content><![CDATA[<h1 id="创作论"><a href="#创作论" class="headerlink" title="创作论"></a>创作论</h1><h2 id="一-两种力"><a href="#一、两种力" class="headerlink" title="一、两种力"></a>一、两种力</h2><p><strong>在内有想要动弹的个性表现的欲望</strong>，而和这正相对，<strong>在外却有社会生活的束缚和强制不绝地迫压着</strong>。在两种的力之间，苦恼挣扎着的状态，就是人类生活。</p>
<h3 id="创造生活的欲求之力"><a href="#创造生活的欲求之力" class="headerlink" title="创造生活的欲求之力"></a>创造生活的欲求之力</h3><ul>
<li>个性表现的内底欲求、<strong>生命力</strong>的发动，在灵与肉两方面，表现为各种各样的生活现象：有时为本能生活，有时为游戏冲动，或为强烈的信念，或为高远的理想，为学子的知识欲，也为英雄的征服欲望。</li>
<li>这样的生命力的显现，是超绝了利害的念头，离了善恶邪正的估价，脱却道德的批评和因袭的束缚而带着一意只要飞跃和突进的倾向。</li>
</ul>
<h3 id="强制压抑之力"><a href="#强制压抑之力" class="headerlink" title="强制压抑之力"></a>强制压抑之力</h3><ul>
<li>在”社会”这个大的有机体中生活，必然要<strong>服从</strong>那巨大的机制</li>
<li>人们若成了单为从外面逼来的力所动的机器的妖精，就是为人的最大苦痛了；反之，倘若因了自己的个性的内底要求所催促的劳动，那可常常是快乐，是愉悦。</li>
<li><strong>个人与外界</strong>的关系中的力的冲突（<strong>外在约束</strong>）<ul>
<li>人们先舍掉了像人样的个性生活，多少总变一些<strong>法则和机械的奴隶</strong>，甚而至于自己若不变成机械的妖精，便活不成的状态了。</li>
<li>人们若成了单为从外面逼来的力所动的机器的妖精，就是为人的最大苦痛了；反之，倘若因了自己的个性的内底要求所催促的劳动，那可常常是快乐，是愉悦。</li>
</ul>
</li>
<li><strong>人类自身</strong>两种矛盾的要求的冲突（<strong>自我压抑</strong>）<ul>
<li>一面有着要彻底地以个人而生活的欲望，而同时又有着 “人类既然是社会底存在物(social being)了，那就需要和家族、社会、国家等概念调和一些” 的欲望。</li>
<li>一面既有自由地使自己的本能得到满足这一种欲求，而人类的本性既然是道德底存在物(moral being),则别一面就该又有一种欲求，要将这样的本能压抑下去。即使不被外来的法则和因袭所束缚，然而却想用自己的道德，来抑制管束自己的要求的是人类。我们有兽性和恶魔性，但一起也有着神性；有利己主</li>
<li>精神和物质，灵和肉，理想和现实之间，有着不绝的不调和，不断的冲突和纠葛。所以生命力愈旺盛，这冲突这纠葛就该愈激烈。一面要积极底地前进，别一面又消极底地要将这阻住，压下。</li>
<li>无压抑，即无生命的飞跃</li>
</ul>
</li>
</ul>
<h3 id="文艺的创作"><a href="#文艺的创作" class="headerlink" title="文艺的创作"></a>文艺的创作</h3><ul>
<li><p>一个绝对无条件地专营纯一不杂的创造生活的世界</p>
</li>
<li><p>文艺是纯然的生命的表现；是能够全然离了外界的压抑和强制，站在绝对自由的心境上，表现出个性来的唯一的世界。忘却名利，除去奴隶根性，从一切羁绊束缚解放下来，这才能成文艺上的创作。</p>
</li>
<li>必须进到那与留心着报章上的批评，算计着稿费之类的全然两样的心境，这才能成真的文艺作品，因为能做到仅被在自己的心里烧着的感激和情热所动，像天地创造的曙神所做的一样程度的自己表现的世界，是只有文艺而已。我们在政治生活、劳动生活、社会生活之类里所到底寻不见的生命力的无条件的发现，只有在这里，却完全存在。换句话说，就是人类得以抛弃了一切虚伪和敷衍，认真地诚实地活下去的唯一的生活。文艺的所以能占人类的文化生活的最高位，那缘故也就在此。和这一比较，便也不妨说，此外的一切人类活动，全是将我们的个性表现的作为加以减削，破坏，蹂躏的了。</li>
<li><strong>生命力受了压抑而生的苦闷懊恼乃是文艺的根柢，而其表现法乃是广义的象征主义</strong></li>
</ul>
<h2 id="二-人间苦与文艺苦闷的象征"><a href="#二、人间苦与文艺——苦闷的象征" class="headerlink" title="二、人间苦与文艺——苦闷的象征"></a>二、人间苦与文艺——苦闷的象征</h2><p><strong>文艺决不是俗众的玩弄物，乃是该严肃而且沉痛的人间苦的象征</strong>。绝对创造的生活即艺术者，就是苦闷的表现。</p>
<p>针对弗洛伊德的观点：</p>
<ul>
<li><p>认同：满足欲望的力和泽恒相犯的压抑力的纠葛冲突而生的精神创伤，伏藏在无意识界</p>
</li>
<li><p>不满意：将一切归于“性底欲望”的偏见，作者将所谓”性底欲望“看做 <strong>最广意义上的生命力的突进跳跃</strong></p>
</li>
</ul>
<h3 id="从人间苦到文艺"><a href="#从人间苦到文艺" class="headerlink" title="从人间苦到文艺"></a>从人间苦到文艺</h3><ul>
<li>生命力、创造性，与这力方向正相反的机械底法则，因袭道德，法律底拘束，社会底生活难，此外各样的力之间所生的<strong>冲突</strong>，看为<strong>人间苦的根柢</strong>。</li>
<li><strong>生即是战斗</strong>。而“活着”这事，就是<strong>反复这种战斗的苦恼</strong>。我们的生活愈不肤浅，愈深，便比照着这深，生命力愈盛，便比照着这盛，这苦恼也不得不愈加其烈。在伏在心的深处的内底生活，即无意识心理的底里，是蓄积着极痛烈而且深刻的许多伤害的。</li>
<li>一面经验着这样的苦闷，一面参与着悲惨的战斗，向人生的道路进行的时候，我们就或呻，或叫，或怨嗟，或号泣，而同时也常有自己陶醉在奏凯的欢乐和赞美里的事。这发出来的声音，就是文艺。</li>
</ul>
<h3 id="从抽象到具象"><a href="#从抽象到具象" class="headerlink" title="从抽象到具象"></a>从抽象到具象</h3><ul>
<li><strong>抽象</strong>底的思想和观念，决不成为艺术。</li>
<li>艺术的最大要件，是在<strong>具象性</strong>。即或一思想内容，经了具象底的人物、事件、风景之类的活的东西而被表现的时候；换了话说，就是和梦的潜在内容改装打扮了而出现时，走着同一的径路的东西，才是艺术。</li>
<li>赋与这具象性者就称为<strong>象征(symbol)</strong>。所谓象征主义者，决非单是前世纪末法兰西诗坛的一派所曾经标榜的主义，<strong>凡有一切文艺，古往今来，是无不在这样的意义上，用着象征主义的表现法的</strong>。</li>
<li>象征具象的内容与象征的外形之间，应为和实为之间，总存在价值之差。</li>
<li>象征的外形更复杂的情况：<ol>
<li>讽喻(allegory)、寓言(fable)、比喻(parable)之类，这些都是将真理或教训，照样<strong>极浅显地嵌在</strong>动物或人物故事上而表现的。</li>
<li>如果那外形成为更加复杂的事象，而备了强的情绪底效果，带着刺激底性质的时候，那便成为很出色的文艺上的作品。</li>
</ol>
</li>
</ul>
<h3 id="作家的真生命"><a href="#作家的真生命" class="headerlink" title="作家的真生命"></a>作家的真生命</h3><ul>
<li>艺术是表现，是创造，不是自然的再现，也不是摹写。</li>
<li>假如不是将伏藏在潜在意识的海的底里的苦闷即<strong>精神底伤害</strong>，象征化了的东西，即非大艺术。</li>
<li>作家将自己的心底的深处，深深地而且更深深地穿掘下去，到了自己的内容的底的底里，从那里生出艺术来。探检自己愈深，便比照着这深，那作品也愈高，愈大，愈强。</li>
</ul>
<p>作家的小我 不等于 作品的个性</p>
<ul>
<li>浅薄的做作物，总是极力想要表现某些观念或概念，描述自我的“小主观”，因此它就不带着真的生命力的普遍性，也缺乏足以打动读者的生命的伟力。</li>
<li>惟其创作家有了竭力忠实地将客观的事象照样地再现出来的态度，这才<strong>从作家的无意识心理的底里，毫不勉强地，浑然地，不失本来地表现出他那自我和个性来</strong>。</li>
<li>惟独如此，<strong>这才发生了生的苦闷，而自然而然地象征化了的“心”，乃成为“形”而出现</strong>。所描写的客观的事象这东西中，就包藏着<strong>作家的真生命</strong>。到这里，客观主义的极致，即与主观主义一致，理想主义的极致，也与现实主义合一，而真的生命的表现的创作于是成功。</li>
</ul>
<p>作家”生育的痛苦“</p>
<ul>
<li>为了怎样将存在自己胸里的东西，炼成自然人生的感觉底事象，而放射到外界去；或者怎样造成理趣情景兼备的一个新的完全的统一的小天地，人物事象，而表现出去的苦痛。</li>
<li>这又如母亲们所做的一样，是<strong>作家分给自己的血，割了灵和肉，作为一个新的创造物而产生</strong>。</li>
<li>又如经了“生育的苦痛”之后，产毕的母亲就有欢喜一样，在成全了自己生命的自由表现的创作家，也有离了压抑作用而得到创造底胜利的欢喜。从什么稿费、名声那些实际底外底的满足所得的不过是快感(pleasure),但别有在<strong>更大更高的地位的欢喜(joy)是一定和创造创作在一处的。</strong></li>
</ul>
<h1 id="鉴赏论"><a href="#鉴赏论" class="headerlink" title="鉴赏论"></a>鉴赏论</h1><blockquote>
<p>一个人先在他自身里，唤起曾经经验过的感情来，在他自身里既经唤起，便用诸动作，诸线，诸色，诸声音，或诸以言语表出的形象，这样的来传这感情，使别人可以经验这同一的感情一这是艺术的活动。艺术是人类活动，其中所包括的是一个人用了或一种外底记号，将他曾经体验过的种种感情，意识底地传给别人，而且别人被这些感情所动，也来经验他们。</p>
<p>——托尔斯泰 《艺术论》</p>
</blockquote>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/%E9%89%B4%E8%B5%8F%E8%BF%87%E7%A8%8B.drawio.png?raw=true" alt="鉴赏过程.drawio.png"></p>
<h2 id="文艺鉴赏的四阶段"><a href="#文艺鉴赏的四阶段" class="headerlink" title="文艺鉴赏的四阶段"></a>文艺鉴赏的四阶段</h2><h3 id="1-理知intellect的作用"><a href="#1-理知-intellect-的作用" class="headerlink" title="1. 理知(intellect)的作用"></a>1. 理知(intellect)的作用</h3><p>懂得文章的意义、追随内容的事迹，有兴会之类。只有理知的兴味，并不能成为真的艺术。</p>
<ul>
<li>许多的通俗的浅薄的，而且总不能触着我们内生命这一类的低级文学，大抵仅诉于读者的理知的作用。例如单以追随事迹的兴味为目的而作的侦探小说、冒险谭、讲谈、下等的电影剧、报纸上的通俗小说之类，大概只要给满足了理知底好奇心(intellectual curiosity)就算完事。</li>
</ul>
<h3 id="2-感觉sense的作用"><a href="#2-感觉-sense-的作用" class="headerlink" title="2. 感觉(sense)的作用"></a>2. 感觉(sense)的作用</h3><ul>
<li>在五感之中，文学上尤其多的是诉于音乐、色彩之类的听觉和视觉。在古今东西的文学中，最主要的感觉底要素，那不待言，是诉于耳的音乐底要素。<blockquote>
<p>はとっさ東雲どさの亂聲に<br>湖水は白さ波につらしも<br>Hototogis Shinonome Doki no Ranjyo ni,<br>Kosui wa,hiroki Nami tatsu rashi mo.<br>杜鹃黎明时候的乱声里，<br>湖水是生了素波似的呀。</p>
</blockquote>
</li>
</ul>
<p>以声调之美为要素：耳中所受的感得，已经有着得了音乐底调和的声调之美。</p>
<h3 id="3-感觉的心象"><a href="#3-感觉的心象" class="headerlink" title="3. 感觉的心象"></a>3. 感觉的心象</h3><p>这并非立即诉于感觉本身，乃是诉于想象底作用，或者唤起感觉底的心象来。就是经过了第一的理知，第二的感觉等作用，到这里才使姿态、景况、音响等，都在心中活跃，在眼前仿佛。</p>
<p>但是前三阶段：理知阶段、感觉作用、感觉的心象，大概从作品的技巧而来，属于能动意识的世界的比较表面的部分。换句话说，以上还属于象征的外形，只能造成在读者心中所架起的幻想的内容，即<strong>梦的外形</strong>，<strong>没有超出道理、物质、感觉的世界。</strong></p>
<p><strong>必须超出了那些，更加深邃地喷薄突进到读者心中深处的无意识心理，那刺激底暗示力触着了生命的内容的时候，在那里唤起共鸣共感来，而文艺的鉴赏这才成立</strong>。这就是说打动读者的情绪、思想、精神、心气的意思，这是作品鉴赏的最后的过程。</p>
<h3 id="4-情绪-思想-精神-心气"><a href="#4-情绪、思想、精神、心气" class="headerlink" title="4. 情绪、思想、精神、心气"></a>4. 情绪、思想、精神、心气</h3><p>到这里，作者的无意识心理的内容，这才传到读者那边，在心的深处的琴弦上唤起反响来，于是暗示遂达了最后的目的。经作品而显现的作家的人生观、社会观、自然观，或者宗教信念，进了这第四阶段，乃触着读者的体验的世界。</p>
<p>因为这第四者的内容，包含着在人类有意义的一切东西，所以正如人类生命的内容的复杂似的也复杂而且各样。要并无余蕴地来说完他，是我们所不能企及的。那美学家所说的美底感情一即视鉴赏者心中的琴弦上所被唤起的震动的强弱大小之差，将这分为崇高(sublime)和优美(beautiful),或者从质的变化上着眼，将这分为悲壮(tragic)和诙谐(humour),并加以议论，就不过是想将这第四的阶段分解而说明之的一种尝试。</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>booknote</tag>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>《中国文学史》读书笔记</title>
    <url>/post/a55cf8e2/</url>
    <content><![CDATA[<h1 id="总绪论"><a href="#总绪论" class="headerlink" title="总绪论"></a>总绪论</h1><h2 id="第一节-文学本位-史学思维-文化学视角"><a href="#第一节-文学本位-史学思维-文化学视角" class="headerlink" title="第一节 文学本位 史学思维 文化学视角"></a>第一节 文学本位 史学思维 文化学视角</h2><p>文学史是文学的历史，文学史著作要在广阔的文化背景上描述文学本身演进的历程</p>
<p>把文学当作文学来研究，文学史著作应立足于文学本位，重视<strong>文学之所以成为文学</strong>并具有<strong>艺术感染力</strong>的特点及其审美价值。</p>
<p>史书不能代替文学作品。文学具有审美的机制，能感染读者。以诗证史并非文学史研究。</p>
<hr>
<p>研究：</p>
<ul>
<li>最外围；文学创作的<strong>社会政治、经济背景</strong></li>
<li>第二层：文学创作的主题，即<strong>作家</strong></li>
<li>第三层：<strong>文学作品</strong>（核心）</li>
</ul>
<p>因此，文学史核心内容就是<strong>阐释文学作品的演变历程</strong></p>
<hr>
<p><strong>主题</strong>：文学创作</p>
<p><strong>一翼</strong>：文学理论、文学批评、文学鉴赏</p>
<p>文学理论：指导文学创作</p>
<p>文学批评、文学鉴赏：文学创作完成后再读者中的反应</p>
<p>文学史应当关心文学思潮的发展演变，并用文学思潮来解释文学创作，并注意文学的接受，引导读者正确地鉴赏文学作品。</p>
<p><strong>一翼</strong>：文学传媒：对创作地影响，对创造带来的变化</p>
<hr>
<p>史学，</p>
<ol>
<li>注意“史”的脉络，清晰地描述出承传流变地过程</li>
<li>将过去惯用地评价式语言，换成<strong>描述式语言</strong></li>
<li>寻找史的规律，而不满足于事实的罗列</li>
</ol>
<h2 id="第二节-中国文学的演进"><a href="#第二节-中国文学的演进" class="headerlink" title="第二节 中国文学的演进"></a>第二节 中国文学的演进</h2><p><strong>文学演进的外部因素与内部因素</strong></p>
<p>外部因素：社会经济、政治、文化的影响、民族矛盾的影响、地理环境的影响等</p>
<p>内部因素：</p>
<ul>
<li>文学发展的不平衡 <strong>中国文学发展的不平衡</strong></li>
<li><ol>
<li>文体发展的不平衡。<ul>
<li>各种问题形成和成熟的时代不同，有先有后。</li>
<li>各种文体从萌生到形成再到成熟，过程长短也不同。</li>
</ul>
</li>
<li>朝代的不平衡。</li>
<li>地域的不平和。<ul>
<li>不同的朝代，各地文学的发展有盛衰的变化，呈现此盛彼衰、此衰彼盛</li>
<li>不同的地域有不同的文体孕育生长，地方特色</li>
</ul>
</li>
</ol>
</li>
<li><strong>俗与雅</strong>之间相互的影响、转化和推动<ul>
<li>主要是俗对雅的影响和推动，以及由俗到雅的转变</li>
</ul>
</li>
<li><strong>各种文体的渗透与融合</strong></li>
<li><strong>复古与革新</strong>：文学体裁内部的运动，主要在诗文领域。</li>
<li><strong>文与道的离合</strong>：文学与儒家伦理道德、儒家政治理想的关系。</li>
</ul>
<h2 id="第三节-中国文学史的分期"><a href="#第三节-中国文学史的分期" class="headerlink" title="第三节 中国文学史的分期"></a>第三节 中国文学史的分期</h2><p>三古 七段具体划分</p>
<ul>
<li><strong>上古期：先秦两汉（公元3世纪以前） </strong> P13<ul>
<li><strong>第一段：先秦</strong></li>
<li><strong>第二段：秦汉</strong></li>
</ul>
</li>
<li><strong>中古期：魏晋至明中叶（公元3世纪至16世纪）</strong>  P15<ul>
<li><strong>第三段：魏晋至唐中叶（天宝末）</strong></li>
<li><strong>第四段：唐中叶至南宋末</strong></li>
<li><strong>第五段：元初至明中叶（正德末）</strong></li>
</ul>
</li>
<li><strong>近古期：明中叶至“五四”运动（公元16世纪至20世纪初期）</strong> P18<ul>
<li><strong>第六段：明嘉靖初至鸦片战争（1840）</strong></li>
<li><strong>第七段：鸦片战争至“五四”运动（1919）</strong></li>
</ul>
</li>
</ul>
<p><strong>双视角</strong>：三古七段视角、朝代分期视角</p>
<h1 id="第一编-先秦文学"><a href="#第一编-先秦文学" class="headerlink" title="第一编 先秦文学"></a>第一编 先秦文学</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>中古期的第一段；尚未从混沌一体的文化形态中分离出来</p>
<h3 id="第一节-中国文学的源头"><a href="#第一节-中国文学的源头" class="headerlink" title="第一节 中国文学的源头"></a>第一节 中国文学的源头</h3><p>传说时期的文学：远古歌谣和神话，文字未产生，记录片段零散，其原始形态并没有很好地保存下去。</p>
<p>文字产生。</p>
<p>诗歌是最古老的文学形式之一。</p>
<h3 id="第二节-先秦文学的形态"><a href="#第二节-先秦文学的形态" class="headerlink" title="第二节 先秦文学的形态"></a>第二节 先秦文学的形态</h3><p>春秋及以前，巫史不分。周宣王后… 史学与巫术的分化过程。</p>
<p><strong>文史哲不分</strong></p>
<p><em>《左传》《国语》《战国策》</em> 历史散文，基本具有叙事文学特征，不是抽象地进行哲学思辨或枯燥地讨论种政治、人生文体，在文章中表现了鲜明地个性，带着浓郁地情感，具有丰富地形象。</p>
<p>先秦诗歌：宗教颂赞祷祝诗 -&gt; 政治叙事诗 -&gt; 言志抒情诗</p>
<p><em>《楚辞》</em>、<em>《诗经》</em></p>
<p><strong>作者和时代难以确定</strong></p>
<h3 id="第三节-先秦文学作者的流变"><a href="#第三节-先秦文学作者的流变" class="headerlink" title="第三节 先秦文学作者的流变"></a>第三节 先秦文学作者的流变</h3><p>原始文化向理性文化的转变 -&gt; 文化主要承担者的身份、地位发生了明显变化</p>
<p>上古巫史不分，史的职务最初也是宗教性的。</p>
<p>商周之际鬼神地位下降，人事受到重视，史官发展了人事方面的职能，并从原始宗教中脱离出来，成为新兴文化的代表。</p>
<p><em>《商书》</em>《春秋》《左传》    《诗经》十五国风</p>
<p>士阶级，文化知识从贵族转移到士</p>
<p>儒家学派</p>
<p>墨家学派</p>
<h3 id="第四节-先秦文化与先秦文学发展的轨迹-p32"><a href="#第四节-先秦文化与先秦文学发展的轨迹-P32" class="headerlink" title="第四节 先秦文化与先秦文学发展的轨迹 P32"></a>第四节 先秦文化与先秦文学发展的轨迹 P32</h3><blockquote>
<p>王国维《殷周制度论》：夏商二代文化略同。《洪范》九畴，帝所以锡禹者，而 传之矣。夏之季世，若胤甲，若孔甲，若履 ，始以日为名，而殷人承之矣。</p>
</blockquote>
<p>夏商文化的意识形态都是以原始宗教为主，以巫文化最有代表性，而夏商文学是与此时的原始宗教紧密联系的。</p>
<p>自西周开始中国进入以礼乐为标志的理性文明阶段。</p>
<blockquote>
<p>殷周间之大变革，自其表言之，不过一姓一家之兴亡与都邑之转移。自其里言之，则旧制度废而新制度兴，旧文化废而新文化兴。</p>
</blockquote>
<p>周代敬礼重德的理性精神，使人类社会和人本身的地位得到肯定。周代文学关注历史、社会、人生。</p>
<p><em>《春秋》</em>将社会伦理秩序，并通过对历史事实的选择、以寓褒贬，寄托自己的社会理想。</p>
<p><em>《左传》《国语》</em>继承并发扬了《春秋》的现实精神和表现手法，倡导儒家敬德崇礼、尊王攘夷、固本保民等思想。</p>
<p>《左传》先秦史传散文的顶峰之作，记述史实，刻画形象，以<strong>极为高超的表现技巧</strong>把中国叙事文推向成熟，开《战国策》、《史记》等史传散文的先河。</p>
<p>《国语》以记言为主，言辞典雅、精练。</p>
<hr>
<p>直接反映显示社会和人生，构建种种不同的社会理想</p>
<p><em>《论语》</em></p>
<p><em>《墨子》</em></p>
<p><em>《老子》</em></p>
<hr>
<p>周代文学在精神和风格上都体现为一种和谐、典雅的特质，婉而多讽的特征。</p>
<hr>
<p>战国、百家争鸣</p>
<p>阴阳、儒、墨、名、法、道德（司马谈） + 农、纵横、杂、小说（刘歆）</p>
<p>秉承战国时代特有的文化气质：道家的庄周、儒家的孟轲与荀卿、法家的韩非、纵横家</p>
<ul>
<li>立足于现实，着眼于现实，很少提及春秋时流行的“天命“等思想</li>
<li>由于士人成为文化甚至政治的中心，所以他们不再盲目认同某种既定的秩序，自觉创作精神大为增强。</li>
<li>文学风格百花齐放</li>
</ul>
<p><em>《庄子》</em></p>
<p><em>《孟子》</em></p>
<p><em>《荀子》</em></p>
<p>纵横家</p>
<p><em>《战国策》</em></p>
<p><em>屈赋</em></p>
<h2 id="第一章-上古神话-p41"><a href="#第一章-上古神话-P41" class="headerlink" title="第一章 上古神话 P41"></a>第一章 上古神话 P41</h2><p>涉及自然环境和社会生活的各个方面，既包括世界的起源、又包括人类的命运，努力向人们展示”自然与人类命运的富有教育意义的意象“。</p>
<h3 id="第一节-中国神话的产生和记录"><a href="#第一节-中国神话的产生和记录" class="headerlink" title="第一节 中国神话的产生和记录"></a>第一节 中国神话的产生和记录</h3><p>神话：保持社会习俗及社会制度的意义和合理性。先民早神秘而悲喜莫测的日常劳动和生活中，积聚了相当多而强烈的情绪体验，神话故事可以使难以理解的现实呈现出种种戏剧性的属性。</p>
<p><em>《山海经》</em> 古代保存神话资料最多的著作</p>
<h3 id="第二节-中国神话及其蕴含的民族精神"><a href="#第二节-中国神话及其蕴含的民族精神" class="headerlink" title="第二节 中国神话及其蕴含的民族精神"></a>第二节 中国神话及其蕴含的民族精神</h3><h4 id="一-创世神话-p44"><a href="#一、创世神话-P44" class="headerlink" title="一、创世神话 P44"></a>一、创世神话 P44</h4><p><strong>盘古故事</strong>——卵生神话——中国阴阳太极观念；</p>
<p>宇宙生成的人格化、意志化过程</p>
<p>”垂死化身“的宇宙观，暗喻了人和自然的相互对应关系</p>
<h4 id="二-始祖神话-p45"><a href="#二、始祖神话-P45" class="headerlink" title="二、始祖神话 P45"></a>二、始祖神话 P45</h4><p>人类共同的始祖：<strong>女娲故事</strong></p>
<p>各部落的始祖神话：</p>
<p>商民族祖契是简狄吞食燕卵而生</p>
<p>周民族始祖后稷的诞生和经历</p>
<h4 id="三-洪水神话-p46"><a href="#三、洪水神话-P46" class="headerlink" title="三、洪水神话 P46"></a>三、洪水神话 P46</h4><p>外国的洪水神话，大多表现：天帝对人类堕落的失望，洪水对人类的惩罚，而洪水之后人类的再造，反映了对人性的反省和批判。</p>
<p>中国汉民族古代文献中的洪水神话：主要把洪水看作一种自然灾害，揭示的是与洪水抗争、拯救生民的积极意义，看重人的智慧及斗争精神。</p>
<p><strong>鲧禹父子</strong></p>
<h4 id="四-战争神话-p47"><a href="#四、战争神话-P47" class="headerlink" title="四、战争神话 P47"></a>四、战争神话 P47</h4><p>阪泉之野——炎帝黄帝的阪泉之战    炎黄两大部落的融合，华夏民族正式形成</p>
<p>蚩尤、黄帝</p>
<h4 id="五-发明创造神话-p49"><a href="#五、发明创造神话-P49" class="headerlink" title="五、发明创造神话 P49"></a>五、发明创造神话 P49</h4><p>黄帝之后，神话进入了一个<strong>英雄的时代</strong>。</p>
<p>后羿</p>
<p>夸父逐日</p>
<p>精卫填海</p>
<h4 id="民族精神的形成及其特征"><a href="#民族精神的形成及其特征" class="headerlink" title="民族精神的形成及其特征"></a>民族精神的形成及其特征</h4><ul>
<li>中国古代神话体现了深重的<strong>忧患意识</strong></li>
<li>中国古代神话具有明确的<strong>厚生爱民意识</strong></li>
<li>体现了先民们的<strong>反抗精神</strong></li>
</ul>
<h3 id="第三节-上古神话的思维特征"><a href="#第三节-上古神话的思维特征" class="headerlink" title="第三节 上古神话的思维特征"></a>第三节 上古神话的思维特征</h3><p>以己观物、以己感物</p>
<h3 id="第四节-上古神话的散失和演化"><a href="#第四节-上古神话的散失和演化" class="headerlink" title="第四节 上古神话的散失和演化"></a>第四节 上古神话的散失和演化</h3><h2 id="第二章-诗经-p64"><a href="#第二章-《诗经》-P64" class="headerlink" title="第二章 《诗经》 P64"></a>第二章 《诗经》 P64</h2><h3 id="第一节-诗经的编定和体制"><a href="#第一节-《诗经》的编定和体制" class="headerlink" title="第一节 《诗经》的编定和体制"></a>第一节 《诗经》的编定和体制</h3><p>第一部诗歌总集 周初至春秋中叶五百多年的作品</p>
<p>风雅颂</p>
<p>用诗、传诗</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>中国古典小说戏曲鉴赏</title>
    <url>/post/67791464/</url>
    <content><![CDATA[<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote>
<p><em>书读百遍，其义自见。</em></p>
</blockquote>
<p>保持阅读</p>
<blockquote>
<p><em>尽信书不如无书。</em></p>
</blockquote>
<p>怀疑的精神</p>
<blockquote>
<p><em>问渠那得清如许，为有源头活水来。</em></p>
</blockquote>
<p>调用自己的人生阅历与人生感受</p>
<h4 id="曹操幼时逸事鉴赏"><a href="#“曹操幼时逸事”鉴赏" class="headerlink" title="“曹操幼时逸事”鉴赏"></a>“曹操幼时逸事”鉴赏</h4><ul>
<li>客观叙事：</li>
<li><ul>
<li>知人善察的犀利眼光</li>
<li>审视度势的高超智力</li>
<li>敢作敢为的非凡能力：努力争取成功，敢于接受失败</li>
</ul>
</li>
<li>主观叙事：</li>
<li><ul>
<li>预示性叙事：叙事文本的文化意蕴</li>
<li>选择性叙事：叙事者的话语权威</li>
<li>评价性叙事：评点者的话语权威</li>
</ul>
</li>
</ul>
<h4 id="黛玉进贾府鉴赏"><a href="#“黛玉进贾府”鉴赏" class="headerlink" title="“黛玉进贾府”鉴赏"></a>“黛玉进贾府”鉴赏</h4><ul>
<li>叙事特点：林黛玉的视角——移步换形的叙事手法；林黛玉的感受（诗人气质）——“总为黛玉眼中写出”，主观评价、也会影响读者的判断</li>
</ul>
<h2 id="三国志演义鉴赏"><a href="#《三国志演义》鉴赏" class="headerlink" title="《三国志演义》鉴赏"></a>《三国志演义》鉴赏</h2><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><p>《三国演义资料汇编》《三国演义大辞典》《三国演义纵横谈》《名家解读三国演义》《读三国 说英雄》</p>
<h3 id="叙事结构与象征意义"><a href="#叙事结构与象征意义" class="headerlink" title="叙事结构与象征意义"></a>叙事结构与象征意义</h3><p>历史小说：历史演义小说、英雄传奇小说</p>
<p>叙事结构：</p>
<blockquote>
<p>《读三国志法》</p>
</blockquote>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>中国近代史 1840至1912</title>
    <url>/post/d225f759/</url>
    <content><![CDATA[<p>不平等条约——近代中国与世界的关系</p>
<p>国际体系的变迁：宗藩体系——不平等条约体系——国际社会新秩序</p>
<h2 id="一-传统中国的国际体系宗藩体系"><a href="#一、传统中国的国际体系：宗藩体系" class="headerlink" title="一、传统中国的国际体系：宗藩体系"></a>一、传统中国的国际体系：宗藩体系</h2><h3 id="1-宗藩体系的构成"><a href="#1-宗藩体系的构成" class="headerlink" title="1. 宗藩体系的构成"></a>1. 宗藩体系的构成</h3><p>传统中国的国际关系体系：以中国为圆心，发展出一个状似同心圆的体系。</p>
<p><img src="https://x0.ifengimg.com/res/2020/C6CC6B0A99DF50D7DEFBF8261BF2CF2951D14800_size255_w852_h578.png" alt="查看源图像" style="zoom:50%;"></p>
<p>理论基础：<strong>天下观</strong></p>
<ul>
<li>中国本土与周边国家共同构成天下。<br>“中国中心主义”：华夏在地域上居天下之中，华夏周边各族“东夷、西戎、南蛮、北狄。”<br>天子是天下唯一的最高统治者。统治中国的皇帝称为天子，拥有统治天下的权利，所谓“君天下曰天子”（《礼记·曲礼》）。<br>天子只统治天下唯一文明地区中国。</li>
</ul>
<p>结构：<strong>内地（本土）、藩部、属国、天下</strong></p>
<ul>
<li>藩部，是中国的一部分，如新疆、蒙古、西藏、西南等，其疆域包括在中国的版图之内。<br>其行政系统属中央政府管辖，其事务纯属中国内政。<br>藩部治理体制，因俗制宜，各有特点。<br>在边疆地区则设置了7区：<br>盛京将军、吉林将军、黑龙江将军、伊犁将军、乌里雅苏台将军五个将军辖区；西藏办事大臣、青海办事大臣两个办事大臣辖区。<br>西南各地区(四川、云南、贵州、西康、青海等)少数民族，清朝任命当地有势力者如土司、土官为官吏，承担统治边境、统辖社会秩序的职责。<br>朝廷对其内部事务并不干预，仅要求其在土司、土官交替之际履行按规定通报朝廷和按期朝贡这两种义务。</li>
<li>属国，同中国保持着从属的关系。但其领土不在中国的版图之内，它有自己独立的行政系统和政治制度。<br>与中国有朝贡关系的国家：安南（越南）、缅甸、锡金、尼泊尔、暹罗（泰国）、南掌（老挝）、高丽（朝鲜）、琉球、苏禄（菲律宾）  (根据《大清会典》所列属国表、赵尔巽所撰《清史稿》、王之春《国朝柔远记》)</li>
</ul>
<p>分界标准：<strong>接受中华文化的程度</strong></p>
<ul>
<li>周边各国奉中国为天朝<br>不仅因为中国的实力、经济利益，核心是中国以礼为基础的优雅文化传统和生活方式。<br>对中国历史文化的仰慕、学习，为朝贡体系的文化基础。 </li>
</ul>
<p>交往规则：礼仪</p>
<ul>
<li><p>自周公制订了包括畿服制在内的「周礼」之后，中国人就将「礼」的文化作为自己永久的精神家园。<br>「礼」  为文明和野蛮的分野。<br>「人而无礼；虽能言，不亦禽兽之心乎？」</p>
<blockquote>
<p>故春秋之義，無論同姓之魯衛，異姓之齊宋，非種之楚越，中國可以退為夷狄，夷狄可以進為中國，專以禮教為標準，而無有親疏之別。</p>
</blockquote>
</li>
<li><p>礼仪：体现了中国的观念，安排了帝国的社会秩序和政治规则。<br>借助礼仪，根据传统中国等级制的组织原则，划分文明世界——未开化世界<br>各国接受中国规定的礼仪，彰显朝廷建立统治的合法根源，这是帝国权力之根本。</p>
</li>
<li><p>圣王制夷之道：<br>王者不治夷狄，来者不拒，去者不追。<br>示之以威、怀之以惠、道之以法<br>来则惩而御之，去则备而守之；其慕义而贡献，则接之以礼让，揭糜不绝，使曲在被；盖圣王制蛮夷之常道也。<br>西戎荒俗，非礼仪之邦。羁縻之道，服而赦之，示以中国之威，道以王化之法。</p>
</li>
</ul>
<p>交往制度：朝贡</p>
<ul>
<li>作为朝贡的前提，是朝贡国以接受中国对当地国王的承认并加以册封。<br>在国王交替之际等机会去中国朝见。<br>举行围绕臣服于中央政权的各种活动，作为维系其与中国的关系的基本方式。<br>各国均定期地向中国进行朝贡。</li>
<li>根据《万历明会典》，朝贡国的分类：<br>东南夷(上)：朝鲜、日本、琉球、安南、占城、爪哇等18国。<br>东南夷(下)：苏禄国、满刺加、锡兰等44国。<br>北狄：鞑靼部的王和首长等8个部分。<br>东北夷：女真部等2个部分。<br>西戎(上)：兰州以西西域38国。<br>西戎(下)：吐蕃部14国。</li>
<li>朝贡的类型：<br>羁縻关系下的朝贡(内藩，国内民族关系)<br>关系最近的朝贡国(朝鲜等)<br>两重关系的朝贡国(琉球等)<br>位于外缘部位的朝贡国(暹罗等)<br>可以看成是朝贡国，实际上却属于互市国之俄罗斯、欧洲诸国等</li>
</ul>
<h3 id="2-宗藩体系的解体"><a href="#2-宗藩体系的解体" class="headerlink" title="2. 宗藩体系的解体"></a>2. 宗藩体系的解体</h3><h2 id="二-不平等条约与条约体系的建构"><a href="#二、不平等条约与条约体系的建构" class="headerlink" title="二、不平等条约与条约体系的建构"></a>二、不平等条约与条约体系的建构</h2><h2 id="三-不平等条约体系的废除"><a href="#三、不平等条约体系的废除" class="headerlink" title="三、不平等条约体系的废除"></a>三、不平等条约体系的废除</h2>]]></content>
      <categories>
        <category>历史</category>
      </categories>
      <tags>
        <tag>history</tag>
      </tags>
  </entry>
  <entry>
    <title>中国古代史</title>
    <url>/post/85c55cfb/</url>
    <content><![CDATA[<h1 id="价值判断-理论分析-事实-要注意区分"><a href="#价值判断、理论分析、事实-要注意区分" class="headerlink" title="价值判断、理论分析、事实 要注意区分"></a>价值判断、理论分析、事实 要注意区分</h1><h1 id="先秦与秦"><a href="#先秦与秦" class="headerlink" title="先秦与秦"></a>先秦与秦</h1><h2 id="第四讲-周代政治社会体制"><a href="#第四讲-周代政治社会体制" class="headerlink" title="第四讲 周代政治社会体制"></a>第四讲 周代政治社会体制</h2><h3 id="一-王朝官员体系"><a href="#一、王朝官员体系" class="headerlink" title="一、王朝官员体系"></a>一、王朝官员体系</h3><h4 id="1-王权"><a href="#1-王权" class="headerlink" title="1. 王权"></a>1. 王权</h4><ul>
<li><p>“帝” 造字</p>
</li>
<li><p>予一人</p>
</li>
<li><p>君权中混融着父权</p>
<blockquote>
<p>商汤：曰天子作民父母，以为天下王。</p>
</blockquote>
</li>
<li><p>天子、天之骄子</p>
</li>
</ul>
<h4 id="2-商代官员体系"><a href="#2-商代官员体系" class="headerlink" title="2. 商代官员体系"></a>2. 商代官员体系</h4><p>示例</p>
<ul>
<li><p>政务官：殷正百辟、百僚庶尹</p>
</li>
<li><p>事务官：牧正、多工、小众人臣</p>
</li>
<li><p>文化官：卜、巫、史、作册</p>
</li>
<li><p>宫廷官：寝、宰</p>
</li>
<li><p>军官：马、亚射、卫、戍</p>
</li>
</ul>
<p>地域控制——内服 外服</p>
<h4 id="3-周代官员体系"><a href="#3-周代官员体系" class="headerlink" title="3. 周代官员体系"></a>3. 周代官员体系</h4><blockquote>
<p><em>中国政治与文化之变革，莫剧于殷周之际。</em> ——王国维《殷周制度论》</p>
</blockquote>
<p>示例</p>
<ul>
<li><p>公：太师、太保、太傅</p>
</li>
<li><p>卿世辽：三士</p>
</li>
<li><ul>
<li>司土、司马、司工</li>
<li>司寇、司士</li>
</ul>
</li>
<li>大史寮：大史、内史、大卜、大祝</li>
<li>内庭官：宰</li>
<li>军官：师氏、虎臣（西六师、殷八师）</li>
</ul>
<h3 id="二-分封制度"><a href="#二、分封制度" class="headerlink" title="二、分封制度"></a>二、分封制度</h3><h4 id="1-授民授疆土"><a href="#1-“授民授疆土”" class="headerlink" title="1. “授民授疆土”"></a>1. “授民授疆土”</h4><p>卫 鲁 唐 燕 齐 宋</p>
<h4 id="2-关于封建"><a href="#2-关于“封建”" class="headerlink" title="2. 关于“封建”"></a>2. 关于“封建”</h4><p>诸家封建论</p>
<p>西欧封建制</p>
<p>郭沫若的说法…</p>
<h3 id="三-井田制"><a href="#三、井田制" class="headerlink" title="三、井田制"></a>三、井田制</h3><h4 id="1-国野制"><a href="#1-国野制" class="headerlink" title="1. 国野制"></a>1. 国野制</h4><p>在氏族的兼并和融合中起了重要作用</p>
<p>六乡、国人——自由人，兵役、教育、低级官吏，氏族民主制度</p>
<p>六遂、野人——外族人，不能受教育</p>
<blockquote>
<p><em>无君子莫治野人</em>,<em>无野人莫养君子。</em> ——《孟子·滕文公上》</p>
</blockquote>
<h4 id="2-井田制"><a href="#2-井田制" class="headerlink" title="2. 井田制"></a>2. 井田制</h4><p>与战国时期的自由小农十分不同。</p>
<p>“耕”——“井”</p>
<blockquote>
<p><em>方里而井，井九百亩，其中为公田。八家皆私百亩，同养公田；公事毕，然后敢治私事，所以别野人也。</em> ——《孟子·滕文公上》</p>
</blockquote>
<h4 id="3-农村公社"><a href="#3-“农村公社”" class="headerlink" title="3. “农村公社”"></a>3. “农村公社”</h4><p>阶级和国家产生之后才有的制度</p>
<ul>
<li><p>氏族公社：原生型公社，依靠<strong>血缘关系</strong>构成氏族。</p>
</li>
<li><p>父家长制家族公社：次生型公社，以<strong>血缘关系</strong>为主导。</p>
</li>
<li><p>农村公社：再次生性公社，<strong>地域性的互助合作单位</strong>。</p>
</li>
</ul>
<p>“公”：土地公有，定期重新分配，互助合作传统，强大凝聚力</p>
<p>“私”：被编制的地域单位，包括非家族成员，君主或领主占有其剩余产品</p>
<p>徐中枢——儒家礼法与公社制度很相似，农村公社或许是儒家思想的温床</p>
<h3 id="四-宗法制"><a href="#四、宗法制" class="headerlink" title="四、宗法制"></a>四、宗法制</h3><h4 id="1-宗法制的内容"><a href="#1-宗法制的内容" class="headerlink" title="1. 宗法制的内容"></a>1. 宗法制的内容</h4><p>古文字解说 “宗”</p>
<p>宗族构成：同一高祖父以下四代子孙构成的血亲集团；</p>
<p>尊卑秩序：族人尊奉宗主，小宗尊奉大宗；</p>
<p>继统原则：嫡长子继承制，称为宗子。</p>
<blockquote>
<p><em>四世而缌,服之穷也;五世袒免,杀同姓也;六世亲属竭矣。</em> ——《礼记》</p>
</blockquote>
<h4 id="2-宗法制的意义"><a href="#2-宗法制的意义" class="headerlink" title="2. 宗法制的意义"></a>2. 宗法制的意义</h4><p>商代有其萌芽</p>
<p>周代达到顶点，与分封制相互结合、水乳交融</p>
<p>封建的亲亲原则和宗法性（<strong>血缘关系</strong>）——与西欧中世纪不同（<strong>契约关系</strong>，层层分封）</p>
<p>侯外庐：周代的维新社会，亲亲的宗法政治——古希腊的革命政治</p>
<blockquote>
<p><em>故天子建国，诸侯立家，卿置侧室，大夫有贰宗，士有隶子弟</em>。 ——《左传》</p>
<p><em>且异姓之国，非宗法之所能统者，以<strong>婚媾甥舅之谊</strong>通之。于是天下之国，大都王之兄弟甥舅，而诸国之间亦皆有兄弟甥舅之亲。</em> ——王国维《殷周制度论》</p>
</blockquote>
<p>战国以后，严格意义的宗法制度衰弱了。个体小家庭大量出现。但取而代之的家族制度，在中国社会依旧发挥着重大影响。</p>
<h3 id="五-礼文化"><a href="#五、-礼文化" class="headerlink" title="五、 礼文化"></a>五、 礼文化</h3><p>《士大夫政治演生史稿》</p>
<h4 id="1-礼的来源和内容"><a href="#1-“礼”的来源和内容" class="headerlink" title="1. “礼”的来源和内容"></a>1. “礼”的来源和内容</h4><p>八礼：冠昏丧祭 射飨朝聘</p>
<p>五礼：吉礼 凶礼 宾礼 军礼 嘉礼</p>
<h4 id="2-周礼的政治精神"><a href="#2-周礼的政治精神" class="headerlink" title="2. 周礼的政治精神"></a>2. 周礼的政治精神</h4><p>尊尊 亲亲 贤贤</p>
<h3 id="本讲阅读书籍"><a href="#本讲阅读书籍" class="headerlink" title="本讲阅读书籍"></a>本讲阅读书籍</h3><p>《士大夫政治演生史稿》、《殷周制度论》</p>
<hr>
<h2 id="第五讲-春秋五霸和战国七雄"><a href="#第五讲-春秋五霸和战国七雄" class="headerlink" title="第五讲 春秋五霸和战国七雄"></a>第五讲 春秋五霸和战国七雄</h2><h3 id="一-从西周到东周"><a href="#一、从西周到东周" class="headerlink" title="一、从西周到东周"></a>一、从西周到东周</h3><h4 id="1-西周的终结"><a href="#1-西周的终结" class="headerlink" title="1. 西周的终结"></a>1. 西周的终结</h4><ul>
<li>国人暴动</li>
<li>宣王中兴</li>
<li>幽王亡国</li>
<li>平王东迁</li>
</ul>
<h4 id="2-共和行政和夏商周断代"><a href="#2-共和行政和夏商周断代" class="headerlink" title="2. 共和行政和夏商周断代"></a>2. 共和行政和夏商周断代</h4><ul>
<li>召公、周公等共同执政</li>
<li>卫国共伯和代行天子事</li>
</ul>
<h4 id="3-霸政的开端尊王攘夷"><a href="#3-霸政的开端【尊王攘夷】" class="headerlink" title="3. 霸政的开端【尊王攘夷】"></a>3. 霸政的开端【尊王攘夷】</h4><p>周平王东迁开始：</p>
<p>《春秋》——鲁国公—隐 桓 庄 闵 僖 文 宣 成 襄 昭 定 哀 </p>
<h3 id="二-春秋五霸"><a href="#二、春秋五霸" class="headerlink" title="二、春秋五霸"></a>二、春秋五霸</h3><h4 id="1-周郑交质"><a href="#1-周郑交质" class="headerlink" title="1. 周郑交质"></a>1. 周郑交质</h4><ul>
<li>郑庄公初霸权</li>
<li>周郑交质</li>
</ul>
<h4 id="2-齐桓公"><a href="#2-齐桓公" class="headerlink" title="2. 齐桓公"></a>2. 齐桓公</h4><ul>
<li><p>救邢存卫</p>
</li>
<li><p>召陵之盟</p>
<blockquote>
<p>微管仲，吾其披发左衽矣！ ——孔子</p>
</blockquote>
</li>
<li><p>葵丘之会</p>
</li>
</ul>
<h4 id="3-宋襄公"><a href="#3-宋襄公" class="headerlink" title="3. 宋襄公"></a>3. 宋襄公</h4><p>春秋战国的笑话很多嘲笑宋人…</p>
<blockquote>
<p><em>君子不重伤，不禽二毛。</em> ——宋襄公</p>
</blockquote>
<h4 id="4-晋文公-秦穆公"><a href="#4-晋文公-秦穆公" class="headerlink" title="4. 晋文公 秦穆公"></a>4. 晋文公 秦穆公</h4><ul>
<li><p>城濮之战</p>
</li>
<li><p>崤之战</p>
</li>
<li><p>践土之盟</p>
</li>
</ul>
<h4 id="5-楚庄王"><a href="#5-楚庄王" class="headerlink" title="5. 楚庄王"></a>5. 楚庄王</h4><ul>
<li>前606年 楚庄王问鼎</li>
<li>前597年 晋楚邺之战</li>
</ul>
<h4 id="7-弭兵"><a href="#7-弭兵" class="headerlink" title="7. 弭兵"></a>7. 弭兵</h4><h4 id="8-吴越争霸"><a href="#8-吴越争霸" class="headerlink" title="8. 吴越争霸"></a>8. 吴越争霸</h4><h3 id="三-战国的到来"><a href="#三、战国的到来" class="headerlink" title="三、战国的到来"></a>三、战国的到来</h3><h4 id="1-战国的开端"><a href="#1-战国的开端" class="headerlink" title="1. 战国的开端"></a>1. 战国的开端</h4><p>多种说法</p>
<h4 id="2-田氏代齐"><a href="#2-田氏代齐" class="headerlink" title="2. 田氏代齐"></a>2. 田氏代齐</h4><h4 id="3-三家分晋"><a href="#3-三家分晋" class="headerlink" title="3. 三家分晋"></a>3. 三家分晋</h4><h3 id="四-战国七雄"><a href="#四、战国七雄" class="headerlink" title="四、战国七雄"></a>四、战国七雄</h3><h4 id="1-魏齐相争"><a href="#1-魏齐相争" class="headerlink" title="1. 魏齐相争"></a>1. 魏齐相争</h4><ul>
<li>桂陵之战</li>
<li>逢泽之会</li>
<li>马陵之战</li>
<li>徐州相王</li>
</ul>
<p>合纵连横</p>
<blockquote>
<p><em>纵者，合众弱以攻一强也；而衡者，事一强以攻众弱也。</em> ——《韩非子》</p>
</blockquote>
<h4 id="2-秦楚之争"><a href="#2-秦楚之争" class="headerlink" title="2. 秦楚之争"></a>2. 秦楚之争</h4><ul>
<li><p>五国伐秦</p>
</li>
<li><p>丹阳蓝田之役——秦破楚</p>
</li>
<li>垂沙之役——齐卫韩破楚</li>
<li>白起破郢——哀郢</li>
</ul>
<h4 id="3-齐秦抗衡"><a href="#3-齐秦抗衡" class="headerlink" title="3. 齐秦抗衡"></a>3. 齐秦抗衡</h4><ul>
<li>三国攻秦</li>
<li>齐秦互帝</li>
<li>五国合纵</li>
<li>齐灭宋</li>
</ul>
<h4 id="4-燕齐相攻"><a href="#4-燕齐相攻" class="headerlink" title="4. 燕齐相攻"></a>4. 燕齐相攻</h4><ul>
<li>乐毅破齐</li>
<li>田单复国</li>
</ul>
<h4 id="5-秦赵之争"><a href="#5-秦赵之争" class="headerlink" title="5. 秦赵之争"></a>5. 秦赵之争</h4><p>赵武灵王胡服骑射</p>
<ul>
<li>之战</li>
<li>长平之战</li>
<li>邯郸之战</li>
</ul>
<h3 id="本讲阅读书籍"><a href="#本讲阅读书籍-1" class="headerlink" title="本讲阅读书籍"></a>本讲阅读书籍</h3><p>《左传》《战国策》《史记》</p>
<p>《战国史》杨宽——以田氏代齐为战国开端  </p>
<p>《中国通史》范文澜——以三家分晋为战国开端</p>
<hr>
<h2 id="第六讲-战国变法运动"><a href="#第六讲-战国变法运动" class="headerlink" title="第六讲 战国变法运动"></a>第六讲 战国变法运动</h2><h3 id="一-贵族政治的衰微"><a href="#一、贵族政治的衰微" class="headerlink" title="一、贵族政治的衰微"></a>一、贵族政治的衰微</h3><h4 id="1-春秋战国间的经济发展"><a href="#1-春秋战国间的经济发展" class="headerlink" title="1. 春秋战国间的经济发展"></a>1. 春秋战国间的经济发展</h4><ul>
<li><p>都市：临淄</p>
</li>
<li><p>水利工程：都江堰</p>
</li>
<li><p>货币：布比、刀币、秦半两</p>
</li>
</ul>
<h4 id="2-贵族政治衰微"><a href="#2-贵族政治衰微" class="headerlink" title="2. 贵族政治衰微"></a>2. 贵族政治衰微</h4><ul>
<li><p>权利下移：礼乐征伐自天下出—&gt; 礼乐征伐自诸侯出（春秋五霸）—&gt; 政逮于大夫（田氏代齐、三家分晋、鲁三桓专政）—&gt; 陪臣执国命（鲁国季氏家臣阳虎专政）</p>
</li>
<li><p>公田的衰弱：井田瓦解、<strong>赋税普及</strong></p>
</li>
<li><ul>
<li><p>相地而衰征</p>
</li>
<li><p>作爰田——自爰其处</p>
</li>
<li>初税亩</li>
<li>书土田</li>
<li>作丘赋</li>
<li>初租禾</li>
</ul>
</li>
</ul>
<h3 id="二-各国变法运动第二次大转型"><a href="#二、各国变法运动——第二次大转型" class="headerlink" title="二、各国变法运动——第二次大转型"></a>二、各国变法运动——第二次大转型</h3><h4 id="1-变法的意义"><a href="#1-变法的意义" class="headerlink" title="1. 变法的意义"></a>1. 变法的意义</h4><ul>
<li>君主专制</li>
<li>中央集权</li>
<li>官僚政治制度<ul>
<li>采用科层形式分配权利、责任与资源；</li>
<li>严格准寻法律规章，充分利用文书档案</li>
<li>择优录取，支付俸禄，根据能力、与年资升迁罢免</li>
</ul>
</li>
</ul>
<h4 id="2-魏国的李悝变法"><a href="#2-魏国的李悝变法" class="headerlink" title="2. 魏国的李悝变法"></a>2. 魏国的李悝变法</h4><ul>
<li>尽地力之教</li>
<li>平mi法——政府平价时买入粮食，粮少时低价卖出</li>
<li>制定《法经》——影响了商鞅、秦律、汉律…</li>
</ul>
<h4 id="3-楚国的吴起变法和韩国的申不害变法"><a href="#3-楚国的吴起变法和韩国的申不害变法" class="headerlink" title="3. 楚国的吴起变法和韩国的申不害变法"></a>3. 楚国的吴起变法和韩国的申不害变法</h4><blockquote>
<p>昔者吴起教楚悼王以楚国之俗曰：“大臣太重，封君太众。若此，则上逼主而下虐民，此贫国弱兵之道也。不如使封君之子孙三世而收爵禄，绝减百吏之禄秩，损不急之枝官，以奉选练之士。”悼王行之期年而薨矣，吴起枝解於楚。 ——《韩非子》</p>
</blockquote>
<p>《申子》 富有政治理性，撕开了掩饰纯粹政治的温情脉脉的周礼。</p>
<h3 id="三-秦国-商鞅变法"><a href="#三、秦国-商鞅变法" class="headerlink" title="三、秦国 商鞅变法"></a>三、秦国 商鞅变法</h3><h4 id="1-商鞅第一次变法前356年"><a href="#1-商鞅第一次变法（前356年）" class="headerlink" title="1. 商鞅第一次变法（前356年）"></a>1. 商鞅第一次变法（前356年）</h4><p>内容…</p>
<p>意义</p>
<ul>
<li>通过户籍制、什伍制、吿奸连坐等法律，把人民纳入官僚政府的控制之下；</li>
<li>通过鼓励分家、免除徭役、对经商及懒惰者“收孥”的政策，鼓励生产；</li>
<li>实行军功爵制，平民可由军功获得爵位。</li>
</ul>
<blockquote>
<p>封建制度的君子小人分野取消了，万民同站在了同一起跑线上……君爵制造新社会。</p>
</blockquote>
<h4 id="2-商鞅第二次变法前350年"><a href="#2-商鞅第二次变法（前350年）" class="headerlink" title="2. 商鞅第二次变法（前350年）"></a>2. 商鞅第二次变法（前350年）</h4><p>内容——多数来自三晋…赵姓嬴氏</p>
<ol>
<li>由雍迁都于咸阳；</li>
<li>革除戎狄风俗；</li>
<li>废除百步为亩之制，以240步为亩；</li>
<li>建41县，通过县及乡里什伍控制编户齐民；</li>
<li>按人口征收户赋（口赋）；</li>
<li>统一度量衡，是行政标准化。</li>
</ol>
<h4 id="3-商鞅变法的成效"><a href="#3-商鞅变法的成效" class="headerlink" title="3. 商鞅变法的成效"></a>3. 商鞅变法的成效</h4><blockquote>
<p>行之十年，秦民大说，道不拾遗，山无盗贼，家给人足。民勇于公战，怯于私斗，乡邑大治。 ——《史记》</p>
</blockquote>
<h3 id="四-官僚制度的发展"><a href="#四、官僚制度的发展" class="headerlink" title="四、官僚制度的发展"></a>四、官僚制度的发展</h3><h4 id="1-职业官僚的任用和管理"><a href="#1-职业官僚的任用和管理" class="headerlink" title="1. 职业官僚的任用和管理"></a>1. 职业官僚的任用和管理</h4><p>【俸禄制】</p>
<p>【文官制】</p>
<p>【符玺制】节 符 玺 券</p>
<p>【考课制】</p>
<h4 id="2-官僚组织的发展"><a href="#2-官僚组织的发展" class="headerlink" title="2. 官僚组织的发展"></a>2. 官僚组织的发展</h4><p>将相制</p>
<p>中央官制</p>
<p>相国——先秦称 相邦</p>
<p>郡县制：春秋前期出现县，春秋后期出现郡。郡有<strong>军区性质</strong>，故长官称为【守】。最初县高于郡，后来逐渐以郡代县。</p>
<p><strong>县</strong></p>
<h4 id="3-法规和文档"><a href="#3-法规和文档" class="headerlink" title="3. 法规和文档"></a>3. 法规和文档</h4><p>成文法取代习惯法 公开法取代秘密法</p>
<p><strong>以法为教，以吏为师</strong></p>
<blockquote>
<p>若欲有学法令，以吏为师。 ——李斯</p>
<p>Justice must not only be done, but must be seen to be done……</p>
</blockquote>
<p>【文法吏】——职业行政文官群体的崛起</p>
<hr>
<h2 id="第七讲-战国士人与百家争鸣"><a href="#第七讲-战国士人与百家争鸣" class="headerlink" title="第七讲 战国士人与百家争鸣"></a>第七讲 战国士人与百家争鸣</h2><h3 id="一-战国的士阶层"><a href="#一、战国的士阶层" class="headerlink" title="一、战国的士阶层"></a>一、战国的士阶层</h3><h4 id="1-士阶层的形成"><a href="#1-士阶层的形成" class="headerlink" title="1. 士阶层的形成"></a>1. 士阶层的形成</h4><ul>
<li>士的类别：【学士】百家学者、【策士】政治家，说客、【术士】各种专门技能者、【食客】形形色色的人才…</li>
<li><p>来源：文化贵族没落者-&gt; 战国士阶层  &lt;- 平民之获得知识才艺者</p>
</li>
<li><p>活动：教学游历、养士制度、稷下学宫</p>
</li>
</ul>
<h4 id="2-士的文化风貌"><a href="#2-士的文化风貌" class="headerlink" title="2. 士的文化风貌"></a>2. 士的文化风貌</h4><ul>
<li><p>独立精神与文化尊严——师？友？臣？“骄富贵，轻王公。”</p>
</li>
<li><p>修齐治平取向：希腊的哲学传统，将人生客观化，同自然界一样作为研究物（出于好奇；知识最基本的来源：惊奇、闲暇、自由）。中国“道”的人间性，强调人间秩序的安排（出于入世；修身齐家治国平天下）。</p>
<blockquote>
<p>夫阴阳、儒、墨、名、法、道德，此务为治者也。 ——《史记》</p>
</blockquote>
</li>
<li><p>实用理性</p>
<blockquote>
<p>六合之外，圣人存而不论；六合之内，圣人论而不议。 ——《齐物论》</p>
<p>其于天地万物也，不务说其所以然而致善用其才。 ——《荀子君道》</p>
</blockquote>
</li>
</ul>
<h3 id="二-诸子略说"><a href="#二、诸子略说" class="headerlink" title="二、诸子略说"></a>二、诸子略说</h3><p>思想史概说，轴心时代…</p>
<h4 id="1-儒家"><a href="#1-儒家" class="headerlink" title="1. 儒家"></a>1. 儒家</h4><ul>
<li><p>孔子</p>
<ul>
<li><p>学习礼乐：学琴于师襄，学乐于苌弘，问道于老子</p>
</li>
<li><p>周游列国，杏坛讲学</p>
</li>
<li><blockquote>
<p>孔子布衣，傅十余世，学者宗之。自天子王侯，中国言六艺者折中于天子，可谓至圣矣！ ——司马迁</p>
</blockquote>
</li>
</ul>
</li>
<li><p>孔子思想</p>
<ul>
<li><p>宗教观——【命】</p>
</li>
<li><p>礼乐观——仁义和礼乐</p>
<p>乐——同——亲——仁——天——阳</p>
<p>礼——异——敬——义——地——阴</p>
</li>
<li><p>君子观</p>
<p>【教化】 儒家心目中的政治，既不是治人也不是治世，而是教育。</p>
</li>
</ul>
</li>
<li><p>孟子——思孟学派？</p>
<ul>
<li><p>仁政思想</p>
</li>
<li><p>民本思想    民权&gt;主权&gt;君权</p>
<blockquote>
<p>民为贵，社稷次之，君为轻。是故得乎丘民而为天子。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>荀子</p>
<ul>
<li><p>唯物天道论</p>
<blockquote>
<p>天行有常，不为尧存，不为桀亡。</p>
</blockquote>
</li>
<li><p>性恶论</p>
</li>
<li><p>以礼入法 礼法兼综 儒法合流</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-法家"><a href="#2-法家" class="headerlink" title="2. 法家"></a>2. 法家</h4><p>争锋相对</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">儒家</th>
<th style="text-align:left">法家</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">历史退化论</td>
<td style="text-align:left">历史进化论</td>
</tr>
<tr>
<td style="text-align:left">性善论</td>
<td style="text-align:left">性恶论</td>
</tr>
<tr>
<td style="text-align:left">主张仁爱 传承礼乐诗书 反战</td>
<td style="text-align:left">六虱（不好的）：礼乐、诗书、修善孝弟、诚信贞廉、仁义、非兵羞战 燔诗书而明法令</td>
</tr>
<tr>
<td style="text-align:left">君子治国 贤人政治</td>
<td style="text-align:left">以文法吏治国</td>
</tr>
<tr>
<td style="text-align:left">孟子：民贵君轻</td>
<td style="text-align:left">李斯：主独制于天下而无所制</td>
</tr>
<tr>
<td style="text-align:left">父为子隐，子为父隐</td>
<td style="text-align:left">不别亲疏，不殊贵贱，一断于法</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>历史进化论</p>
<blockquote>
<p><em>上世亲亲而爱私，中世尚贤而说仁，下世贵贵而尊官</em>。 ——《商君书》</p>
</blockquote>
</li>
<li><p>性恶论——以法律驾驭臣民</p>
<p>近代的法治思想、西方近代史</p>
</li>
<li><p>法治思想——建立官僚帝国的理论</p>
</li>
<li><p>国家主义和专制主义</p>
</li>
</ul>
<blockquote>
<p><em>孟子长于诗书，荀子长于制度。荀子“隆礼乐而杀诗书”。其书中的《王制》《礼论》《乐论》等篇，可称独步。孟子则疏于礼，疏于“王政”。“简陋不堪，哪能及荀子的博大！”</em> 章太炎</p>
</blockquote>
<p>章太炎论韩非</p>
<h4 id="3-墨家"><a href="#3-墨家" class="headerlink" title="3. 墨家"></a>3. 墨家</h4><ul>
<li>兼爱</li>
<li>尚贤</li>
<li>天志 明鬼</li>
<li>科技知识</li>
</ul>
<h4 id="4-道家"><a href="#4-道家" class="headerlink" title="4. 道家"></a>4. 道家</h4><p>老子</p>
<ul>
<li>以无为本的本体论</li>
<li>辩证法思想</li>
<li>无为和以退为进</li>
<li>历史退化论——小国寡民</li>
</ul>
<p>庄子</p>
<ul>
<li>相对主义的认识论</li>
<li>消极自由的人生观</li>
</ul>
<h4 id="5-名家"><a href="#5-名家" class="headerlink" title="5. 名家"></a>5. 名家</h4><p>惠施 合同异</p>
<p>公孙龙 离坚白</p>
<h4 id="6-阴阳家"><a href="#6-阴阳家" class="headerlink" title="6. 阴阳家"></a>6. 阴阳家</h4><h4 id="7-兵家"><a href="#7-兵家" class="headerlink" title="7. 兵家"></a>7. 兵家</h4><h4 id="8-农家"><a href="#8-农家" class="headerlink" title="8. 农家"></a>8. 农家</h4><h3 id="本讲阅读书籍"><a href="#本讲阅读书籍-2" class="headerlink" title="本讲阅读书籍"></a>本讲阅读书籍</h3><p>余英时《士与中国文化》 萧公权《中国政治思想史》 林达</p>
<hr>
<h2 id="第八讲-秦帝国的兴亡"><a href="#第八讲-秦帝国的兴亡" class="headerlink" title="第八讲 秦帝国的兴亡"></a>第八讲 秦帝国的兴亡</h2><h3 id="一-秦国的历史"><a href="#一、秦国的历史" class="headerlink" title="一、秦国的历史"></a>一、秦国的历史</h3><h4 id="1-秦国的早期历史"><a href="#1-秦国的早期历史" class="headerlink" title="1. 秦国的早期历史"></a>1. 秦国的早期历史</h4><p>秦历史上曾多次迁都。 东来说？西来说？</p>
<p>尚武、军事化倾向——游牧民族背景</p>
<p>秦与六国的对立地位</p>
<blockquote>
<p><em>秦在制度、思想学术、语言文字、宗教意识上与六国存在的这些差异，却表现出了强烈的对抗性</em>。 ——《秦称虎狼考》</p>
<p><em>秦与戎狄同俗，有虎狼之心，贪戾好利而无信。苟有利焉，不顾亲戚兄弟，若禽兽耳。</em> ——《战国策》</p>
</blockquote>
<h4 id="2-秦国的政治文化特色"><a href="#2-秦国的政治文化特色" class="headerlink" title="2. 秦国的政治文化特色"></a>2. 秦国的政治文化特色</h4><p>秦国建筑和墓葬方向…</p>
<p>人殉风气，反映秦文化对生命的轻蔑…</p>
<p>杜正胜：秦人尚武的习性与其社会构成之戎狄成分，恐怕有很密切的关系。</p>
<blockquote>
<p><em>临其穴，惴惴其栗。彼苍者天，歼我良人！如可赎兮，人百其身！</em> ——《秦风 黄鸟》</p>
</blockquote>
<p>魏特夫：东方专制君主——“伟大的建设者”</p>
<blockquote>
<p><em>况复秦兵耐苦战，被驱不异犬与鸡。</em></p>
</blockquote>
<h3 id="二-秦帝国的统一成就"><a href="#二、秦帝国的统一成就" class="headerlink" title="二、秦帝国的统一成就"></a>二、秦帝国的统一成就</h3><h4 id="1-奠定了中国版图和民族的基础"><a href="#1-奠定了中国版图和民族的基础" class="headerlink" title="1. 奠定了中国版图和民族的基础"></a>1. 奠定了中国版图和民族的基础</h4><blockquote>
<p><em>海内为郡县，法令由一统，自上古以来未曾有，五帝所不及。</em></p>
</blockquote>
<h4 id="2-推动了共同文化的发展"><a href="#2-推动了共同文化的发展" class="headerlink" title="2. 推动了共同文化的发展"></a>2. 推动了共同文化的发展</h4><ul>
<li>统一文字 小篆</li>
<li>统一货币 秦半两</li>
<li>统一度量衡</li>
</ul>
<h4 id="3-确立中华帝国的基本政治架构"><a href="#3-确立中华帝国的基本政治架构" class="headerlink" title="3. 确立中华帝国的基本政治架构"></a>3. 确立中华帝国的基本政治架构</h4><p>五德之说…</p>
<h3 id="三-天下反秦与亡秦必楚"><a href="#三、天下反秦与亡秦必楚" class="headerlink" title="三、天下反秦与亡秦必楚"></a>三、天下反秦与亡秦必楚</h3><h4 id="1-天下反秦"><a href="#1-“天下反秦”" class="headerlink" title="1. “天下反秦”"></a>1. “天下反秦”</h4><h4 id="2-亡秦必楚"><a href="#2-“亡秦必楚”" class="headerlink" title="2. “亡秦必楚”"></a>2. “亡秦必楚”</h4><p><strong>非张楚不能灭秦</strong></p>
<p><strong>非承秦不能立汉</strong></p>
<h3 id="本讲阅读书籍"><a href="#本讲阅读书籍-3" class="headerlink" title="本讲阅读书籍"></a>本讲阅读书籍</h3><p>何晋《秦称虎狼考》</p>
<hr>
<h1 id="汉"><a href="#汉" class="headerlink" title="汉"></a>汉</h1><h2 id="第二讲-休养生息和削抑藩国"><a href="#第二讲-休养生息和削抑藩国" class="headerlink" title="第二讲 休养生息和削抑藩国"></a>第二讲 休养生息和削抑藩国</h2><h3 id="一-承秦立汉与修养无为"><a href="#一、承秦立汉与修养无为" class="headerlink" title="一、承秦立汉与修养无为"></a>一、承秦立汉与修养无为</h3><h4 id="1-非承秦不能立汉"><a href="#1-“非承秦不能立汉”" class="headerlink" title="1. “非承秦不能立汉”"></a>1. “非承秦不能立汉”</h4><blockquote>
<p>刘邦入关：与父老约，法三章耳，杀人者死，伤人及盗抵罪。余悉除去秦法。</p>
<p>萧何守关中，治栎阳，为令约束，立宗庙、社稷、宫室、县邑。</p>
<p><em>汉初制度，法律，一切全依秦旧</em>。 ——钱穆</p>
<p><em>汉律值峻峭，比秦更甚</em>。 ——侯外庐</p>
<p><em>汉初法律全部承秦</em>。 ——高敏</p>
</blockquote>
<ul>
<li>官制承秦</li>
<li>爵制承秦</li>
</ul>
<h4 id="2-休养生息与黄老无为"><a href="#2-休养生息与黄老无为" class="headerlink" title="2. 休养生息与黄老无为"></a>2. 休养生息与黄老无为</h4><p>背景：生产被破坏，百业凋敝</p>
<p>恢复社会秩序和经济生产的措施——<em>高帝五年诏</em></p>
<ul>
<li>“兵皆罢归家……以有功劳行田宅”</li>
<li>号召流亡者返乡，“复故爵田宅”</li>
<li>“民以饥饿自卖为人奴婢者……皆免为庶人”</li>
<li>禁止商人衣丝、乘车、骑马、操兵器及做官，算赋加倍</li>
<li>减轻田租。十五税一</li>
</ul>
<p>汉初的政治选择：<strong>用秦制而不用秦政</strong></p>
<p>萧规曹随——汉早期政治方针没有变化</p>
<h3 id="二-布衣将相和军功受益集团"><a href="#二、“布衣将相”和“军功受益集团”" class="headerlink" title="二、“布衣将相”和“军功受益集团”"></a>二、“布衣将相”和“军功受益集团”</h3><h3 id="1-布衣将相"><a href="#1-“布衣将相”" class="headerlink" title="1. “布衣将相”"></a>1. “布衣将相”</h3><p>先秦 贵族政治；秦以后 官僚政治</p>
<blockquote>
<p><em>盖秦汉间为天地一大变局，自古皆封建诸侯，各君其国，卿大夫亦世为官……汉祖以匹夫起事，角群雄而定一尊。其君既起自布衣，其臣亦自多亡命无赖之徒，立功以取将相，此气运为之也。天之变局于是始定。</em>——赵翼 《廿二史札记》</p>
</blockquote>
<h4 id="2-汉初的军功受益阶级"><a href="#2-汉初的“军功受益阶级”" class="headerlink" title="2. 汉初的“军功受益阶级”"></a>2. 汉初的“军功受益阶级”</h4><p>两部分人</p>
<ol>
<li>创建西汉王朝的政治军事集团成员</li>
<li>通过汉高祖五年诏等优待将士的法令获得利益者</li>
</ol>
<ul>
<li>军功政治</li>
<li>联合帝国</li>
<li>有限皇权</li>
<li>马上天下</li>
</ul>
<h3 id="三-分封和削藩"><a href="#三、分封和削藩" class="headerlink" title="三、分封和削藩"></a>三、分封和削藩</h3><h4 id="1-异姓王的分封和剪除"><a href="#1-异姓王的分封和剪除" class="headerlink" title="1. 异姓王的分封和剪除"></a>1. 异姓王的分封和剪除</h4><ul>
<li>燕王臧荼</li>
<li>赵王张耳</li>
<li>楚王韩信</li>
<li>淮南王黥布</li>
<li>韩王信</li>
<li>梁王彭越</li>
<li>长沙王吴芮</li>
</ul>
<h4 id="2-同姓王分封与藩国危机"><a href="#2-同姓王分封与藩国危机" class="headerlink" title="2. 同姓王分封与藩国危机"></a>2. 同姓王分封与藩国危机</h4><ul>
<li>楚王刘交</li>
<li>齐王刘肥</li>
<li>赵王如意</li>
<li>代王刘恒</li>
<li>梁王刘恢</li>
<li>淮南王刘友</li>
<li>淮南王刘长</li>
<li>吴王刘濞</li>
<li>燕王刘建</li>
</ul>
<p>多封，每个都很小</p>
<blockquote>
<p><em>欲天下之治安，莫若众建诸侯而少其力。力少则易使以义，国小则亡邪心……割地定制，令齐赵楚各为若干国。</em> ——贾谊</p>
</blockquote>
<p>封国而不治民，只是<strong>“衣食租税而已</strong>“</p>
<h4 id="3-景帝平叛与武帝削藩"><a href="#3-景帝平叛与武帝削藩" class="headerlink" title="3. 景帝平叛与武帝削藩"></a>3. 景帝平叛与武帝削藩</h4><p>颁<strong>《左官律》</strong>，以王国官为“左官”；颁<strong>《附益法》</strong>，禁止大臣为诸侯牟取非法利益</p>
<h3 id="本讲阅读书籍"><a href="#本讲阅读书籍-4" class="headerlink" title="本讲阅读书籍"></a>本讲阅读书籍</h3><p>赵翼 《廿二史札记》 李开元《汉帝国的建立与刘邦集团》</p>
<hr>
<h2 id="第三讲-全盛与转向"><a href="#第三讲-全盛与转向" class="headerlink" title="第三讲 全盛与转向"></a>第三讲 全盛与转向</h2><h3 id="一-汉武帝的功业"><a href="#一、汉武帝的功业" class="headerlink" title="一、汉武帝的功业"></a>一、汉武帝的功业</h3><p>汉武帝统治50多年，汉武帝进入全盛。</p>
<h4 id="1-文化政策独尊儒术"><a href="#1-文化政策：独尊儒术" class="headerlink" title="1. 文化政策：独尊儒术"></a>1. 文化政策：独尊儒术</h4><p>董仲舒 李斯 对比 强调一家独尊 企图通过政治力量来扩大学术上的影响力</p>
<blockquote>
<p><em>董仲舒对策：今师异到，人异论，百家殊方……臣愚以为诸不在六艺之科孔子之术者，皆绝其道，毋使并进。邪辟之说灭息，然后统纪可一而法度可明，民知所从矣</em>。 ——《汉书 董仲舒传》</p>
</blockquote>
<h4 id="2-对外政策反击与开边"><a href="#2-对外政策：反击与开边" class="headerlink" title="2. 对外政策：反击与开边"></a>2. 对外政策：反击与开边</h4><ul>
<li>东南：制服闽越、东瓯、南越</li>
<li>北方：北击匈奴，令“漠南无王庭”</li>
<li>西北：张骞通西域，王恢破楼兰，赵破奴破姑师，李广利伐大宛，李息破羌，设护羌校尉</li>
<li>西南：制服贵州的且(ju)兰，云南的滇王</li>
</ul>
<h4 id="3-经济政策国家统制"><a href="#3-经济政策：国家统制" class="headerlink" title="3. 经济政策：国家统制"></a>3. 经济政策：国家统制</h4><div class="table-container">
<table>
<thead>
<tr>
<th>措施</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>盐鉄均输平淮</td>
<td>设盐铁官，实行盐鉄国营。<br>行均输法，国家经商，一年收入500万匹<br>行平淮法平抑物价、调节市场</td>
</tr>
<tr>
<td>国家铸货</td>
<td>把铸钱权力收归政府(重金属，亦为生产)，由钟官、辨铜、均输三官铸“五铢钱”，铸钱的重大收益归于政府</td>
</tr>
<tr>
<td>算缗</td>
<td>对工商业者加增财产税，检举揭发偷税漏税者</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-制度建设强化专政集权"><a href="#4-制度建设：强化专政集权" class="headerlink" title="4. 制度建设：强化专政集权"></a>4. 制度建设：强化专政集权</h4><div class="table-container">
<table>
<thead>
<tr>
<th>措施</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>继续削藩</td>
<td>用主父堰“推恩”之策，穷治诸王宾客，颁“左官律”、“附益法”，使用“酬金”时间削夺106个列侯的爵位</td>
</tr>
<tr>
<td>削弱相权</td>
<td>以布衣公孙弘为相，结束了功臣子弟独占相位之局；<br>选拔任用文学（儒学）之士，分大臣议政之权；<br>以尚书（中书）掌机要，形成“内朝”</td>
</tr>
<tr>
<td>强化京师力量</td>
<td>在京师建长从而非番上之军；<br>设屯骑、步兵等八校尉；<br>设期门军、羽林军、羽林孤儿</td>
</tr>
<tr>
<td>加强地方监察</td>
<td>分全国为十三州部，各设刺史负责监察。<br>京师设司隶校尉，纠察百官和三辅等七郡。<br>临时事宜，派侍御史为“绣衣直指”专程巡视。</td>
</tr>
<tr>
<td>创建察举(700多年察举，1000多年科举)</td>
<td>元光元年(前134年)“初令郡国举孝廉各一名”，孝廉岁举制建立。</td>
</tr>
<tr>
<td>完善法制</td>
<td>张汤、赵禹等负责立法，法律至359章，大辟409章，1882事；死罪决事比13472事。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="二-亡秦之迹与轮台之诏"><a href="#二、“亡秦之迹“与《轮台》之诏" class="headerlink" title="二、“亡秦之迹“与《轮台》之诏"></a>二、“亡秦之迹“与《轮台》之诏</h3><h4 id="1-汉武帝亡秦之迹"><a href="#1-汉武帝“亡秦之迹”" class="headerlink" title="1. 汉武帝“亡秦之迹”"></a>1. 汉武帝“亡秦之迹”</h4><p>与秦朝类似的危机</p>
<ul>
<li><p>建宫馆，大兴土木</p>
</li>
<li><p>求神仙，”今天子即位，尤敬鬼神之祠……”，例子 李少君 少翁 栾大</p>
</li>
<li><p>用酷吏，例子 宁成 张汤 王温舒 杜周（法律的渊源就是皇帝的意志）</p>
</li>
</ul>
<p>国家耗费 见《汉书》《资治通鉴》</p>
<blockquote>
<p><em>及赂遗赠送，万里相奉，师旅之费，不可胜计。至于用度不足，乃榷酒酤，筦盐铁，铸白金，造皮币，算至车船，租及六畜。民力屈，财用竭，因之以凶年，寇盗并起，道路不通，直指之使始出，衣绣杖斧，断斩于郡国，然后胜之。是以末年遂弃轮台之地，而下哀痛之诏，岂非仁圣之所悔哉！</em> ——《汉书》</p>
<p><em>孝武穷奢极欲、繁刑重敛，内侈宫室，外事四夷，信惑鬼神，巡游无度，使百姓疲敝，起为盗贼，其所以异于秦始皇者无几矣。</em> ——《资治通鉴》</p>
</blockquote>
<h4 id="2-戾太子与守文派"><a href="#2-“戾太子”与守文派" class="headerlink" title="2. “戾太子”与守文派"></a>2. “戾太子”与守文派</h4><p>太子刘据不赞成武帝的政策路线。</p>
<p><strong>守文 与 用法</strong></p>
<blockquote>
<p><em>群臣宽厚长者皆附太子，而深酷用法者皆毁之。邪臣多党羽，故太子誉少而毁多。卫青薨后，臣下无复外家为据，竟欲构太子。</em> ——《资治通鉴》</p>
<p><em>江充充当了深酷用法臣僚的代表，秉承武帝意旨，凭借党与优势，用非常手段摧毁以卫太子为代表的“守文”的政治势力，这也许就是<strong>巫蛊之狱</strong>的实质。</em></p>
<p><em>朝廷纷争，几乎都与屠杀相伴。</em></p>
<p>——田余庆</p>
</blockquote>
<p>巫蛊之狱</p>
<h4 id="3-仁圣之悔-轮台诏"><a href="#3-“仁圣之悔”-《轮台诏》" class="headerlink" title="3. “仁圣之悔” 《轮台诏》"></a>3. “仁圣之悔” 《轮台诏》</h4><h3 id="三-昭-宣时的政策转变"><a href="#三、昭、宣时的政策转变" class="headerlink" title="三、昭、宣时的政策转变"></a>三、昭、宣时的政策转变</h3><h4 id="1-霍光的与民休息"><a href="#1-霍光的“与民休息”" class="headerlink" title="1. 霍光的“与民休息”"></a>1. 霍光的“与民休息”</h4><p>汉武帝指定的辅政大臣：霍光、金日磾、上官桀、桑弘羊(财务专家)</p>
<p>轻徭薄赋、与民休息</p>
<h4 id="2-盐铁会议"><a href="#2-盐铁会议" class="headerlink" title="2. 盐铁会议"></a>2. 盐铁会议</h4><blockquote>
<p><em>要从桑弘羊手上夺取财政大权，必先打击桑弘羊所凭藉的财经政策。由贤良文学在朝廷上公开反映出人民对盐铁政策的反对，即足以使桑弘羊失掉他所挟以自重的政治资本。</em> ——徐复观《汉代思想史》</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>措施</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>盐铁官营</td>
<td>【贤良文学】愿罢盐铁、酒榷、均输，所以进本退末，广利农业，便也。<br>【桑弘羊】边用度不足，故兴盐铁，设酒榷、置均输……罢之，不便也。</td>
</tr>
<tr>
<td>匈奴和战</td>
<td>【贤良文学】去武行文，废力尚德……以仁义导之<br>【桑弘羊】匈奴一举，则中外震惧，释备而何宜也！</td>
</tr>
<tr>
<td>礼法刑德</td>
<td>【贤良文学】商鞅峭法长利，秦人不聊生……商鞅以重刑峭法为秦国基，故二世而夺。<br>【桑弘羊】秦任商君，国以富强，其后卒并六国而成帝业。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-宣帝中兴-刘病已"><a href="#3-宣帝“中兴”-刘病已" class="headerlink" title="3. 宣帝“中兴” 刘病已"></a>3. 宣帝“中兴” 刘病已</h4><p>反霍联盟：燕王刘旦、长公主、上官桀、上官安、桑弘羊、丁外人 被破除</p>
<p>霍光主政 </p>
<p>《宣帝纪》</p>
<h3 id="本讲阅读书籍"><a href="#本讲阅读书籍-5" class="headerlink" title="本讲阅读书籍"></a>本讲阅读书籍</h3><p>田余庆《秦汉魏晋史探微》</p>
<hr>
<h2 id="第四讲-王莽变法"><a href="#第四讲-王莽变法" class="headerlink" title="第四讲 王莽变法"></a>第四讲 王莽变法</h2><h3 id="一-复古改制思潮与王莽篡汉"><a href="#一、复古改制思潮与王莽篡汉" class="headerlink" title="一、复古改制思潮与王莽篡汉"></a>一、复古改制思潮与王莽篡汉</h3><h4 id="1-霸王道杂之问题"><a href="#1-“霸王道杂之”问题" class="headerlink" title="1. “霸王道杂之”问题"></a>1. “霸王道杂之”问题</h4><blockquote>
<p><em>孝元皇帝，……柔仁好儒，见先帝所用多文法吏，以刑名绳下。……尝侍燕，从容曰：”陛下持刑太深，宜用儒生。”宣帝作色曰：”<strong>汉家自有制度，本以霸王道杂之</strong>，奈何纯任德教，用周政乎？”</em> ——《汉书 元帝纪》</p>
</blockquote>
<h4 id="2-复古改制呼吁"><a href="#2-复古改制呼吁" class="headerlink" title="2. 复古改制呼吁"></a>2. 复古改制呼吁</h4><p>制度浪漫主义——<strong>春秋之道，奉天而法古。</strong></p>
<ul>
<li>天人感应：孔子的“天”在有意识与无意识之间；汉儒的“天”是有鲜明意志的至高主宰</li>
<li>五德：各朝依木水火金木往复循环——历史退化说</li>
<li>三统：各朝依黑统、白统、赤统循环往复</li>
<li>谶(chen 应验的预言)纬(用神秘方式解经)：汉代儒学神秘化，儒生与方士合流、儒家与阴阳家合流</li>
</ul>
<h4 id="3-王莽篡汉"><a href="#3-王莽篡汉" class="headerlink" title="3. 王莽篡汉"></a>3. 王莽篡汉</h4><blockquote>
<p><em>及王莽之兴，由孝元后历汉四世为天下母，飨国六十余载。群弟世权，更持国柄，五将十侯，卒成新都。</em> ——《汉书元后传》</p>
</blockquote>
<h3 id="二-王莽变法"><a href="#二、王莽变法" class="headerlink" title="二、王莽变法"></a>二、王莽变法</h3><p><strong>政令日变，官名月易，货币岁改</strong></p>
<h4 id="1-定三统-五德系统"><a href="#1-定三统、五德系统" class="headerlink" title="1. 定三统、五德系统"></a>1. 定三统、五德系统</h4><p>周：火德</p>
<p>秦：水德</p>
<p>汉初：水德</p>
<p>汉武帝：土德</p>
<p>王莽：改用<strong>相生说</strong>，自为土德，以汉为火德</p>
<h4 id="2封古帝王之后"><a href="#2-封古帝王之后" class="headerlink" title="2.封古帝王之后"></a>2.封古帝王之后</h4><h4 id="3-定郊祀-庙祀之制"><a href="#3-定郊祀、庙祀之制" class="headerlink" title="3. 定郊祀、庙祀之制"></a>3. 定郊祀、庙祀之制</h4><p>汉武帝天地祭祀，承秦又用方士之说。</p>
<p>祭祀制度：郊祀改革</p>
<h4 id="4-建明堂-辟雍"><a href="#4-建明堂、辟雍" class="headerlink" title="4. 建明堂、辟雍"></a>4. 建明堂、辟雍</h4><h4 id="5-改州郡名-地名"><a href="#5-改州郡名、地名" class="headerlink" title="5. 改州郡名、地名"></a>5. 改州郡名、地名</h4><h4 id="6-改官名-爵制"><a href="#6-改官名、爵制" class="headerlink" title="6. 改官名、爵制"></a>6. 改官名、爵制</h4><h4 id="7-改易币制"><a href="#7-改易币制" class="headerlink" title="7. 改易币制"></a>7. 改易币制</h4><h4 id="8-实行井田制"><a href="#8-实行井田制" class="headerlink" title="8. 实行井田制"></a>8. 实行井田制</h4><p>耕者有其田</p>
<blockquote>
<p><em>今更名天下田曰’王田’，奴婢曰’私属’，皆不得买卖。其男口不盈八，而田过一井者，分余田予九族邻里乡党，故无田，今当受田者，如制度，敢有非井田圣制，无法惑众者，投诸四裔，以御魑魅。</em> ——王莽《井田诏》</p>
</blockquote>
<ul>
<li><p>钱穆：均产运动，如近时所谓“国家社会主义”</p>
</li>
<li><p>胡适：一千九百年前的一个社会主义者</p>
</li>
</ul>
<h4 id="9改外族称号"><a href="#9-改外族称号" class="headerlink" title="9.改外族称号"></a>9.改外族称号</h4><h3 id="三-农民起义与新朝灭亡"><a href="#三、农民起义与新朝灭亡" class="headerlink" title="三、农民起义与新朝灭亡"></a>三、农民起义与新朝灭亡</h3><p>杨雄<strong>《剧秦美新》</strong></p>
<ul>
<li>【秦】刮烧诗书，弛礼蹦乐。</li>
<li>【汉】秦余制度，项氏爵号，虽违古而犹袭之。是以帝典阙而不补，王纲弛而未张。</li>
<li>【新】…</li>
</ul>
<p>农民起义</p>
<ul>
<li>绿林军</li>
<li>赤眉军</li>
<li>铜马军</li>
</ul>
<h4 id="王莽变法简评"><a href="#王莽变法简评" class="headerlink" title="王莽变法简评"></a>王莽变法简评</h4><blockquote>
<p><em>王莽的垮台是由于几次黄河改道的重大积累的影响……王莽是机智而能干的</em>。 ——毕汉斯</p>
<p><em>王莽打击侵凌小农的豪强势力。各大士族大姓都纷纷率领宗室子弟起而反叛，王莽政权终因而覆灭。</em>  ——余英时</p>
<p><em>王莽法令有关实际的，怕没有一件能够真正推行，而达到目的。因此而生的流弊，则无一事不有，且无一事不厉害。</em> ——吕思勉</p>
<p><em>井田制度是“<strong>间架性设计</strong>”的代表。它意味着<strong>国家和社会结构是可以人为地创造出来的</strong>。</em> ——黄仁宇</p>
</blockquote>
<p>从奉行法术、霸道的秦政，</p>
<p>到“霸王道杂之”的汉政，</p>
<p>再到一意贯彻儒家王道的王莽新政，</p>
<p>历史似乎经历了一个两极转向</p>
<hr>
<h2 id="第五讲-专制强化和皇权旁落"><a href="#第五讲-专制强化和皇权旁落" class="headerlink" title="第五讲 专制强化和皇权旁落"></a>第五讲 专制强化和皇权旁落</h2><h3 id="一-东汉初年专制的强化"><a href="#一、东汉初年专制的强化" class="headerlink" title="一、东汉初年专制的强化"></a>一、东汉初年专制的强化</h3><h4 id="1-光武起兵-人心思汉"><a href="#1-光武起兵-“人心思汉”" class="headerlink" title="1. 光武起兵 “人心思汉”"></a>1. 光武起兵 “人心思汉”</h4><p>“仕宦当作执金吾，娶妻当得阴丽华。”</p>
<p><strong>王莽时起兵皆称汉后</strong></p>
<h4 id="2-恢复秩序和加强专制"><a href="#2-恢复秩序和加强专制" class="headerlink" title="2. 恢复秩序和加强专制"></a>2. 恢复秩序和加强专制</h4><div class="table-container">
<table>
<thead>
<tr>
<th>措施</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>轻刑薄赋</td>
<td>称帝后“大赦天下，议者刑法”，建武六年再行三十税一。</td>
</tr>
<tr>
<td>释放奴婢</td>
<td>建武二年至十四年，颁布了6个释放奴婢的法令。重中“卖人法”“略人法”</td>
</tr>
<tr>
<td>度田</td>
<td>建武15年（39）下诏州郡检核垦田頃亩和户口纪年。</td>
</tr>
<tr>
<td>退功臣而进文吏</td>
<td>一、“不欲功臣拥众京师”，使其领兵外驻；<br>二、“退功臣而进文吏”</td>
</tr>
<tr>
<td>压制宗室外戚</td>
<td>后族、宫戚“不得封侯与政”，收捕诸王宾客</td>
</tr>
<tr>
<td>精兵简政</td>
<td>裁剪三分之一的县，吏职减损，文书调役，务多从简</td>
</tr>
<tr>
<td>加强尚书台</td>
<td>加强<strong>秘书机要机构</strong>尚书台的事权，削弱宰相三公权势，君主集权得以强化</td>
</tr>
</tbody>
</table>
</div>
<h3 id="二-儒生与文吏的融合"><a href="#二、儒生与文吏的融合" class="headerlink" title="二、儒生与文吏的融合"></a>二、儒生与文吏的融合</h3><h4 id="1-法治精神的复归"><a href="#1-法治精神的复归" class="headerlink" title="1. 法治精神的复归"></a>1. 法治精神的复归</h4><p>（再次转为 霸王道杂之） <strong>中兴以来，追踪宣帝。汉家中兴，唯宣帝取法。 </strong>——《后汉书》</p>
<p>儒生与文吏的关系变迁</p>
<ul>
<li>秦以文法吏治天下</li>
<li>汉廷儒生文吏并用</li>
<li>王莽变法重用儒生</li>
</ul>
<blockquote>
<p><em>文吏以事胜，以忠负；儒生以节优，以职劣。二者长短，各有所宜；世之将相，各有所取。取儒生者，必轨德立化者也；取文吏者，必优事理乱者也。</em> ——《论衡》</p>
</blockquote>
<p>儒生兼学经书、律令</p>
<p>史书：律令</p>
<h4 id="2-儒生与文吏的融合学者兼为官僚"><a href="#2-儒生与文吏的融合——学者兼为官僚" class="headerlink" title="2. 儒生与文吏的融合——学者兼为官僚"></a>2. 儒生与文吏的融合——学者兼为官僚</h4><blockquote>
<p><em>西汉开国，功臣多出于亡命无赖；至东汉中兴，则诸将皆有儒者气象，亦一时风会不同也……是光武诸功臣，大半多习儒术，与光武意气相符合。</em> ——赵翼《东汉功臣多进儒》</p>
<p><em>执法之吏，不窥先王之典；搢绅之儒，不通律令之要。彼刀笔之吏，岂生而察刻哉！起于几案之下，长于官曹之间，无温裕文雅以自润，虽欲无察刻，弗能得矣。竹帛之儒，岂生而迂缓也！起于讲堂之上，游于乡校之中，无严猛断割以自裁，虽欲不迂缓，弗能得矣。先王见其如此也，是以博陈其教，辅和民性，达其所壅，祛其所蔽，吏服雅训，儒通文法；故能<strong>宽猛相济，刚柔自克</strong>也。</em> ——王桀《儒吏论》</p>
</blockquote>
<h3 id="三-外戚与宦官的轮流专政"><a href="#三、外戚与宦官的轮流专政" class="headerlink" title="三、外戚与宦官的轮流专政"></a>三、外戚与宦官的轮流专政</h3><h4 id="1-家天下和母族权势"><a href="#1-“家天下”和母族权势" class="headerlink" title="1. “家天下”和母族权势"></a>1. “家天下”和母族权势</h4><p>《春秋时代母系遗俗公羊证义》 《汉初公主及外戚在帝室中之地位试释》</p>
<ul>
<li>外戚可以称宗室</li>
<li>外戚不称异姓</li>
<li>长公主的特殊权力</li>
<li>皇子称母姓</li>
<li>“舅权”之重</li>
</ul>
<blockquote>
<p><em>东京皇统屡绝，权归女主，外立者四帝，临朝者六后。</em></p>
</blockquote>
<p>孤儿寡母——外立者：安帝、质帝、桓帝、灵帝；临朝者：</p>
<h4 id="2-外戚与宦官的轮流专政"><a href="#2-外戚与宦官的轮流专政" class="headerlink" title="2. 外戚与宦官的轮流专政"></a>2. 外戚与宦官的轮流专政</h4><p>章德窦太后家族</p>
<p>和熹邓皇后</p>
<p>安思阎皇后</p>
<p>顺烈梁皇后</p>
<blockquote>
<p><em>宦官、外戚专政，并不是完全的衰弱，而只是<strong>“皇权的旁落”</strong>。东晋皇权衰弱，“主弱臣强”、门阀当权，其时就没有宦官、外戚专政的现象。</em> ——田余庆</p>
<p><em>一<strong>宦官用事，必不在贵族执政之世。</strong>周公时贵族执政，断无防及刑余擅权之理，汉唐明三代，皆有刑余擅权之事，六朝则无何则？贵族执政阶级严明，非刑余所得间也。</em> ——章太炎</p>
</blockquote>
<h3 id="本讲阅读书籍"><a href="#本讲阅读书籍-6" class="headerlink" title="本讲阅读书籍"></a>本讲阅读书籍</h3><p>《廿二史札记》</p>
<hr>
<h2 id="第六讲-清议与党锢"><a href="#第六讲-清议与党锢" class="headerlink" title="第六讲 清议与党锢"></a>第六讲 清议与党锢</h2><h3 id="一-士人群体的发展"><a href="#一、士人群体的发展" class="headerlink" title="一、士人群体的发展"></a>一、士人群体的发展</h3><h4 id="1-儒学教育的发达"><a href="#1-儒学教育的发达" class="headerlink" title="1. 儒学教育的发达"></a>1. 儒学教育的发达</h4><p>汉末太学生约占洛阳居民的1/10</p>
<ul>
<li>光武帝：修太学，稽式古典</li>
<li>汉明帝：亲行其礼，正坐自讲</li>
<li>汉章帝：大会群儒于白虎观</li>
<li>汉顺帝：建房…</li>
<li>汉桓帝：游学增盛，至三万生</li>
</ul>
<blockquote>
<p><em>若乃经生所处，不远万里之路；精庐暂建，赢粮动有千百，其耆名高义开门受徒者，编牒不下万人。</em> ——《后汉书 儒林传》</p>
</blockquote>
<h4 id="2-交游风气"><a href="#2-交游风气" class="headerlink" title="2. 交游风气"></a>2. 交游风气</h4><blockquote>
<p><em>自是游学增盛，至三万余生。然章句渐疏，而多以<strong>浮华</strong>相尚，儒者之风盖衰矣。</em>  ——《后汉书 儒林传》</p>
</blockquote>
<p>士林、士人开辟了属于自己的社交空间</p>
<h4 id="3-风谣与品题"><a href="#3-风谣与品题" class="headerlink" title="3. 风谣与品题"></a>3. 风谣与品题</h4><p>用一句话评价士人、人物评价</p>
<p>治世之能臣，乱世之奸雄。 许劭目曹操</p>
<h4 id="4-不应辟举"><a href="#4-不应辟举" class="headerlink" title="4. 不应辟举"></a>4. 不应辟举</h4><p>朝廷请士人做官，不就</p>
<p>士人这个群体、士林这个活动空间影响力的增大</p>
<h4 id="5-东汉重名节"><a href="#5-东汉重名节" class="headerlink" title="5. 东汉重名节"></a>5. 东汉重名节</h4><h3 id="二-清议与党锢"><a href="#二、清议与党锢" class="headerlink" title="二、清议与党锢"></a>二、清议与党锢</h3><h4 id="1-士大夫与宦官的冲突"><a href="#1-士大夫与宦官的冲突" class="headerlink" title="1. 士大夫与宦官的冲突"></a>1. 士大夫与宦官的冲突</h4><p>《后汉书 党锢列传》</p>
<blockquote>
<p><em>东汉士大夫以气节相尚，故各奋死与之拄；<strong>虽湛宗灭族，有不顾焉</strong>。至唐则仅有一刘对策。</em> ——《汉末诸臣劾治宦官》</p>
</blockquote>
<p>东汉士气最盛</p>
<h4 id="2-桓帝第一次党锢"><a href="#2-桓帝第一次党锢" class="headerlink" title="2. 桓帝第一次党锢"></a>2. 桓帝第一次党锢</h4><p>《后汉书 党锢列传》</p>
<h4 id="3-灵帝第二次党锢"><a href="#3-灵帝第二次党锢" class="headerlink" title="3. 灵帝第二次党锢"></a>3. 灵帝第二次党锢</h4><h3 id="三-士族的崛起"><a href="#三、士族的崛起" class="headerlink" title="三、士族的崛起"></a>三、士族的崛起</h3><blockquote>
<p><em>在西汉末叶，士人已不再是无根的“游士”，而是具有深厚社会基础的“<strong>士大夫</strong>”了。……士人的背后已附随了整个的宗族，士与宗族的结合，便产生了中国历史上著名的“<strong>士族</strong>”。</em> ——余英时《东汉政权建立与士族大姓之关系》</p>
</blockquote>
<p>《中国思想通史》</p>
<h4 id="东汉的三种世家"><a href="#东汉的三种世家" class="headerlink" title="东汉的三种世家"></a>东汉的三种世家</h4><ul>
<li>【官僚世家】 <strong>秦汉</strong>“选贤举能”，但也保证官僚特权。如二千石可任子弟一人为郎。一些家族世代居官，由此建立了族望、形成官族。如“家世二千石”之类。</li>
<li>【豪强世家】 拥有大田庄、大宗族和大量依附民的豪强世家，<strong>在东汉不断发展</strong>。其子弟往往在本地做官。</li>
<li>【文化世家】 <strong>东汉</strong>出现了很多经学世家和名士家族。</li>
</ul>
<p><strong>士家门阀，就是士人家族、豪强家族和官僚家族的三位一体。</strong></p>
<p><strong>累世传经；累世三公</strong></p>
<p>战国士人-&gt;汉代儒生-&gt;汉末名士-&gt;魏晋士族</p>
<blockquote>
<p><em>东汉末年，大姓、名士处于左右政局的重要地位。他们在经济上、政治上广泛地控制了农村，文化上几乎出于垄断地位。东汉王超瓦解后，他们是各个割据政权的骨干，三国政权的上层统治这主要也是从老一代到年轻一代的大姓名士中选拔出来的。他们是构成魏晋士族的基础。</em> ——唐长孺</p>
</blockquote>
<h3 id="四-黄巾起义与军阀割据"><a href="#四、黄巾起义与军阀割据" class="headerlink" title="四、黄巾起义与军阀割据"></a>四、黄巾起义与军阀割据</h3><h4 id="1-灭亡预期与取代预期"><a href="#1-灭亡预期与取代预期" class="headerlink" title="1. 灭亡预期与取代预期"></a>1. 灭亡预期与取代预期</h4><h4 id="2-从黄巾起义到军阀割据"><a href="#2-从黄巾起义到军阀割据" class="headerlink" title="2. 从黄巾起义到军阀割据"></a>2. 从黄巾起义到军阀割据</h4><hr>
<h1 id="魏晋南北朝"><a href="#魏晋南北朝" class="headerlink" title="魏晋南北朝"></a>魏晋南北朝</h1><h2 id="第一讲-帝国的分裂和脆弱的统一"><a href="#第一讲-帝国的分裂和脆弱的统一" class="headerlink" title="第一讲 帝国的分裂和脆弱的统一"></a>第一讲 帝国的分裂和脆弱的统一</h2><h3 id="一-曹操崛起与三国鼎立"><a href="#一、曹操崛起与三国鼎立" class="headerlink" title="一、曹操崛起与三国鼎立"></a>一、曹操崛起与三国鼎立</h3><h4 id="1-曹操的崛起"><a href="#1-曹操的崛起" class="headerlink" title="1. 曹操的崛起"></a>1. 曹操的崛起</h4><p>乞丐携养？赘阉遗丑？</p>
<p>迎纳献帝</p>
<p>屯田许下</p>
<h4 id="2-三国鼎立的形成"><a href="#2-三国鼎立的形成" class="headerlink" title="2. 三国鼎立的形成"></a>2. 三国鼎立的形成</h4><ul>
<li>200年官渡之战，曹操击败袁绍，中原统一</li>
<li>208年赤壁之战，决定了南北对峙的局面</li>
<li>211年刘备取益州，蜀国奠基</li>
<li>219年刘备夺汉中</li>
<li>219年关羽攻樊城</li>
<li>219年吕蒙袭取江陵，三国鼎立局面形成</li>
</ul>
<p>三国鼎立的原因</p>
<ul>
<li><p>地理形势造成了三国的相对隔离</p>
<blockquote>
<p>嗟乎，固天之所以隔南北也！ ——曹丕</p>
</blockquote>
</li>
<li><p>经济发展为蜀吴政权提供了自给条件</p>
</li>
<li><p>汉末军阀混战一度破坏了北方经济</p>
</li>
</ul>
<p>《曹操论集》</p>
<blockquote>
<p><em>创业之君兼擅文学，曹魏父子，固已旷绝百代。</em> ——赵翼</p>
</blockquote>
<h4 id="3-司马氏代魏"><a href="#3-司马氏代魏" class="headerlink" title="3. 司马氏代魏"></a>3. 司马氏代魏</h4><p>司马氏坐家门</p>
<h3 id="二-诸葛亮治蜀"><a href="#二、诸葛亮治蜀" class="headerlink" title="二、诸葛亮治蜀"></a>二、诸葛亮治蜀</h3><h4 id="1-隆中对"><a href="#1-隆中对" class="headerlink" title="1. 隆中对"></a>1. 隆中对</h4><ul>
<li>跨有荆益</li>
<li>联吴抗曹</li>
</ul>
<p>《隆中对的再认识》</p>
<h4 id="2-诸葛亮治蜀"><a href="#2-诸葛亮治蜀" class="headerlink" title="2. 诸葛亮治蜀"></a>2. 诸葛亮治蜀</h4><p>人员构成</p>
<ul>
<li>刘备旧部：大量荆楚人士，构成政权中坚。“豫州入蜀，荆楚人贵”</li>
<li>益州土著：有拉有打。“芳兰生门，不得不除”</li>
<li>刘璋旧部：努力拉拢。对争权者并不客气。</li>
</ul>
<blockquote>
<p><em>对争权夺利者，诸葛亮并不客气。如南阳人李严，继董和之后称为“旧人”即刘璋旧部的代表。诸葛亮北伐时曾罢免李严。诸、李之争有深刻的派系斗争背景</em>  ——田余庆《李严兴废与诸葛用人》</p>
</blockquote>
<h4 id="3-诸葛亮北伐"><a href="#3-诸葛亮北伐" class="headerlink" title="3. 诸葛亮北伐"></a>3. 诸葛亮北伐</h4><p><strong>汉贼不两立，王业不偏安。</strong></p>
<blockquote>
<p><em>然亮才，于治<strong>戎为长，奇谋为短，理民之干，优于将略</strong>。而所与对敌，或值人杰，加众寡不侔，攻守异体，故虽连年动众，未能有克。昔萧何荐韩信，管仲举王子城父，皆忖己之长，未能兼有故也。</em> ——陈寿《三国志》</p>
</blockquote>
<h3 id="三-孙氏政权与江东士族"><a href="#三、孙氏政权与江东士族" class="headerlink" title="三、孙氏政权与江东士族"></a>三、孙氏政权与江东士族</h3><h4 id="1-政权构成及江东化问题"><a href="#1-政权构成及“江东化”问题" class="headerlink" title="1. 政权构成及“江东化”问题"></a>1. 政权构成及“江东化”问题</h4><p>孙氏本是江东人，但其早期支持者如庐江周瑜、临淮鲁肃、汝南吕蒙、南阳诸葛瑾等，都是<strong>皖北大族</strong>，或称<strong>淮泗势力</strong>。江东本土士族，以<strong>吴郡朱、张、顾、陆</strong>为首。</p>
<blockquote>
<p><em>孙坚早年离开江东，返归后一度与江东士族对立，“平定吴会，诛其英豪”。孙策、孙权也杀了不少当地名流。但随时间推移，孙吴开始了<strong>“江东化”</strong>进程。</em> ——田余庆</p>
</blockquote>
<p><strong>暨艳案</strong>：孙吴江东化过程中，曾发生暨艳案。他在江东士族子弟纷纷入仕时，激浊扬清，惩处贪鄙卑污者，遭到了孙权的严惩。</p>
<p>一、扶持拥戴者——政治忠诚；二、行政能力</p>
<h3 id="四-西晋的短期统一和灭亡很重要"><a href="#四、西晋的短期统一和灭亡——很重要" class="headerlink" title="四、西晋的短期统一和灭亡——很重要"></a>四、西晋的短期统一和灭亡——很重要</h3><p><strong>“低质量的统一”</strong></p>
<h4 id="1-士族崛起和政治萎靡"><a href="#1-士族崛起和政治萎靡" class="headerlink" title="1. 士族崛起和政治萎靡"></a>1. 士族崛起和政治萎靡</h4><h4 id="注意社会形态与历史分析的背景"><a href="#注意社会形态与历史分析的背景" class="headerlink" title="注意社会形态与历史分析的背景"></a>注意社会形态与历史分析的背景</h4><p>户口减少，自由小农变成私家佃农-&gt; 马克思学者：封建化</p>
<p><strong>魏晋封建论</strong>（西周封建论、战国封建论、魏晋封建论）：何兹全、王仲荤、唐长孺</p>
<p>内藤湖南的<strong>现代史学分析</strong>（算是开风气之先，影响越来越深）：古代社会—六朝贵族制—“东洋的近世”</p>
<blockquote>
<p><em>六朝至唐中叶，是贵族政治最盛的时代……这个时期的贵族制度，并不是天子赐予人民领土，而是由地方有名望的家族长期自然相续，从这种关系中产生世家，亦就是郡望的本体……君主是贵族的共有物。</em> ——《概括的唐宋时代观》</p>
</blockquote>
<p>谷川道雄：“豪族共同体”和“非封建的中世”</p>
<p>历史分析的总结</p>
<ul>
<li>魏晋封建论模式</li>
<li>六朝贵族论模式</li>
<li>变态——回归模式  田余庆《东晋文化政治》<ul>
<li>士族是官僚、士人阶层与宗族的结合。士族是贵族化和士人化的官僚。</li>
<li>汉代处历史早期，官僚政治尚不成熟，由此在魏晋以下出现士族政治。</li>
<li><strong>门阀政治是皇权政治的“变态”</strong>，来自皇权统治，最终将“回归”皇权政治。对士族特殊性不应过分强调。</li>
</ul>
</li>
</ul>
<p>东汉以来不断发展的士族阶层，在魏晋间获得了重大政治权势。中国官僚政治进入【士族政治】时代。</p>
<p><strong>改良而非革命</strong>：魏晋易代用“禅让”，未经战火充分洗礼，<strong>未能彻底扫除前朝政府而另起炉灶</strong>。西晋统治集团成员依然是曹魏那批高官显达及其子弟，他们所积累的<strong>腐化、老化、贵族化</strong>的因素，几乎原封不动带入了西晋朝廷（并非新世、而是末世）。王朝对他们无法绳之以法，只能优容甚至纵容，以换取支持。（王朝循环的规律在魏晋时代的表现）</p>
<p>因此，西晋统治集团一开始就异常贪婪、奢侈、腐败、残暴，和汉初、魏初的统治集团有所不同。</p>
<h4 id="2-八王之乱"><a href="#2-八王之乱" class="headerlink" title="2. 八王之乱"></a>2. 八王之乱</h4><p>《晋书八王列传》</p>
<p>专制帝王 首先看<strong>秦</strong>；西晋大肆封王与专制帝王不同，以下为部分原因</p>
<blockquote>
<p><em>在贵族政权之下，皇室作为第一家族凌驾于其他家族之上，皇帝作为<strong>第一家族的代表</strong>君临天下，其家族成员有资格也有必要取得更大权势以<strong>保持其优越地位</strong>。</em> ——唐长孺</p>
<p><strong>魏削宗室而权臣篡，晋封同姓而骨肉残</strong>——王夫之</p>
</blockquote>
<h3 id="本讲阅读书籍"><a href="#本讲阅读书籍-7" class="headerlink" title="本讲阅读书籍"></a>本讲阅读书籍</h3><p>《秦汉魏晋史探微》</p>
<hr>
<h2 id="第二讲-江左士族门阀政治"><a href="#第二讲-江左士族门阀政治" class="headerlink" title="第二讲 江左士族门阀政治"></a>第二讲 江左士族门阀政治</h2><p>五胡入主中原</p>
<h3 id="一-东晋的立国"><a href="#一、东晋的立国" class="headerlink" title="一、东晋的立国"></a>一、东晋的立国</h3><p><strong>开创江左五朝之局，维系不绝如缕的中华种族文化。</strong></p>
<h4 id="1-永嘉南渡与王导经营"><a href="#1-永嘉南渡与王导经营" class="headerlink" title="1. 永嘉南渡与王导经营"></a>1. 永嘉南渡与王导经营</h4><ul>
<li>向见管夷吾，无复忧也。</li>
<li>王导：当共勠力王室，克复神州，何至作楚囚相对泣邪！</li>
</ul>
<h4 id="2-皇帝垂拱-门阀专权-流民御边"><a href="#2-皇帝垂拱-门阀专权-流民御边" class="headerlink" title="2. 皇帝垂拱 门阀专权 流民御边"></a>2. 皇帝垂拱 门阀专权 流民御边</h4><p><strong>王与马，共天下</strong></p>
<ul>
<li>王鸣盛：《王导传》一篇凡六千余字，殊多溢美，要之看似煌煌一代名臣，<strong>其实井无一事</strong>，徒有门阀显荣，子孙官秩而已。</li>
<li>陈寅恪：王导之笼络江东士族，统一内部，结合南人北人两种实力，以抵抗外侮，民族得以独立，文化因得以续延。不谓<strong>民族之功臣</strong>，似非平情之论。</li>
</ul>
<p>三定江南</p>
<p>最初江东士族并不接纳东晋政权，接纳有一个过程</p>
<p>“门阀政治”指“<strong>门阀与皇权的共治</strong>”，是相对于<strong>皇权政治</strong>而言的，<strong>只存在于东晋一朝</strong>。</p>
<p>“士族政治”指<strong>门阀的政治社会特权</strong>，是相对于<strong>官僚政治</strong>而言的，<strong>存在于整个魏晋南北朝</strong>。</p>
<ul>
<li>皇帝垂拱：朝权国命，递归台辅（执政的士族门阀）；君道虽存，主威久谢。</li>
<li>门阀当权：两大层次，侨姓（北来） 吴姓</li>
<li>流民御边：利用流民武装捍卫江淮</li>
</ul>
<h4 id="专制君权-贵族-官僚关系的论述"><a href="#专制君权、贵族、官僚关系的论述" class="headerlink" title="专制君权、贵族、官僚关系的论述"></a>专制君权、贵族、官僚关系的论述</h4><p>三个类似的看法</p>
<blockquote>
<p>【梁启超】贵族政治虽平民政治之蟊贼，然亦<strong>君主专制之悍敌</strong>也。试政诸西史，国民议会之制度殆无不由贵族起。 ——《中国专制政治进化史论》</p>
<p>【培根】一个完全没有贵族的君主国，总是一个纯粹而极端的专制国，土耳其是也。因为贵族是<strong>调剂君权</strong>的，贵族把人民的眼光引开，使其多少离开皇室。 ——《培根论说文集》</p>
<p>【孟德斯鸠】在没有贵族的君主国，君主将成为暴君。 ——《论法的精神》</p>
</blockquote>
<h3 id="二-东晋的内乱和北伐"><a href="#二、东晋的内乱和北伐" class="headerlink" title="二、东晋的内乱和北伐"></a>二、东晋的内乱和北伐</h3><h4 id="1-东晋的内乱"><a href="#1-东晋的内乱" class="headerlink" title="1. 东晋的内乱"></a>1. 东晋的内乱</h4><ul>
<li>吴姓士族作乱<ul>
<li>周 “杀我者，诸伧子”</li>
<li>周姓服从侨姓</li>
</ul>
</li>
<li>王敦叛乱</li>
<li>祖约苏峻之乱——农民武装</li>
<li>桓氏之乱<ul>
<li>桓温：少有豪迈风气。“木犹如此，人何以堪”；求加九锡</li>
<li>桓玄：“父为九州伯，子为五湖长”</li>
</ul>
</li>
<li>孙恩卢循之论——下层民众借用宗教</li>
</ul>
<h4 id="2-东晋的北伐和北防"><a href="#2-东晋的北伐和北防" class="headerlink" title="2. 东晋的北伐和北防"></a>2. 东晋的北伐和北防</h4><ul>
<li><p>元帝时期：<strong>祖逖北伐</strong> 农民武装；黄河以南，尽为晋土</p>
</li>
<li><p>康帝、穆帝时期：失败</p>
</li>
<li><p>穆帝、哀帝、废帝时期：<strong>桓温三次北伐</strong>，一度收复洛阳，最后一次惨败</p>
</li>
<li><p>淝水之战：东晋政权转危为安</p>
<blockquote>
<p>（谢）玄等既破坚，有驿书至，（谢）安方对客围棋。看书既竟，便摄放床，了无喜色，棋如故。客问之，徐答云：“小儿辈遂已破贼。”既罢还内，过户限，心喜甚，不觉屐齿之折。</p>
</blockquote>
</li>
</ul>
<p>东晋门阀很有活力，但北伐难以取胜：北方五胡强悍+东晋内部矛盾深刻</p>
<p>但是北伐有其政治意义甚至政权正统性的意义</p>
<blockquote>
<p><em>南朝士大夫对于皇室禅代无动于衷，而对南方政权据守江南，与北方胡族政权相对峙，即<strong>保存汉族之正朔</strong>一事，则极为重视。</em> ——周一良</p>
</blockquote>
<h3 id="三-江左的门阀士族"><a href="#三、江左的门阀士族" class="headerlink" title="三、江左的门阀士族"></a>三、江左的门阀士族</h3><p><strong>先秦士人 -&gt; 两汉儒生 -&gt; 东汉名士 -&gt; 中古士族</strong> 故士族主要是文化士族</p>
<h4 id="1-士族的文化性格注意与中古西欧贵族的对比"><a href="#1-士族的文化性格——注意与中古西欧贵族的对比" class="headerlink" title="1. 士族的文化性格——注意与中古西欧贵族的对比"></a>1. 士族的文化性格——注意与中古西欧贵族的对比</h4><ul>
<li>东汉士族的继续发展</li>
<li>文教的普遍破坏造成的学在家族</li>
<li>政治动荡导致的政治集团封闭化</li>
<li>禅让式王朝更迭促进权势传承</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>朝代</th>
<th>国家形态</th>
<th>官僚政治组成</th>
</tr>
</thead>
<tbody>
<tr>
<td>周代</td>
<td>早期国家</td>
<td>传统贵族</td>
</tr>
<tr>
<td>秦汉</td>
<td>中央集权官僚帝国</td>
<td>文法吏 儒生</td>
</tr>
<tr>
<td>魏晋南北朝</td>
<td>—-</td>
<td>士族门阀</td>
</tr>
<tr>
<td>唐 宋 明 清</td>
<td>—-</td>
<td>科举官僚</td>
</tr>
</tbody>
</table>
</div>
<h5 id="由儒入玄"><a href="#由儒入玄" class="headerlink" title="由儒入玄"></a><strong>由儒入玄</strong></h5><p>正始名士-&gt; 竹林名士 -&gt; 中朝名士 -&gt; 江左八达</p>
<p>形成原因的一个说法</p>
<blockquote>
<p>两晋时期，儒学家族如果不入玄风，就产生不了为世所知的名士，从而也不能继续维持其尊显的士族地位。东晋执政的门阀士族，其家族在什么时候、以何人为代表、在多大程度上由儒入玄，史籍都斑斑可考。 ——田余庆</p>
</blockquote>
<h4 id="2-士族的选官特权"><a href="#2-士族的选官特权" class="headerlink" title="2. 士族的选官特权"></a>2. 士族的选官特权</h4><p><strong>魏晋王朝权贵势力一脉相承</strong>。士族世代高位，官僚身份化。 “平流进取，坐致公卿”</p>
<blockquote>
<p><em>周汉之道,<strong>以智役愚</strong>;台隶参差,用成等级。魏晋以来,<strong>以贵役贱</strong>,士庶之科,较然有辨。</em></p>
</blockquote>
<h4 id="3-士族的门第婚"><a href="#3-士族的门第婚" class="headerlink" title="3. 士族的门第婚"></a>3. 士族的门第婚</h4><p>侨姓士族联姻</p>
<p>吴姓士族联姻</p>
<p>侨姓吴姓之间很少通婚</p>
<h4 id="4-谱学和郡望"><a href="#4-谱学和郡望" class="headerlink" title="4. 谱学和郡望"></a>4. 谱学和郡望</h4><p>家谱是选官重要的参考文献</p>
<h4 id="5-士庶之辨"><a href="#5-士庶之辨" class="headerlink" title="5. 士庶之辨"></a>5. 士庶之辨</h4><p><strong>士庶之际，实自天隔</strong></p>
<p>中古时代的社会风貌</p>
<hr>
<h2 id="第三讲-南朝政治-皇权复兴与政治僵局-33-34"><a href="#第三讲-南朝政治-皇权复兴与政治僵局-33-34" class="headerlink" title="第三讲 南朝政治 皇权复兴与政治僵局 33 34"></a>第三讲 南朝政治 皇权复兴与政治僵局 33 34</h2><h3 id="一-北府兵与刘裕代晋"><a href="#一、北府兵与刘裕代晋" class="headerlink" title="一、北府兵与刘裕代晋"></a>一、北府兵与刘裕代晋</h3><h4 id="1-刘裕与北府兵"><a href="#1-刘裕与北府兵" class="headerlink" title="1. 刘裕与北府兵"></a>1. 刘裕与北府兵</h4><p>西晋以广陵在洛阳之东，故设东中郎将镇守。东晋元帝以琅琊王舒为北中郎将镇广陵，因广陵在建康以北，故以“北”为号，称为“<strong>北府</strong>”。</p>
<p>北府统帅非侨姓门阀不能染指，京口人多劲悍。</p>
<h4 id="2-刘裕代晋与皇权的重振"><a href="#2-刘裕代晋与皇权的重振" class="headerlink" title="2. 刘裕代晋与皇权的重振"></a>2. 刘裕代晋与皇权的重振</h4><ul>
<li>409年伐南燕、破广固，擒慕容超，斩于建康</li>
<li>410年破卢循</li>
<li>412年朱龄石平蜀</li>
<li>216年伐后秦，收复洛阳、长安，后秦主姚泓出降</li>
</ul>
<p>东晋一朝大事，几乎都与<strong>流民群</strong>有直接的或间接的关系……而刘裕的成功终归也是靠<strong>京口流民</strong>的力量。</p>
<h4 id="3-元嘉之治及其终结"><a href="#3-元嘉之治及其终结" class="headerlink" title="3. 元嘉之治及其终结"></a>3. 元嘉之治及其终结</h4><p>宋文帝元嘉二十七年北伐失利</p>
<p>宋失淮北</p>
<h3 id="二-宋齐的皇权"><a href="#二、宋齐的皇权" class="headerlink" title="二、宋齐的皇权"></a>二、宋齐的皇权</h3><p>南朝的皇权复兴。</p>
<blockquote>
<p><em>孝建（宋孝武帝）、泰始（宋明帝），主威独运，官置百司，<strong>权不外假</strong>。</em> ——《宋书》</p>
</blockquote>
<p><strong>南朝的皇权复兴</strong>：严格意义上的门阀政治是确定不移地一去不复返了</p>
<h4 id="1-武将执兵柄"><a href="#1-武将执兵柄" class="headerlink" title="1. 武将执兵柄"></a>1. 武将执兵柄</h4><p>赵翼论“<strong>江左世族无功臣</strong>“</p>
<p>南朝寒门武将驰骋疆埸(yi)、捍卫国风，发挥了重大作用。但士族重文轻武的风尚，对武将从政依旧是沉重的压抑。南朝将才日益匮乏……</p>
<h4 id="2-寒门掌机要"><a href="#2-寒门掌机要" class="headerlink" title="2. 寒门掌机要"></a>2. 寒门掌机要</h4><p>宋齐中书省有中书通事舍人四员，各任一省。地居机要，人近天子，<strong>官品虽卑，权势颇重</strong>。</p>
<blockquote>
<p><em>其时高门大族，门户已成，令仆三司，可安流平进，<strong>不屑竭智尽心</strong>，以邀恩宠。且风流相尚，罕以物务关怀，人主遂不能借以集事。于是不得不用寒人。<strong>人寒则希荣切，而宣力勤</strong>，便于驱策，不觉倚之为心腹。</em> ——《南朝多以寒门掌机要》</p>
</blockquote>
<p>此时仍被称为“寒门”——士族门阀的社会观念仍然在压抑着他们</p>
<h4 id="3-皇子镇要藩"><a href="#3-皇子镇要藩" class="headerlink" title="3. 皇子镇要藩"></a>3. 皇子镇要藩</h4><p>南朝皇子以皇子封王，镇守荆、扬、徐、江、雍等要藩，始自刘裕。</p>
<p>门阀政治下，<strong>微弱的皇权孽生不了</strong>那种必须依附于皇权而行专擅的宦官、外戚、宗室，孽生了也难以长期起重要作用。动乱的根源却较易来自士族中的权臣。</p>
<h4 id="4-宗室政治与皇室相残"><a href="#4-宗室政治与皇室相残" class="headerlink" title="4. 宗室政治与皇室相残"></a>4. 宗室政治与皇室相残</h4><p>皇权重振后即扶持宗室，诸王再次成为政坛主角。这类似西晋，但很不同于东晋门阀政治。</p>
<p>高级官职人选的变化，显示士族与宗戚势力<strong>互为消长</strong>。</p>
<p>宗室相残，说明皇权仍不稳定。</p>
<ul>
<li>宋齐多荒主</li>
<li>宋世闺门无礼</li>
<li>宋子孙屠戮之惨</li>
<li>齐明帝杀子孙</li>
</ul>
<h3 id="三-梁武帝其人"><a href="#三、梁武帝其人" class="headerlink" title="三、梁武帝其人"></a>三、梁武帝其人</h3><p>周一良《论梁武帝及其时代》</p>
<p><strong>梁武帝</strong> 在位502-549</p>
<h4 id="1-梁武帝前期政绩"><a href="#1-梁武帝前期政绩" class="headerlink" title="1. 梁武帝前期政绩"></a>1. 梁武帝前期政绩</h4><ul>
<li>鼓励农耕，减免租调</li>
<li>用人不限高门，兼用“寒士”（士族中地位比较低的，与“寒门”有区别），以扩大统治基础</li>
<li>编成《梁律》《梁令》《梁科》《五礼》</li>
<li>“军事才能不在刘裕、萧道成、陈霸先之下”</li>
<li>著《群经讲疏》 文集… 主编《通史》…</li>
<li>生活简朴、不好声色</li>
</ul>
<p>“陛下为法，<strong>急于黎庶，缓于权贵</strong>。“</p>
<blockquote>
<p>罔恤民之不存，而忧士之不禄……</p>
</blockquote>
<h4 id="2-梁武帝之宽纵与佞佛"><a href="#2-梁武帝之宽纵与佞佛" class="headerlink" title="2. 梁武帝之宽纵与佞佛"></a>2. 梁武帝之宽纵与佞佛</h4><ul>
<li>天监三年(504) 宣布由道入佛</li>
<li>大通元年(527)舍身于同泰寺</li>
<li>中大通元年(529)舍身，公卿以钱一亿万奉赎（给他赎身）</li>
<li>太清元年(549)舍身，公卿以钱一亿万奉赎</li>
</ul>
<blockquote>
<p><em>大经中说道有九十六种，<strong>唯佛一道，是于正道</strong>；其余九十五种，名为邪道。朕舍邪外，以事正内，诸佛如来！</em></p>
</blockquote>
<h4 id="3-梁武帝北伐"><a href="#3-梁武帝北伐" class="headerlink" title="3. 梁武帝北伐"></a>3. 梁武帝北伐</h4><h4 id="4-侯景之乱"><a href="#4-侯景之乱" class="headerlink" title="4. 侯景之乱"></a>4. 侯景之乱</h4><h4 id="梁武帝之评价"><a href="#梁武帝之评价" class="headerlink" title="梁武帝之评价"></a>梁武帝之评价</h4><p>统治特征</p>
<ul>
<li>调和内部矛盾，是高门、寒士、旧族等各种势力利益均沾</li>
<li>通过玄佛文史、制礼作乐粉饰太平</li>
</ul>
<p>【庾信】天子方删诗书、定礼乐，设重云之讲，开士林之学……宰衡以干戈为儿戏，搢绅以清谈为庙略。</p>
<p>【王夫之】梁武帝之始立也，惩齐政之鄙固，而崇虚文以靡天下之士，尚宽弛以佚天下之民，垂四十年，而国政日以偷废。</p>
<h3 id="四-南朝的没落"><a href="#四、南朝的没落" class="headerlink" title="四、南朝的没落"></a>四、南朝的没落</h3><p>侯景之乱后的变化</p>
<h4 id="1-土豪酋帅的崛起"><a href="#1-土豪酋帅的崛起" class="headerlink" title="1. 土豪酋帅的崛起"></a>1. 土豪酋帅的崛起</h4><h4 id="2-南朝的没落"><a href="#2-南朝的没落" class="headerlink" title="2. 南朝的没落"></a>2. 南朝的没落</h4><ul>
<li>士族门阀衰而不僵，其传统权势与文化风尚依然阻碍着政治变革</li>
<li>寒人与武将被文化士族压抑，难以形成新兴政治力量</li>
<li>吴姓士族地位上升，酋帅土豪参与政治角逐，但其政治号召力是很有限的</li>
</ul>
<p>汉人剽悍进取，崇尚骑马驾马；中古流行牛车，悠闲缓慢。</p>
<hr>
<h2 id="第四讲-民族冲突中的十六国更迭-35-36"><a href="#第四讲-民族冲突中的十六国更迭-35-36" class="headerlink" title="第四讲 民族冲突中的十六国更迭 35 36"></a>第四讲 民族冲突中的十六国更迭 35 36</h2><h3 id="一-北方少数族的内徙"><a href="#一、北方少数族的内徙" class="headerlink" title="一、北方少数族的内徙"></a>一、北方少数族的内徙</h3><h4 id="1-少数族内徙"><a href="#1-少数族内徙" class="headerlink" title="1. 少数族内徙"></a>1. 少数族内徙</h4><h4 id="2-徙戎论"><a href="#2-徙戎论" class="headerlink" title="2. 徙戎论"></a>2. 徙戎论</h4><hr>
<h1 id="隋唐"><a href="#隋唐" class="headerlink" title="隋唐"></a>隋唐</h1><h2 id="第一讲-隋朝大一统帝国的建立"><a href="#第一讲-隋朝：大一统帝国的建立" class="headerlink" title="第一讲 隋朝：大一统帝国的建立"></a>第一讲 隋朝：大一统帝国的建立</h2><h3 id="1杨隋代周"><a href="#1-杨隋代周" class="headerlink" title="1.杨隋代周"></a>1.杨隋代周</h3><p>杨丽华… 隋文帝杨坚逼帝退位</p>
<p>杨坚继承父亲杨忠的爵位“隨国公”，故王朝称为“隋朝”</p>
<blockquote>
<p><em>古来得天下之易，未有如隋文帝者。</em> ——《廿二史札记》</p>
</blockquote>
<p>后人对隋文帝的评价：性至察而心不明。</p>
<blockquote>
<p><em>以立法而施及唐宋，盖<strong>隋亡而法不亡</strong>也。若置仓，递运之类也。</em></p>
</blockquote>
<h4 id="关陇集团"><a href="#关陇集团" class="headerlink" title="关陇集团"></a>关陇集团</h4><p>关系紧密的胡汉/文武混合集团，实际上是一个<strong>军事贵族集团</strong>。（西魏-北周-隋-唐）</p>
<p><strong>关中本位政策</strong></p>
<blockquote>
<p><em>帝国的继承和创建，在当时不过是一次宫廷政变，是西北的一个贵族家族接替另一个家族即位。</em> ——《剑桥中国隋唐史》</p>
</blockquote>
<p>这个只是表现了当时的人事变动</p>
<blockquote>
<p><em>本来政治应该分为两方面来讲：一是讲人事，一是讲制度。</em> ——钱穆</p>
</blockquote>
<p>所以探索的核心问题：<strong>婚与宦</strong>；哪一部分势力起主导的作用</p>
<h4 id="隋朝建立后颁布的重要政令制度"><a href="#隋朝建立后颁布的重要政令（制度）" class="headerlink" title="隋朝建立后颁布的重要政令（制度）"></a>隋朝建立后颁布的重要政令（制度）</h4><ul>
<li>令宇文泰时改为鲜卑姓氏的汉人文武大臣，恢复原来的姓氏。</li>
<li>废除北周“六官制度”，复行魏晋官制。</li>
</ul>
<h4 id="历史意义"><a href="#历史意义" class="headerlink" title="历史意义"></a>历史意义</h4><p>杨隋代周，实际上建立了以<strong>关陇集团汉人贵族</strong>为本位的新政权。尽管这些汉人贵族往往具有双重血统，但他们却自我标举为<strong>中原汉文化的代表</strong>。</p>
<p>隋朝的制度改革为后来的大一统做了准备。</p>
<h3 id="2-隋朝前期政治经济措施"><a href="#2-隋朝前期政治经济措施" class="headerlink" title="2. 隋朝前期政治经济措施"></a>2. 隋朝前期政治经济措施</h3><p>隋朝：从研究魏晋南北朝的角度说，<em>魏晋南北朝的“历史出口”</em>；从隋唐史的角度，<em>隋唐这样新时代的历史入口</em>。</p>
<h4 id="政治制度的整理和更革"><a href="#政治制度的整理和更革" class="headerlink" title="政治制度的整理和更革"></a>政治制度的整理和更革</h4><ul>
<li><p>中央制度：<strong>三省六部制</strong></p>
</li>
<li><p>地方制度：如何有效地中央控制地方；</p>
<blockquote>
<p><em>当今郡县，<strong>倍多于古</strong>。或地无百里，数县并置。或户不满千，二郡分领。</em> ——《隋书·杨尚希传》</p>
<p><em>民少官多，十羊九牧。</em></p>
</blockquote>
<p>侨置州郡县；</p>
<p>| 时代     | 州                   | 郡（国）   | 县     |<br>| ———— | —————————— | ————— | ——— |<br>| 秦       |                      | 48         | 1000多 |<br>| 汉       | 13、14               | 约100      | 1500多 |<br>| 西晋     | 19                   | 172        | 1232   |<br>| 北周、陈 | 263                  | 617        | 1562   |<br>| 隋文帝时 | 300多                | <strong>去掉郡</strong> | 约1500 |<br>| 隋炀帝时 | <strong>把州的名字改为郡</strong> | 190        | 1255   |</p>
<p>隋代改地方行政三级制为二级制，唐代又出现向三级制回归的倾向。</p>
<p><strong>地方佐官</strong>：长官辟属协助办事的官僚</p>
<blockquote>
<p><em>往者诸州唯置纲纪，郡置守丞，县唯令而已。其所具僚，则长官自辟。受诏赴任，每州不过数十。今则不然，<strong>大小之官悉由吏部，纤介之迹皆属考功</strong>，其繁二也。</em> ——《隋书》</p>
</blockquote>
<p>不靠武力、战功升迁</p>
</li>
</ul>
<h4 id="经济政策大索貌阅与输籍之法"><a href="#经济政策-“大索貌阅”与“输籍之法”" class="headerlink" title="经济政策:“大索貌阅”与“输籍之法”"></a>经济政策:“大索貌阅”与“输籍之法”</h4><p>经济政策与政治需求不可分割</p>
<p>国家财政来源：<strong>赋税</strong>-&gt;户口，落实在人丁上 、<strong>征役</strong></p>
<p>“<strong>大索貌阅</strong>”是一种较为严格的户口清查制度；貌阅：户口清查方式，看面貌</p>
<blockquote>
<p><em>是时山东尚承齐俗，机巧奸伪，避役惰游者十六七。四方疲人或<strong>诈老诈小</strong>，规免租赋。</em> ——《隋书》</p>
</blockquote>
<p>为了减少诈老诈小的现象</p>
<p><strong>输籍之法</strong>：让基层了解经济政策</p>
<h3 id="3-大一统格局的形成"><a href="#3-大一统格局的形成" class="headerlink" title="3. 大一统格局的形成"></a>3. 大一统格局的形成</h3><p>理解中国古代史的方法：</p>
<ul>
<li>学习朝代史</li>
<li>有长时段的关怀</li>
</ul>
<p>《地中海与菲利普二世时代的地中海世界》 <strong>整体史观</strong>、<strong>年鉴学派</strong></p>
<h4 id="南北统一的深层原因"><a href="#南北统一的深层原因" class="headerlink" title="南北统一的深层原因"></a>南北统一的深层原因</h4><p>南北的再统一是民族斗争与民族融合的结果。</p>
<blockquote>
<p><em>时佗钵控弦数十万，中国惮之，周、齐争结姻好，倾府藏以事之。佗钵益骄，每谓其下曰：「我在南两儿常孝顺，何患贫也！」</em> ——《隋书》</p>
</blockquote>
<p>隋代原则：远交近攻</p>
<p><strong>制度因素</strong></p>
<p><strong>观念因素</strong></p>
<blockquote>
<p><em>居天下之正，<strong>合天下于一</strong>。</em> ——欧阳修《正统论》</p>
</blockquote>
<p>问鼎-&gt;逐鹿-&gt;统一</p>
<p><strong>文化因素</strong></p>
<blockquote>
<p><em>东海西海，心理攸同。南学北学，道术未裂。</em> ——钱锺书</p>
<p><em>只有野蛮人才能使一个在垂死的文明中挣扎的世界年轻起来。</em> ——恩格斯</p>
</blockquote>
<h4 id="鼎盛局面的形成"><a href="#鼎盛局面的形成" class="headerlink" title="鼎盛局面的形成"></a>鼎盛局面的形成</h4><p>富——三方面</p>
<ul>
<li>表现：仓库盈积、户口增殖（国家可以统计这么多人，国家对于户口的控制力加强）</li>
<li>途径</li>
<li>影响：四海百姓，衣食不丰（国富民贫）</li>
</ul>
<p>隋炀帝杨广：志包宇宙；威振殊俗</p>
<h3 id="4-大运河的开通及其历史意义"><a href="#4-大运河的开通及其历史意义" class="headerlink" title="4. 大运河的开通及其历史意义"></a>4. 大运河的开通及其历史意义</h3><h4 id="沟通南北"><a href="#沟通南北" class="headerlink" title="沟通南北"></a>沟通南北</h4><p>大运河的开凿以洛阳为中心，向南北呈辐射状。</p>
<p>大运河真正把中国两大流域——黄河流域、长江流域密切联系起来。</p>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><blockquote>
<p><em>炀帝此举，为其国促数年之祚，而为后世开万世之利，可谓不仁而有功者矣。</em> ——《行水金鉴》</p>
</blockquote>
<p>秦汉帝国：政治重心——北方；经济重心——北方</p>
<p>唐宋帝国：政治重心——北方；经济重心——南方</p>
<p>全汉昇《唐宋帝国与运河》</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BB%A3%E9%83%BD%E5%9F%8E%E7%A7%BB%E5%8A%A8.PNG" alt></p>
<p>扬一益二</p>
<h4 id="某些负面影响"><a href="#某些负面影响" class="headerlink" title="某些负面影响"></a>某些负面影响</h4><ul>
<li>受热水系影响，运河难以保持正常水量</li>
<li>与农田水利灌溉相互争水，引发社会问题</li>
<li>阻断西部排水，造成区域土壤盐碱化</li>
</ul>
<h3 id="5-隋末农民起义与隋的灭亡不怎么说"><a href="#5-隋末农民起义与隋的灭亡（不怎么说）" class="headerlink" title="5. 隋末农民起义与隋的灭亡（不怎么说）"></a>5. 隋末农民起义与隋的灭亡（不怎么说）</h3><hr>
<h2 id="第二讲-从贞观之治到开元盛世"><a href="#第二讲-从贞观之治到开元盛世" class="headerlink" title="第二讲 从贞观之治到开元盛世"></a>第二讲 从贞观之治到开元盛世</h2><h3 id="1-唐太宗与贞观之治"><a href="#1-唐太宗与“贞观之治”" class="headerlink" title="1. 唐太宗与“贞观之治”"></a>1. 唐太宗与“贞观之治”</h3><h4 id="李唐建国"><a href="#李唐建国" class="headerlink" title="李唐建国"></a>李唐建国</h4><p>对突厥称臣？ 旗帜：绛白杂用</p>
<blockquote>
<p><em>盖唐室先世，出自武川，<strong>其自视原与鲜卑无异</strong>，以中国而称臣于突厥，则可耻矣，鲜卑则何有焉？</em> ——《吕思勉读史札记》</p>
</blockquote>
<p><strong>李渊时期的尚“门阀”</strong>——与魏晋不同</p>
<ul>
<li>注重冠冕 即当朝权贵</li>
<li>注重贵戚 即军功贵族</li>
</ul>
<p>胡汉混合</p>
<h4 id="贞观之治"><a href="#贞观之治" class="headerlink" title="贞观之治"></a>贞观之治</h4><p><strong>用人</strong></p>
<ul>
<li>不拘于出身地域</li>
<li>不拘于出身门第</li>
<li>不拘于民族背景</li>
<li>不拘于原属故我</li>
</ul>
<blockquote>
<p><em>人君兼听广纳，则贵臣不得壅蔽，而下情得以上通也。</em> ——《资治通鉴》</p>
</blockquote>
<p>太宗（598-649）统治以<strong>低调</strong>告终</p>
<ul>
<li>立嗣</li>
<li>亲征高丽不顺</li>
<li>贞观前期的良好政治风气未能完全保持</li>
</ul>
<p>《贞观政要》玄宗时期 一种政治资源的寻找 ——书写和记忆</p>
<blockquote>
<p>All history is contemporary history. </p>
</blockquote>
<h3 id="2-一代女皇武则天"><a href="#2-一代女皇武则天" class="headerlink" title="2. 一代女皇武则天"></a>2. 一代女皇武则天</h3><h4 id="从废帝立武到二圣"><a href="#从“废帝立武”到“二圣”" class="headerlink" title="从“废帝立武”到“二圣”"></a>从“废帝立武”到“二圣”</h4><p><strong>素多智计，兼涉文史。</strong></p>
<p>天后 -&gt; 临朝称制 -&gt; 圣母神皇</p>
<p><strong>任威刑以禁异议，授禄位以收人心。</strong>——恐怖政治</p>
<h4 id="武则天得以掌权的原因"><a href="#武则天得以掌权的原因" class="headerlink" title="武则天得以掌权的原因"></a>武则天得以掌权的原因</h4><ul>
<li>北朝遗风，胡族风俗</li>
<li>家族背景</li>
<li>佛教影响</li>
<li>个人性格能力</li>
<li>统治手段丰富</li>
</ul>
<h4 id="武则天称帝面临的困难"><a href="#武则天称帝面临的困难" class="headerlink" title="武则天称帝面临的困难"></a>武则天称帝面临的困难</h4><ul>
<li>无法从根本上证明改朝换代的合理性</li>
<li>传位</li>
<li>性别带来的压力和苦恼</li>
</ul>
<blockquote>
<p><em>故武周之代李唐，不仅为政治之变迁，实亦社会之革命。若依此义言，则武周之代李唐较李唐之代杨隋其关系人群之演变，尤为重大也。</em> ——陈寅恪《唐代政治史述论稿》</p>
</blockquote>
<h3 id="3-开元盛世"><a href="#3-开元盛世" class="headerlink" title="3. 开元盛世"></a>3. 开元盛世</h3><p>705~712年，八年五次宫廷政变——<strong>李武政权</strong></p>
<blockquote>
<p><em>姚、宋相继为相，崇善应变成务，善守法持正；二人志操不同，然协心辅佐，使赋役宽平，刑罚清省，百姓富庶。唐世贤相，前称房、杜，后称姚、宋，他人莫得比焉。</em> ——《资治通鉴》</p>
</blockquote>
<p><strong>盛唐气象</strong></p>
<p>竺可桢《中国近五千年来气候变迁的初步研究》 盛唐的气候原因</p>
<p>谭其骧《何以黄河在东汉以后会出现一个长期安流的局面》</p>
<h4 id="制度调整和天宝政局"><a href="#制度调整和天宝政局" class="headerlink" title="制度调整和天宝政局"></a>制度调整和天宝政局</h4><ul>
<li>人事<ul>
<li><strong>“文学”派</strong>人士是新起的<strong>普通地主</strong>的政治代表，如张九龄；但部分“文学”派人士不善应变，不能系统解决国家面临的各类实际问题，“不胜烦剧”</li>
<li><strong>“吏治”派</strong>官员包括两类人：门荫出身的上层人士、吏干出身的人士</li>
</ul>
</li>
<li>制度</li>
</ul>
<p><strong>盛世隐忧</strong>：不正常的政治空气与决策机制</p>
<p>李林甫：守成综核</p>
<hr>
<h2 id="从安史之乱到五代十国"><a href="#从安史之乱到五代十国" class="headerlink" title="从安史之乱到五代十国"></a>从安史之乱到五代十国</h2><h3 id="安史之乱"><a href="#安史之乱" class="headerlink" title="安史之乱"></a>安史之乱</h3><p>。。。</p>
<p>藩镇基本类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>地区</th>
<th>情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>河北地区“河朔三镇”</td>
<td>与中央对立，长期割据。</td>
</tr>
<tr>
<td>东南地区</td>
<td>中央直接控制，为唐后期立国之根本。</td>
</tr>
<tr>
<td>中原、西南、西北地区</td>
<td>中间状态。依附和游离两重色彩。与中央存在摩擦，尚未达到割据程度。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><em>弱唐者，诸侯也；唐既弱矣，而久不亡者，诸侯维之也。</em> ——《宋史》</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>历史</category>
      </categories>
      <tags>
        <tag>history</tag>
      </tags>
  </entry>
  <entry>
    <title>中国近代史 研究范式</title>
    <url>/post/11dbd13c/</url>
    <content><![CDATA[<p>中国近代史课程内容</p>
<h1 id="近现代中国历史研究的基本范式"><a href="#近现代中国历史研究的基本范式" class="headerlink" title="近现代中国历史研究的基本范式"></a>近现代中国历史研究的基本范式</h1><ol>
<li>历史，是过去发生的事实。</li>
</ol>
<blockquote>
<p>1912年1月，中华民国建立。 </p>
</blockquote>
<ol>
<li>历史，是对过去事实的记载。</li>
</ol>
<blockquote>
<p>在齐太史简，在晋董狐笔<br>《史记齐太公世家》：周灵王二十四年，齐庄公六年，春三月乙亥，崔杼弑齐庄公光于其府……齐太史书曰“崔杼弑庄公”，崔杼杀之。其弟复书，崔杼复杀之。少弟复书，崔杼乃舍之。 </p>
</blockquote>
<ol>
<li>历史是人们对过去事实的认知(技术、方法和立场)。</li>
</ol>
<blockquote>
<p>中国抗日战争胜利年纪念日的确定 </p>
<p>抗日胜利历程</p>
<p>1945年8月15日，日本宣布投降。<br>8月21日，日军代表抵湖南芷江，与中国陆军举行洽降会议。<br>9月2日，日本向盟军投降，签署投降书。<br>9月9日，中国战区的受降仪式在南京举行，陆军总司令何应钦接受日本投降。</p>
<p>“一夫” —— “君”</p>
<p>《孟子 梁惠王 下》：<br>  齐宣王问曰：“汤放桀，武王伐纣，有诸？”<br>  孟子对曰：“于传有之。”<br>  曰：“臣弑其君，可乎？”<br>  曰：“贼仁者谓之贼，贼义者谓之残。残贼之人谓之一夫。闻诛一夫纣矣，未闻弑君也。”</p>
</blockquote>
<ol>
<li>历史，是当下社会形成的对过去事实的集体性记忆。</li>
</ol>
<blockquote>
<p>228事件的历史建构：<br>     中共：台湾人民反抗国民党的斗争<br>     国民党：接收中的政府与民众的冲突<br>     民进党：台湾独立运动的先声</p>
</blockquote>
<p>“范式”：某学科领域内研究者所共同拥有的理论、概念术语和方法。</p>
<p>历史研究中的“范式”问题：基于不同的<strong>历史理论</strong>，采取不同的<strong>研究方法</strong>，选取不同的<strong>历史材料</strong>为依据，形成<strong>有特点的学科术语和逻辑思维</strong>，建立<strong>差异化的研究框架</strong>，得出<strong>个性化的历史结论</strong>。</p>
<p>中国近现代史纲要的学术范式：</p>
<ul>
<li>鸦片战争——中共十八大（1840——2015）</li>
<li>上篇：从鸦片战争到五四运动前夜（1840——1919）</li>
<li>中篇：从五四运动到新中国成立（1919——1949）</li>
<li>下篇：从新中国成立到社会主义现代化建设新时期       （1949——2015）</li>
</ul>
<h2 id="一-现代化研究范式"><a href="#一、现代化研究范式" class="headerlink" title="一、现代化研究范式"></a>一、现代化研究范式</h2><p>近代史研究的源起</p>
<ul>
<li>20世纪初—30年代初：中国近代史研究作为历史学科分支形成的萌芽阶段 。<ul>
<li>1931年罗家伦发表了《研究中国近代史的意义和方法》，呼吁将中国近代史研究纳入主流史学范畴。作者对研究鸦片战争以来的中国近代史的历史意义、方法和史料等方面的论述，奠定了此后中国近代史研究体系的基础，标志着作为学科的中国近代史研究的兴起。</li>
</ul>
</li>
<li>20年代末30年代初，学术界曾有一场关于中国出路的大讨论。<ul>
<li>中国社会的主要任务是革命，还是现代化？</li>
<li>一种观点认为：<br>中国落后的根源就在于没有完成现代化<br>中国问题的出路就在于，在国民党政府领导下开展现代化。</li>
</ul>
</li>
<li>抗战爆发后，民族救亡成为头等任务。如何实现民族救亡？<br>抗日战争不仅仅是一场军事上的抗战，而是实现国家独立和民族复兴的关键。<br>国民政府提出了抗战和建国的双重任务，以抗战促进建国，以建国完成抗战。<br>国民党认为完成抗战建国的关键，就在于贯彻孙中山先生提出的三民主义，实际上也就是完成中国现代化。</li>
<li>历史研究直接服务于抗战与建国<br>以现代化范式为框架的中国近代史研究，将中国近代史视为在西方冲击下走向近代化的历史。<br><strong>陈恭禄的《中国近代史》</strong><br><strong>蒋廷黻的《中国近代史》</strong></li>
</ul>
<p><strong>蒋廷黻：《中国近代史》（1938）</strong></p>
<ul>
<li><p>蒋廷黻以现代化为构架，建构的中国近代史研究的话语系统，源自他对当时中国主题的判断和对近代中国基本走向的把握。</p>
</li>
<li><p>蒋廷黻的《中国近代史》：近代中国的悲剧，肇始于嘉庆、道光年间中国还处于中古世界：<br>一是科学不如人，当时西方的科学基础已经打好，而中国还在做八股文，讲阴阳五行；<br>二是西方已经开始使用机器，中国的工农业还维持着中古时期模样；<br>三是西方民族观念已发达，中国仍死守着家族和家乡观念。</p>
</li>
<li><p>中国的首要问题就是现代化，抗战建国的关键也取决于现代化。</p>
<blockquote>
<p>近百年的中华民族根本上只有一个问题，那就是：中国人能近代化吗？能赶上西洋人吗？能利用科学和机械吗？能废除我们的家族和家乡观念而组织一个近代民族的国家吗？能的话，我们的民族前途是光明的；不能的话，我们的民族是没有前途的。</p>
</blockquote>
</li>
<li><p>近代中国根本问题是走出中古，走向近代化。走向近代化，是贯穿全书的主线。</p>
</li>
<li><p>蒋廷黻以<strong>近代化</strong>作为核心概念来诠释中国近代史，构建了近代化评价标准。</p>
</li>
</ul>
<h2 id="二-革命研究范式"><a href="#二、革命研究范式" class="headerlink" title="二、革命研究范式"></a>二、革命研究范式</h2><ul>
<li>中国共产党认为，中国社会主要任务是革命，主要是土地革命。</li>
<li>西方国家的入侵是近代中国贫穷落后的主要原因。</li>
<li>以马克思主义为指导、以阶级分析为主要方法、围绕近代中国革命的主题建构的革命史范式。</li>
</ul>
<p>新民主主义革命理论与近现代史</p>
<ul>
<li>基本理论依据是历史唯物主义和唯物史观<br>李大钊的研究，是革命史范式的起点。<br>新民主主义革命理论的形成，开始了中国共产党的近代中国革命历史研究。<br>毛泽东的《中国革命和中国共产党》（1939年12月）和《新民主主义论》（1940年1月</li>
</ul>
<p>近现代中国社会的主要矛盾</p>
<ul>
<li>关于主要矛盾的讨论<br>帝国主义和中华民族的矛盾，封建主义和人民大众的矛盾，这些就是中国近代社会的主要的矛盾。</li>
</ul>
<p>中华民族的两大历史任务</p>
<ul>
<li>一是求得民族独立和人民解放<br>二是实现国家繁荣富强和人民共同富裕</li>
</ul>
<p>近现代中国历史的基本内容</p>
<ul>
<li>中国近代史：就是“帝国主义和封建主义相结合，把中国变为半殖民地和殖民地过程，也就是中国人民反抗帝国主义及其走狗的过程”</li>
</ul>
<p>革命史范式的理论和分析框架</p>
<ul>
<li>以马克思主义的历史唯物主义和阶级斗争理论为指导<br>以阶级分析方法为基本研究方法<br>以政治是经济的集中表现为基本线索<br>以一条红线、两个过程、三次革命高潮、八大历史事件为基本构架，<br>力图揭示近代中国半殖民地半封建社会的历史发展规律。</li>
</ul>
<p><strong>范文澜:《中国近代史》上编（1947）</strong></p>
<ul>
<li>是马克思主义中国近代史研究学科体系初步形成时期的代表作，是完整地开辟“革命史范式”的典型著作。 </li>
<li>其研究设计，把鸦片战争至五四运动的历史根据毛泽东的论述视为旧民主主义革命时代，所以整个分析框架，是以革命史框架建立起来的，是从革命的角度看待近代中国历史的。</li>
<li>作为20世纪40年代国共斗争的产物， 范文澜的《中国近代史》从学术的角度证明了毛泽东关于中国近代史认识的正确，是马克思主义中国化的产物——毛泽东思想这种政治话语系统的重要历史佐证。</li>
</ul>
<p><strong>胡绳：《从鸦片战争到五四运动》（1981）</strong></p>
<ul>
<li>以帝国主义侵略中国、反对中国独立和中国人民反抗帝国主义侵略这一主线，论述了鸦片战争后80多年间民族矛盾和阶级矛盾的发展和变化。</li>
</ul>
<h2 id="三-革命与现代化研究范式"><a href="#三、革命与现代化研究范式" class="headerlink" title="三、革命与现代化研究范式"></a>三、革命与现代化研究范式</h2><p>革命史范式与现代化范式的对立</p>
<h3 id="1-问题的提出"><a href="#1、问题的提出" class="headerlink" title="1、问题的提出"></a>1、问题的提出</h3><ul>
<li>1949年之后，革命史范式为架构的中国近代史研究成为主流。<br>以现代化范式为框架的中国近代史研究，在中国大陆无容身之地。</li>
<li><p>改革开放之后，传统的革命理论与经济建设为中心的现实之间形成了反差。<br>“四个现代化目标”引发了现代化理论在中国近现代史研究中的应用。<br>由于“现代化”成为中国的政治主题，以革命史范式为架构的中国近代史研究的主导地位受到挑战。<br>现代化研究范式在80年代中国再度活跃。</p>
</li>
<li><p>相关研究包括：</p>
<p><strong>罗荣渠：《现代化新论：东亚与中国的现代化进程》（北京大学出版社，1997年）</strong><br><strong>许纪霖、陈达凯：《中国现代化史》（上海三联书店，1995年）</strong><br><strong>金耀基：《现代化与中国现代历史——提供一个理解中国百年来现代史的概念架构》</strong><br><strong>吉尔伯特‧罗兹曼：《中国的现代化》（江苏人民出版社，1988年）</strong></p>
</li>
<li><p>近现代史研究的关键议题：怎样理解革命与现代化的关系？怎样处理近现代史研究中的革命史范式与现代化范式的关系？</p>
<p>革命是现代化的前提。<br>革命实现了民族独立，为现代化开辟了道路、提供了前提。<br>现代化是革命的目的。<br>因而，中共十五大概括了中华民族的两大历史任务，一是通过革命求得民族独立和人民解放，二是通过现代化建设实现国家繁荣富强和人民共同富裕。</p>
</li>
</ul>
<h3 id="2-革命与现代化研究范式的特点"><a href="#2、革命与现代化研究范式的特点" class="headerlink" title="2、革命与现代化研究范式的特点"></a>2、革命与现代化研究范式的特点</h3><ul>
<li><p>“革命与现代化研究范式”作为一种政治性概念术语和政党理论，其起源有一定的<strong>合理性</strong>。但作为一个分析中国近代史的理论工具，则<strong>有所欠缺</strong>。因为它难以把近代中国取得的许多成就总括进去。</p>
<ul>
<li>中国共产党政治理论的基础<br>以革命的历史来划分历史阶段<br>主体性不够突出<br>逻辑体系不一致<br>过于强调外因的作用<br>在主权与社会发展之间的尴尬</li>
</ul>
</li>
<li><blockquote>
<p>案例：抗日战争的立场问题</p>
<p>共产党的抗战？<br>国民党的抗战？<br>中国人民的抗战？</p>
</blockquote>
</li>
</ul>
<h2 id="四-现代民族国家范式"><a href="#四、现代民族国家范式" class="headerlink" title="四、现代民族国家范式"></a>四、现代民族国家范式</h2><h3 id="1-近现代史与现代文明"><a href="#1、-近现代史与现代文明" class="headerlink" title="1、 近现代史与现代文明"></a>1、 近现代史与现代文明</h3><ul>
<li>近现代史不仅是时间概念，而是是现代文明。现代性涉及<strong>政治的、经济的、社会的和文化的</strong>四个领域之间的复杂的互动历史。</li>
<li>现代民族国家的建立最具有包容性，能够涵盖现代化进程中的基本内容。<br>现代民族国家和现代社会的建构：<strong>世俗政治权力的确立和合法化、工业文明和市场经济的形成、传统社会秩序的衰落和社会的分化以及宗教的衰微和世俗文化的兴起。</strong></li>
</ul>
<h3 id="2-古代中国只有王朝-天下没有国家"><a href="#2、古代中国只有王朝、天下，没有国家" class="headerlink" title="2、古代中国只有王朝、天下，没有国家"></a>2、古代中国只有王朝、天下，没有国家</h3><ul>
<li><p>传统典籍也有“国”，它指的指王朝。<br>中国人“国家是君主一家之产业”及“君主即国家”等观念。数千年之史家“知有朝廷不知有国家”。</p>
</li>
<li><blockquote>
<p>顾炎武：天下兴亡，匹夫有责</p>
<p>“有亡国，有亡天下。亡国与亡天下奚辨？曰：易姓改号，谓之亡国。仁义充塞，而至于率兽食人，人将相食，谓之亡天下……是故知保天下，然后知保其国。保国者，其君其臣肉食者谋之。保天下者，匹夫之贱，与有责焉耳矣。”</p>
</blockquote>
</li>
<li><blockquote>
<p>梁启超的《爱国论》</p>
<p>“我支那人非无爱国之性质也，其不知爱国者，由不自知其为国也。中国自古一统，环列皆小蛮夷，无有文物，无有政体，不称其为国，吾民亦不以平等之国视之。故吾国数千年来，常处于独立之势，吾民之称禹域也，谓之为天下，而不谓之为国。”</p>
</blockquote>
</li>
<li><p>亡国就是一家一姓的王朝的灭亡；亡天下就是亡文化。<br>顾炎武在王朝与天下之间，没有一个“民族”或者“国家”的观念。<br>传统社会有坚定的王朝认同、文化认同。王朝认同与文化认同一表一里，维系着传统社会的人们的基本心理结构。 </p>
</li>
</ul>
<p><strong>中华文明共同体</strong></p>
<ul>
<li>梁漱溟在《中国文化要义》中，特辟一章为“中国是否一国家”，“中国不像国家。”<br>梁启超：“吾人所最惭愧者，莫如我国无国名一事。”<br>罗素当年在上海演讲的时候就说：“中国实为一文化实体而非国家。”<br>历史学家雷海宗也说：“二千年来的中国，只能说是一个庞大的社会，一个具有松散政治形态的大文化区，与战国七雄或近代西洋列国，决然不同。”</li>
</ul>
<h3 id="3-从王朝帝国到现代民族国家"><a href="#3、从王朝帝国到现代民族国家" class="headerlink" title="3、从王朝帝国到现代民族国家"></a>3、从王朝帝国到现代民族国家</h3><p>传统王朝国家的解构历程</p>
<ul>
<li>近代以来国家之间交往、竞争，刺激了人们对国家认知的深入，国家观念成为讨论的关键。在近代西方国家的实践与理论的刺激下，古老王朝帝国开始解体。</li>
<li>洋务运动所行之器物层面改革<br>维新变法所言之制度层面变革<br>新文化运动所行之文化革命</li>
<li>中国历史必须放在世界历史发展的格局之中加以重新定位、认识。中国历史一旦从一种“地方时间”被纳入“世界时间”的流程，按照国际社会的标准来改变中国传统社会成为国际社会流行的政治组织——国家。</li>
</ul>
<p>帝制的结束</p>
<ul>
<li>以民权思想否定了王权的合法性<br>以“国民史”代替“二十四史”的“帝王将相家谱”。<br>辛亥一役,其革新焦点也渐从“尊王攘夷”式的御辱图强之策也转向于“民族”、“国家”之发达昌盛。</li>
</ul>
<p>现代民族国家的建构</p>
<ul>
<li><p>近现代中国历史的主体—民族国家开始登台。现代民族国家是受单一最高权力当局根据单一行政和法律体系所治理，领土是联成一体并有明确边界的完整区域，国家应代表一个单一民族。<br>晚清社会中现代文明因素的传播：民权思想、民国体制</p>
</li>
<li><p>现代国家要素：</p>
<p>国土：边界、领土性质的变化<br>民族：民族整合、现代公民<br>主权：独立主权、治理方式的统一<br>制度：经济制度、社会制度和政治制度等</p>
</li>
<li><p><strong>领土</strong>是现代国家民族国家建构的核心主题领土，是中国近现代史上历届政府的头等大事。历届政府的表现，要实事求是地进行分析、按照统一标准来评价，而不是简单的爱国、卖国所能概括的。国内各种政治力量及关系，与领土问题密切相关</p>
</li>
</ul>
<p>现代国家建构的理论范式</p>
<ul>
<li>中国近现代史就是围绕着现代国家建构的基本元素<strong>领土、民族、主权和制度</strong>等而渐次展开的发展历程，现代民族国家的建构是这一特定历史阶段的主题。</li>
<li>反映这一特定历史阶段的独特本质。</li>
<li>契合近代中国从传统社会走向现代文明的艰难历程，揭示了现代文明基本方向。</li>
<li>具有较大的包容性，能够涵盖不政治、经济、文化思想诸层面的发展本质及其趋向。</li>
<li>贯穿近现代历史始终，为近现代史研究提供了统一的逻辑体系。</li>
</ul>
]]></content>
      <categories>
        <category>历史</category>
      </categories>
      <tags>
        <tag>history</tag>
      </tags>
  </entry>
  <entry>
    <title>内存堆，内存池，常量池</title>
    <url>/post/ff4ddc00/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="java的六个不同存储数据位置"><a href="#JAVA的六个不同存储数据位置：" class="headerlink" title="JAVA的六个不同存储数据位置："></a>JAVA的六个不同存储数据位置：</h2><p><strong>1. 寄存器</strong>：最快的存储区，位于处理器内部（不同于其他存储区的地方）。寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。</p>
<p><strong>2. 栈</strong>：存放<strong>基本类型</strong>(byte, short, int, long, float, double, boolean, char)的变量数据和<strong>对象的引用</strong>。<strong>堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。</strong>这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成 相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性。</p>
<p><strong>3. 堆</strong>：一种通用性的内存池（也存在于RAM中），用于存放所有的JAVA对象。堆不同于堆栈的好处是：<strong>编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存活多长时间。</strong>因此，在堆里分配存储有很大的灵活性。代价是<strong>用堆进行存储分配比用堆栈进行存储存储需要更多的时间</strong>。  </p>
<p><strong>4. 静态域</strong>：存放静态成员，<strong>static</strong>定义 。</p>
<p><strong>5. 常量池</strong>：存放<strong>字符串常量和基本类型常量</strong>（public static final）。 常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。</p>
<p><strong>6. 非RAM存储</strong>：<strong>硬盘等永久存储空间</strong>。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。 </p>
<h2 id="栈堆和常量池"><a href="#栈，堆和常量池" class="headerlink" title="栈，堆和常量池"></a>栈，堆和常量池</h2><h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><ul>
<li>栈中的数据大小和生命周期是可以<strong>确定</strong>的，当没有引用指向数据时，这个数据就会消失。</li>
<li>堆中的对象的由<strong>垃圾回收器</strong>负责回收，因此<strong>大小和生命周期不需要确定</strong>，具有很大的灵活性。 </li>
</ul>
<ol>
<li><p>对于<strong>字符串</strong></p>
<ol>
<li><p>其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。</p>
</li>
<li><p>```java<br>String string1 = “a”;<br>String string2 = “a”;<br>String string3 = “a”;<br>String ss1 = new String(“a”);<br>String ss2 = new String(“a”);<br>String ss3 = new String(“a”);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      ![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/栈堆字符串.png)</span><br><span class="line"></span><br><span class="line">      对于通过new产生一个字符串（假设为”a”）时，会先去常量池中查找是否已经有了”a”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此”a”对象的拷贝对象。所以new String(&quot;a&quot;)产生的对象既然可能是1或2。</span><br><span class="line"></span><br><span class="line">2. 对于**基础类型的变量和常量**</span><br><span class="line"></span><br><span class="line">   1. 变量和引用存储在栈中，常量存储在常量池中。</span><br><span class="line">         ```java</span><br><span class="line">            int i1 = 9;</span><br><span class="line">            int i2 = 9;</span><br><span class="line">            public static final int j1 = 9;</span><br><span class="line">            public static final int j2 = 9;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<pre><code>  ![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/堆栈基础类型.png)
</code></pre><ol>
<li><p><strong>成员变量和局部变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BirthDate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BirthDate</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        day = d; </span><br><span class="line">        month = m; </span><br><span class="line">        year = y;</span><br><span class="line">    &#125;</span><br><span class="line">    省略get,set方法………</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> date = <span class="number">9</span>;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();      </span><br><span class="line">        test.change(date); </span><br><span class="line">        BirthDate d1= <span class="keyword">new</span> BirthDate(<span class="number">7</span>,<span class="number">7</span>,<span class="number">1970</span>);       </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">     i = <span class="number">1234</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：对于以上这段代码，date为局部变量，i,d,m,y都是形参为局部变量，day，month，year为成员变量。下面分析一下代码执行时候的变化：</p>
<ol>
<li><p>main方法开始执行：</p>
<p>int date = 9;date局部变量，基础类型，引用和值都存在栈中。</p>
</li>
<li><p>Test test = new Test();</p>
<p>test为对象引用，存在栈中，对象(new Test())存在堆中。</p>
</li>
<li><p>test.change(date);</p>
<p>i为局部变量，引用和值存在栈中。当方法change执行完成后，i就会从栈中消失。</p>
</li>
<li><p>BirthDate d1= new BirthDate(7,7,1970);  </p>
<p>d1为对象引用，存在栈中，对象(new BirthDate())存在堆中，其中d，m，y为局部变量存储在栈中，且它们的类型为基础类型，因此它们的数据也存储在栈中。day,month,year为成员变量，它们存储在堆中(new BirthDate()里面)。当BirthDate构造方法执行完之后，d,m,y将从栈中消失。</p>
</li>
<li><p>main方法执行完之后，date变量，test，d1引用将从栈中消失，new Test(),new BirthDate()将等待垃圾回收。</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/堆栈成员变量局部变量.png" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/Eason-S/p/5658230.html">堆、栈、常量池的比较</a></p>
<p>《深入理解java虚拟机》</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《乡土中国》 读书笔记</title>
    <url>/post/bbc6ebd1/</url>
    <content><![CDATA[<p><a href="https://www.zhihu.com/question/22122194/answer/679068135"> 如何评价费孝通的《乡土中国》？ - 知乎 (zhihu.com)</a></p>
<p>作者：约格莫夫<br>链接：<a href="https://www.zhihu.com/question/22122194/answer/72724413">https://www.zhihu.com/question/22122194/answer/72724413</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="一-核心概念释义"><a href="#一-核心概念释义" class="headerlink" title="一. 核心概念释义"></a>一. 核心概念释义</h2><p>　　1.    <a href="https://www.zhihu.com/search?q=礼俗社会&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">礼俗社会</a>：没有具体目标，只是因为在一起生长而发生的社会。p9 </p>
<p>　　2.    <a href="https://www.zhihu.com/search?q=法理社会&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">法理社会</a>：为了要完成一件任务而结合的社会。p9 </p>
<p>　　3.    愚：文盲，不识字。p12 </p>
<p>　　4.    面对面的社群：生活上互相合作而且天天见面的一群人。p14 </p>
<p>　　5.    特殊语言：非文字性的，可以用来传情达意的语言，如表情、肢体语言、行话等。 </p>
<p>　　6.    时间阻隔：一方面是个人的今昔之隔，一方面是社会的世代之隔。p18 </p>
<p>　　7.    记忆：“记”带有在当前为了将来有用而加以认取的意思；“忆”是为了当前有关而回想到过去经验。 </p>
<p>　　8.    文化：依赖象征体系和个人的记忆而维护着的社会共同经验。P19 </p>
<p>　　9.    私：由于缺乏对“公”的共识，而每个人对“公”与“私”划分的伸缩性又极强，所以很难对“私”的评价做界定。 </p>
<p>　　10.    团体：用捆柴来打比方，只指由<a href="https://www.zhihu.com/search?q=团体格局&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">团体格局</a>中所形成的社群。p24、p36 </p>
<p>　　11.    团体格局：如同一捆捆、一扎扎、一把把柴火摆在一起。个人间的联系靠着一个共同的架子；先有了这架子，每个人结上这架子，而互相发生关联。p24、p30 </p>
<p>　　12.    亲属关系：根据生育和婚姻事实所发生的社会关系。p25 </p>
<p>　　13.    伦：从自己推出去的和自己发生社会关系的那一群人里所发生的一轮轮波纹的差序。p26 </p>
<p>　　14.    <a href="https://www.zhihu.com/search?q=差序格局&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">差序格局</a>：同“伦”，即以“己”为中心，通过有差等的次序和一根根私人联系而构成的网络。p26 </p>
<p>　　15.    个人主义：一方面是平等观念，指在同一团体中各分子的地位相等，个人不能侵犯大家的权利；一方面是<a href="https://www.zhihu.com/search?q=宪法观念&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">宪法观念</a>，指团体不能抹煞个人，只能在个人们所愿意交出的一分权力上控制个人。p27 </p>
<p>　　16.    <a href="https://www.zhihu.com/search?q=自我主义&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">自我主义</a>：一切价值是以“己”作为中心的主义，具有相对性和伸缩性。p27 </p>
<p>　　17.    道德观念：在社会里生活的人自觉应当遵守社会行为规范的信念，包括着行为规范、行为者的信念和社会的制裁。内容是人和人关系的行为规范，是依着该社会的格局而决定的。p30 </p>
<p>　　18.    代理者：团体格局社会中，执行团体意志的人。p31 </p>
<p>　　19.    社群：一切有组织的人群，把社群来代替普通所谓团体。P36 </p>
<p>　　20.    社会圈子：差序格局中的基本社群，相当于“小家族”。P36 </p>
<p>　　21.    事业组织：用来形容中国<a href="https://www.zhihu.com/search?q=乡土社会&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">乡土社会</a>的家族或家庭。在生育、政治、经济、宗教等功能上具有绵延性，主轴在父子之间、婆媳之间，夫妇是配轴，这两轴都被事业的需要排斥了普通的感情（与纪律相对照的普通感情）。P39 </p>
<p>　　22.    生活堡垒：用来形容西洋家庭团体。此类家庭里，夫妇是主轴，共同经营生育事物，两性之间的感情是凝合的力量，家庭是其获取生活安慰的中心；子女是配角，政治、经济、宗教等功能也都不是家庭的分内事。P39 </p>
<p>　　23.    感情定向：文化所规定个人感情可以发展的方向。P41 </p>
<p>　　24.    了解：指接受着同一的意义体系。稳定社会关系的力量，不是感情，而是了解。P42 </p>
<p>　　25.    阿波罗式（Apollonian）的西方文化模式：认定宇宙的安排有一个完善的秩序，这个秩序超于人力的创造，人不过是去接受它，安于其位，维持它；但是人连维持它的力量都没有，天堂遗失了，黄金时代过去了。P42 </p>
<p>　　26.    浮士德式（Faustian）的西方文化模式：把冲突看成存在的基础，生命是阻碍的克服；没有了阻碍，生命也就失去了意义；他们把前途看成无尽的创造过程，不断地变。P42 </p>
<p>　　27.    法治：社会上人和人的关系是根据法律来维持的，其实是“人依法而治”。在一个变迁很快的社会，传统的效力无法保证，所应付的问题如果要由团体合作的时候，就得大家接受个同意的办法，要保证大家在规定的办法下合作应付共同问题，就得有个力量来控制各个人，这个力量就是法律。P46 </p>
<p>　　28.    人治：其实是“礼治”，没有所谓“人治”的概念。但礼治并不意味着文质彬彬，也可以很残忍。 </p>
<p>　　29.    礼：社会公认合式（对是合式的意思）的行为规范，从教化中养成了个人的敬畏之感，使人服膺，用“克”、“约”等字表示。【克己复礼、推己及人、约定俗成】P49 </p>
<p>　　30.    传统：社会所累积的经验，用来维持“礼”这种规范的无形权力。P48 </p>
<p>　　31.    <a href="https://www.zhihu.com/search?q=横暴权力&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">横暴权力</a>：从社会冲突方面着眼，权力表现在社会不同团体或阶层间主从的形态里，权力是维持这种主从关系所必需的手段，具有压迫性质。P56 </p>
<p>　　32.    同意权力：从社会合作方面着眼，由于社会分工使得每个人都不能“不求人”而生活。其权力的基础是社会契约，是同意，权利与义务要相称，否则就当鲁滨逊。P57 </p>
<p>　　33.    教化权力：paternalism，发生于社会继替的过程，同爸爸式的权力或称长老权力，是为了被教化者，而不是为了统治关系，带来长老统治。 </p>
<p>　　34.    <a href="https://www.zhihu.com/search?q=时势权力&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">时势权力</a>：“时势造英雄”，他提得出办法，有能力组织新的试验，能获得别人的信任。这种人可以支配其他的群众，发生了一种权力。P72 </p>
<p>　　35.    长老统治：难以用民主和不民主的尺度来衡量中国社会下的权宜之计。P64 </p>
<p>　　36.    文化与政治的区别：凡是被社会不成问题地加以接受的规范，是文化性的；当一个社会还没有共同接受一套规范，各种意见纷呈，求取临时解决办法的活动是政治。 </p>
<p>　　37.    社会继替：指社会成员新陈代谢的过程，人物在固定的社会结构中的流动。P60、p71 </p>
<p>　　38.    社会变迁：指社会结构本身的变动。P71 </p>
<p>　　39.    血缘：人和人的权利和义务根据亲属关系来决定，是身份社会的基础。P70 </p>
<p>　　40.    地缘：血缘的空间投影，从商业里发展出来的社会关系，是<a href="https://www.zhihu.com/search?q=契约社会&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">契约社会</a>的基础。P70 </p>
<p>　　41.    注释：是维持<a href="https://www.zhihu.com/search?q=长老权力&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">长老权力</a>的形式而注入变动的内容。 </p>
<p>　　42.    欲望：人类在取舍之间的根据，规定了人类行为的方向，是文化事实。 </p>
<p>　　43.    需要：自觉的生存条件。P80 </p>
<h2 id="二-研究方法素描"><a href="#二-研究方法素描" class="headerlink" title="二. 研究方法素描"></a>二. 研究方法素描</h2><p>　　1．    研究基础：充分的社区分析。 </p>
<p>　　社区分析：以某个具体社区的全盘社会结构的格式作为研究对象，在一定时空坐落中去描画出该地方的人民所赖以生活的社会结构。该方法与历史学的工作相通，如果历史材料充分的话，任何时代的社区都同样可作分析对象（东坪）。同时与人类学的一部分也相通。P85 </p>
<p>　　2．    问题意识：作为中国<a href="https://www.zhihu.com/search?q=基层社会&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">基层社会</a>的乡土社会究竟是个什么样的社会？p4 </p>
<p>　　3．    社会学研究方法：属于社区第二步的比较研究的范围。p87 </p>
<p>　　先得确立若干可以比较的类型，也就是依不同结构的原则分别确定它所形成的格式。p87 </p>
<p>　　不妨称之为“结构论Structuralism”，是“功能论Functionalism”的延续。 </p>
<p>　　4．    该研究的模仿对象：Mead女士根据美国的事实说明移民的特性，写成《The American character 》一书。p88 </p>
<p>　　5．    研究目的：通过从具体社会里提炼出的一些作为认识事物工具的概念，呈现包含在具体的中国基层传统社会里的一种特具的、支配社会生活方方面面的体系，来帮助我们去理解具体的中国社会。P4 </p>
<h2 id="三-作者是怎样把上述概念提炼出来的"><a href="#三-作者是怎样把上述概念提炼出来的？" class="headerlink" title="三. 作者是怎样把上述概念提炼出来的？"></a>三. 作者是怎样把上述概念提炼出来的？</h2><p>　　1.    确立中国基层社会的根本性特质： </p>
<p>　　从基层上看去，中国社会是乡土性的。P6 </p>
<p>　　2.    明确与中国乡土社会相比较的几种社会类型 </p>
<p>　　<a href="https://www.zhihu.com/search?q=西洋社会&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">西洋社会</a>； </p>
<p>　　城市社会 </p>
<p>　　3.    确立若干可供比较的社会结构或功能类型，寻找合适的理论对话对象或其他类似的表述形式，这个过程可逆；并将乡土社会与比较对象两者都抽象出对应的概念。前者为乡土社会的概念，后者为非乡土社会的概念。【】内为其他学者对这个问题类似的表述。 </p>
<p>　　    社会学中的社会性质：礼俗社会、法理社会 </p>
<p>　　【Tonnies：Gemeinschaft、Gesellschaft】 </p>
<p>　　【Durkheim：前者是“有机的团结”、后者是“机械的团结”】p9 </p>
<p>　　    交往中信任的来源：对规矩的熟悉、对契约的认可p10 </p>
<p>　　    对农民的一般性认知：平民教育工作者提出的农民四病“愚、弱、贫、私”，作者直接诘问其中的“愚”与“私” </p>
<p>　　    社区间人员的流动率：熟人社会、陌生人社会p9 </p>
<p>　　    作为交往中传情达意的工具（现代化的工具）：特殊语言、文字p16 </p>
<p>　　    社会结构的格局（社群如何形成）：差序格局、团体格局 </p>
<p>　　【<a href="https://www.zhihu.com/search?q=潘光旦&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">潘光旦</a>《说伦字》：凡是有“仑”做公分母的意思都相同，共同表示的是条理、类别、秩序的一番意思】 </p>
<p>　　【《礼记》十伦：鬼神、君臣、父子、贵贱、亲疏、爵赏、夫妇、政事、长幼、上下】</p>
<p>　　【孔子：推己及人，推，如同水纹波浪向外扩张；克己复礼；壹是皆以修身为本】 </p>
<p>　　【现代国家理念】 </p>
<p>　　    价值观：个人主义、自我主义p27 </p>
<p>　　【杨朱：拔一毛而利天下不为】 </p>
<p>　　【孔子：君子求诸己，小人求诸人】 </p>
<p>　　【《大学》修身齐家治国平天下】 </p>
<p>　　    维系格局中私人的道德体系：礼教、宗教p31 </p>
<p>　　【礼教：天人合一，神与代理者的合一】 </p>
<p>　　【宗教：神与代理者的分离】 </p>
<p>　　【基督教的道德观念：每个个人在神前的平等，神对每个个人的公道】p31 </p>
<p>　　【爱——仁——忠】 </p>
<p>　　    格局内的基本单位：社会圈子、团体p36 </p>
<p>　　    家庭性质：事业组织、生活堡垒p39 </p>
<p>　　    文化模式：阿波罗式、浮士德式 </p>
<p>　　    维持社会秩序的治理方式：礼治、法治 </p>
<p>　　【子曰：克己复礼为仁】 </p>
<p>　　【子曰：非礼勿视，非礼勿听，非礼勿言，非礼勿动】 </p>
<p>　　    权力在社会继替与社会变迁交织时的运作方式： </p>
<p>　　横暴权力、同意权力、教化权力、时势权力 </p>
<p>　　    统治权力的性质：长老统治、民主\不民主 </p>
<p>　　    个人生存条件是否变为自觉：欲望、需要 </p>
<h2 id="四-作者是怎样把上述概念串联在一起的"><a href="#四-作者是怎样把上述概念串联在一起的？" class="headerlink" title="四. 作者是怎样把上述概念串联在一起的？"></a>四. 作者是怎样把上述概念串联在一起的？</h2><p>　　    作者开宗明义申明中国基层社会是乡土性的，农业生产和农业生活的特征正是取决于农民对“土”的依赖。在对中国乡村特征的认识上，有不少提倡乡村工作的人将“愚、弱（病）、贫、私”作为其征候，尽管对“弱”与“贫”有客观的标准可说，但“愚”与“私”却定义的很牵强，作者直接诘问这两方面。 </p>
<p>　　首先，“愚”是指农民不识字，可是从传情达意、传递世代间经验的工具性角度，以及农民所处的空间阻隔与时间阻隔的状态来看，特殊语言与文字的功能并无二致，相反在近距离沟通中更加有效。我们也正处于现代化进程，文字固然是现代化的工具，文字的发生是在人和人传情达意的过程中受到了空间和时间的阻隔的情境里P18，但要考虑此类工具的内生性与有效性。作者就是在阐述这些工具与特征在乡土社会是如何内生的，如何发挥作用的，这种作用发挥的怎样，认为本来平行的两种工具不应有高低贵贱之分，文字下乡的前提是要帮助他们在社会中生活的需要。 </p>
<p>　　其次，“私”的毛病很难做出评价，是需要先将群己、人我的界限划定清楚的，所以讨论这个问题前要考虑整个社会结构的格局。作者分别用团体格局和差序格局比拟西洋社会和乡土中国的格局，团体格局中的个人崇尚个人主义，差序格局中的个人遵从自我主义。这种自我主义极具相对性和伸缩性，有的人同心圆网络很小，而有的人甚至可以完全依靠同心圆网络生存。所以，究其评价农民“私”的本质，其实是西洋社会的现代国家理念对乡土社会的冲击。在辨清乡土社会的整体结构后，接下来要去发现社会格局中维系私人的核心道德观念是什么。差序格局的社会是由无数私人关系搭成的网络，不同的私人关系之间存在亲疏远近、高低贵贱，需要与之相配的道德要素，所以传统的道德里找不出一个笼统性的道德观念，所有的价值标准不能超脱于差序的人伦而存在。因此在对某个人做道德判断前，一定要问清对象是谁，对象和自己什么关系，才能拿出相应的标准来。 </p>
<p>　　<a href="https://www.zhihu.com/search?q=社会格局&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A72724413}">社会格局</a>是由社群这一基本单位所构成，团体格局的基本社群是团体，差序格局的基本社群是社会圈子，也可称之为“小家族”。在“家族”和“男女有别”这两个章节，作者用差序格局中最基本的社群单位——家庭以及家庭中的男女关系——与团体格局的相应概念做比较，说明家庭中“纪律排斥私情”、“男女有别”是让乡土社会呈现安稳秩序的重要因素。 </p>
<p>　　从差序格局的基本社群单位来看，安稳的秩序在家庭内部已经达成，但是社会整体的有序还需要有一种明确的对秩序的治理模式。普遍的观点是将乡土社会归为“人治”，西洋社会归为“法治”，可“人治”的观点其实本身并不成立。首先，“法治”也属于广义上的“人治”，应该叫“人依法而治”。其次，望文生义的来看，“人治”是指统治者随个人好恶做决定，这种好恶难以被预期，这时人们会不知道怎样行动，会导致天下大乱，因之根本算不上“治”。它们二者的差别在于维持秩序时所用的力量和所根据的规范的性质，所以所谓的“人治”其实是“礼治”。“礼”作为社会公认合式的行为规范，主要是在社会继替的教化中养成个人的敬畏之感，使人主动服膺。同时，这带来了区别于同意权力、横暴权力的第三种权力——教化权力，并带来长老统治，“礼治”的存在条件在于社会变迁并不剧烈，传统可以有效地应付生活问题。而在变迁很快的社会，所要应付的问题传统办法解决不了，需要保证大家在规定的办法下合作应付共同问题，这时法律作为控制各个人的力量出现了，也就是所谓“法治”。 </p>
<p>　　所以“法治”和“礼治”是发生在两种不同的社会情态中，即取决于在社会继替发生的同时社会变迁的速率。在社会变迁过程中，其社会性质很大的一个转变就是从血缘结合转变到地缘结合。同时，文化的不稳定带来竞争优势在年轻人和老人间重新配置，原先的教化权力遭到了挑战，“时势造英雄”，涌现出了时势权力。在这里我有一点疑问，作者说时势权力与“法治”都出现于激烈的社会变迁过程中，但时势权力是怎样转化为“法治”的呢”？ </p>
<p>　　最后作者谈到人性发生的一些重要变化，从欲望到需要是社会变迁中一个很重要的里程碑。在乡土社会中人可以靠欲望来行事，但在现代社会中欲望并不能作为人们行为的指导，于是产生“需要”，因而有了“计划”。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>几种二十世纪西方思潮</title>
    <url>/post/5cbef579/</url>
    <content><![CDATA[<h1 id="现代性问题"><a href="#现代性问题" class="headerlink" title="现代性问题"></a>现代性问题</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>《学术与政治》马克思韦伯</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>philosophy</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/post/9e8f7e4b/</url>
    <content><![CDATA[<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></p>
<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> partitionIndex = partition(arr, left, right);</span><br><span class="line">            quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        <span class="keyword">int</span> pivot = left;</span><br><span class="line">        <span class="keyword">int</span> index = pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">                swap(arr, i, index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0 十大经典排序算法 | 菜鸟教程 (runoob.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能索引策略——《高性能MySQL》第五章</title>
    <url>/post/56a6a98a/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是阅读《高性能mysql》第五章的记录。</p>
<h1 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h1><p>非独立的列是<strong>索引列是表达式的一部分或是函数的参数</strong>，这会导致索引使用不当，或无法使用已有的索引</p>
<p>错误示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select actor_id from sakila.actor where actor_id + 1 = 5;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ... where to_days(current_date) - to_days(date_col) &lt;= 10;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>养成简化where条件的习惯，始终将索引列单独放在比较符号的一侧</p>
<h1 id="2-前缀索引和索引选择性"><a href="#2-前缀索引和索引选择性" class="headerlink" title="2. 前缀索引和索引选择性"></a>2. 前缀索引和索引选择性</h1><p><strong>索引选择性：</strong>不重复的索引值（也称为基数，cardinality）和数据表的记录总值（#T）的比值，范围从（1/#T）到1之间。索引选择性越高，查询效率越高。唯一索引的选择性是1,是最好的索引选择性，性能最好。</p>
<p><strong>前缀索引</strong>：一般情况下，某个列的前缀选择性足够高，足以满足查询性能。对于<strong>BLOB\TEXT\VARCHAR</strong>类型的列，必须用前缀索引——mysql不允许索引在这些列的完整长度</p>
<p><strong>诀窍</strong>：足够长——保证较高的选择性，不能太长——节约空间。<strong>前缀的“基数”应该接近于完整列的“基数”</strong></p>
<p><strong>例子</strong>：</p>
<h1 id="3-多列索引"><a href="#3-多列索引" class="headerlink" title="3. 多列索引"></a>3. 多列索引</h1><p>在多列上建立独立的单列索引大部分情况下不能提高Mysql查询性能。</p>
<h1 id="4-选择合适的索引列顺序"><a href="#4-选择合适的索引列顺序" class="headerlink" title="4. 选择合适的索引列顺序"></a>4. 选择合适的索引列顺序</h1><p>正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。</p>
<p>选择性更高的列放在索引最前列，某些场景有用。但通常不如避免随机IO和排序重要。</p>
<p>将选择性最高的列放在前面通常是很好，这时候索引的作用只是用于<strong>优化WHERE条件的查找</strong>。然而，<strong>性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关</strong>。可能也需要根据那些<strong>运行频率最高的查询</strong>来调整索引列的顺序，让这种情况下索引的选择性更高</p>
<h1 id="5-聚簇索引"><a href="#5-聚簇索引" class="headerlink" title="5. 聚簇索引"></a>5. 聚簇索引</h1><p>并非一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引在同一个结构中保存了B-Tree索引和数据行。</p>
<h1 id="6-覆盖索引"><a href="#6-覆盖索引" class="headerlink" title="6. 覆盖索引"></a>6. 覆盖索引</h1><p>查询只需要扫描索引而无须回表，带来的好处</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那么Mysql就会<strong>极大地减少数据访问量。</strong>这对缓存的负载非常重要，因为这种情况下<strong>响应时间大部分花在数据拷贝</strong>上。这对<strong>I/O密集型的应用</strong>也有帮助。</li>
<li>索引是按照列值顺序存储的，所以<strong>对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多</strong>。</li>
<li>一些存储引擎如<strong>MyISAM</strong>在内存中只缓存索引，数据则依赖于操作系统来缓存，因此访问数据需要一次系统调用，可能导致严重的性能问题。</li>
<li>对于InnoDB的<strong>聚簇索引</strong>，覆盖索引对InnoDB表特别有用。InnoDB的<strong>二级索引在叶节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询</strong>。</li>
</ul>
<h1 id="7-使用索引扫描来做排序"><a href="#7-使用索引扫描来做排序" class="headerlink" title="7. 使用索引扫描来做排序"></a>7. 使用索引扫描来做排序</h1><p>两种方式生成有序结果：排序操作、按索引顺序扫描（explain的type结果为index，而不是extra列的”Using index”）</p>
<p><strong>扫描索引本身很快，但如果索引不能覆盖所有查询所需的全部列，就不得不每扫描一条索引记录就都回表查询一次对应的行。</strong>基本上都是<strong>随机I/O</strong>，因此按索引顺序读取数据的速度他哦农场要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。</p>
<p>所以最后的结果，是<strong>同一索引既满足排序，又用于查找行</strong>。</p>
<p>使用索引排序的一个重要用法是当<strong>查询同时有ORDER BY 和 LIMIT 子句</strong>时 </p>
<h1 id="8-压缩前缀压缩索引"><a href="#8-压缩（前缀压缩）索引" class="headerlink" title="8. 压缩（前缀压缩）索引"></a>8. 压缩（前缀压缩）索引</h1><p>MyISAM</p>
<h1 id="9-冗余和重复索引"><a href="#9-冗余和重复索引" class="headerlink" title="9. 冗余和重复索引"></a>9. 冗余和重复索引</h1><p><strong>重复索引</strong>——在相同的列上按照相同的顺序创建的相同类型的索引。</p>
<p><strong>冗余索引</strong>——如果创建了索引(A,B)，再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引，加入是再创建(B,A)就不是。通常发生在<strong>为表添加新索引的时候。</strong></p>
<p>MySQL允许在相同列创建多个索引。但需要单独维护重复的索引，并且<strong>优化器在优化查询时需要逐个考虑</strong>，这会影响性能。</p>
<p>大多数情况都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。（除非扩展会让索引变得太大了）</p>
<h1 id="10-未使用的索引"><a href="#10-未使用的索引" class="headerlink" title="10. 未使用的索引"></a>10. 未使用的索引</h1><p>建议考虑删除</p>
<p>定位未使用索引的工具<em>Percona Server</em>，<em>MariaDB</em>查看每个索引的使用频率。</p>
<h1 id="11-索引和锁"><a href="#11-索引和锁" class="headerlink" title="11. 索引和锁"></a>11. 索引和锁</h1>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>协程</title>
    <url>/post/bb1e53b0/</url>
    <content><![CDATA[<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>进程、线程会遇到的性能问题：</p>
<ul>
<li>同步锁</li>
<li>涉及到线程阻塞状态和可运行状态之间的切换</li>
<li>设置到线程上下文的切换</li>
</ul>
<p>协程是一种比线程更加轻量级的，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4933701-4a7846c5d7c1290c.png?imageMogr2/auto-orient/strip|imageView2/2/w/646/format/webp" alt="img"></p>
<p>协程是<strong>用户态</strong>的，完全由程序所控制的。好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<p>协程可看成某种特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。</p>
<p>因此，通常说一个线程包含多个协程，是指一个线程内可以由多个这样的特殊函数在运行，但是有一点必须明确的是，一个线程的多个协程的运行是<strong>串行</strong>的。如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。当一个协程运行时，其它协程必须挂起。</p>
<h3 id="进程-线程-协程的对比"><a href="#进程、线程、协程的对比" class="headerlink" title="进程、线程、协程的对比"></a>进程、线程、协程的对比</h3><hr>
<ul>
<li>协程既不是进程也不是线程，协程仅仅是一个<strong>特殊的函数</strong></li>
<li>一个进程可以包含多个线程，一个线程可以包含多个协程</li>
<li>一个线程内的多个协程虽然可以切换，但是多个协程是<strong>串行执行</strong>的，只能在一个线程内运行，没法利用CPU多核能力。</li>
<li>协程与进程一样，切换也需要上下文切换</li>
</ul>
<h3 id="协程上下文切换"><a href="#协程上下文切换" class="headerlink" title="协程上下文切换"></a>协程上下文切换</h3><hr>
<ul>
<li>进程切换对象是操作系统，内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换是由“用户态到内核态到用户态”的方式，切换效率低</li>
<li>线程切换对象是操作系统，切换时机是os设置的切换恶略。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。</li>
<li>协程切换者是用户（准确的说是用户态的操作者，可以是编译器或应用程序），切换时机是用户自己的程序决定的。协程切换内容是硬件上下文，切换内存保存在用户自己的变量（用户堆、栈）中。切换过程只有用户态，即没有陷入内核态，因此切换效率更高。</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/post/12bcd26e/</url>
    <content><![CDATA[<h1 id="学习课程"><a href="#学习课程" class="headerlink" title="学习课程"></a>学习课程</h1><p><a href="https://www.coursera.org/learn/game-theory-1">博弈论 | Coursera</a></p>
<h1 id="intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>博弈论研究的是 两位自利者的策略性互动 </p>
<p>这些学科共同点，在于它们都关心自利者在策略性互动当中如何做 ，同时考虑这些互动如何为研究者所建构</p>
<h2 id="self-interested-agents-and-utility-theory"><a href="#Self-Interested-Agents-and-Utility-Theory" class="headerlink" title="Self-Interested Agents and Utility Theory"></a>Self-Interested Agents and Utility Theory</h2><p>Utility Function 收益函数：决定一个局中人对于特定情况的喜恶程度</p>
<p><em>现代博弈论的基础：每个人都试图将期望效益最大化</em></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>Players: who are the decision makers?<ul>
<li>明确主体：<em>政府？公民？企业？员工？</em></li>
</ul>
</li>
<li>Actions: what can the players do?<ul>
<li>明确决策：<em>拍卖行为？投资行为？投票行为？</em></li>
</ul>
</li>
<li>Payoffs: what motivates players?<ul>
<li>明确收益</li>
<li>明确主体对收益的态度：<em>主体是否在乎收益？主体是否在乎别人的收益？</em></li>
</ul>
</li>
<li>Normal Form 范式博弈：以<strong>函数关系</strong>呈现参与者收益与其行为的关系<ul>
<li>参与者同时行动</li>
<li>参与者产生策略</li>
</ul>
</li>
<li>Extensive Form 拓展形式的博弈：<strong>树形图</strong>表示<ul>
<li>新增其他要素<ul>
<li><em>timing</em>，参与者按次序行动，谁会先采取行动，例如<em>下棋、打牌…</em></li>
<li><em>Information</em>，参与者知道自己和其他人所采取的行动的信息</li>
</ul>
</li>
<li>跟踪参与者的决策</li>
</ul>
</li>
</ul>
<h3 id="normal-form-范式博弈模型构建"><a href="#Normal-Form-范式博弈模型构建" class="headerlink" title="Normal Form 范式博弈模型构建"></a>Normal Form 范式博弈模型构建</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/2022%E5%B9%B41%E6%9C%8822%E6%97%A5160817.PNG" alt="范式博弈公式"></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/2022%E5%B9%B41%E6%9C%8822%E6%97%A5160818.PNG" alt="范式博弈矩阵模型"></p>
<p>根据上述模型，形成TCP博弈矩阵</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>C</strong></th>
<th><strong>D</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>C</strong></td>
<td>-1, -1</td>
<td>-4, 0</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>0, -4</td>
<td>-3, -3</td>
</tr>
</tbody>
</table>
</div>
<h3 id="大规模群体的博弈"><a href="#大规模群体的博弈" class="headerlink" title="大规模群体的博弈"></a>大规模群体的博弈</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/2022%E5%B9%B41%E6%9C%8822%E6%97%A5160819.PNG" alt></p>
<h2 id="nash-equilibrium-纳什均衡"><a href="#Nash-Equilibrium-纳什均衡" class="headerlink" title="Nash Equilibrium  纳什均衡"></a>Nash Equilibrium  纳什均衡</h2><h3 id="凯恩斯选美博弈股票买卖的例子"><a href="#凯恩斯选美博弈：股票买卖的例子" class="headerlink" title="凯恩斯选美博弈：股票买卖的例子"></a>凯恩斯选美博弈：股票买卖的例子</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/2022%E5%B9%B41%E6%9C%8822%E6%97%A5160820.PNG" alt></p>
<h2 id="strategic-reasoning-决策推理"><a href="#Strategic-Reasoning-决策推理" class="headerlink" title="Strategic Reasoning 决策推理"></a>Strategic Reasoning 决策推理</h2>]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>Game Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据论文课程学习</title>
    <url>/post/ff0a1714/</url>
    <content><![CDATA[<h1 id="学习课程"><a href="#学习课程" class="headerlink" title="学习课程"></a>学习课程</h1><p><a href="https://time.geekbang.org/column/intro/100091101">大数据经典论文解读 (geekbang.org)</a></p>
<h1 id="何为大数据"><a href="#何为大数据" class="headerlink" title="何为大数据"></a>何为大数据</h1><h2 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h2><p>wiki解释：<a href="https://en.wikipedia.org/wiki/Big_data">Big data - Wikipedia</a></p>
<p>即传统数据处理应用软件时，不足以处理的大的或者复杂的数据集的术语。换句话说，就是<strong>技术上的老办法行不通了，必须使用新办法才能处理的数据</strong>就叫大数据。</p>
<ol>
<li><strong>能够伸缩到一千台服务器以上的分布式数据处理集群的技术</strong><ul>
<li>传统的并行数据库技术尝试处理海量数据，但这些并行数据库单个集群只有<strong>几十数量级的服务器</strong></li>
<li>2003年，<strong>Google 的 GFS 的论文</strong>，单个集群里就可以有<strong>上千数量级的节点</strong></li>
</ul>
</li>
<li><strong>这个上千个节点的集群，是采用廉价的 PC 架构搭建起来的。</strong><ul>
<li>不用超算或专用存储设备，“大数据”技术<strong>在硬件层面，是完全架设在开放的 PC 架构下的</strong></li>
</ul>
</li>
<li><strong>“把数据中心当作是一台计算机”（Datacenter as a Computer）。</strong><ul>
<li>所有的“大数据”框架，都希望就算没有“大数据”底层技术知识的工程师，也能很容易地处理海量数据。</li>
</ul>
</li>
<li>总结：大型集群让处理海量数据变得<strong>“可能”</strong>；基于开放的 PC 架构，让处理海量数据变得“便宜”；而优秀的封装和抽象，则是让处理海量数据变得<strong>“容易”</strong>。这也是现在谁都能用上大数据技术的基础。</li>
</ol>
<h2 id="大数据的三驾马车"><a href="#大数据的三驾马车" class="headerlink" title="大数据的三驾马车"></a>大数据的三驾马车</h2><h3 id="三个核心架构"><a href="#三个核心架构" class="headerlink" title="三个核心架构"></a>三个核心架构</h3><ul>
<li><p><strong>存储 GFS</strong></p>
<ul>
<li>核心功能<ul>
<li>存储数据——分布式文件系统</li>
<li>并发写入——顺序写入</li>
</ul>
</li>
<li>不足和缺陷<ul>
<li>缺乏高可用性</li>
<li>“至少一次”的弱一致性</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>计算 MapReduce</strong>——通过借鉴 Lisp，Google 利用简单的 Map 和 Reduce 两个函数，对于海量数据计算做了一次抽象</p>
<ul>
<li><p>核心功能</p>
<ul>
<li>数据本地化的并行机损</li>
<li>系统容错和自动恢复</li>
</ul>
</li>
<li><p>不足和缺陷</p>
<ul>
<li>计算模型简单</li>
<li>海量硬盘读写</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>在线服务 Bigtable</strong> ——直接使用 GFS作为底层存储，来做好集群的分片调度，以及利用 <strong>MemTable+SSTable 的底层存储格式</strong>，来解决大集群、机械硬盘下的高性能的随机读写问题。</p>
<ul>
<li>核心功能<ul>
<li>在线服务</li>
<li>高性能随机读写</li>
<li>自动调度和分片</li>
</ul>
</li>
<li>不足和缺陷<ul>
<li>缺少Schema</li>
<li>缺少跨行事务</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>核心功能<ul>
<li>在线服务</li>
<li>高性能随机读写</li>
<li>自动调度和分片</li>
</ul>
</li>
<li>不足和缺陷<ul>
<li>缺少Schema</li>
<li>缺少跨行事务</li>
</ul>
</li>
</ul>
<h3 id="两个基础设施"><a href="#两个基础设施" class="headerlink" title="两个基础设施"></a>两个基础设施</h3><ul>
<li>一致性问题：<ul>
<li>实现了 Paxos 算法的 <strong>Chubby 锁服务</strong>——保障数据一致性的分布式锁</li>
</ul>
</li>
<li>系统之间通信问题 + 数据存储格式化问题：<ul>
<li>RPC：数据序列化和分布式系统之间通信的实现——通过 Thrift 序列化：我们要预知未来才能向后兼容吗？</li>
</ul>
</li>
</ul>
<h2 id="三家马车的进化方向"><a href="#三家马车的进化方向" class="headerlink" title="三家马车的进化方向"></a>三家马车的进化方向</h2><p>一个新系统的设计当然不能用一句话概括，也不是理所当然如此。<strong>任何一个新系统都是为了解决前一个系统的不足之处</strong>。</p>
<p><img src="C:\Users\m1885\AppData\Roaming\Typora\typora-user-images\image-20220301231317621.png" alt="image-20220301231317621"></p>
<p><img src="C:\Users\m1885\AppData\Roaming\Typora\typora-user-images\image-20220301231607528.png" alt="image-20220301231607528"></p>
<p><img src="C:\Users\m1885\AppData\Roaming\Typora\typora-user-images\image-20220301231725889.png" alt="image-20220301231725889"></p>
<h2 id="小结-论文清单"><a href="#小结-论文清单" class="headerlink" title="小结 论文清单"></a>小结 论文清单</h2><h1 id="知识网络"><a href="#知识网络" class="headerlink" title="知识网络"></a>知识网络</h1><p><img src="C:\Users\m1885\AppData\Roaming\Typora\typora-user-images\image-20220301232105100.png" alt="image-20220301232105100"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读笔记——基于大数据的数据模式挖掘研究</title>
    <url>/post/96a2640/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="2-日志数据挖掘"><a href="#2-日志数据挖掘" class="headerlink" title="2. 日志数据挖掘"></a>2. 日志数据挖掘</h2><h3 id="21-特征工程难点"><a href="#2-1-特征工程难点" class="headerlink" title="2.1 特征工程难点"></a>2.1 特征工程难点</h3><ul>
<li>难以快速理解复杂的业务逻辑和业务背景</li>
<li>基础数据不全面、不完整</li>
<li>某些数据的采集非常有难度，或是暂时没有行之有效的采集和处理方法，如某些自然语言的特征</li>
</ul>
<h3 id="22-日志数据挖掘目标"><a href="#2-2-日志数据挖掘目标" class="headerlink" title="2.2 日志数据挖掘目标"></a>2.2 日志数据挖掘目标</h3><h4 id="221-多维分析"><a href="#2-2-1-多维分析" class="headerlink" title="2.2.1 多维分析"></a>2.2.1 多维分析</h4><p>在不同维度上对数据进行汇总和整理，并通过结合业务问题，或者与其他对象进行对比，以期发现相同的规律或业务内在流程和提升方式。通过对数据进行定期的总结，可以实现<em>对业务在实际数据上的全盘掌握</em>。</p>
<p>利用<em>传统的统计方法来统计数据库中的数据或进行多维数据查询和计算</em>。</p>
<p>日志数据挖掘——使用平台对日志进行统计分析和可视化。</p>
<h4 id="222-关联分析"><a href="#2-2-2-关联分析" class="headerlink" title="2.2.2 关联分析"></a>2.2.2 关联分析</h4><p>通过<em>对数据项集之间的共现关系的计算</em>，以及<em>对于项集间的<strong>支持度</strong>和<strong>置信度</strong>的要求</em>，从而导出项集之间的<strong>关联规则</strong>。</p>
<p>日志数据挖掘——对warning日志的因果关联分析，进行错误检测。</p>
<h4 id="223-分类和预测"><a href="#2-2-3-分类和预测" class="headerlink" title="2.2.3 分类和预测"></a>2.2.3 分类和预测</h4><p>通过对已有数据和结论进行分析来对未知事物进行判断。</p>
<p>日志数据挖掘——对warning日志的分析来进行故障的预测。</p>
<h4 id="224-聚类分析"><a href="#2-2-4-聚类分析" class="headerlink" title="2.2.4 聚类分析"></a>2.2.4 聚类分析</h4><p>根据对象在各维度上的<strong>相似性判别指标</strong>进行聚类，使得在同一个类中的对象可以无监督地进行类别区分。</p>
<p>日志数据挖掘——通过对web日志数据的聚类分析，对web日志进行聚类以减少页面数据量。</p>
<h4 id="225-孤立点分析"><a href="#2-2-5-孤立点分析" class="headerlink" title="2.2.5 孤立点分析"></a>2.2.5 孤立点分析</h4><p>虽然孤立点在进行规律总结是会被认为是异常点或是噪声，从而被排除。但是在某些应用中国，孤立点本省就是挖掘的目的所在。</p>
<p>日志数据挖掘——通过对使用日志的异常点分析，从而发现登录数据中的异常登录行为。</p>
<h4 id="226-时间序列分析"><a href="#2-2-6-时间序列分析" class="headerlink" title="2.2.6 时间序列分析"></a>2.2.6 时间序列分析</h4><p>数据的属性值随时间不断变化，而且这类变化还可能与时间周期有一定关系。这些数据一般在相等或不等的时间间隔内取得，通过<strong>时间序列图</strong>的方法还可以对时间序列数据进行可视化，更直观地发现序列规律。</p>
<h3 id="23-日志数据挖掘常用算法"><a href="#2-3-日志数据挖掘常用算法" class="headerlink" title="2.3 日志数据挖掘常用算法"></a>2.3 日志数据挖掘常用算法</h3><h4 id="231-分类与回归预测算法"><a href="#2-3-1-分类与回归预测算法" class="headerlink" title="2.3.1  分类与回归预测算法"></a>2.3.1  分类与回归预测算法</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">算法名称</th>
<th style="text-align:left">算法描述</th>
<th style="text-align:left">使用场景</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BP(Back Propagation, 反向传播)</td>
<td style="text-align:left">按<strong>误差逆传播算法</strong>训练的多层反馈网络</td>
<td style="text-align:left">电信客户分析识别</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">LM(Levenberg-Marquardt)</td>
<td style="text-align:left">基于<strong>梯度下降法</strong>和<strong>牛顿法</strong>结合的优化算法，特点是迭代次数少，收敛速度快，精准度高</td>
<td style="text-align:left">证券策略投资、水质样本评价</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">FNN(Fuzzy Neural Network, 模糊神经网络)</td>
<td style="text-align:left">具有模糊权系数或者输入信号是模糊量的神经网络，是<strong>模糊系统</strong>和<strong>神经网络</strong>相结合的产物，汇聚了神经网络和模糊系统的优点</td>
<td style="text-align:left">用户服务感知</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">RBF(Radial Basis Function, 径向基函数)</td>
<td style="text-align:left">具有<strong>单隐层</strong>的<strong>三层前馈网络</strong>。是一种局部逼近网络，能够以任意精度逼近任意连续函数，特别适合解决分类问题。</td>
<td style="text-align:left">桩基完整性检测、企业客户关系分析</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">ANFIS(Adaptive Neural Fuzzy Inference System, 自适应神经模糊推理网络)</td>
<td style="text-align:left">功能上与一<strong>阶T-S模糊推理系统</strong>等价的<strong>自适应网络</strong></td>
<td style="text-align:left">交叉路口信号灯控制</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">WNN(Wavelet Neural Network, 小波神经网络)</td>
<td style="text-align:left">基于<strong>小波变换</strong>而构成的神经网络模型，即用非线性小波基代替通常的神经元非线性激励函数</td>
<td style="text-align:left">智能复合材料应变损伤位置的诊断</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">SVM(Support Vector Machine, 支持向量机)</td>
<td style="text-align:left">支持向量机根据有限的样本信息在模型的复杂性和学习能力之间寻求最佳折中</td>
<td style="text-align:left">生物质废物混合厌氧消化有事组合互补机制</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">CART(Classification And Regression Tree, 分类与回归树)</td>
<td style="text-align:left"><strong>非参数分类和回归方法</strong>，通过构建树、修建树、评估树来构建一个二叉树</td>
<td style="text-align:left">纳税评估模型</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">朴素贝叶斯</td>
<td style="text-align:left">根据特征属性，计算<strong>某个输入分类项属于某个类别的概率</strong>，选择其中最大的作为其类别</td>
<td style="text-align:left">检测SNS社区中不真实账户</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">贝叶斯网络</td>
<td style="text-align:left">基于<strong>概率推理</strong>的图形化网络</td>
<td style="text-align:left">解决复杂设备不确定性和关联性引起的故障</td>
</tr>
</tbody>
</table>
</div>
<h4 id="232-聚类算法"><a href="#2-3-2-聚类算法" class="headerlink" title="2.3.2 聚类算法"></a>2.3.2 聚类算法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>主要算法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>划分（分裂）方法</td>
<td>K-means(K-平均值)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>K-MEDOIDS(K-中心值)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>CLARAND(基于选择的算法)</td>
<td></td>
</tr>
<tr>
<td>层次方法</td>
<td>BIRCH(平衡迭代规约和聚类)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>CURE(代表点聚类)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>CHAMELEON(动态模型)</td>
<td></td>
</tr>
<tr>
<td>基于密度的方法</td>
<td>DBSCAN(基于高密度连续区域)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>DENCLUE(密度分布函数)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>OPTICS(对象排序识别)</td>
<td></td>
</tr>
<tr>
<td>基于网格的方法</td>
<td>STING(统计信息网络)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>CLIOUE(聚类高维空间)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>WAVE-CLUSTER(小波变换)</td>
<td></td>
</tr>
<tr>
<td>基于模型的方法</td>
<td>统计学方法</td>
<td></td>
</tr>
<tr>
<td></td>
<td>神经网络方法</td>
</tr>
</tbody>
</table>
</div>
<h4 id="233-关联规则"><a href="#2-3-3-关联规则" class="headerlink" title="2.3.3 关联规则"></a>2.3.3 关联规则</h4><div class="table-container">
<table>
<thead>
<tr>
<th>算法名称</th>
<th>算法描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apriori</td>
<td>挖掘布尔关联规则频繁项集的算法。核心是基于两阶端频基思想的递推算法</td>
<td></td>
</tr>
<tr>
<td>FP-Tree</td>
<td>不产生候选挖掘频繁项集的方法</td>
<td></td>
</tr>
<tr>
<td>灰色关联法</td>
<td>分析和确定各因素之间的影响程度或若干子因素（子序列）对主因素（母序列）的贡献程度而进行的一种分析方法</td>
<td></td>
</tr>
<tr>
<td>HotSpot</td>
<td>挖掘得到通过树状结构显示的感兴趣的目标最大化/最小化的一套规则，最大化/最小化的利益目标变量/值</td>
</tr>
</tbody>
</table>
</div>
<p><a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201802&amp;filename=1018168975.nh&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9ydkpoNVhhbm45WFhxV0VMYzRMQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MjU2NTExVDNxVHJXTTFGckNVUkxPZVplUnJGQ2puVkwzS1ZGMjZGcksrRnRqTHFwRWJQSVI4ZVgxTHV4WVM3RGg=">参考文献</a></p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>data mining</tag>
      </tags>
  </entry>
  <entry>
    <title>控制冗余的反范式模式</title>
    <url>/post/1a233e39/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="pattern-1-合并一对一关系"><a href="#Pattern-1-合并一对一关系" class="headerlink" title="Pattern 1 合并一对一关系"></a>Pattern 1 合并一对一关系</h2><p>该模式较为常见，风险低</p>
<p><strong>问题</strong>：引入空值</p>
<p>可能产生空值的字段要拒绝可能的比较操作</p>
<h2 id="pattern2-加入非键值减少关联操作"><a href="#Pattern2-加入非键值减少关联操作" class="headerlink" title="Pattern2 加入非键值减少关联操作"></a>Pattern2 加入非键值减少关联操作</h2><p>最常见</p>
<p>不需要进行关联 joins</p>
<p>直接将需要的非键值拷贝到另一表中</p>
<h2 id="pattern3-添加外键减少关联join"><a href="#Pattern3-添加外键减少关联join" class="headerlink" title="Pattern3 添加外键减少关联join"></a>Pattern3 添加外键减少关联join</h2><p>传递参数出现的问题 需要每次查询都进行三表链接</p>
<p>直接在底层表添加外键</p>
<h2 id="pattern4-在关系中复制列减少关联join"><a href="#Pattern4-在-关系中复制列减少关联join" class="headerlink" title="Pattern4 在:关系中复制列减少关联join"></a>Pattern4 在<em>:</em>关系中复制列减少关联join</h2><h2 id="pattern5-重复组"><a href="#Pattern5-重复组" class="headerlink" title="Pattern5 重复组"></a>Pattern5 重复组</h2><h2 id="pattern6-创建提取表"><a href="#Pattern6-创建提取表" class="headerlink" title="Pattern6 创建提取表"></a>Pattern6 创建提取表</h2><p>查询的结果集先放在一张提取表，下一次查询就直接查提取表</p>
<p>需要定时做多表连接查询，更新提取表数据</p>
<p>立竿见影，几乎都能提高效率</p>
<p>不建议：饮鸩止渴吧。开始有快速的效率反馈，使之被频繁使用，容易剑走偏锋、走火入魔 。使用时间长了，提取表会特别多且庞大十分不适合维护，影响其他技术人员更新。</p>
<h2 id="pattern7-分区表"><a href="#Pattern7-分区表" class="headerlink" title="Pattern7 分区表"></a>Pattern7 分区表</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>对广告系统的理解</title>
    <url>/post/63d5ed22/</url>
    <content><![CDATA[<h1 id="何为广告系统-加坑"><a href="#何为广告系统-加坑" class="headerlink" title="何为广告系统 加坑"></a>何为广告系统 加坑</h1>]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>常识性法律案件</title>
    <url>/post/a65cf062/</url>
    <content><![CDATA[<h1 id="常识性案例"><a href="#常识性案例" class="headerlink" title="常识性案例"></a>常识性案例</h1><h2 id="一-孙志刚案件"><a href="#一、-孙志刚案件" class="headerlink" title="一、 孙志刚案件"></a>一、 孙志刚案件</h2><p><a href="https://zh.wikipedia.org/wiki/孙志刚事件">孙志刚事件 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a href="https://baike.baidu.com/item/孙志刚事件/4430559">孙志刚事件_百度百科 (baidu.com)</a></p>
<p><a href="https://www.chinacourt.org/article/detail/2003/11/id/93752.shtml">一个公民的最后60个小时——孙志刚案大事记-中国法院网 (chinacourt.org)</a></p>
<blockquote>
<p>原籍湖北黄冈的孙志刚被广州市人民政府执法机关以<a href="https://zh.wikipedia.org/wiki/三無">三无</a>人员的理由收押，拘禁期间被收容所员工殴打身亡的事件。此事件虽经官方声称为收容所员工犯罪的个案，却引发了中国国内对<a href="https://zh.wikipedia.org/wiki/收容遣送制度">收容遣送制度</a>的大讨论。中华人民共和国政府之后颁发新法规，废除了广泛被认为是有弊端漏洞、并有违宪指责的<a href="https://zh.wikipedia.org/wiki/收容遣送制度">收容遣送制度</a>。</p>
<p>——wiki百科</p>
<p>孙志刚事件和三博士上书全国人大常委会事件，也许将被记入中国依法治国的历史之中：这是<strong>中国公民首次行使违宪审查建议权</strong>，由此引发的关于全国人大应当尽快启动违宪审查制度的讨论，也将对中国依法治国的进程起到一定的推动作用。</p>
<p>——中国法院网</p>
<p>因一个人的死亡而引发国务院出台了新的《城市生活无着的流浪乞讨人员救助管理办法》。从“收容”变“救助”，湖北青年孙志刚付出了生命的代价——一个自由公民，在自己的国家因为没有携带证件而被活活打死。在媒体和学界关注下，国务院出台了新的《城市生活无着的流浪乞讨人员救助管理办法》。旧制度开始松动，但是暴露出的城乡二元结构对立、公民自由迁徙权、违宪审查机制等问题，还需要更长时间的努力。</p>
<p>……</p>
<p>鉴于中国的现实情况和城市稳定发展的需要，现实的选择是：在剥离收容遣送制度的强制人身自由的权能，恢复其救济、教育和安置的初始功能后，收容遣送制度（这一制度的名称可以探讨）也许仍将继续存在。这也是上书的三位公民所希望的。</p>
<p>要实现这一目的，无论是选择撤销或废止该办法，重新制定相关法规，还是选择彻底修改该办法，有两点必须坚持：一是必须排除其强制人身自由的权能。对违法行为可以适用行政处罚法、治安管理处罚条例等进行处理，必要时可以修改治安管理处罚条例，使其包含原收容遣送办法的某些内容。二是对适用对象和执法程序要做严格规定。比如执法时必须履行一定的手续，必须听取行政相对人的申辩，收容对象只能限于流浪乞讨人员，不能包含民工等，使这一制度真正起到动员政府有关部门和社会力量共同救助流浪乞讨人员的作用。</p>
<p>——百度百科</p>
</blockquote>
<h2 id="二-李慧娟河南洛阳种子案法的位阶问题"><a href="#二、-李慧娟——河南洛阳种子案：法的位阶问题" class="headerlink" title="二、 李慧娟——河南洛阳种子案：法的位阶问题"></a>二、 李慧娟——河南洛阳种子案：法的位阶问题</h2><p><a href="http://blog.sina.com.cn/s/blog_722136880102f0ab.html">[转载]李慧娟——河南洛阳种子案_李振功律师_新浪博客 (sina.com.cn)</a></p>
<ul>
<li><p>中国的法官并没有宣布法律条款无效的权利，而本案法官作出了此判决，自然涉及到了一个越权的问题。</p>
<p>该法官当时需要决定的，就是在相抵触的法律与地方性法规中间选择来作为本案依据。该法官可根据相关法律来避开地方性法规的约束，《中华人民共和国立法法》第79条规定：法律的效力高于行政法规、地方性法规、规章。北大一位法学博士向记者分析说，从法理上讲<strong>法理的无效</strong>分为三种情况，一是法理本身规定的失效时间已到，该法律即告无效；二是国家制定了新的法律，明确宣告旧法失效，此谓“宣告无效”；三是《立法法》六十四条规定之情形，上位法与下位法抵触之条款自然无效。 </p>
</li>
<li><p>本案暴露出来的<strong>立法漏洞</strong>在于地方人大制定的法规、包括国务院行政法规如果违法了怎么办？按照现存法律，只有全国人民代表大会才能撤销国务院行政法规和地方性人大法规，但是全国人大从来都没有撤销过；其次，全国人大对这方面也并没有任何专门规定具体操作办法，撤销程序也并不明确。 </p>
</li>
<li><p>国家行政学院杜钢建教授认为，<strong>李慧娟事件是我们促进统一法治秩序和统一市场秩序进程中的标志性事件之一</strong>。入世前中央已经在对一系列的法律法规，包括地方法规进行了清理，而且从2000年至去年的清理力度更大，很有成效。但问题依然很多，具体表现在：<strong>中国目前的市场经济是一种缺少统一市场秩序的市场经济，没有一个在一个主权国家中应有的以宪法法律尊严为基础的市场经济</strong>。</p>
</li>
<li><p>各级人民法院<strong>没有合宪性审查权，只有合法性审查权</strong>，即对行政法规和地方法规是否符合法律的审查权力。这种只有法规合法性审查权的司法审查权就是<strong><em>有限司法审查权</em></strong>。“与完整的司法审查权相比，有限司法审查权有以下特点</p>
<ol>
<li>没有合宪性审查权，只有合法性审查权；</li>
<li>限于对行政法规和地方法规以及各种规章的合法性进行审查，没有对法律和宪法进行评判的权力；</li>
<li>对行政法规和地方法规以及各种规章的合法性所作的审查和评判，效力只限于具体个案，对其他法院和案件没有必然的效力；</li>
<li>限于对与法律相抵触条款的效力作出评判，对整部行政法规、地方法规或规章的效力不做评判；</li>
<li>所作评判不是最终的，当事人和制定机关有异议，可以向全国人民代表大会常务委员会申请对争议中的法律条款做出最终裁决。”</li>
</ol>
</li>
<li><p><a href="https://www.zhihu.com/question/41447309">用人工智能辅助法官判案可行么？ - 知乎 (zhihu.com)</a></p>
</li>
</ul>
<h2 id="三-辛普森杀妻案程序正义-疑罪从无"><a href="#三、辛普森杀妻案：程序正义、疑罪从无" class="headerlink" title="三、辛普森杀妻案：程序正义、疑罪从无"></a>三、辛普森杀妻案：程序正义、疑罪从无</h2><blockquote>
<p>1994年，前美式橄榄球运动员辛普森(O.J. Simpson)杀妻一案成为当时美国最为轰动的事件。此案当时的审理一波三折，辛普森(O.J. Simpson)在用刀杀前妻及餐馆的侍应生郎·高曼两项一级谋杀罪的指控中，由于警方的几个重大失误导致有力证据的失效，以无罪获释，仅被民事判定为对两人的死亡负有责任。<strong>本案也成为美国历史上疑罪从无的最大案件。</strong></p>
<p>辛普森在刑事审判中共花了近1000万美元，他请了最有才能的律师、最有名的刑侦专家，甚至是科学家，后面这些专家也许不一定有意偏袒被告，而是表述自己的专业知识和经验。</p>
<p>在美国的司法体制中，只依赖间接证据就把被告定罪判刑绝非易事。由于检方证据全都是间接证据，因此，辩方律师对这些“旁证”进行严格鉴别和审核，是这场官司中极为重要的一环。而检方呈庭的证据破绽百出，难以自圆其说，使辩方能够以比较充足的证据向陪审团证明辛普森未必就是杀人凶手。比如，检方呈庭的重要证据二——黑色血手套（上面有受害人和辛普森的血迹），辛普森在法庭上折腾了很久都戴不上。</p>
<p>戏剧性的是，本案中检方的“明星”证人福尔曼警官，被举报称其有“种族歧视”倾向（后来他也因为作伪证被判三年有期徒刑，狱外监管）；警方在现场勘查过程中也犯了常识性错误；警方涉嫌非法搜查；警方带着辛普森的血迹回过现场（辩方以此怀疑可能是伪造证据）</p>
</blockquote>
<h2 id="四-齐玉苓案宪法司法化问题"><a href="#四、齐玉苓案：宪法司法化问题" class="headerlink" title="四、齐玉苓案：宪法司法化问题"></a>四、齐玉苓案：宪法司法化问题</h2><p>1990年，<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%8E%9F%E5%91%8A/433945">原告</a>齐玉苓与被告之一陈晓琪都是山东省滕州市第八中学的初中学生，都参加了中等专科学校的预选考试。陈晓琪在预选考试中成绩不合格，失去继续参加统一招生考试的资格。而齐玉苓通过预选考试后，又在当年的统一招生考试中取得了超过委培生录取分数线的成绩。<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%B1%B1%E4%B8%9C%E7%9C%81/209822">山东省</a><a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%B5%8E%E5%AE%81%E5%95%86%E4%B8%9A%E5%AD%A6%E6%A0%A1/7749257">济宁商业学校</a>给齐玉苓发出录取通知书，由滕州八中转交。陈晓琪从滕州八中领取齐玉苓的录取通知书，在其父亲陈克政的策划下，运用各种手段，以齐玉苓的名义到济宁商校就读直至毕业。毕业后，陈晓琪仍然使用齐玉苓的姓名，在<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E9%93%B6%E8%A1%8C/245376">中国银行</a>滕州支行工作。</p>
<p>本案一审在枣庄市中级人民法院审理后，认定齐玉苓的姓名权被侵害；但是对于齐玉苓的受教育权，认定其已放弃，不能成立。随后，齐玉苓向山东省管高级人民法院提起上诉。山东省高级人民法院在审理中认为，这个案件存在适用法律方面的疑难问题，因此依照《<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E4%BA%BA%E6%B0%91%E6%B3%95%E9%99%A2%E7%BB%84%E7%BB%87%E6%B3%95/7545124">中华人民共和国人民法院组织法</a>》第32条 [1] 的规定，报请最高人民法院进行解释。最高人民法院经过研究后，作出了《关于以侵犯姓名权的手段侵犯宪法保护的公民受教育的基本权利是否应承担民事责任的批复》。在《批复》中，认定“齐玉苓要求各被上诉人承担侵犯其受教育权的责任，理由正当，应予支持”</p>
<p>本案的争议在于宪法是否可以直接作为裁判案件的法律依据。</p>
<h2 id="五-延安黄碟案警察能否随意闯入私人空间"><a href="#五、延安黄碟案：警察能否随意闯入私人空间" class="headerlink" title="五、延安黄碟案：警察能否随意闯入私人空间"></a>五、延安黄碟案：警察能否随意闯入私人空间</h2><p>2002年8月18日23时，延安市公安局宝塔分局万花山派出所前往当事人张某所开诊所（也系张某与其妻的卧室），发现张某与其妻在看黄碟，欲查处和收缴黄碟，在扣押机器和黄碟的过程中，张某将一名警察的手打伤，当事人则称警察先动手打人；当晚，张某被警察带往派出所留置并审查。</p>
<p>2002年8月20日，陕西当地媒体《华商报》以《家中看黄碟，民警上门查》为题，开始对此事予以报道，随后引起社会各界的广泛关注，并由此引发了有关“公权是否有权干涉私权空间”的大讨论；2002年8月22日，宝塔公安分局决定对张某打伤民警的行为以妨碍公务罪立案，并由分局治安大队调查；2002年10月21日，张某被宝塔公安分局以涉嫌妨碍公务罪刑事拘留；2002年10月25日，宝塔公安分局向宝塔区人民检察院提请批捕犯罪嫌疑人张某；2002年11月4日，宝塔区检察院作出不批准逮捕决定，并送达公安机关；2002年11月5日，宝塔公安分局对张某变更强制措施，取保候审；2002年12月5日，宝塔公安分局解除对张某的取保候审，并宣布撤销该案；2002年12月25日，张某向宝塔公安分局提出国家赔偿申请书，并要求公安机关恢复名誉、赔礼道歉，处理相关责任人；2002年12月31日，宝塔公安分局和张某在案件调查小组的主持下达成处理协议，协议规定由宝塔公安分局向当事人赔礼道歉，一次性补偿张某29137元人民币，并处理相关责任人员。</p>
<p>争议：本案中大众舆论倾向于是公权力与隐私的冲突，而苏力在其文章中提供了不同的角度“几乎所有法律人都断然说没有，至少从未提起，都说这对夫妇是在自己家中看黄碟。所有学术和实务法律人似乎都有意忽视了一个明明白白摆在这里无人争议但对分析此事件至关重要的细节：“民警接到了群众的电话举报”。这只是一点点事实。”</p>
<h2 id="六-沙利文案批评官员的尺度官员-政府机构是否享有名誉权"><a href="#六、沙利文案：批评官员的尺度，官员、政府机构是否享有名誉权" class="headerlink" title="六、沙利文案：批评官员的尺度，官员、政府机构是否享有名誉权"></a>六、沙利文案：批评官员的尺度，官员、政府机构是否享有名誉权</h2><h2 id="七-马伯里诉麦迪逊案件"><a href="#七、马伯里诉麦迪逊案件" class="headerlink" title="七、马伯里诉麦迪逊案件"></a>七、马伯里诉麦迪逊案件</h2><h2 id="八-及中国的公序良俗泸州二奶遗赠案司法自治"><a href="#八、及中国的公序良俗，泸州二奶遗赠案；司法自治" class="headerlink" title="八、及中国的公序良俗，泸州二奶遗赠案；司法自治"></a>八、及中国的公序良俗，<strong><em>泸州二奶遗赠案；</em></strong>司法自治</h2><p>四川泸州的黄永彬与妻子蒋伦芳结婚30多年，有一养子。1994年起黄开始与张学英来往，1996年起二人公开同居，依靠黄的工资（退休金）及奖金生活，并曾经共同经营。但黄永彬与蒋伦芳并未离婚。2001年2月起，黄病重住院，蒋伦芳一直在医院照顾，法院认为其尽到了扶养义务。4月18日黄永彬立下遗嘱：“我决定，将依法所得的住房补贴金、公积金、抚恤金和卖泸州市江阳区一套住房售价的一半（即4万元），以及手机一部遗留给我的朋友张学英一人所有。我去世后骨灰盒由张学英负责安葬。”4月20日，该遗嘱在纳溪区公证处得到公证。黄去世后，张根据遗嘱向蒋索要财产和骨灰盒，遭到蒋拒绝。张遂向纳溪区人民法院起诉，请求依据《继承法》的有关规定，判令被告蒋伦芳按遗嘱履行，同时对遗产申请诉前保全。</p>
<p>本案一审判决认定“遗嘱虽是遗赠人黄永斌的真实意思表示且形式上合法，但在实质赠与财产的内容上存在违法之处”；二审则“基于其与上诉人张学英的非法同居关系而订立遗嘱将其遗产和属于被上诉人的财产赠与上诉人”，从而将此遗赠行为判定为“无效民事行为”。</p>
<p>本案的争议焦点：一是法院在审理时直接适用了民法公序良俗的原则，并没有依据具体的《继承法》规则;二是公民张享有的民法上的财产权益是否受“第三者”身份的阻碍;三是黄以遗嘱的形式处分财产的行为是否符合法律的规定。</p>
<h2 id="九-诉讼米兰达诉亚利桑那州案-米兰达警告程序正义"><a href="#九、诉讼——米兰达诉亚利桑那州案、米兰达警告：程序正义；" class="headerlink" title="九、诉讼——米兰达诉亚利桑那州案、米兰达警告：程序正义；"></a>九、诉讼——米兰达诉亚利桑那州案、米兰达警告：程序正义；</h2><h2 id="十-聂树斌案类似的冤假错案-排除规则-刑事诉讼"><a href="#十、-聂树斌案类似的冤假错案、排除规则、刑事诉讼" class="headerlink" title="十、 聂树斌案类似的冤假错案、排除规则、刑事诉讼"></a>十、 聂树斌案类似的冤假错案、排除规则、刑事诉讼</h2>]]></content>
      <categories>
        <category>法律</category>
      </categories>
      <tags>
        <tag>law</tag>
      </tags>
  </entry>
  <entry>
    <title>广告——商业变现模式</title>
    <url>/post/30560696/</url>
    <content><![CDATA[<p>学习课程：<a href="https://time.geekbang.org/column/intro/100107801">大厂广告产品心法 (geekbang.org)</a></p>
<h1 id="关于商业变现模式"><a href="#关于商业变现模式" class="headerlink" title="关于商业变现模式"></a>关于商业变现模式</h1><p>模式包括但不限于：广告、用户直接付费、佣金分成、金融运作、增值服务等</p>
<h2 id="关于广告模式的问题"><a href="#关于广告模式的问题" class="headerlink" title="关于广告模式的问题"></a>关于广告模式的问题</h2><ol>
<li><p>着手单个产品的商业化，是否应当采取广告变现方式？因为并非所有产品及平台适合广告变现。</p>
</li>
<li><p>广告产品与用户体验的权衡。涉及广告呈现方式、广告出现频率等因子。</p>
</li>
<li><p>广告产品受何种因素的影响？即实现广告模式的变现能力的量化。</p>
<p>其影响因子包括：流量库存和广告占有率、广告创意的制作、用户标签体系和广告定向能力、算法优化与转化能力等等</p>
</li>
</ol>
<h1 id="何为广告产品及其商业模式"><a href="#何为广告产品及其商业模式" class="headerlink" title="何为广告产品及其商业模式"></a>何为广告产品及其商业模式</h1><h2 id="广告"><a href="#“广告”" class="headerlink" title="“广告”"></a>“广告”</h2><blockquote>
<p><strong>广告</strong>（英语：advertising或advertizing），从狭义上讲是一种<a href="https://zh.wikipedia.org/wiki/市场营销">市场营销</a>行为，用于劝说阅听人，通常以引发产品或服务，即商业广告。另一方面从广义上认识广告，它是一切为了沟通信息、促进认识的广告传播活动，无论是否作用于商业领域，是否将营利作为运作目标，只要具备广告的基本特征，都是广告活动，如为增加政治或意识上的支持，例如竞选广告和公益广告。每则广告由<a href="https://zh.wikipedia.org/wiki/訊息">讯息</a>与传递讯息的<a href="https://zh.wikipedia.org/wiki/傳播媒體">媒介</a>构成。广告仅是全部<a href="https://zh.wikipedia.org/wiki/行銷">行销</a>（即营销，市场营销）策略中的一环。行销其他方面包括宣传、公关、推销、竞销等。</p>
</blockquote>
<p>从报纸、TV、PC 到智能手机，主流媒介的变化影响的广告的发展。</p>
<p>PC互联网时代的广告呈现样式：</p>
<p>邮件广告；横幅广告；按钮广告；搜索广告；弹窗广告；富媒体广告；视频贴片广告；其他广告形式，如文字链广告、社交广告等等</p>
<h2 id="产品"><a href="#“产品”" class="headerlink" title="“产品”"></a>“产品”</h2><p>互联网产品大致可分为：</p>
<ol>
<li>用户产品，为了满足用户的使用价值而设计开发的产品</li>
<li>商业产品，为了满足公司的盈利需求而设计开发的产品，包括但不限于 增值服务类产品、电商类产品、内容付费类产品、佣金抽成类产品、技术服务类产品等等</li>
<li>二者不是非此即彼的关系</li>
</ol>
<h2 id="广告产品"><a href="#广告产品" class="headerlink" title="广告产品"></a>广告产品</h2><blockquote>
<p><strong>广告产品是互联网时代的媒体或者技术公司，为了满足广告主向目标消费者推广自身品牌和产品的营销目标，而推出的各种规模化的产品和服务</strong>，包括但不限于直接面向终端用户的硬广、非标准广告，和面向需求方或者内部使用的广告投放平台、程序化广告交易平台、广告数据管理平台等</p>
</blockquote>
<p>类似卖广告牌，属于 To B 的商业产品；</p>
<p>广告产品的商业模式属于双边平台，用户和广告主缺一不可；</p>
<h2 id="商业模式"><a href="#商业模式" class="headerlink" title="商业模式"></a>商业模式</h2><p>所谓商业模式，描述的就是一个企业是如何创造价值、传递价值、获取价值的</p>
<p>广告产品的商业模式包含9个关键要素：客户细分、客户关系、渠道通路、价值主张、关键业务、核心资源、重要伙伴，还有成本结构和收入来源。</p>
<p><img src="https://github.com/ShortPupil/VPicture/blob/main/%E5%B9%BF%E5%91%8A%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F.png?raw=true" alt="广告商业模式.png"></p>
<ol>
<li><p><strong>客户细分</strong>：通过这张商业画布，我们可以看出，百度拥有两种不同类型的客户。一种是普通网民，也就是作为个人的用户；一种是广告主也就是宝洁、奔驰、IBM 这些企业。这些企业还可以细分成各种类型</p>
</li>
</ol>
<p><strong>价值主张</strong>：百度为个人用户提供的是免费的搜索服务，为广告主提供的则是付费的搜索广告。</p>
<p><strong>客户关系、渠道通路、重要伙伴</strong>：用户是通过自助的形式使用免费搜索服务的。中大型广告主由百度的销售团队、百度合作的渠道代理商和广告代理公司，还有第三方服务公司（例如数据统计公司）提供服务。众多小型广告主则通过自助的形式使用百度设计的自助投放平台。</p>
<p><strong>核心资源与关键业务：</strong>百度搜索引擎广告之所以能做起来，关键是首先做起来了百度这样一个具有海量用户和市场领先地位的搜索平台，并且搭建了一套当时国内领先的产品开发和营销服务体系。</p>
<p><strong>成本与利润：</strong>为了支持这样一套商业模式，百度在产品平台建设、广告产品研发和广告产品销售上投入了巨大的成本，而利润主要来自丰厚的广告费用</p>
<h2 id="1-广告产品依附于用户产品用户产品的成功才有可能换来广告产品的成功"><a href="#1-广告产品依附于用户产品，用户产品的成功才有可能换来广告产品的成功" class="headerlink" title="1. 广告产品依附于用户产品，用户产品的成功才有可能换来广告产品的成功"></a>1. 广告产品依附于用户产品，用户产品的成功才有可能换来广告产品的成功</h2><ol>
<li>靠什么样的用户产品去吸引（足够多的）用户?</li>
<li>如果没有用户，广告产品以何种优势吸引广告主支付广告费？</li>
</ol>
<h2 id="2-有效的客户关系和渠道通路管理机制"><a href="#2-有效的客户关系和渠道通路管理机制" class="headerlink" title="2. 有效的客户关系和渠道通路管理机制"></a>2. 有效的客户关系和渠道通路管理机制</h2><ol>
<li>大型客户：对口的销售团队进行沟通协调，以质为先</li>
<li>中小型客户户：伸长渠道代理商的触角，接触、引导广泛中小广告主，以量为先</li>
</ol>
<h1 id="业务链条上的三方如何认识广告产品广告主-媒体-第三方"><a href="#业务链条上的三方如何认识广告产品：广告主、媒体、第三方" class="headerlink" title="业务链条上的三方如何认识广告产品：广告主、媒体、第三方"></a>业务链条上的三方如何认识广告产品：广告主、媒体、第三方</h1><p><img src="https://github.com/ShortPupil/VPicture/blob/main/%E5%B9%BF%E5%91%8A%E4%BA%A7%E5%93%81%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%93%BE%E6%9D%A1.drawio.png?raw=true" alt="广告产品的业务链条.drawio.png"></p>
<h2 id="1-广告主"><a href="#1-广告主" class="headerlink" title="1. 广告主"></a>1. 广告主</h2><p>属于广告产品的最终需求方。<strong>广告主可以根据规模、行业分为各种不同的类别，而你所开发的广告产品，是针对哪一类广告主的，这一点很关键。</strong></p>
<p>广告主，<strong>无论企业规模大小、属于什么行业，本质上都是希望从购买的广告产品中获取最大化的商业价值的。</strong>所以，站在广告主的角度，他们其实是希望我们设计的广告产品能够承诺最终结果的，也就是商品的销售收入。</p>
<h3 id="11-大型企业"><a href="#1-1-大型企业" class="headerlink" title="1.1 大型企业"></a>1.1 大型企业</h3><p>用户访问量大、位置显眼、尺寸大、创意空间丰富的广告产品，首先要针对的是大型企业的广告主，如开屏广告</p>
<h3 id="12-中小型企业"><a href="#1-2-中小型企业" class="headerlink" title="1.2 中小型企业"></a>1.2 中小型企业</h3><p>相对于大型企业，中小型企业对于广告的尺寸、形式和创意空间不那么在意。他们更加注重的是<strong>广告的实际效果</strong>，即广告究竟能不能为他们带来更多的销售额和利润。</p>
<p>例如：搜索关键词竞价广告，最主要的购买者就是中小型广告主</p>
<h2 id="2-媒体平台"><a href="#2-媒体平台" class="headerlink" title="2. 媒体平台"></a>2. 媒体平台</h2><p>媒体平台指的就是诸如百度、腾讯、阿里这样的平台。</p>
<p>站在平台的立场上，作为用户和广告主的中介，一方面要考虑如何为公司带来更多的商业价值，另一方面还要考虑如何平衡用户体验，**因为用户是我们能够为广告主提供广告产品，并从中获取广告收入的根本所在。</p>
<h3 id="21-媒体平台与广告主的博弈"><a href="#2-1-媒体平台与广告主的博弈" class="headerlink" title="2.1 媒体平台与广告主的博弈"></a>2.1 媒体平台与广告主的博弈</h3><p>媒体平台，一般都是不会同意为广告主的销售而负责的，媒体平台最多也就是同意按照广告点击数收取广告费用。因为他们首先要保证用户的体验，首先要保证的还是自己的品牌和产品推广信息可以“广而告之”。</p>
<h3 id="22-广告代理公司"><a href="#2-2-广告代理公司" class="headerlink" title="2.2 广告代理公司"></a>2.2 广告代理公司</h3><p><strong>广告代理公司，顾名思义，就是作为广告主的代表，来和媒体平台打交道，进行广告产品的采购和投放的公司</strong></p>
<p>中国境内的广告代理公司</p>
<ol>
<li>跨国广告代理公司</li>
<li>本土广告代理公司</li>
</ol>
<p><strong>广告代理公司的立场，介于广告主和媒体平台之间。</strong>因为他们除了服务广告主，也要和大的媒体平台保持良好的关系，毕竟市场上有那么多大大小小的跨国或本土的广告代理公司可以选。很多广告代理公司的金牌销售，自己出来单干，只要有好的客户关系，往往也能做起来一个新的代理公司。</p>
<p>广告代理公司在做广告产品的购买和组合方案时，必然不会只考虑广告主的利益，而是会综合考虑自己的利润。在有多个都能被广告主所接受的方案的前提下，广告代理公司倾向于选择自身利润最大化的方案。</p>
<h2 id="3-第三方服务公司"><a href="#3-第三方服务公司" class="headerlink" title="3. 第三方服务公司"></a>3. 第三方服务公司</h2><p>指这些公司既不属于甲方广告主，以及作为甲方代言人的广告代理公司，也不属于乙方媒体平台，而是作为第三方提供相对独立的各种服务。例如：广告数据监测公司、程序化交易主体公司</p>
]]></content>
      <categories>
        <category>商业</category>
      </categories>
      <tags>
        <tag>business</tag>
      </tags>
  </entry>
  <entry>
    <title>干好工作十八法</title>
    <url>/post/ef52ded7/</url>
    <content><![CDATA[<h1 id="干好工作18法-李小三"><a href="#干好工作18法-李小三" class="headerlink" title="干好工作18法 李小三"></a>干好工作18法 李小三</h1><p>好文记录</p>
<p>方法是为达到某种目标而采取的途径、步骤、手段等，是人类认识和改造客观世界的明灯和路标。毛泽东同志曾强调，“我们不但要提出任务，而且要解决完成任务的方法问题。我们的任务是过河，但是没有桥或没有船就不能过。不解决桥或船的问题，过河就是一句空话。不解决方法问题，任务也只是瞎说一顿。”可见方法十分重要，方法得当事半功倍，方法失当事倍功半。方向正确以后，方法便为王。工作中只有掌握科学的工作方法，才能确保高效，圆满完成各项任务，提升工作的境界和水平。</p>
<h2 id="一-不要差不多盯住最完美"><a href="#一、不要差不多，盯住最完美" class="headerlink" title="一、不要差不多，盯住最完美"></a>一、不要差不多，盯住最完美</h2><p>“差不多”是我们平时常说的一句口头语。很多人学习上一知半解、浅尝辄止；工作中只求过得去，不求过得硬，满足于应付了事；生活中粗心大意、随意邋遢等等，其实都是“差不多”心理使然。“差不多”心态看似没有什么大碍，但是若干个小的“差不多”，集中起来就会导致“差很多”，1%的疏漏往往会造成100%的错误，正所谓差之毫厘、谬以千里，上错一点、下错一片，长期下去对工作对事业不利、对自身成长不利、对单位形象也不利。其实质是一个态度问题，与能力基本无关，但与一个人的品行、性格、习惯有关。鲁迅先生曾专门批评过“马马虎虎”现象，胡适先生还写过一篇寓言故事叫《差不多先生》，这位“差不多先生”十字常常写成千字，千字常常写成十字，最终因为找错医生而一命呜呼。故事虽然滑稽可笑，但其处事方式，至今仍是不少人的写照。世界上的事最需要“认真”，也最怕“认真”，所以一定要强化精品意识、细节意识，时刻拥有“没有最好，只有更好”的理念，养成严肃、严格、严谨地对待工作的习惯，绝不忽视任何一个细节，绝不放过任何一个疑点，要做就把一件事做到极致，把“严细实”要求贯穿办文、办会、办事的全过程，切实做到“文经我手无差错、事交我办请放心”，自觉杜绝“差不多”，追求最完美。</p>
<hr>
<h2 id="二-长计划-短安排-立即做"><a href="#二、长计划、短安排、立即做" class="headerlink" title="二、长计划、短安排、立即做"></a>二、长计划、短安排、立即做</h2><p>长计划，就是说要着眼明天、着眼未来、着眼长远。凡事预则立，不预则废。一个对人生和工作有计划的人，他就能胸怀大局、放眼长远，不为一时一地的不利所困。俗话说得好，愚者赚今朝，智者赚明天。有人说，工作天天短平快、年年马拉松。其实这其中也要有一个科学合理的长期计划的问题，切忌贪一时之功、图一时之名，而要脚踏实地、从长计议。当然，不积跬步无以至千里，光有长期计划还不够，还要善于将其具体化、阶段化，也就是要有短安排，从细从实，每天给自己制定一个小的目标，计划好今天要完成的事情，这样不仅可以知道每天要做些什么、做了些什么，还可以对工作进行有效控制，让每一个小目标、短安排的成绩，都成为成功路上的阶梯和里程碑。不管是长计划还是短安排，都要立即行动、马上就办，将工作落到实处，否则都只是一句空话。这样坚持一段时间，就会发现，计划的工作都能如期完成，工作效果也会非常明显，工作给我们带来的快乐也容易获得。只有做到了长计划、短安排，才能真正实现有序、有效；也只有把“立即做”当成自己的座右铭，并形成习惯，才能不断进步。</p>
<hr>
<h2 id="三-日清月结有条不紊"><a href="#三、日清月结，有条不紊" class="headerlink" title="三、日清月结，有条不紊"></a>三、日清月结，有条不紊</h2><p>所谓“日清月结”，是指办理现金出纳业务必须按日清理、按月结账。它原本是一个财务术语，运用到工作当中，就是要“今日事，今日毕”，每过一段时间就及时“回头看”，检查审视一下自己的工作，确保任务不拖延、事情不遗漏。如果今日事明日做，那一定是“日日待明日，明日何其多”，工作就永远拎不清、无章法、效果差。有些人责任心不强，工作没有规划目标，任务稍重一点，就有畏难情绪，找理由拖延，觉得今天做不完的，明天还可以接着做。殊不知今天的事情做不完，明天的事情也会做不完，“躲过了初一，躲不过十五”，在拖延中自己并不快乐，反而会累积许多压力，严重影响工作效率，甚至导致自信心下降。所谓“有条不紊”，就是说话做事有条有理，不打乱仗，这是一个非常重要的习惯，甚至影响一个人的成功和发展。工作往往人少事多，如果缺乏条理性，就会忙乱而效率不高、效果不好。做好日清月结，要统筹规划、有条不紊，不轻视怠慢眼前和当下的工作，把今天该做的做好，把明天要做的计划好、准备好，努力做到事不过夜、案无积卷，从容不迫、井然有序地应对复杂工作。</p>
<hr>
<h2 id="四-学习工作化工作学习化"><a href="#四、学习工作化，工作学习化" class="headerlink" title="四、学习工作化，工作学习化"></a>四、学习工作化，工作学习化</h2><p>所谓“学习工作化，工作学习化”，就是要在学中干、在干中学，两手抓、两不误、两促进。事实反复告诉我们，学习力的高低是人与人之间拉开距离的重要因素。一个人只要做到坚持学习、善于学习、快速地学习，就一定会有所成就。当然，学习既是一件快乐的事，也是一件苦差事，再加上工作任务繁重，如何长久地保持学习激情、提高工作效率，其奥妙就是在学的过程中结合工作，在干的过程中感悟学习，互相启发促进，自然而然就会在心中不断迸发出热情的火花。有人认为，一个人一生中90%的学习都是在工作中实现的，这是有一定道理的。习近平总书记指出：“领导干部学习不学习不仅仅是自己的事情，本领大小也不仅仅是自己的事情，而是关乎党和国家事业发展的大事情。”大家应该把学习作为一种精神追求、一种工作状态、一种生活方式，下得苦功夫，求得真学问。要树立“不学习无以立”的意识，坚持向书本学习、向实践学习，边学边用，边用边学，在学习与工作的良性互动中不断增强本领，超越自我，不能把两者对立起来，搞成“两张皮”。</p>
<hr>
<h2 id="五-注重积累始终在研究状态下工作"><a href="#五、注重积累，始终在研究状态下工作" class="headerlink" title="五、注重积累，始终在研究状态下工作"></a>五、注重积累，始终在研究状态下工作</h2><p>合抱之木，生于毫末；百丈之台，起于垒土。任何事物都要有量的积累才有可能发生质的变化，但也不是说积累越多就越好，如果没有研究和思考，积累也只是把一堆东西堆砌在一起，做一个“储物柜”而已，工作、学习都是如此。每个人都有自身的职能职责，要想做好工作，必须能沉下身来、静下心来、置身事中，广泛了解自身工作所涉及的业务知识，做到底数清、情况明，成为本职工作的通才。有了一定的知识积累，还要注重调查研究，就是用脑子干活做事，不仅苦干实干，还要巧干会干。在面临许多新情况、新问题、新矛盾时，必须在研究状态下工作，提出解决问题的点子、办法，这就要求我们要领会上级的精神、吃透书本的理论、借鉴别人的经验，结合工作实际，身在事之中、心在事之上，把握大局，多谋善断、敢于拍板决策。要强化问题导向、目标导向和效果导向，知行合一，日积月累，就能不断提升自身的专业素养、专业方法、专业能力，就能成为一个专家、成为工作的行家里手。</p>
<hr>
<h2 id="六-信息要对称善于沟通"><a href="#六、信息要对称，善于沟通" class="headerlink" title="六、信息要对称，善于沟通"></a>六、信息要对称，善于沟通</h2><p>现在是信息时代，信息对称、沟通及时十分重要。每个领导干部要有及时获取信息的能力，要有总结归纳信息的能力，要努力成为提供相关信息的源头，要重视沟通协调。沟通是人与人之间思想和信息的交换，是人类集体活动的基础。世界上的事情，都需要沟通，沟通是人们必备的基本能力。及时有效的沟通，才能达成协调一致的意见、形成步调统一的行动。信息对称是做好自身工作、提高工作水平一个很重要的要素。对自己所从事的工作，要了解上面的要求、左右的情况、下面的进展，就要增强主动沟通的意识，确保上情准确下达、下情及时上传，着力构建上下贯通、左右衔接、内外一体、立体交叉的运转体系，实现各方面工作无缝对接，形成“整体一盘棋，同唱一台戏”的良好格局。向上沟通要及时，该请示的请示，该报告的报告，既要提出问题，还要给出意见建议，上级决定了的事项要全力落实；同级沟通要真诚，互相尊重，换位思考，积极配合，不设障碍；对下沟通要体谅，不能蛮横霸道，颐指气使，要准确了解下属的优点和长处，有针对性地安排部署工作，关心关爱下属，增强亲和力、凝聚力。</p>
<hr>
<h2 id="七-分工不分家主动补台"><a href="#七、分工不分家，主动补台" class="headerlink" title="七、分工不分家，主动补台"></a>七、分工不分家，主动补台</h2><p>同心山成玉，协力土变金。刘邦、张良、萧何、韩信相互协作补台才有了大汉天下，廉颇、蔺相如“将相和”才有了赵国的祥和稳定。团队是一个集体，团结协作、主动补台不只是一种工作方法，更是一种品行操守、一种胸怀胸襟。互相补台，好戏连台；互相拆台，一起垮台。工作中有人补台，就可能避免错误，或是将损失降到最低，若是各人自扫门前雪，不管他人瓦上霜，站在城楼看风景，结果“城门失火，殃及池鱼”，一荣俱荣，一损俱损。很多工作不是哪一个部门能单独完成的，同一个部门的工作也不是哪一个人能单独完成的，没有谁可以包打天下。要做到分工不分家，既提高个人单兵作战能力，也提高团队的整体作战能力，超越个体认知和个体力量的局限，发挥1+1&gt;2的效果。班子成员之间、部门之间、同事之间，要重视互相补台，还要善于补台。帮别人补台，当无名英雄，时间久了，大家终会认清你的为人，最后都愿意为你补台。当然，补台也不是说毫无主见的盲从，更重要的是发现问题和不足，大胆提出意见，修正决策，不断完善；补台更不是毫无原则的迁就，对涉及个人利益的小事要讲风格，至于事关原则性的问题，则要敢于“拆台”，这样的拆台恰恰是为大局更好地补台。</p>
<hr>
<h2 id="八-执行有力反馈及时"><a href="#八、执行有力，反馈及时" class="headerlink" title="八、执行有力，反馈及时"></a>八、执行有力，反馈及时</h2><p>一个行动胜过一打纲领。习近平总书记指出：“如果不沉下心来抓落实，再好的目标，再好的蓝图，也只是镜中花、水中月。”对大多数人而言，执行力是第一位的能力。提高执行力，要有强烈的责任感和进取心，要有从小事做起、从点滴做起的实干精神，要有较强的工作能力，要有健全的制度规则作保障，更要有及时反馈的“复命意识”和“划句号”的能力。事毕不回复，就像任务完成了99%，只有这1%没落实，虽然就差这么一丁点，事情却没有到位。实际工作中，绝不能搞先斩后奏、边斩边奏、甚至斩而不奏，也不能等任务全部完成了才反馈，应该注意适时反馈、阶段性反馈，一方面可以让领导和同事放心，另一方面及时反馈情况又能为正确决策提供依据，特别是执行中遇到困难、发现问题时更需要及时反馈，以便重新调整思路和办法，从而更好地化解矛盾、解决问题。只要是和岗位职责有关的事，都要及时反馈，做到凡事有交代、件件有着落、事事有回音。</p>
<hr>
<h2 id="九-跳出自身看自身立足自己看自己"><a href="#九、跳出自身看自身，立足自己看自己" class="headerlink" title="九、跳出自身看自身，立足自己看自己"></a>九、跳出自身看自身，立足自己看自己</h2><p>人生是一个不断认识自我、完善自我的过程，一个人不可能用自己的眼睛完全看清自己，不识庐山真面目，只缘身在此山中。有些人经常自我感觉良好、夜郎自大，就是把自己局限在了一个较为狭窄的时空内，殊不知天外有天、人外有人。认清自我最好的办法就是“跳出自身看自身”。要学会登高望远，放开视野去比较，在一览众山小中看清自己的位置、自己的渺小，看到别人看不到的；要学会用“第三只眼”看自身，不以自我为中心，用旁观者的心态，高出事物的一两个层次来审视自己；要学会以人为镜，见贤思齐，照出自己的差距和不足，明确方向和目标。另一方面，又要找准自己的定位，立足此时此地的人生思考问题，扬长避短，不纠结过往，不忧心未来，做好当下正在做的事，过好眼前的生活，立足自己看自己，这是一切工作的原点。要善于正确认识自己，不能听了几句表扬就妄自尊大、自以为是，也不能挨了几句批评就妄自菲薄、自我否定；要能够搞清楚现状是什么样，未来要怎么发展，吃透上情，了解下情，把自己的潜能发挥到最佳状态，干一行爱一行精一行，活在当下，做好自己。跳出自身看自身，可以看得更加明白；立足自己看自己，能够走得更加顺畅。</p>
<hr>
<h2 id="十-事情要一桩一桩地做"><a href="#十、事情要一桩一桩地做" class="headerlink" title="十、事情要一桩一桩地做"></a>十、事情要一桩一桩地做</h2><p>人们常说，饭要一口一口地吃，日子要一天一天地过，文章要一篇一篇地写，事情要一桩一桩地做。这些都是大白话、大实话，富有哲理。“心急吃不了热豆腐”“一口吃不成大胖子”，我们很多工作都不是一朝一夕、一蹴而就的，有的需要好几年甚至好几届领导班子传承接力，不能急于求成、心浮气躁。明朝吕坤在《续小儿语》中说：“大凡做一件事，就要当一件事；若还苟且粗疏，定不成一件事。”就是说无论什么事情，要取得实效、赢得胜利，都不能东一榔头西一棒槌、打一枪换一个地方，一阵风、不落实，更不能脚踩西瓜皮——滑到哪里算哪里。部门工作事务繁杂，既要会总体把握、分步实施、统筹推进，更要发扬钉钉子精神，一件事不做则已，做必做到底，做到最后胜利。不能三心二意，猴子掰棒子，抓一个丢一个，如果这样就什么事也做不成。要咬定青山不放松，一茬接着一茬干，做好做透做实每一件事，用足够的耐心和韧劲来面对工作生活，不折腾、不反复，久久为功、绵绵用力、一抓到底，积小胜为大胜。</p>
<hr>
<h2 id="十一-想问题-做事情要尽可能合情合理"><a href="#十一、想问题、做事情要尽可能合情合理" class="headerlink" title="十一、想问题、做事情要尽可能合情合理"></a>十一、想问题、做事情要尽可能合情合理</h2><p>人有人情，物有物理，合情合理就是要合乎情理、合乎原则，两者兼顾。现实社会中，有时候合情不一定合理，合理不一定合情。中国自古就是人情社会，“投桃报李”“滴恩泉报”“千里送鹅毛，礼轻情义重”等传统观念在人们的头脑中根深蒂固。人不可能生活在真空里、没有感情，肯定也要讲人情，不近人情的人是缺少情商、缺少魅力和感召力的。但是，人情也有其世俗庸俗乃至功利丑恶的一面，只讲人情不讲原则的人，颠倒人情与原则的关系，丧失自己的立场和原则，迟早要“栽跟头”。当然，情与理也不是完全对立的，一个人既不能太死板机械，更不能太圆滑世故，尤其面对重大利益和重要人事问题，要自觉和严密地设置人情防火墙，自己不去突破，也严防别人逾越。要重视人际关系，但不可刻意去追求搞好人际关系，要学会以简单对复杂，别人复杂，自己要简单。要同情弱者有善心，努力做到情理兼顾，在不好兼顾的情况下，坚持原则就是最好的选择，也是唯一的选择，只有这样才能保全自己，也才能做到“自己不打倒自己，别人永远打不倒你”。</p>
<hr>
<h2 id="十二-自觉按职能职责做事永远忠于职守"><a href="#十二、自觉按职能职责做事，永远忠于职守" class="headerlink" title="十二、自觉按职能职责做事，永远忠于职守"></a>十二、自觉按职能职责做事，永远忠于职守</h2><p>处在什么岗位就要履行什么职责，岗位就是责任，职务就是责任。不管是在公司部门还是在各自的家庭里，每个人都有一定的职能职责，这是我们做事的前提和方向，方向不对，努力白费。明确了职能职责，更要忠于职守，就是忠诚地担起自己的岗位责任和职责操守，时刻提醒自己工作就意味着责任，这是所有职业规范的基本要求。每个人首先要熟悉自己工作岗位的职能职责，对自己职能职责范围内的事，都要主动地去做，尽心尽力地去做，千万不要事事等领导来安排，那不是一个好员工。其实，每个人都做好了自己的本职工作，当好一个“循吏”，那也是大贡献。当然，也要有更高的追求，要努力做个“能吏”，发扬“职业精神”“工匠精神”，以强烈的事业心和责任感来对待工作，自觉做到“有信念，讲规矩、有纪律，讲道德、有品行，讲奉献、有作为”，苦累面前多思得，工作当中多思责，“专心致志，以事其业”，做到在其位、谋其政、负其责、尽其力，干大活、出新彩、干出水平。</p>
<hr>
<h2 id="十三-分清轻重缓急抓本质-抓重点-抓关键"><a href="#十三、分清轻重缓急，抓本质、抓重点、抓关键" class="headerlink" title="十三、分清轻重缓急，抓本质、抓重点、抓关键"></a>十三、分清轻重缓急，抓本质、抓重点、抓关键</h2><p>轻重缓急是指各项工作有主要的和次要的，有急于要办的和可以慢一点办的。面对纷繁复杂的工作，要学会运用辩证法，善于“弹钢琴”，把最重要最紧迫的放在第一位，不太重要不太紧迫的放在第二位，依此类推，分出轻重缓急。要善于紧盯大事要事打攻坚战、紧盯急事难事打歼灭战、紧盯薄弱环节打持久战，牢牢把控工作节奏、力度和质量，善于抓本质抓重点抓关键，切实做到“打鼓打到重心处、工作抓到要害上”。抓本质，就是要善于透过现象看本质，知其然更要知其所以然，客观全面、深刻系统、辩证历史地看问题，坚持打破砂锅问到底，深挖细查，为工作打牢基础。抓重点，就是要抓主要矛盾和矛盾的主要方面，始终能分清主次、合理布局工作力量，以重点带动一般，不平均用力、撒胡椒面，不“眉毛胡子一把抓”，一把抓不如抓一把，都想满把抓反倒都抓不住，要把好钢用在刀刃上。抓关键，就是要把握关键少数，掌控关键环节，认准关键时机，“射人先射马，擒贼先擒王”，牵牛牵住牛鼻子，打蛇打到七寸上，牢牢把握工作主动权，集中精力，扭住不放，持续用力，善作善成。</p>
<hr>
<h2 id="十四-掌握特点把握规律"><a href="#十四、掌握特点，把握规律" class="headerlink" title="十四、掌握特点，把握规律"></a>十四、掌握特点，把握规律</h2><p>特点是事物本身所具有的特别之处，任何事物都有其自身与众不同的特性，也就是个性。但无论事物如何复杂、如何变化，其背后都存在着必然的内在联系和发展趋势，这就是规律，也可以称之为共性。规律具有稳定性、重复性、普遍性和客观性，我们不能任意创造和改变，但可以认识和利用它来改造自然、改造社会、造福人类。实践证明，善于把握规律，才能认识事物发展的轨迹和趋势，形成分析问题、解决问题的新思路和新举措。倘若没有掌握特点、把握规律，将会是盲目推进，不得要领，甚至事与愿违。工作同样如此，不同的部门和岗位都有其自身特点和规律，要想得心应手、从容应对、体现水平，就要掌握特点、把握规律。首先要正视每一件工作的个体性，以高度的责任感和严谨的工作态度，认真对待，全面分析，合理施策，有针对性地把每一个问题解决好、每一项工作落实好。同时，我们所从事的工作和岗位也有共同的规律，不能拍脑袋决策，否则就要吃苦头，造成损失。要善于把平时零碎、肤浅、表面的感性认识，上升为全面、系统、本质的理性认识，使思想和行动既不落后也不超越于客观实际，增强认识规律、找准规律、把握规律的能力，提高运用规律的水平，从而在具体工作中增强主动性和有效性。</p>
<hr>
<h2 id="十五-始终保持适度的紧张感"><a href="#十五、始终保持适度的紧张感" class="headerlink" title="十五、始终保持适度的紧张感"></a>十五、始终保持适度的紧张感</h2><p>生命是需要永远激活的，天有日月星，人有精气神，工作必须在状态。对每一个人来说，压力太大会崩溃，但没有一定的压力，不保持适度的紧张感，对身体、对生命、对工作都是负能量。鲁迅先生有句名言：“生活太安逸了，工作就会被生活所累。”青蛙在温水里待得太久，就会跳不出来；人如果太闲适，就容易生出事、干坏事。井无压力不出油，人无压力轻飘飘，有压力不一定是坏事，适度的紧张感对于一个单位、一个团队、一个组织、一个人的健康等方方面面都有好处，它能使我们不忘“初心”，远离职业倦怠，激发工作热情，始终让思维和行动保持在平均水准以上，甚至可以迸发出超出想象的能力。工作任务重、节奏快，更要人在岗上、岗在心上，时刻警醒、积极适应、快速跟进，在落细落小落实上下功夫，以“一日不为，三日不安”的责任感和“时不我待，只争朝夕”的紧迫感，一心一意谋工作、干事业，推动创新发展。当然，也不能过于紧张，要劳逸结合，生动活泼，正确面对工作、生活、人际关系等多方面的压力，避免造成心理失衡和精神压抑。</p>
<hr>
<h2 id="十六-不多事-不误事-不坏事"><a href="#十六、不多事、不误事、不坏事" class="headerlink" title="十六、不多事、不误事、不坏事"></a>十六、不多事、不误事、不坏事</h2><p>不多事、不误事、不坏事，看似简单，要求不高，实则蕴含深刻。“不多事”就是尽好本职、守好本分，看好自己的门，走好自己的路，做好自己的事，不该看的不看，不该问的不问，不该说的不说，不该做的不做，不越位抢球，不无事生非，做老实人不吃亏。知事晓事不多事，就会太平无事。“不误事”就是勇于担当、敢于负责，坚持高标准、严要求，把岗位作为锻炼自己的舞台，认真履职尽责，把工作作为展示自己才能的载体，这是一种牢记使命、敬畏岗位的责任自觉。也只有责任才能使一个人坚持和长久。“不坏事”就是走得端、行得正，不坏别人的事、不坏大家的事、不坏集体的事。现在职场里，有些人名利思想作怪、价值取向错位、红眼病严重，喜欢搬弄是非、挑拨离间、混淆黑白，他们不是跟事过不去，而是跟人过不去、跟心过不去。岂不知，举头三尺有神明，多行不义必自毙。要有阳光心态，光明磊落，坦坦荡荡，与人为善。</p>
<hr>
<h2 id="十七-急事缓办-缓事急办"><a href="#十七、急事缓办、缓事急办" class="headerlink" title="十七、急事缓办、缓事急办"></a>十七、急事缓办、缓事急办</h2><p>所谓“急事”往往是突发事件、紧急事件、影响全局的事，让人措手不及，无法选择、不能回避。人的一生，遇急遇险在所难免，能够坦然面对，急事缓办、缓事急办才是大智慧。急事急办可能会忙中出错，急上加急就会错漏百出，难以弥补。急中生智也是有的，但可遇不可求，急中生智是超常态，急中失措才是常态，所以说很多急事反而急不得。急事缓办体现的是一个人沉着冷静、深思熟虑的智慧、勇气和应急能力，遇到急事要赶不要急，应当冷静思考、从容应对，不急于表态，不随便答复，考虑周全后再去妥善办理。所谓“缓事”，是指常规性、日常性事务或者预先知道需要做的事，都是你必须做的职责内的事，类似统计报表、会议纪要、旬报月报等等，有的人往往认为这个事是一个周或者一个月以后的事，现在不用着急，以后再说，最后缓事都变成了急事，时间到了就措手不及，弄得一团糟。缓事急办显示的是一个人的工作态度、工作的计划性和条理性，对缓事要有计划，抽空及时做，不要拖延，要事先安排，以免临时抱佛脚，忙乱而又得不到好结果。</p>
<hr>
<h2 id="十八-务虚与务实相结合"><a href="#十八、务虚与务实相结合" class="headerlink" title="十八、务虚与务实相结合"></a>十八、务虚与务实相结合</h2><p>务实是指脚踏实地，从实际出发，说实话、办实事、想实招、求实效；务虚则指仔细分析，深入研究，搞清楚为什么做、做什么、怎么做。如果说务实是决胜千里之外的实践，务虚就是运筹帷幄之中的谋划。一般来说，人们比较警惕务虚不务实的毛病，却不大重视只务实而不善或不会务虚的做法，如果过分强调“埋头拉车”，忽视“抬头看路”，就会陷入事无巨细、疲于奔命的困境，工作就很难突破和提高。孙悟空随唐僧去西天取经，经历九九八十一难，每渡过一难，他都会腾云驾雾到空中，看看妖魔鬼怪在何方，并思考如何应对，这其实就是务虚；如果发现妖怪，那就跳下来打，这就是务实。没有务虚，务实就没有方向性，所务之“实”就可能是一种盲动或蛮干；没有务实，目标计划则都停留在想象阶段，一切就都是空想。务虚是为了更好地务实，要务好实必须务好虚。每个人要在务实中生存，更要在务虚中提升，不能借口真抓实干否定务虚的重要性，错误地认为务虚就是空谈道理、只说不干，更不能借口务虚，不干实事、不求实效、坐而论道。既要真抓实干、求真务实，又要善于谋划、注重总结提升。一定要正确理解务虚与务实的关系，将二者有机结合，相互促进，相辅相成，不断提高工作水平。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title>微观经济学概论</title>
    <url>/post/ab89d379/</url>
    <content><![CDATA[<p><a href="https://pan.baidu.com/s/1Xk9nTPHCamuFvlfSMBQyOQ">百度云盘 曼昆 经济学原理 第七版 微观经济学分册 pdf</a></p>
<p>提取码：9d89 </p>
<p>以下内容用于理解<strong>微观经济学</strong>中的各种概念</p>
<h2 id="第一章-绪论"><a href="#第一章、绪论" class="headerlink" title="第一章、绪论"></a>第一章、绪论</h2><h3 id="一-什么是经济学"><a href="#一、什么是经济学" class="headerlink" title="一、什么是经济学"></a>一、什么是经济学</h3><h4 id="1-经济学的起源"><a href="#1-经济学的起源" class="headerlink" title="1. 经济学的起源"></a>1. 经济学的起源</h4><h5 id="1-两类资源"><a href="#（1）-两类资源" class="headerlink" title="（1） 两类资源"></a>（1） 两类资源</h5><p>“非经济资源”和“经济资源”</p>
<h5 id="2三大基本经济问题"><a href="#（2）三大基本经济问题" class="headerlink" title="（2）三大基本经济问题"></a>（2）三大基本经济问题</h5><p>生产什么</p>
<p>如何生产</p>
<p>为谁生产</p>
<h5 id="3稀缺性和选择"><a href="#（3）稀缺性和选择" class="headerlink" title="（3）稀缺性和选择"></a>（3）稀缺性和选择</h5><p>资源的有限性和人类需要的无限性导致稀缺，进而导致选择</p>
<h5 id="4机会成本与生产可能性曲线"><a href="#（4）机会成本与生产可能性曲线" class="headerlink" title="（4）机会成本与生产可能性曲线"></a>（4）机会成本与生产可能性曲线</h5><h4 id="2-什么是经济学"><a href="#2-什么是经济学" class="headerlink" title="2. 什么是经济学"></a>2. 什么是经济学</h4><h5 id="1初步的定义"><a href="#（1）初步的定义" class="headerlink" title="（1）初步的定义"></a>（1）初步的定义</h5><p>经济学是一门研究如何配置和利用稀缺资源的科学</p>
<h5 id="2进一步的定义"><a href="#（2）进一步的定义" class="headerlink" title="（2）进一步的定义"></a>（2）进一步的定义</h5><p>研究目的是使一定稀缺资源能获得最大的产品（劳务）满足人类的需要（福利）</p>
<h3 id="二-微观经济学和宏观经济学"><a href="#二、微观经济学和宏观经济学" class="headerlink" title="二、微观经济学和宏观经济学"></a>二、微观经济学和宏观经济学</h3><h4 id="1-微观经济学"><a href="#1-微观经济学" class="headerlink" title="1. 微观经济学"></a>1. 微观经济学</h4><h5 id="1定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h5><p>以单个经济单位为考察对象，研究其经济行为，以及相应的经济变量的单项数值如何决定</p>
<h5 id="2特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h5><ol>
<li>研究的对象：单个经济单位（指组成经济的基本单位）。</li>
<li>解决的问题：资源配置</li>
<li>中心理论：价格理论</li>
<li>研究方法：个量分析</li>
</ol>
<h5 id="3-基本内容"><a href="#（3）-基本内容" class="headerlink" title="（3） 基本内容"></a>（3） 基本内容</h5><p>价格理论</p>
<p>消费者行为理论</p>
<p>生产理论</p>
<p>成本理论</p>
<p>厂商均衡理论</p>
<p>收入分配理论</p>
<p>福利经济学</p>
<p>一般均衡分析</p>
<h4 id="2-宏观经济学"><a href="#2-宏观经济学" class="headerlink" title="2. 宏观经济学"></a>2. 宏观经济学</h4><h5 id="1定义"><a href="#（1）定义-1" class="headerlink" title="（1）定义"></a>（1）定义</h5><p>以整个国民经济活动为考察对象，研究社会总体经济问题及相应经济变量总量如何决定及相互关系</p>
<h5 id="2特点"><a href="#（2）特点-1" class="headerlink" title="（2）特点"></a>（2）特点</h5><ol>
<li>研究的对象：整个国民经济</li>
<li>解决的问题：资源利用</li>
<li>中心理论：国民收入决定理论</li>
<li>研究方法：总量分析</li>
</ol>
<h5 id="3基本内容"><a href="#（3）基本内容" class="headerlink" title="（3）基本内容"></a>（3）基本内容</h5><p>国民收入决定理论</p>
<p>就业理论</p>
<p>通货膨胀理论</p>
<p>经济周期理论</p>
<p>经济增长理论</p>
<p>财政与货币政策理论等</p>
<h4 id="3-宏观经济学与微观经济学的关系"><a href="#3-宏观经济学与微观经济学的关系" class="headerlink" title="3. 宏观经济学与微观经济学的关系"></a>3. 宏观经济学与微观经济学的关系</h4><h5 id="1联系"><a href="#（1）联系" class="headerlink" title="（1）联系"></a>（1）联系</h5><p>总量是由个量所组成的，国民经济活动必须建立在微观经济主体的经济活动基础上。</p>
<h5 id="2区别"><a href="#（2）区别" class="headerlink" title="（2）区别"></a>（2）区别</h5><p>研究对象、解决的问题、中心理论、分析方法不同。见上方</p>
<h3 id="三-经济学产生和发展简史"><a href="#三、经济学产生和发展简史" class="headerlink" title="三、经济学产生和发展简史"></a>三、经济学产生和发展简史</h3><h4 id="1-萌芽时期"><a href="#1-萌芽时期" class="headerlink" title="1. 萌芽时期"></a>1. 萌芽时期</h4><p>重商主义阶段</p>
<h4 id="2-形成时期"><a href="#2-形成时期" class="headerlink" title="2. 形成时期"></a>2. 形成时期</h4><p>古典经济学阶段</p>
<h4 id="3-微观经济学形成时期"><a href="#3-微观经济学形成时期" class="headerlink" title="3. 微观经济学形成时期"></a>3. 微观经济学形成时期</h4><p>新古典经济学阶段</p>
<h4 id="4-现代经济学形成时期"><a href="#4-现代经济学形成时期" class="headerlink" title="4. 现代经济学形成时期"></a>4. 现代经济学形成时期</h4><p>宏观经济学建立和发展阶段</p>
<h3 id="四-经济学的研究方法"><a href="#四、经济学的研究方法" class="headerlink" title="四、经济学的研究方法"></a>四、经济学的研究方法</h3><ol>
<li>实证分析与规范分析</li>
<li>经济模型</li>
<li>个量分析与总量分析</li>
<li>均衡分析</li>
<li>边际分析</li>
<li>静态分析、比较静态分析、动态分析</li>
</ol>
<h2 id="第二章-供求理论"><a href="#第二章、供求理论" class="headerlink" title="第二章、供求理论"></a>第二章、供求理论</h2><h3 id="一-价格概论"><a href="#一、价格概论" class="headerlink" title="一、价格概论"></a>一、价格概论</h3><h4 id="1-价格对微观经济学的重要性"><a href="#1-价格对微观经济学的重要性" class="headerlink" title="1. 价格对微观经济学的重要性"></a>1. 价格对微观经济学的重要性</h4><p>微观经济学的中心理论就是<strong>价格决定理论</strong></p>
<h4 id="2-两种基本的价格理论"><a href="#2-两种基本的价格理论" class="headerlink" title="2. 两种基本的价格理论"></a>2. 两种基本的价格理论</h4><p>（1）以<strong>劳动价值论</strong>为基础的价格理论</p>
<p>（2）以<strong>供求论</strong>为基础的价格理论</p>
<h3 id="二-需求理论"><a href="#二、需求理论" class="headerlink" title="二、需求理论"></a>二、需求理论</h3><h4 id="1-需求的含义"><a href="#1-需求的含义" class="headerlink" title="1. 需求的含义"></a>1. 需求的含义</h4><p>消费者在某一定时期内在<strong>各种可能的价格水平</strong> <strong>愿意而且能够购买</strong>的该商品的数量</p>
<h4 id="2-需求的条件"><a href="#2-需求的条件" class="headerlink" title="2. 需求的条件"></a>2. 需求的条件</h4><p>购买欲望</p>
<p>购买能力</p>
<h4 id="3-影响需求的因素"><a href="#3-影响需求的因素" class="headerlink" title="3. 影响需求的因素"></a>3. 影响需求的因素</h4><p>（1）商品价格(P);</p>
<p>（2）收入(I);</p>
<p>（3）替代商品价格(P~s~)</p>
<p>（4）互补商品价格(P~c~)</p>
<p>（5）消费者偏好(T)</p>
<p>（6）预期(E)</p>
<p>（7）其他(Q)</p>
<h4 id="4-需求函数"><a href="#4-需求函数" class="headerlink" title="4. 需求函数"></a>4. 需求函数</h4><h5 id="1含义"><a href="#（1）含义" class="headerlink" title="（1）含义"></a>（1）含义</h5><p>以<strong>影响因素</strong>为自变量，<strong>需求</strong>为因变量的函数</p>
<h5 id="2种类"><a href="#（2）种类" class="headerlink" title="（2）种类"></a>（2）种类</h5><ol>
<li>需求量函数<ol>
<li>含义：以价格为自变量（其他因素不变）、需求量为因变量的函数</li>
<li>表达方式：需求表、需求方程式(Q~4~=a-bP)、需求曲线</li>
<li>需求量的变动规律：其他因素不变，因价格变动而引起的需求量的变动</li>
<li>需求规律：其他条件不变，需求量与其价格呈反方向变化</li>
</ol>
</li>
<li><p>需求的函数</p>
<ol>
<li><p>含义：假定商品价格固定，其他因素（如收入）变动，即以价格以外的因素（如收入I）为自变量，以需求量为因变量的函数</p>
</li>
<li><p>表达：</p>
<script type="math/tex; mode=display">
Q~4~=f(P)</script></li>
<li><p>需求的变动规律：价格不变，因价格以外的因素（如收入）变动而引起的需求量的变动</p>
</li>
</ol>
</li>
</ol>
<h3 id="三-供给理论"><a href="#三、供给理论" class="headerlink" title="三、供给理论"></a>三、供给理论</h3><h4 id="1-供给的含义"><a href="#1-供给的含义" class="headerlink" title="1. 供给的含义"></a>1. 供给的含义</h4><p>厂商在某一特定时期内，愿意而且能够供应的商品量</p>
<h4 id="2-影响供应的因素"><a href="#2-影响供应的因素" class="headerlink" title="2. 影响供应的因素"></a>2. 影响供应的因素</h4><p>（1）商品价格(P);</p>
<p>（2）生产技术和管理水平(a);</p>
<p>（3）生产要素的价格(P~j~)</p>
<p>（4）其他商品价格(P~i~)</p>
<p>（5）预期(E)</p>
<h4 id="3-供给函数"><a href="#3-供给函数" class="headerlink" title="3. 供给函数"></a>3. 供给函数</h4><h5 id="1含义"><a href="#（1）含义-1" class="headerlink" title="（1）含义"></a>（1）含义</h5><p>以<strong>影响因素</strong>为自变量，<strong>供给量</strong>为因变量的函数</p>
<h5 id="2-种类"><a href="#（2）-种类" class="headerlink" title="（2） 种类"></a>（2） 种类</h5><ol>
<li><p>供给量函数</p>
<ol>
<li><p>含义：以价格为自变量（其他因素不变）、供给量为因变量的函数</p>
</li>
<li><p>表达方式：供给方程式</p>
<script type="math/tex; mode=display">
Q~5~ = -c + dP</script></li>
<li><p>供给量的变化规律：其他因素不变，因价格变动而引起的供给量的变动</p>
</li>
<li><p>供给规律：其他条件不变，供给量与其价格呈正方向变动</p>
</li>
</ol>
</li>
<li><p>供给函数</p>
<ol>
<li><p>含义：假设商品价格固定，其他因素（如技术）变动，即以价格以外的因素为自变量，以供给量为因变量的函数</p>
</li>
<li><p>表达方式：</p>
<script type="math/tex; mode=display">
Q~5~ = b + r * P</script></li>
<li><p>供给的变动规律：价格不变，因其他因素变动而引起的供给量的变动</p>
</li>
</ol>
</li>
</ol>
<h3 id="四-均衡价格"><a href="#四、均衡价格" class="headerlink" title="四、均衡价格"></a>四、均衡价格</h3><h4 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h4><p>一种商品需求与供给相等时的价格，这时该商品的需求价格与供给价格相等，称为均衡价格</p>
<h4 id="2-形成"><a href="#2-形成" class="headerlink" title="2. 形成"></a>2. 形成</h4><p>均衡价格表现为商品市场上需求和供给这两种相反的力量共同作用的结果，它是在市场的供求力量的自发调节下形成的。</p>
<h4 id="3-计算"><a href="#3-计算" class="headerlink" title="3. 计算"></a>3. 计算</h4><p>?</p>
<h4 id="4-供求规律"><a href="#4-供求规律" class="headerlink" title="4. 供求规律"></a>4. 供求规律</h4><p>指每一种商品的均衡价格和均衡数量的变动规律</p>
<p>（1）假定供给不变、需求变动，则均衡价格、均衡数量与需求发生同方向变动</p>
<p>（2）假定需求不变、供给变动，则均衡数量与供给发生同方向变动，均衡价格与供给发生反方向变动</p>
<p>（3）需求和供给同时发生变化</p>
<p>​    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">供求同时变动</th>
<th style="text-align:center">均衡价格</th>
<th style="text-align:center">均衡数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">需求上升，供给上升</td>
<td style="text-align:center">无法确定</td>
<td style="text-align:center">上升</td>
</tr>
<tr>
<td style="text-align:center">需求下降，供给下降</td>
<td style="text-align:center">无法确定</td>
<td style="text-align:center">下降</td>
</tr>
<tr>
<td style="text-align:center">需求上升，供给下降</td>
<td style="text-align:center">上升</td>
<td style="text-align:center">无法确定</td>
</tr>
<tr>
<td style="text-align:center">需求下降，供给上升</td>
<td style="text-align:center">下降</td>
<td style="text-align:center">无法确定</td>
</tr>
</tbody>
</table>
</div>
<h3 id="五-均衡价格理论的应用"><a href="#五、均衡价格理论的应用" class="headerlink" title="五、均衡价格理论的应用"></a>五、均衡价格理论的应用</h3><p>均衡价格理论作为经济学的基石有着非常广泛的用途，它可以解释价格变动的原因、预测价格变化的方向，同时也有利于分析政府干预市场可能出现的后果。</p>
<h2 id="第三章-弹性理论"><a href="#第三章、-弹性理论" class="headerlink" title="第三章、 弹性理论"></a>第三章、 弹性理论</h2><h3 id="一-什么是弹性理论"><a href="#一、-什么是弹性理论" class="headerlink" title="一、 什么是弹性理论"></a>一、 什么是弹性理论</h3><h4 id="1-弹性质量"><a href="#1-弹性质量" class="headerlink" title="1. 弹性质量"></a>1. 弹性质量</h4><p>（物理学上）指某一物体对外界力量的反应力</p>
<h4 id="2-经济学的弹性理论"><a href="#2-经济学的弹性理论" class="headerlink" title="2. 经济学的弹性理论"></a>2. 经济学的弹性理论</h4><h5 id="1含义"><a href="#（1）含义-2" class="headerlink" title="（1）含义"></a>（1）含义</h5><p>指经济变量之间存在函数关系时，因变量对自变量变动的反应程度</p>
<h5 id="2种类"><a href="#（2）种类-1" class="headerlink" title="（2）种类"></a>（2）种类</h5><p>需求弹性</p>
<p>供给弹性</p>
<h3 id="二-需求弹性"><a href="#二、需求弹性" class="headerlink" title="二、需求弹性"></a>二、需求弹性</h3><h4 id="1-含义"><a href="#1-含义-1" class="headerlink" title="1. 含义"></a>1. 含义</h4><p>某物品的需求量对其影响因素发生变化时的反应力</p>
<h4 id="2-种类"><a href="#2-种类" class="headerlink" title="2. 种类"></a>2. 种类</h4><h5 id="1需求的价格弹性"><a href="#（1）需求的价格弹性" class="headerlink" title="（1）需求的价格弹性"></a>（1）需求的价格弹性</h5><ul>
<li>含义：某物品的需求量对其价格变动的反应力</li>
<li>弹性系数：</li>
</ul>
<script type="math/tex; mode=display">
Ed = 需求量变动的百分比/价格变动的百分比</script><ul>
<li><p>计算方法</p>
</li>
<li><ul>
<li><p>点弹性公式：</p>
<script type="math/tex; mode=display">
Ed = (-dQ / dP) * (P / Q)</script></li>
<li><p>弧弹性公式：</p>
<script type="math/tex; mode=display">
Ed = (-dQ / dP) * [(P~1~ + P~2~)/(Q~1~ + Q~2~)]</script></li>
</ul>
</li>
<li><p>弹性与斜率</p>
</li>
<li><p>五种典型：</p>
<script type="math/tex; mode=display">
Ed > 1;Ed < 1; Ed = 1; Ed = 0; Ed = 无穷</script></li>
<li><p>影响需求价格弹性的因素</p>
</li>
<li><ul>
<li>消费者对商品的需求程度：必需品Ed小，奢侈品Ed大</li>
<li>商品的替代品数目和可替代程度：替代品多、替代程度大、Ed大；反之则小</li>
<li>商品用途的广泛性：用途广、Ed大；反之则小</li>
<li>此外，还有时间和地域差别、消费习惯、商品质量、售后服务等因素</li>
</ul>
</li>
<li><p>需求的价格弹性与总收益</p>
<p>| 需求价格弹性 Ed | 价格变动 |  需求变动  | 总收益变动 |<br>| :——————-: | :———: | :————: | :————: |<br>|   |Ed| &gt; 1    |   上升   |  下降更多  |    下降    |<br>|   |Ed| &gt; 1    |   下降   |  上升更多  |    上升    |<br>|   |Ed| &lt; 1    |   上升   |  下降较少  |    上升    |<br>|   |Ed| &lt; 1    |   下降   |  上升较少  |    下降    |<br>|   |Ed| = 1    |   上升   | 同比例下降 |    不变    |<br>|   |Ed| = 1    |   下降   | 同比例上升 |    不变    |</p>
</li>
</ul>
<h5 id="2需求的收入弹性"><a href="#（2）需求的收入弹性" class="headerlink" title="（2）需求的收入弹性"></a>（2）需求的收入弹性</h5><ul>
<li><p>含义：一种商品的需求量对消费者收入变动的反应程度</p>
</li>
<li><p>弹性系数 </p>
<script type="math/tex; mode=display">
Em = 需求量变动的百分比  / 收入变动的百分比</script></li>
</ul>
<ul>
<li><p>计算公式</p>
<ul>
<li><p>点弹性公式：</p>
<script type="math/tex; mode=display">
Em = (dQ / dI) * (I / Q)</script></li>
<li><p>弧弹性公式：</p>
<script type="math/tex; mode=display">
Em = (dQ / dI) * [(I~1~ + I~2~)/(Q~1~ + Q~2~)]</script></li>
</ul>
</li>
<li><p>需求收入弹性的正负值</p>
<ul>
<li>Em &gt; 0  正常商品</li>
<li>Em &lt; 0  劣等品</li>
</ul>
</li>
</ul>
<h5 id="3需求的交叉弹性"><a href="#（3）需求的交叉弹性" class="headerlink" title="（3）需求的交叉弹性"></a>（3）需求的交叉弹性</h5><ul>
<li><p>含义：指某一种商品的需求量对其他有关商品价格变动的反应程度</p>
</li>
<li><p>弹性系数：</p>
<script type="math/tex; mode=display">
Exy = x 商品需求量变动的百分比 / y 商品价格变动的百分比</script></li>
</ul>
<ul>
<li><p>计算公式</p>
<ul>
<li><p>点弹性公式</p>
<script type="math/tex; mode=display">
Exy = (dQx / dPy) * (Py/Qx)</script></li>
<li><p>弧弹性公式</p>
</li>
</ul>
</li>
<li><p>判断两种商品的关系</p>
<ul>
<li>Exy &gt; 0 表示y商品与x商品有替代关系，为互替品</li>
<li>Exy &lt; 0 表示y商品与x商品有互补关系，为互补品</li>
<li>Exy = 0 表示y商品与x商品有独立关系</li>
</ul>
</li>
</ul>
<h3 id="三-供给弹性供给的价格弹性"><a href="#三、供给弹性（供给的价格弹性）" class="headerlink" title="三、供给弹性（供给的价格弹性）"></a>三、供给弹性（供给的价格弹性）</h3><ul>
<li><p>含义：指某一种商品的供给量对其价格变动的反应程度</p>
</li>
<li><p>弹性系数：Es = 供给量变动的百分比 / 价格变动的百分比</p>
</li>
<li><p>计算公式</p>
<ul>
<li><p>点弹性公式：</p>
<script type="math/tex; mode=display">
Ed = (dQx / dP) * (P/Q)</script></li>
<li><p>弧弹性公式：Ed = </p>
</li>
</ul>
</li>
<li><p>类型： </p>
<script type="math/tex; mode=display">
Es > 1; Es < 1; Es = 1; Es = 0; Es = 无穷</script></li>
</ul>
<ul>
<li>影响因素：<ul>
<li>生产的难易程度</li>
<li>生产规模和规模变化的难易程度</li>
<li>其他：时间的差异、厂商生产能力、对未来价格的预期等</li>
</ul>
</li>
</ul>
<h3 id="四-弹性理论的应用"><a href="#四、-弹性理论的应用" class="headerlink" title="四、 弹性理论的应用"></a>四、 弹性理论的应用</h3><ol>
<li>易腐商品的售卖</li>
<li>价格放开</li>
<li>最高限价和最低限价</li>
<li>谷贱伤农</li>
</ol>
<h3 id="五-蛛网理论"><a href="#五、-蛛网理论" class="headerlink" title="五、 蛛网理论"></a>五、 蛛网理论</h3><h4 id="1-含义"><a href="#1-含义-2" class="headerlink" title="1. 含义"></a>1. 含义</h4><p>一种将均衡价格理论与弹性理论结合起来，并引入时间因素，研究商品均衡价格变动规律的理论</p>
<h4 id="2-蛛网类型"><a href="#2-蛛网类型" class="headerlink" title="2. 蛛网类型"></a>2. 蛛网类型</h4><h5 id="1收敛型"><a href="#（1）收敛型" class="headerlink" title="（1）收敛型"></a>（1）收敛型</h5><script type="math/tex; mode=display">
Ed > Es</script><h5 id="2封闭型"><a href="#（2）封闭型" class="headerlink" title="（2）封闭型"></a>（2）封闭型</h5><script type="math/tex; mode=display">
Ed = Es</script><h5 id="3扩散型"><a href="#（3）扩散型" class="headerlink" title="（3）扩散型"></a>（3）扩散型</h5><script type="math/tex; mode=display">
Ed < Es</script><h4 id="3-应用条件"><a href="#3-应用条件" class="headerlink" title="3. 应用条件"></a>3. 应用条件</h4><p>商品生产周期长</p>
<p>生产规模中途不易变动</p>
<p>本期供给决定本期价格</p>
<p>本期价格决定下期供给</p>
<h2 id="第四章-消费者行为理论"><a href="#第四章-消费者行为理论" class="headerlink" title="第四章 消费者行为理论"></a>第四章 消费者行为理论</h2><h3 id="一-消费者行为理论概念"><a href="#一、消费者行为理论概念" class="headerlink" title="一、消费者行为理论概念"></a>一、消费者行为理论概念</h3><ul>
<li><strong>居民户</strong>——个人或家庭，<strong>消费的决策单位</strong></li>
<li>消费者行为即消费者购买物品（劳务）的行为</li>
<li>消费者行为理论研究消费者的<strong>购物目标</strong>及<strong>实现目标的途径</strong></li>
</ul>
<h3 id="二-欲望-需要-效用"><a href="#二、-欲望-需要-效用" class="headerlink" title="二、 欲望 需要 效用"></a>二、 欲望 需要 效用</h3><h4 id="欲望"><a href="#欲望" class="headerlink" title="欲望"></a>欲望</h4><ul>
<li>含义：满足具体效用的期望</li>
<li>重要性：因为消费者一旦对某种产品有了强烈的<strong>购买欲望</strong>，他会为实现这一愿望多赚钱</li>
</ul>
<h4 id="需要"><a href="#需要" class="headerlink" title="需要"></a>需要</h4><ul>
<li>含义：通常指对人类<strong>基本生存条件</strong>的满足期望</li>
<li>重要性：产生需求的必要条件</li>
</ul>
<h4 id="效用"><a href="#效用" class="headerlink" title="效用"></a>效用</h4><ul>
<li>含义：消费者消费物品或劳务中所获得的<strong>满足程度</strong>，并且这种满足程度村崔是一种<strong>消费者主观心理感觉</strong></li>
<li><strong>欲望-&gt;需要-&gt;效用</strong></li>
<li>两种效用理论——按照<strong>效用能不能量化</strong>划分<ul>
<li>基数效用论：用一<strong>基数数值</strong>来度量的心理满足程度</li>
<li>序数效用论：人们消费某种商品所得到的、并<strong>用序数来度量</strong>的心理满足程度</li>
</ul>
</li>
</ul>
<h3 id="三-效用函数"><a href="#三、效用函数" class="headerlink" title="三、效用函数"></a>三、效用函数</h3><h4 id="1-含义"><a href="#1-含义-3" class="headerlink" title="1. 含义"></a>1. 含义</h4><p>以<strong>消费者在同一时间消费物品（劳务）的数量</strong>为自变量，<strong>效用</strong>为因变量的函数</p>
<h3 id="2-种类"><a href="#2-种类-1" class="headerlink" title="2. 种类"></a>2. 种类</h3><h4 id="1总效用tu函数"><a href="#（1）总效用（TU）函数" class="headerlink" title="（1）总效用（TU）函数"></a>（1）总效用（TU）函数</h4><ul>
<li><p>含义：指消费者在一定时间内从一定数量的商品的消费中所得到的效用量的总和</p>
</li>
<li><p>公式 ：</p>
<script type="math/tex; mode=display">
TU = f(Q)</script></li>
</ul>
<h4 id="2边际效用mu函数"><a href="#（2）边际效用（MU）函数" class="headerlink" title="（2）边际效用（MU）函数"></a>（2）边际效用（MU）函数</h4><ul>
<li>含义：指消费者在一定时间内增加一单位商品的消费所得到的效用量的增量</li>
<li>公式</li>
<li>特征：边际效用递减</li>
</ul>
<h4 id="3总效用与边际效用的关系"><a href="#（3）总效用与边际效用的关系" class="headerlink" title="（3）总效用与边际效用的关系"></a>（3）总效用与边际效用的关系</h4><h4 id="4边际效用递减规律"><a href="#（4）边际效用递减规律" class="headerlink" title="（4）边际效用递减规律"></a>（4）边际效用递减规律</h4><ul>
<li>含义：随着消费者在同一时间内消费同一物品（劳务）数量的增加，他从每一个最后新增单位物品（劳务）中所获得的效用（边际效用）是递减的</li>
<li>条件<ul>
<li>心理、生理原因</li>
<li>一种物品（劳务）用途的多样性</li>
</ul>
</li>
</ul>
<h4 id="5消费者剩余"><a href="#（5）消费者剩余" class="headerlink" title="（5）消费者剩余"></a>（5）消费者剩余</h4><ul>
<li>含义：指消费者在购买物品（劳务）时所得到的总效用和实际支付的总效用之间的差额</li>
<li>特点：消费者剩余是一种心理现象。它常常被用来研究消费者福利状况的变化，以及评价政府的公共支出与税收政策等。</li>
</ul>
<h3 id="四-消费者均衡边际效用法"><a href="#四、消费者均衡（边际效用法）" class="headerlink" title="四、消费者均衡（边际效用法）"></a>四、消费者均衡（边际效用法）</h3><h3 id="五-消费者均衡无差异曲线分析"><a href="#五、消费者均衡——无差异曲线分析" class="headerlink" title="五、消费者均衡——无差异曲线分析"></a>五、消费者均衡——无差异曲线分析</h3><h3 id="六-消费者行为与需求"><a href="#六、消费者行为与需求" class="headerlink" title="六、消费者行为与需求"></a>六、消费者行为与需求</h3><h3 id="七-恩格尔曲线"><a href="#七、恩格尔曲线" class="headerlink" title="七、恩格尔曲线"></a>七、恩格尔曲线</h3><h3 id="八-替代效应-收入效应-消费者需求"><a href="#八、替代效应、收入效应、消费者需求" class="headerlink" title="八、替代效应、收入效应、消费者需求"></a>八、替代效应、收入效应、消费者需求</h3>]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>micro-economics</tag>
      </tags>
  </entry>
  <entry>
    <title>《庄子》读书笔记</title>
    <url>/post/9cafe24c/</url>
    <content><![CDATA[<h2 id="一-导论"><a href="#一-导论" class="headerlink" title="一 导论"></a>一 导论</h2><p><strong>1、精读</strong></p>
<ul>
<li>完备：典籍、<strong>注书</strong></li>
<li>仔细：识字通经</li>
</ul>
<p>经典：思想活着、语言活着（成语）</p>
<p><strong>2、博览</strong>：扩展眼界，有中心的</p>
<p>百家——九流十家 汉代方有“家”之称</p>
<blockquote>
<p><em>太后好<strong>黄老之言</strong>，而魏其、武安、赵、王臧等务隆推<strong>儒术</strong>，贬<strong>道家</strong>言，是以窦太后兹不说魏其等。</em> </p>
<p>——《史记 · 魏其武安侯列传》</p>
</blockquote>
<p>所谓“道不同不相为谋”，汉初道儒之争很突出；此时道家，即黄老之言，庄子并未在其中</p>
<p>但《庄子》仍有黄老之论述</p>
<blockquote>
<p><em>夫帝王之德，以天地为宗，以道德为主，以无为为常。无为也，则用天下而有余；有为也，则为天下用而不足。<strong>故古之人贵夫无为也。</strong></em></p>
</blockquote>
<p>上下之辨</p>
<blockquote>
<p><em>上无为也，下亦无为也，是下与上同德。下与上同德则不臣。下有为也，上亦有为也，是上与下同道。上与下同道则不主。<strong>上必无为</strong>而用天下，<strong>下必有为</strong>为天下用。此不易之道也。</em></p>
<p>——《庄子 · 天道》</p>
<p>此篇之说，有与庄子之旨迥不相侔者；特因劳资守静之言而演之，亦未尽合于老子。<strong>盖秦汉间学黄老之术以干人主者之所作也</strong>。 ——王夫之《庄子解》</p>
<p><em>上之人明其道，下之人守其职，上下之分不同任，而复为一体。</em></p>
<p>——《管子》</p>
<p><em>君臣之道，臣事事而君无事。</em> </p>
<p>——《慎到》</p>
</blockquote>
<p>史记 陈胜世家 项羽本纪</p>
<p><strong>3、跳读</strong></p>
<p><strong>4、拆读</strong></p>
<p>“<strong>八面受敌</strong>”：从多个方面去读一本书；拆散再重新组织</p>
<h2 id="二-其人其书"><a href="#二-其人其书" class="headerlink" title="二 其人其书"></a>二 其人其书</h2><p>《庄子集释》 《庄子集解》《庄子浅注》</p>
<h3 id="庄子其人"><a href="#庄子其人" class="headerlink" title="庄子其人"></a>庄子其人</h3><p>文学…思想… <strong>文字的可塑性极强</strong></p>
<blockquote>
<p>庄周家贫，故往贷粟于监河侯。监河侯曰：“诺，我将得邑金，将贷子三百金，可乎？”</p>
<p>庄周忿然作色曰：“周昨来，有中道而呼者。周顾视，车辙中有鲋鱼焉。周问之曰：‘鲋鱼来！子何为者耶？’对曰：‘我，东海之波臣也。君岂有斗升之水而活我哉？’周曰‘诺！我且南游吴越之王，激西江之水而迎子，可乎？’鲋鱼忿然作色曰：‘<strong>吾失我常与，我无所处。吾得斗升之水然活耳，君乃言此，曾不如早索我于枯鱼之肆!</strong>’ ” </p>
<p>——《庄子 · 外物》</p>
</blockquote>
<p>寓言 藉外论之</p>
<p>文学辨别：<strong>诚伪而非真假</strong></p>
<p>别的记在书里了</p>
<h3 id="庄子其书"><a href="#庄子其书" class="headerlink" title="庄子其书"></a>庄子其书</h3><p>分篇</p>
<p>内：理——本</p>
<p>外：事——迹</p>
<p>《<strong>秋水</strong>》——《<strong>逍遥游</strong>》《<strong>齐物论</strong>》</p>
<p>《刻意》——《<strong>养生主</strong>》《大宗师》</p>
<p>《<strong>骈拇</strong>》《<strong>马蹄</strong>》《<strong>胊箧</strong>》：政治态度</p>
<p>《<strong>天下</strong>》：对诸子的梳理、惠施</p>
<p>以下几篇都记在书上对应位置了，此处不赘述</p>
<h2 id="三-逍遥游篇"><a href="#三-逍遥游篇" class="headerlink" title="三 逍遥游篇"></a>三 逍遥游篇</h2><h2 id="四-秋水篇"><a href="#四-秋水篇" class="headerlink" title="四 秋水篇"></a>四 秋水篇</h2><h2 id="五-齐物论篇"><a href="#五-齐物论篇" class="headerlink" title="五 齐物论篇"></a>五 齐物论篇</h2><h2 id="六-养生主篇"><a href="#六-养生主篇" class="headerlink" title="六 养生主篇"></a>六 养生主篇</h2>]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>成长型思维</title>
    <url>/post/c6adcf57/</url>
    <content><![CDATA[<blockquote>
<p>… the path to a growth mindset is a [LIFELONG] journey, not a proclamation. - Carol Dweck</p>
</blockquote>
<p>固定型思维：认为天赋就是一切，思维固定<br>成长型思维：认为努力就是一切，思维成长</p>
<p>1、固定思维的人关注结果，他认为创业对于有那些天赋的人来说比较容易，所以他放弃了<br>2、成长型思维的人认为过程最重要，能学到不少，作为一个学生，漫长的过程是老师</p>
<p>如何培养“成长型思维”</p>
<ol>
<li><p>要确信“成长型思维”是存在的，我们的大脑不是固定的，是非常可塑的<br>出租车司机年限越久，脑中的灰质越多，使他们工作中更有效</p>
</li>
<li><p>要注重过程而不是结果<br>应该赞扬学生：你为这次考试准备了很多，你的努力得到了回报<br>而不是：你真聪明，得到了个A<br>他们需要把他们可以通过改变过程 来改变结果这一想法内化</p>
</li>
<li><p>走出你的舒适圈<br>一个学生在自己舒适圈内经常拿A，就不会想怎么才能成功这个process<br>走出你的舒适圈，强迫你接受成长型思维，避免在逆境的重压下崩溃</p>
</li>
</ol>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>psychology</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库（一）</title>
    <url>/post/83a80715/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="building-the-data-warehouse第一章-决策支持系统的发展"><a href="#《Building-the-Data-Warehouse》第一章-决策支持系统的发展" class="headerlink" title="《Building the Data Warehouse》第一章 决策支持系统的发展"></a>《Building the Data Warehouse》第一章 决策支持系统的发展</h2><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">简称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DSS</td>
<td style="text-align:center">决策支持系统</td>
</tr>
<tr>
<td style="text-align:center">DASD</td>
<td style="text-align:center">直接存取存储设备</td>
</tr>
<tr>
<td style="text-align:center">DBMS</td>
<td style="text-align:center">数据库管理系统</td>
</tr>
<tr>
<td style="text-align:center">MIS</td>
<td style="text-align:center">管理信息系统</td>
</tr>
</tbody>
</table>
</div>
<h2 id="dss处理演化"><a href="#DSS处理演化" class="headerlink" title="DSS处理演化"></a>DSS处理演化</h2><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409103253.png" alt></p>
<h3 id="创建运行于主文件上的单个应用"><a href="#创建运行于主文件上的单个应用" class="headerlink" title="创建运行于主文件上的单个应用"></a>创建运行于主文件上的单个应用</h3><ul>
<li>顺序访问。所有数据被访问，只有5%或更少真正需要。</li>
<li>主文件和磁盘的使用迅速膨胀。大量<strong>冗余</strong>文件。</li>
</ul>
<h3 id="直接存取存储设备的产生"><a href="#直接存取存储设备的产生" class="headerlink" title="直接存取存储设备的产生"></a>直接存取存储设备的产生</h3><ul>
<li>直接读取</li>
<li>产生DBMS。使得程序员能在DASD上方便存储和访问数据。</li>
<li>产生“数据库”思想——所有处理工作的单一数据源</li>
</ul>
<h3 id="个人计算机第四代编程语言技术"><a href="#个人计算机-第四代编程语言技术" class="headerlink" title="个人计算机/第四代编程语言技术"></a>个人计算机/第四代编程语言技术</h3><ul>
<li>除了对高性能联机事务处理，对数据进行更多处理。</li>
<li>MIS 或称 DSS——产生管理决策的处理过程</li>
<li>产生新思想体系——一个单一数据库既可以用作<strong>操作型的高性能事务处理</strong>，同时有用作<strong>DSS分析处理</strong>。</li>
</ul>
<h3 id="进入抽取程序"><a href="#进入抽取程序" class="headerlink" title="进入抽取程序"></a>进入抽取程序</h3><ul>
<li>简单，作用——搜索整个文件或数据库，使用<strong>某些标准</strong>选择<strong>合乎限制的数据</strong>，并把数据传到其他文件或数据库中。</li>
<li>为什么？</li>
<li><ul>
<li>性能——将数据从<strong>高性能联机事务处理方式（？）</strong>中转移，与联机事务处理性能不冲突</li>
<li>控制——数据可以被用户控制</li>
</ul>
</li>
</ul>
<h3 id="蜘蛛网"><a href="#蜘蛛网" class="headerlink" title="蜘蛛网"></a>蜘蛛网</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409105511.png" alt></p>
<ul>
<li>背景：抽取过多过频繁</li>
<li>由<strong>失控的抽取过程</strong>产生的结构被称为<strong>“自然演化体系结构”</strong></li>
</ul>
<h3 id="自然演化体系结构的问题"><a href="#自然演化体系结构的问题" class="headerlink" title="自然演化体系结构的问题"></a>自然演化体系结构的问题</h3><h4 id="问题1数据缺乏可行性"><a href="#问题1：数据缺乏可行性" class="headerlink" title="问题1：数据缺乏可行性"></a>问题1：数据缺乏可行性</h4><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409105640.png" alt></p>
<ul>
<li>数据无时基</li>
<li>算法上的差异——例如不同部门对同一个指标的算法的差异</li>
<li>前两个理由的扩展问题——（与具体业务有关，暂时不理解）</li>
<li>由外部数据引起的问题——分析人员在取得的数据来自外界，无法明确其准确性</li>
<li>没有公共的起始数据源——不同部门的文件或数据库之间业务关系怎样，都不存在数据同步或数据共享。</li>
</ul>
<h4 id="问题2生产率问题"><a href="#问题2：生产率问题" class="headerlink" title="问题2：生产率问题"></a>问题2：生产率问题</h4><p>什么是生产率？——经济学术语，是指<strong>由原材料变成产品的过程中的效能和效率表现</strong>，是<strong>每单位投入的产出</strong>。生产率的提高是由于资本或劳动力效率的提高，但将资本生产率和劳动生产率分开计算常常不可能的，通常情况下，生产率这一概念一般限于劳动生产率。</p>
<ul>
<li>生成企业报表花费大量资源——数据定位、数据编辑</li>
<li>时间代价不是一次性的，<strong>前面生成的企业报表非常不可能为后面的报表降低时间代价</strong></li>
</ul>
<h4 id="问题3从数据到信息的不可行性"><a href="#问题3：从数据到信息的不可行性" class="headerlink" title="问题3：从数据到信息的不可行性"></a>问题3：从数据到信息的不可行性</h4><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409111112.png" alt></p>
<ul>
<li>发现相关数据很困难</li>
<li>应用程序中缺少足够的历史数据以满足DSS分析员的需求</li>
<li>自然演化系统结构中建立的系统对信息需求的支持不充分</li>
</ul>
<h4 id="问题4方法的变迁"><a href="#问题4：方法的变迁" class="headerlink" title="问题4：方法的变迁"></a>问题4：方法的变迁</h4><p>原始数据——公司每天操作运行所用的细节性数据</p>
<p>导出数据——统计出来或计算出来满足公司管理者需要的数据</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409112029.png" alt></p>
<h3 id="体系结构设计环境"><a href="#体系结构设计环境" class="headerlink" title="体系结构设计环境"></a>体系结构设计环境</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409112139.png" alt></p>
<h4 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h4><ul>
<li>操作层</li>
<li>原子（数据仓库）层——保存原始数据并服务于高性能事务处理领域</li>
<li>部分层</li>
<li>个体层</li>
</ul>
<h4 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h4><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409112619.png" alt></p>
<p>数据从操作型环境载入到数据仓库环境，一定要<strong>集成才有意义</strong>。</p>
<p>数据的企业视图是体系结构设计环节的本质之一。</p>
<h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>DSS分析员——商务人员（先）、技术人员（后）</p>
<p>DSS分析员的想法和他们对使用数据仓库的理解很重要</p>
<h3 id="开发生命周期"><a href="#开发生命周期" class="headerlink" title="开发生命周期"></a>开发生命周期</h3><ul>
<li>实现数据仓库</li>
<li>集成数据</li>
<li>检验偏差</li>
<li>针对数据编程</li>
<li>设计DSS系统</li>
<li>分析结果</li>
<li>理解需求</li>
</ul>
<h3 id="硬件利用模式"><a href="#硬件利用模式" class="headerlink" title="硬件利用模式"></a>硬件利用模式</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409113327.png" alt></p>
<p>数据仓库环境是<strong>利用的二元模式</strong>——要么全部利用，要么都不用。</p>
<h3 id="重建工程"><a href="#重建工程" class="headerlink" title="重建工程"></a>重建工程</h3><ul>
<li><p>从生产环境中移走大量数据——大部分为档案数据</p>
</li>
<li><ul>
<li>生产环境易于纠错</li>
<li>生产环境易于重构</li>
<li>生产环境易于监控</li>
<li>生产环境易于索引</li>
</ul>
</li>
<li><p>从生产环境中移走信息性处理</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409113708.png" alt></p>
<ul>
<li>更小</li>
<li>更简单</li>
<li>更集中</li>
</ul>
</li>
</ul>
<h3 id="监控数据仓库环境"><a href="#监控数据仓库环境" class="headerlink" title="监控数据仓库环境"></a>监控数据仓库环境</h3><ul>
<li>识别发生了什么增长，增长发生在什么地方，增长以什么速率发生。</li>
<li>识别正在使用什么数据。</li>
<li>估算最终用户得到的响应时间。</li>
<li>确定谁在实际使用数据仓库。</li>
<li>说明正在使用数据仓库中的多少数据。</li>
<li>精确指出数据仓库何时被使用。</li>
<li>识别数据仓库的多少数据被使用。</li>
<li>检查使用数据仓库的层次</li>
</ul>
]]></content>
      <categories>
        <category>商务智能</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Data Warehouse</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库（二）</title>
    <url>/post/b3beebcd/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="building-the-data-warehouse第二章-数据仓库环境"><a href="#《Building-the-Data-Warehouse》第二章-数据仓库环境" class="headerlink" title="《Building the Data Warehouse》第二章 数据仓库环境"></a>《Building the Data Warehouse》第二章 数据仓库环境</h2><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">简称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DSS</td>
<td style="text-align:center">决策支持系统</td>
</tr>
<tr>
<td style="text-align:center">DASD</td>
<td style="text-align:center">直接存取设备</td>
</tr>
<tr>
<td style="text-align:center">DBMS</td>
<td style="text-align:center">数据库管理系统</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="数据仓库的特性"><a href="#数据仓库的特性" class="headerlink" title="数据仓库的特性"></a>数据仓库的特性</h2><p>数据仓库是一个<strong>面向主题的</strong>、<strong>集成的</strong>、<strong>非易失的</strong>且<strong>随时间变化</strong>的<strong>数据集合</strong>，用来支持管理人员的决策。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190409152310.png" alt></p>
<p>不同的<strong>细节级</strong>——早期细节级（备用的、批量的存储）、当前细节级、轻度综合数据集（数据集市）、高度综合数据集。</p>
<h3 id="面向主题"><a href="#面向主题" class="headerlink" title="面向主题"></a>面向主题</h3><p>数据仓库是面向在数据模型中已定义好的公司的主要主题领域的。典型的主题领域例如：</p>
<ul>
<li>顾客。</li>
<li>产品。</li>
<li>事务或活动。</li>
<li>保险单。</li>
<li>索赔。</li>
<li>帐目。</li>
</ul>
<p>在数据仓库中，主要主题领域是以一组相关的表来具体实现的。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190410182844.png" alt></p>
<p>有的数据存储在直接存取DASD上，有的数据存储在磁带上。数据存储在不同介质上意味着在数据仓库中可能有多个DBMS对数据进行管理，或者某些数据根本没有被某个DBMS管理。<strong>不能仅仅因为数据存储在磁带上，就认为它不是数据仓库的一部分。</strong></p>
<h3 id="随时间变化"><a href="#随时间变化" class="headerlink" title="随时间变化"></a>随时间变化</h3><p>建立数据仓库是<strong>进化性</strong>的——数据仓库只能一次一步地进行设计和载入数据。由于建立数据仓库的成本，数据仓库的建立要采用<strong>有序地反复和一次一步地方式</strong>。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190410183413.png" alt></p>
<h3 id="粒度第一个主要涉及问题"><a href="#粒度——第一个主要涉及问题" class="headerlink" title="粒度——第一个主要涉及问题"></a>粒度——第一个主要涉及问题</h3><p>粒度是指<strong>数据仓库的数据单位中保存数据的细化或综合程度的级别</strong>。细化程度越高，粒度级就越小；反之则反。</p>
<p>粒度是<strong>主要的设计问题</strong>——<strong>数据仓库的数据量大小和查询的详细程度的权衡</strong>——它深深地影响存放在数据仓库中的数据量的大小，同时影响数据仓库所能回答的查询类型。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190410184523.png" alt></p>
<h4 id="粒度的例子"><a href="#粒度的例子" class="headerlink" title="粒度的例子"></a>粒度的例子</h4><p>暂时还不太理解</p>
<h4 id="粒度的双重级别"><a href="#粒度的双重级别" class="headerlink" title="粒度的双重级别"></a>粒度的双重级别</h4><p>当一个企业或组织的数据仓库中拥有大量数据时，在数据仓库的细节部分考虑双重 (或多重)粒度级是很有意义的。事实上，需要多个粒度级而不是一个粒度级的需求，是因为<strong>粒度级设计采用双重级别应该是几乎每个机构默认的选择</strong>。</p>
<h3 id="分隔问题第二个主要设计问题"><a href="#分隔问题——第二个主要设计问题" class="headerlink" title="分隔问题——第二个主要设计问题"></a>分隔问题——第二个主要设计问题</h3><p>如果粒度和分隔做得很好，则数据仓库的设计和实现的几乎所有其他问题都容易解决。</p>
<p>数据分隔是<strong>把数据分散到各自的物理单元中去，它们能独立地处理</strong>。分隔问题的焦点是<strong>如何</strong>去进行分隔。</p>
<h3 id="样本数据库"><a href="#样本数据库" class="headerlink" title="样本数据库"></a>样本数据库</h3><p>数据仓库的一种特殊形式，只是真实档案数据或轻度综合数据的子集。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190410190235.png" alt></p>
<p>在人口统计分析等情况下，样本数据库是非常有用的，其最大好处是存取效率非常高。一个分析员可能花24小时来浏阅与分析一个大数据库，而浏览与分析一个样本数据库则可能只需10分钟。在进行启发式分析中，周转时间对可以进行的分析而言是至关重要的。</p>
<p>但是其存在一些<strong>苛刻的限制</strong>，假如设计者知道这些限制，否则就不应该创建这种数据库作为数据仓库的一部分。</p>
<h3 id="数据分割不同于数据分隔"><a href="#数据分割——不同于数据分隔" class="headerlink" title="数据分割——不同于数据分隔"></a>数据分割——不同于数据分隔</h3><p><strong>问题</strong>：如何对当前细节数据进行分割。</p>
<p><strong>准确含义</strong>：当结构相同的数据被分成多个数据物理单元时，数据便被分割了。此外，任何给定的数据单元属于且仅属于一个分割。</p>
<p>总体<strong>目的</strong>：把数据划分成小的物理单元。</p>
<p><strong>重要性</strong>：因为小的物理单元能为操作者和设计者在管理数据时提供比对大的物理单元<strong>更大的灵活性</strong>。</p>
<p>数据库放在大的物理单元，不容易实现的——重构、自由索引、顺序扫描、重组、恢复、监控。</p>
<p>数据仓库的<strong>本质</strong>之一就是<strong>灵活地访问数据</strong>。如果是大块的数据，就达不到这一要求。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190410192258.png" alt></p>
<p>常见的数据分隔的标准有：时间、商业线、地理位置、组织单位等等</p>
<p>主要问题之一：在<strong>系统层</strong>上还是在<strong>应用层</strong>上对数据进行分割</p>
<h3 id="数据仓库中的数据组织"><a href="#数据仓库中的数据组织" class="headerlink" title="数据仓库中的数据组织"></a>数据仓库中的数据组织</h3><h4 id="简单堆积结构最简单最常见"><a href="#简单堆积结构——最简单最常见" class="headerlink" title="简单堆积结构——最简单最常见"></a>简单堆积结构——最简单最常见</h4><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190410192752.png" alt></p>
<h4 id="轮转综合数据存储简单~的一种变种"><a href="#轮转综合数据存储——简单-的一种变种" class="headerlink" title="轮转综合数据存储——简单~的一种变种"></a>轮转综合数据存储——简单~的一种变种</h4><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190410192855.png" alt></p>
<h4 id="上面的对比"><a href="#上面的对比" class="headerlink" title="上面的对比"></a>上面的对比</h4><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190410192959.png" alt></p>
<h4 id="简单直接文件"><a href="#简单直接文件" class="headerlink" title="简单直接文件"></a>简单直接文件</h4><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190410193115.png" alt></p>
<h4 id="连续文件"><a href="#连续文件" class="headerlink" title="连续文件"></a>连续文件</h4><p>创建的两种方法</p>
<ul>
<li>依据两个或更多的简单直接文件能生成一种连续文件</li>
<li>通过把一个快照追加到一个以前生成的连续文件上来创建</li>
</ul>
<h3 id="标准手册"><a href="#标准手册" class="headerlink" title="标准手册"></a>标准手册</h3><h3 id="审计和数据仓库"><a href="#审计和数据仓库" class="headerlink" title="审计和数据仓库"></a>审计和数据仓库</h3><h3 id="成本合理性"><a href="#成本合理性" class="headerlink" title="成本合理性"></a>成本合理性</h3><h3 id="清理仓库数据"><a href="#清理仓库数据" class="headerlink" title="清理仓库数据"></a>清理仓库数据</h3><h3 id="报表和体系结构设计环境"><a href="#报表和体系结构设计环境" class="headerlink" title="报表和体系结构设计环境"></a>报表和体系结构设计环境</h3><h3 id="机遇性的操作型窗口"><a href="#机遇性的操作型窗口" class="headerlink" title="机遇性的操作型窗口"></a>机遇性的操作型窗口</h3>]]></content>
      <categories>
        <category>商务智能</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Data Warehouse</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库（三）</title>
    <url>/post/fea0489f/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="building-the-data-warehouse第三章-设计"><a href="#《Building-the-Data-Warehouse》第三章-设计" class="headerlink" title="《Building the Data Warehouse》第三章 设计"></a>《Building the Data Warehouse》第三章 设计</h2><p>建造的两个主要方面——与操作型系统接口的设计和<strong>数据仓库本身的设计</strong>。但“设计”本身不是精确地描述，启发式的设计流程一般为，<strong>首先，载入一部分数据，供DSS分析员使用和查看。然后，根据最终用户的反馈，在数据仓库中修改、增添一些数据。</strong></p>
<h2 id="操作型数据开始"><a href="#操作型数据——开始" class="headerlink" title="操作型数据——开始"></a>操作型数据——开始</h2><p>建造数据仓库仅仅是数据的抽取过程错误——原因：操作型环境中的数据是<strong>非集成</strong>的。如下图</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190411095919.png" alt></p>
<h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><h4 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h4><ul>
<li>从操作型环境中<strong>适当地提取数据</strong>的<strong>编码</strong>过程——不同的数据类型，字段值必须正确地译码并采用合适的值重新写入记录仪；统一度量</li>
<li>字段转换，建立<strong>不同源字段到数据仓库字段的映射</strong></li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>存取现存系统数据的<strong>效率</strong></p>
<p>对全部文件数据进行扫描造成很大的浪费。</p>
<p>从操作型—-&gt;数据仓库的<strong>三种装载工作</strong></p>
<h5 id="装载档案数据"><a href="#装载档案数据" class="headerlink" title="装载档案数据"></a>装载<strong>档案数据</strong></h5><p>难度不大，操作频率低</p>
<h5 id="装载在操作型系统中目前已有的数据"><a href="#装载在操作型系统中目前已有的数据" class="headerlink" title="装载在操作型系统中目前已有的数据"></a>装载在<strong>操作型系统</strong>中目前<strong>已有</strong>的数据</h5><p>难度不大，只需要装载一次</p>
<h5 id="装载数据库更新"><a href="#装载数据库更新" class="headerlink" title="装载数据库更新"></a>装载<strong>数据库更新</strong></h5><p>最为困难。将自数据库上次刷新以来在操作型环境中不断发生的变化 (更新)从操作型环境中装载到数据仓库中。</p>
<p>数据仓库体系结构设计者的主要问题——<strong>扫描已有的文件，捕捉变化并对之进行处理</strong></p>
<h4 id="时基变化"><a href="#时基变化" class="headerlink" title="时基变化"></a>时基变化</h4>]]></content>
      <categories>
        <category>商务智能</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Data Warehouse</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库（四）</title>
    <url>/post/498d51fa/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="building-the-data-warehouse第四章-粒度"><a href="#《Building-the-Data-Warehouse》第四章-粒度" class="headerlink" title="《Building the Data Warehouse》第四章 粒度"></a>《Building the Data Warehouse》第四章 粒度</h2><p>数据仓库开发者要解决的重要的设计问题是<strong>粒度确定</strong>。</p>
<h3 id="粗略估算"><a href="#粗略估算" class="headerlink" title="粗略估算"></a>粗略估算</h3><p><strong>起点</strong>——粗略估算数据仓库中将来的数据行数和所需DASD（直接存取存储设备）数——关于<strong>数量级</strong>的估计。</p>
<p><strong>例子</strong></p>
<p>估计数据仓库环境中的行数/空间大小</p>
<ol>
<li><p>对每一个已知的表：</p>
<p>​    计算一行所占字节数的</p>
<p>​        最大估计值</p>
<p>​        最小估计值</p>
<p>对一年内：</p>
<p>​    最大行数可能是多少？</p>
<p>​    最小行数可能是多少？</p>
<p>对五年内：</p>
<p>​    最大行数可能是多少？</p>
<p>​    最小行数可能是多少？</p>
<p>对表的每个键码：</p>
<p>​    该键码的大小（按字节）是多少；</p>
<p>​    一年总的最大空间=最大行大小 * 一年内最大行数</p>
<p>​    一年总的最小空间=最小行大小 * 一年内最小行数</p>
<p>​    累加索引空间</p>
</li>
<li><p>对所有已知的表重复第1步</p>
</li>
</ol>
<h3 id="粒度划分过程的输入"><a href="#粒度划分过程的输入" class="headerlink" title="粒度划分过程的输入"></a>粒度划分过程的输入</h3><p><strong>估计的行数</strong>和<strong>DASD数</strong>作为粒度划分过程的输入</p>
<h4 id="空间估算-行估算"><a href="#空间估算、行估算" class="headerlink" title="空间估算、行估算"></a>空间估算、行估算</h4><ul>
<li>需要多少DASD？排序的引导时间估计是多少？</li>
<li>需要双重粒度吗？</li>
</ul>
<h3 id="选择双重还是单一的粒度"><a href="#选择双重还是单一的粒度" class="headerlink" title="选择双重还是单一的粒度"></a>选择双重还是单一的粒度</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190413212024.png" alt></p>
<h3 id="确定粒度的级别"><a href="#确定粒度的级别" class="headerlink" title="确定粒度的级别"></a>确定粒度的级别</h3><p>对于轻度汇总的数据要确定合适的粒度级别，唯一可行的方法是将数据拿到最终用户面前。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190413212918.png" alt></p>
<h3 id="反馈循环技巧不是很懂"><a href="#反馈循环技巧（不是很懂）" class="headerlink" title="反馈循环技巧（不是很懂）"></a>反馈循环技巧（不是很懂）</h3><h3 id="粒度级别银行环境"><a href="#粒度级别——银行环境" class="headerlink" title="粒度级别——银行环境"></a>粒度级别——银行环境</h3><ul>
<li></li>
</ul>
<h2 id="building-the-data-warehouse第五章-数据仓库与技术"><a href="#《Building-the-Data-Warehouse》第五章-数据仓库与技术" class="headerlink" title="《Building the Data Warehouse》第五章 数据仓库与技术"></a>《Building the Data Warehouse》第五章 数据仓库与技术</h2><p>数据仓库在<strong>技术上的需求</strong></p>
<h3 id="技术需求"><a href="#技术需求" class="headerlink" title="技术需求"></a>技术需求</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190422001508.png" alt></p>
<h4 id="1-管理大量数据最重要"><a href="#1-管理大量数据——最重要" class="headerlink" title="1. 管理大量数据——最重要"></a>1. 管理大量数据——最重要</h4><p>具体方法：</p>
<ul>
<li>寻址</li>
<li>索引</li>
<li>数据的外延</li>
<li>有效的溢出管理</li>
</ul>
<p>两方面——</p>
<ul>
<li><strong>能够</strong>管理大量数据的能力</li>
<li>能够<strong>管理好</strong>的能力</li>
</ul>
<h4 id="2-管理多介质"><a href="#2-管理多介质" class="headerlink" title="2. 管理多介质"></a>2. 管理多介质</h4><p>在处理大量数据时满足<strong>高效率</strong>和<strong>合理的费用</strong></p>
<p>层次划分</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>存储方式</th>
<th>访问速度</th>
<th>存储费用</th>
</tr>
</thead>
<tbody>
<tr>
<td>主存</td>
<td>非常快</td>
<td>非常贵</td>
</tr>
<tr>
<td>扩展内存</td>
<td>非常快</td>
<td>贵</td>
</tr>
<tr>
<td>高速缓存</td>
<td>非常快</td>
<td>贵</td>
</tr>
<tr>
<td>DASD</td>
<td>快</td>
<td>适中</td>
</tr>
<tr>
<td>光盘</td>
<td>不慢</td>
<td>不贵</td>
</tr>
<tr>
<td>缩微胶片</td>
<td>满</td>
<td>便宜</td>
</tr>
</tbody>
</table>
</div>
<p>处理数据仓库技术应该能管理多种存储介质上的数据。</p>
<h4 id="3-索引数据监视"><a href="#3-索引-数据监视" class="headerlink" title="3. 索引/数据监视"></a>3. 索引/数据监视</h4><p>数据仓库——<strong>灵活性</strong>、<strong>对数据会进行不可预测的访问</strong>——要能对数据进行<strong>快速和方便的访问</strong></p>
<p>索引——<strong>有用的</strong>、建立和应用的<strong>费用不能太高</strong></p>
<p>数据监视——<strong>费用不能太高</strong>、<strong>过程不能太复杂</strong>、<strong>在需要时随时运行</strong></p>
<p>监视数据仓库中数据的<strong>理由</strong></p>
<ul>
<li>决定是否应数据重组</li>
<li>决定是否应数据重组。</li>
<li>决定索引是否建立得不恰当。</li>
<li>决定是否有太多数据溢出。</li>
<li>决定数据的统计成份。</li>
<li>决定剩余的可用空间。</li>
</ul>
<h4 id="4-多种技术的接口"><a href="#4-多种技术的接口" class="headerlink" title="4. 多种技术的接口"></a>4. 多种技术的接口</h4><p><strong>能够用各种不同的技术获得和传送数据</strong></p>
<p>接口不仅要<strong>高效</strong>，还要<strong>便于使用</strong>，并<strong>能够在批模式下运行</strong></p>
]]></content>
      <categories>
        <category>商务智能</category>
      </categories>
      <tags>
        <tag>BI</tag>
        <tag>Data Warehouse</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘——概念和技术</title>
    <url>/post/f4ae35d9/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h2><p>《数据挖掘：概念与技术（第三版）》</p>
<p><strong>数据挖掘入门导论</strong>章节</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">章节</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第一章</td>
<td style="text-align:center">引论</td>
</tr>
<tr>
<td style="text-align:center">第二章</td>
<td style="text-align:center">认识数据</td>
</tr>
<tr>
<td style="text-align:center">第三章</td>
<td style="text-align:center">数据预处理</td>
</tr>
<tr>
<td style="text-align:center">第六章</td>
<td style="text-align:center">挖掘频繁模式、关联和相关性：基本概念和方法</td>
</tr>
<tr>
<td style="text-align:center">第八章</td>
<td style="text-align:center">分类：基本概念</td>
</tr>
<tr>
<td style="text-align:center">第十章</td>
<td style="text-align:center">聚类分析：基本概念和方法</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><h3 id="11-为什么需要数据挖掘"><a href="#1-1-为什么需要数据挖掘" class="headerlink" title="1.1 为什么需要数据挖掘"></a>1.1 为什么需要数据挖掘</h3><p>数据丰富，信息贫乏</p>
<h3 id="12-什么是数据挖掘"><a href="#1-2-什么是数据挖掘" class="headerlink" title="1.2 什么是数据挖掘"></a>1.2 什么是数据挖掘</h3><p>数据挖掘 = 数据中的知识发现（KDD） or  知识发现过程的一个基本步骤</p>
<p>由以下迭代序列组成</p>
<ol>
<li><p><strong>数据清理</strong>（消除噪音和删除不一致数据）</p>
</li>
<li><p><strong>数据集成</strong>（多种数据源可以组合在一起）</p>
</li>
</ol>
<ol>
<li><p><strong>数据选择</strong>（从数据库中提取与分析任务相关的数据）</p>
</li>
<li><p><strong>数据变换</strong>（通过汇总或狙击操作，把数据变换和统一成适合挖掘的形式）</p>
</li>
<li><p><strong>数据挖掘</strong>（基本步骤，使用智能方法提取数据模式）</p>
</li>
<li><p><strong>模式评估</strong>（根据某种<em>兴趣度量</em>，识别代表知识的真正有趣的模式。）</p>
</li>
<li><p><strong>知识表示</strong>（使用可视化和知识表示技术，向用户提供挖掘的知识）</p>
</li>
</ol>
<h3 id="13-可以挖掘什么类型的数据"><a href="#1-3-可以挖掘什么类型的数据" class="headerlink" title="1.3 可以挖掘什么类型的数据"></a>1.3 可以挖掘什么类型的数据</h3><h4 id="131-数据库数据"><a href="#1-3-1-数据库数据" class="headerlink" title="1.3.1 数据库数据"></a>1.3.1 数据库数据</h4><p>关系型数据库是数据挖掘最常见、最丰富的信息源头。</p>
<h4 id="132-数据仓库"><a href="#1-3-2-数据仓库" class="headerlink" title="1.3.2 数据仓库"></a>1.3.2 数据仓库</h4><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190425095053.png" alt></p>
<p>见    <a href="http://songzi.info/tags/Data-Warehouse/">数据仓库</a></p>
<p><strong>数据立方体</strong>——多维数据挖掘（详情见第四章）</p>
<h4 id="133-事务数据"><a href="#1-3-3-事务数据" class="headerlink" title="1.3.3 事务数据"></a>1.3.3 事务数据</h4><p><strong>频繁模式挖掘</strong></p>
<h4 id="134-其他类型的数据"><a href="#1-3-4-其他类型的数据" class="headerlink" title="1.3.4 其他类型的数据"></a>1.3.4 其他类型的数据</h4><p>更高级的课题</p>
<h3 id="14-挖掘模式"><a href="#1-4-挖掘模式" class="headerlink" title="1.4 挖掘模式"></a>1.4 挖掘模式</h3><p>用于指定数据挖掘任务发现的模式，任务类型可分为</p>
<ul>
<li>描述性</li>
<li>预测性</li>
</ul>
<h4 id="141-类概念描述特征化与区分"><a href="#1-4-1-类-概念描述：特征化与区分" class="headerlink" title="1.4.1 类/概念描述：特征化与区分"></a>1.4.1 类/概念描述：特征化与区分</h4><p>通过以下方法得到类/概念描述</p>
<ol>
<li><em>数据特征化</em>：一般地汇总<strong>目标类</strong>的数据<ul>
<li>基于统计度量和图的简单数据汇总（第二章）</li>
<li>基于数据立方体的OLAP上卷操作（第四五章）</li>
<li>面向属性的归纳技术（第四章）</li>
<li>输出形式：<strong>多维表</strong>、<strong>广义关系或特征规则</strong></li>
</ul>
</li>
<li><em>数据区分</em>：将<strong>目标类</strong>与一个或多个<strong>对比类</strong>进行比较<ul>
<li><strong>区分规则</strong></li>
</ul>
</li>
<li>数据特征化和区分</li>
</ol>
<h4 id="142-挖掘频繁模式-关联-相关性"><a href="#1-4-2-挖掘频繁模式、关联、相关性" class="headerlink" title="1.4.2 挖掘频繁模式、关联、相关性"></a>1.4.2 挖掘频繁模式、关联、相关性</h4><ul>
<li><p><strong>频繁模式</strong>：数据中频繁出现的模式</p>
<ul>
<li>频繁项集：例如小卖部被许多顾客频繁一起购买的啤酒和尿布</li>
<li>频繁子序列（序列模式）：例如项集里的购买顺序</li>
<li>频繁子结构：将项集与子序列结合起来的数据结构</li>
</ul>
</li>
<li><p><strong>单维关联规则</strong></p>
<script type="math/tex; mode=display">{单维关联规则}
buys (X, "computer") => buys(X, "software")[support = 0.01, confidence = 0.5]</script><p>以上为包含单个谓词的关联规则-&gt; <strong>单维关联规则</strong>，可简化为</p>
<script type="math/tex; mode=display">{单维关联规则}
computer=>software[0.01, 0.5]</script></li>
</ul>
<ul>
<li><p><strong>多维关联规则</strong></p>
<script type="math/tex; mode=display">{多维关联规则}
age(X, "20..29") ~ income(X, "40K..49K")=>buys(X,"laptop")[support = 0.02, confidence = 0.6]</script></li>
<li><p><strong>最小支持度阈值</strong> 和 <strong>最小置信度阈值</strong></p>
</li>
<li><p><strong>相关性</strong></p>
</li>
</ul>
<p>详情见第六七章</p>
<h4 id="143-预测分析的分类与回归"><a href="#1-4-3-预测分析的分类与回归" class="headerlink" title="1.4.3 预测分析的分类与回归"></a>1.4.3 预测分析的分类与回归</h4><ul>
<li><p><strong>分类模型</strong> 分类预测类别符号</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190427134617.png" alt></p>
<ul>
<li><strong>IF-THEN 规则</strong></li>
<li><strong>决策树</strong>——每个节点代表在一个属性值上的测试，每个分支代表测试的一个结果，树叶代表类或类分布</li>
<li><strong>神经网络</strong>——类似神经元的处理单位，单元之间加权连接</li>
</ul>
</li>
<li><p><strong>回归</strong>建立连续值函数模型；也包含基于可用数据的分布<em>趋势</em>识别</p>
</li>
<li><p>相关分析 试图识别与分类和回归过程显著相关的属性</p>
</li>
</ul>
<h4 id="144-聚类分析"><a href="#1-4-4-聚类分析" class="headerlink" title="1.4.4 聚类分析"></a>1.4.4 聚类分析</h4><p>聚类<strong>分析数据对象</strong>，而不考虑类符号。</p>
<p>对象根据<strong>最大化类内相似性</strong>、<strong>最小化类间相似性</strong>的原则进行聚类</p>
<h4 id="145-离群点分析-第十二章"><a href="#1-4-5-离群点分析-第十二章" class="headerlink" title="1.4.5 离群点分析 第十二章"></a>1.4.5 离群点分析 第十二章</h4><ul>
<li><strong>离群点</strong>：在数据集中，与其他数据的一般行为或模型不一致的数据对象</li>
<li>检测方法<ul>
<li>统计检测</li>
<li>距离度量</li>
<li>基于密度的一系列方法</li>
</ul>
</li>
</ul>
<h4 id="146-寻找有趣的模式"><a href="#1-4-6-寻找有趣的模式" class="headerlink" title="1.4.6 寻找有趣的模式"></a>1.4.6 寻找有趣的模式</h4><h3 id="15-使用的技术"><a href="#1-5-使用的技术" class="headerlink" title="1.5 使用的技术"></a>1.5 使用的技术</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/截图20190427164619.png" alt="数据挖掘从其他许多领域吸纳技术"></p>
<ul>
<li>统计</li>
<li>及其学习</li>
<li>数据库系统与数据仓库</li>
<li>信息检索</li>
</ul>
<h3 id="16-面向什么类型的应用"><a href="#1-6-面向什么类型的应用" class="headerlink" title="1.6 面向什么类型的应用"></a>1.6 面向什么类型的应用</h3><p>数据挖掘本身是<strong>应用驱动</strong>的学科</p>
<p>两个数据挖掘非常成功的应用例子</p>
<ul>
<li>商务智能——是BI的核心。商务智能的联机分析处理工具依赖于<strong>数据仓库和多维数据挖掘</strong>。<strong>分类和预测技术</strong>是商务智能预测分析的核心。</li>
<li>Web引擎——本质是<strong>大型数据挖掘应用</strong><ul>
<li>云计算</li>
<li>实时处理在线数据</li>
<li>在快速增长的数据流上维护和增量更新模型</li>
<li>处理出现次数不多的查询</li>
</ul>
</li>
</ul>
<h3 id="17-数据挖掘的重要问题"><a href="#1-7-数据挖掘的重要问题" class="headerlink" title="1.7 数据挖掘的重要问题"></a>1.7 数据挖掘的重要问题</h3><h4 id="171-挖掘方法"><a href="#1-7-1-挖掘方法" class="headerlink" title="1.7.1 挖掘方法"></a>1.7.1 挖掘方法</h4><p>要考虑数据的不确定性、噪声和不完全等问题</p>
<ul>
<li>挖掘各种<strong>新的知识类型</strong></li>
<li>挖掘<strong>多维空间的知识</strong></li>
<li><strong>集成多学科</strong>的新方法</li>
<li>提升<strong>网络环境</strong>下的发现能力：<strong>多个数据对象之间的语义链接-</strong>&gt;链接创造知识发现</li>
<li>处理不确定性、噪声、不完全数据：<strong>数据清洗、数据预处理、离群点检测与删除、不确定推理等等</strong></li>
<li>模式评估和模式或约束指导的挖掘</li>
</ul>
<h4 id="172-用户界面"><a href="#1-7-2-用户界面" class="headerlink" title="1.7.2 用户界面"></a>1.7.2 用户界面</h4><ul>
<li>交互挖掘：如何与数据挖掘系统交互。</li>
<li>结合背景知识：把<strong>背景知识、约束、规则和关于该领域的其他信息</strong>结合到发现过程中</li>
<li>特定的数据挖掘和数据挖掘<strong>查询语言</strong></li>
<li>数据挖掘结果的<strong>表示和可视化</strong></li>
</ul>
<h4 id="173-有效性和可伸缩性"><a href="#1-7-3-有效性和可伸缩性" class="headerlink" title="1.7.3 有效性和可伸缩性"></a>1.7.3 有效性和可伸缩性</h4><ul>
<li>数据挖掘算法的<strong>有效性和可伸缩性</strong>：驱动算法开发的关键标准</li>
<li>并行、分布式、增量挖掘算法</li>
</ul>
<p>==&gt; 云计算 集群计算</p>
<h2 id="第二章-认识数据"><a href="#第二章-认识数据" class="headerlink" title="第二章 认识数据"></a>第二章 认识数据</h2><h3 id="21-数据对象与属性类型"><a href="#2-1-数据对象与属性类型" class="headerlink" title="2.1 数据对象与属性类型"></a>2.1 数据对象与属性类型</h3><p>一个数据对象代表一个实体，用属性描述。</p>
<h4 id="211-什么是属性"><a href="#2-1-1-什么是属性" class="headerlink" title="2.1.1 什么是属性"></a>2.1.1 什么是属性</h4><p><em>属性（attribute）</em>数据字段——常常等同于<em>维度（dimension）</em>、<em>特征（feature）</em>、<em>变量（variable）</em>。</p>
<p><em>观测</em>——给定属性的观测值</p>
<p><em>属性向量（特征向量）</em>——描述一个给定对象的一组属性</p>
<p><em>单变量的（univariate）</em>——涉及一个属性或变量的数据分布</p>
<p><em>双变量的（bivariate）</em>——涉及两个属性</p>
<h4 id="212-标称属性"><a href="#2-1-2-标称属性" class="headerlink" title="2.1.2 标称属性"></a>2.1.2 标称属性</h4><p><em>标称属性（normal attribute）</em>的值是一些符号或事物的名称。每个值表示某种类别、编码、状态。因此，标称数据被看作是<em>分类的（categorical）</em>或<em>枚举的（enumeration）</em>。</p>
<p>标称数据没有序列，也不是定量的。</p>
<p>对于标称属性，均值或中位数没有意义。</p>
<p>众数，中心趋势度量 有意义。</p>
<h5 id="特殊二元属性"><a href="#特殊：二元属性" class="headerlink" title="特殊：二元属性"></a>特殊：二元属性</h5><p>只有两个类别或状态：0或1</p>
<ul>
<li>对称——两种状态具有同等价值并携带相同权重，如性别</li>
<li>非对称——状态的结果不是同样重要的，如HIV化验结果</li>
</ul>
<h4 id="213-序数属性"><a href="#2-1-3-序数属性" class="headerlink" title="2.1.3 序数属性"></a>2.1.3 序数属性</h4><p>在记录<strong>不能客观度量的主观质量评估</strong>时很有用，例如满意程度从0-5排序。</p>
<p>其中心趋势可以用众数和中位数（有序序列的中间值）表示</p>
<p>，但不能定义均值。</p>
<p>以上属性都是<strong>定性的</strong>。</p>
<h4 id="214-数值属性"><a href="#2-1-4-数值属性" class="headerlink" title="2.1.4 数值属性"></a>2.1.4 数值属性</h4><p><em>数值属性（numeric attribute）</em>是定量的，用整数或实数值表示，可以使<em>区间标度</em>或<em>比率标度</em>。</p>
<h5 id="2141-区间标度属性"><a href="#2-1-4-1-区间标度属性" class="headerlink" title="2.1.4.1 区间标度属性"></a>2.1.4.1 区间标度属性</h5><p>例如温度，用相等的单位尺度度量</p>
<h5 id="2142-比率标度属性"><a href="#2-1-4-2-比率标度属性" class="headerlink" title="2.1.4.2 比率标度属性"></a>2.1.4.2 比率标度属性</h5><p>例如工作年限，具有固定零点的数值属性</p>
<h4 id="215-离散属性和连续属性"><a href="#2-1-5-离散属性和连续属性" class="headerlink" title="2.1.5 离散属性和连续属性"></a>2.1.5 离散属性和连续属性</h4><h3 id="22-数据基本统计描述"><a href="#2-2-数据基本统计描述" class="headerlink" title="2.2 数据基本统计描述"></a>2.2 数据基本统计描述</h3><h4 id="221-中心趋势度量均值-中位数-总数"><a href="#2-2-1-中心趋势度量：均值、中位数、总数" class="headerlink" title="2.2.1 中心趋势度量：均值、中位数、总数"></a>2.2.1 中心趋势度量：均值、中位数、总数</h4><h4 id="222-度量数据散布极差-四分位数-方差-标准差-四分位数极差"><a href="#2-2-2-度量数据散布：极差、四分位数、方差、标准差、四分位数极差" class="headerlink" title="2.2.2 度量数据散布：极差、四分位数、方差、标准差、四分位数极差"></a>2.2.2 度量数据散布：极差、四分位数、方差、标准差、四分位数极差</h4>]]></content>
      <categories>
        <category>商务智能</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
      </tags>
  </entry>
  <entry>
    <title>简单数据库实现一</title>
    <url>/post/1a82e99d/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><a href="https://sites.google.com/site/cs186fall2013">课程链接</a></p>
<h2 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h2><h3 id="1-simpledb体系结构"><a href="#1-SimpleDB体系结构" class="headerlink" title="1. SimpleDB体系结构"></a>1. SimpleDB体系结构</h3><p>Consists of</p>
<ul>
<li><strong>包含字段、元组、元组架构的类</strong>。Classes that represent fields, tuples, and tuple schemas;</li>
<li><strong>将谓词和条件应用于元组的类</strong>。Classes that apply predicates and conditions to tuples;</li>
<li><strong>一种或多种访问方式</strong>——将关系存储在磁盘上并提供一种遍历这些关系的元组的方法。One or more access methods (e.g., heap files) that store relations on disk and provide a way to iterate through tuples of those relations;</li>
<li><strong>处理元组的运算符类(select, join, insert, delete)的集合</strong>。</li>
<li><strong>缓冲池</strong>，用于在内存中缓存活动的元组和页面，并处理并发控制和事务。demo已经做好了</li>
<li><strong>存储有关可用表及其模式的信息的目录</strong>。A catalog that stores information about available tables and their schemas.</li>
</ul>
<h4 id="11-class-database"><a href="#1-1-Class-Database" class="headerlink" title="1.1 Class: Database"></a>1.1 Class: Database</h4><p>Database类提供<strong>对静态对象集合的访问</strong>，这些静态对象是数据库的<strong>全局对象</strong>。特别是，这包括访问目录（数据库中所有表的列表），缓冲池（当前驻留在内存中的数据库文件页面的集合）和日志文件的方法。</p>
<h4 id="12-field-tuple"><a href="#1-2-Field-Tuple" class="headerlink" title="1.2 Field  Tuple"></a>1.2 Field  Tuple</h4><p><strong>实现非常基本</strong>。包含一组 <code>Field</code>对象，每个字段一个<code>Tuple</code>。 </p>
<p><code>Field</code>是不同数据类型 (integer, string…) 实现的接口。</p>
<p><code>Tuple</code>对象是由基础访问方法(heap file, B-trees)创建的。</p>
<p>元组还具有一种由对象表示的类型（或架构），称为<em>元组描述符</em><code>TupleDesc</code>。</p>
<p>该对象由对象的集合组成，<code>Type</code>元组中的每个字段一个，每个对象描述相应字段的类型。</p>
<h4 id="13-class-catalog"><a href="#1-3-Class-Catalog" class="headerlink" title="1.3 Class: Catalog"></a>1.3 Class: Catalog</h4><p>由<strong>table lists</strong>和<strong>数据库中当前存在的表的schemas</strong>组成。</p>
<p><strong>添加新表</strong>以及<strong>获取有关特定表的信息</strong>的功能需要用到这个类。</p>
<p>与每个表相关联的是一个<code>TupleDesc</code>对象，该对象可以确定<strong>表中字段的类型和数量</strong>。</p>
<p>The global catalog是<code>Catalog</code>为整个SimpleDB进程分配的<strong>单个实例</strong>。 可用方法<code>Database.getCatalog()</code>。</p>
<h4 id="14-class-bufferpool"><a href="#1-4-Class-BufferPool" class="headerlink" title="1.4 Class: BufferPool"></a>1.4 Class: BufferPool</h4><p>负责在内存中<strong>缓存最近被读页面</strong>。</p>
<p>所有操作都通过缓冲池<strong>从磁盘上的各种文件读取和写入页面</strong>。</p>
<p>它由固定数量的页面组成，由构造函数的<code>numPages</code>参数定义 <code>BufferPool</code>。</p>
<p><code>Database</code>类提供一个获取BufferPool的静态方法，其中 <code>Database.getBufferPool()</code>即返回到单个缓冲池实例的引用整个SimpleDB的过程。</p>
<h4 id="15-heapfile-access-method"><a href="#1-5-HeapFile-access-method" class="headerlink" title="1.5 HeapFile access method"></a>1.5 HeapFile access method</h4><p>堆文件访问方法提供了一种<strong>从磁盘中读取或写入以特定方式排列的数据的方法</strong>。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘算法（一）——Aprior算法和FP-Tree算法</title>
    <url>/post/93db42ae/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p><a href="http://book.douban.com/subject/3283973/">啤酒与尿布</a></p>
<h3 id="总项集"><a href="#总项集" class="headerlink" title="总项集"></a>总项集</h3><p>数据记录的所有项的集合</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>TID</th>
<th>Items</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>{牛奶， 面包}</td>
</tr>
<tr>
<td>T2</td>
<td>{面包，尿布，啤酒， 鸡蛋}</td>
</tr>
<tr>
<td>T3</td>
<td>{尿布，啤酒}</td>
</tr>
<tr>
<td>T4</td>
<td>{面包，牛奶，尿布，可乐}</td>
</tr>
</tbody>
</table>
</div>
<h3 id="关联规则的定义"><a href="#关联规则的定义" class="headerlink" title="关联规则的定义"></a>关联规则的定义</h3><p>两个不相交的非空集合X、Y，如果有X—&gt;Y，就说X—&gt;Y是一条关联规则。例如购买啤酒就一定会购买尿布，可表示为<em>{啤酒}—&gt;{尿布}</em>。</p>
<p>下面两项用于描述<strong>关联规则的强度</strong></p>
<h4 id="支持度-support"><a href="#支持度-support" class="headerlink" title="支持度 support"></a>支持度 support</h4><p><strong>项集{X,Y}在总项集里出现的概率</strong></p>
<script type="math/tex; mode=display">
Support(X→Y) = P(X,Y) / P(I) = P(X∪Y) / P(I) = num(XUY) / num(I) = (同时购买{X, Y}的订单) / (总订单)</script><p>I表示总事务集。num()表示求事务集里特定项集出现的次数。 num(I)表示总事务集的个数。num(X∪Y)表示含有{X,Y}的事务集的个数（个数也叫次数）。</p>
<h4 id="置信度-confidence"><a href="#置信度-confidence" class="headerlink" title="置信度 confidence"></a>置信度 confidence</h4><p><strong>在先决条件X发生的情况下，由关联规则”X→Y“推出Y的概率</strong></p>
<script type="math/tex; mode=display">
Confidence(X→Y) = P(Y|X)  = P(X,Y) / P(X) = P(XUY) / P(X) = （同时购买{X, Y}的订单）/（购买X的订单）</script><script type="math/tex; mode=display">
Confidence(Y→X) = P(X|Y)  = P(X,Y) / P(Y) = P(XUY) / P(Y) = （同时购买{X, Y}的订单）/（购买Y的订单）</script><h4 id="提升度-lift"><a href="#提升度-lift" class="headerlink" title="提升度 lift"></a>提升度 lift</h4><p><strong>含有X的条件下，同时含有Y的概率，与Y总体发生的概率之比</strong></p>
<script type="math/tex; mode=display">
Lift(X→Y) = P(Y|X) / P(Y) = （同时购买{X，Y}的订单*总订单）/（购买X的订单*购买Y的订单）</script><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>buy tea</th>
<th>buy coffee</th>
</tr>
</thead>
<tbody>
<tr>
<td>Group A(500)</td>
<td>500</td>
<td>450</td>
</tr>
<tr>
<td>Group B(500)</td>
<td>0</td>
<td>450</td>
</tr>
</tbody>
</table>
</div>
<p>X= {buy tea}，Y={buy coffee}，则规则”茶叶→咖啡“表示”即买了茶叶，又买了咖啡“</p>
<ul>
<li>support(X→Y) =  450 / 500 = 90%</li>
<li>Confidence(X→Y) = 450 / 500 = 90%</li>
<li>Lift(X→Y) = Confidence(X→Y) / P(Y) = 90% /  ((450+450) / 1000) = 90% / 90% = 1</li>
</ul>
<h3 id="关联规则挖掘的定义和步骤"><a href="#关联规则挖掘的定义和步骤" class="headerlink" title="关联规则挖掘的定义和步骤"></a>关联规则挖掘的定义和步骤</h3><p><em>给定一个交易数据集T，找出其中所有支持度$support &gt;= minSupport$、自信度$confidence &gt;= minConfidence$的关联规则。</em></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li><p><strong>生成频繁项集（O(2^N)，耗时，优化对象）</strong></p>
<p>找出所有满足最小支持度的项集</p>
</li>
<li><p><strong>生成规则</strong></p>
<p>生成满足最小自信度的规则，产生的规则为强规则</p>
</li>
</ul>
<h2 id="apriori定律消除频繁项集生成时间"><a href="#Apriori定律——消除频繁项集生成时间" class="headerlink" title="Apriori定律——消除频繁项集生成时间"></a>Apriori定律——消除频繁项集生成时间</h2><h4 id="定律一"><a href="#定律一" class="headerlink" title="定律一"></a>定律一</h4><p><em>如果一个集合是频繁项集，则它的所有子集都是频繁项集</em>。</p>
<p>举例：假设一个集合{A,B}是频繁项集，即A、B同时出现在一条记录的次数大于等于最小支持度min_support，则它的子集{A},{B}出现次数必定大于等于min_support，即它的子集都是频繁项集。</p>
<h4 id="定律二"><a href="#定律二" class="headerlink" title="定律二"></a>定律二</h4><p><em>如果一个集合不是频繁项集，则它的所有超集都不是频繁项集。</em></p>
<p>举例：假设集合{A}不是频繁项集，即A出现的次数小于min_support，则它的任何超集如{A,B}出现的次数必定小于min_support，因此其超集必定也不是频繁项集。</p>
<h3 id="apriori算法实现"><a href="#Apriori算法实现" class="headerlink" title="Apriori算法实现"></a>Apriori算法实现</h3><p><a href="https://github.com/linyiqun/DataMiningAlgorithm/tree/master/AssociationAnalysis/DataMining_Apriori">大佬的算法实现</a></p>
<h2 id="fp-tree频繁模式树算法"><a href="#FP-Tree频繁模式树算法" class="headerlink" title="FP-Tree频繁模式树算法"></a>FP-Tree频繁模式树算法</h2><p>FP-Tree算法是Apriori算法的优化处理，Apriori算法在过程中会产生大量的候选集的问题，FP-Tree算法则是<em>发现频繁模式而不产生候选集</em>。</p>
<p>但是频繁模式挖掘出来后，产生关联规则的步骤还是和Apriori是一样的。</p>
<h3 id="步骤"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><p>创建根节点</p>
</li>
<li><p>统计所有的事务数据，统计事务中各个类型项的总支持度(在下面的例子中就是各个商品ID的总个数)</p>
</li>
<li><p>依次读取每条事务，比如T1， 1， 2， 5，因为按照总支持度计数数量降序排列，输入的数据顺序就是2， 1， 5，然后挂到根节点上</p>
</li>
<li><p>依次读取后面的事务，并以同样的方式加入的FP树中，顺着根节点路径添加，并更新节点上的支持度计数。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/fengfenggirl/p/associate_apriori.html">数据挖掘系列（1）关联规则挖掘基本概念与Aprior算法</a></p>
<p><a href="https://github.com/linyiqun/DataMiningAlgorithm/tree/master/AssociationAnalysis/DataMining_Apriori">算法实现</a></p>
]]></content>
      <categories>
        <category>商务智能</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘算法（二）——Boosting算法和AdaBoost装袋提升算法</title>
    <url>/post/f0ff41c2/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><h3 id="boosting算法"><a href="#Boosting算法" class="headerlink" title="Boosting算法"></a>Boosting算法</h3><p><strong>Boosting 提升算法</strong>是<strong>一系列</strong>将罗学习器提升为强学习器的算法。</p>
<p>思想：对于一个复杂的任务，将多个专家的判断总和得出的结果要比任何一个专家单独的判断好。</p>
<p>大致工作机制：</p>
<p>先从初始训练集训练出一个<strong>基学习器</strong>，再根据基学习器表现对训练样本分布进行调整，在后续赋予基学习器中做错的样本更大的权值，然后基于调整后的样本分布来训练下一个基学习器，一直反复进行，直到达到指定值。</p>
<h3 id="adaboost算法"><a href="#AdaBoost算法" class="headerlink" title="AdaBoost算法"></a>AdaBoost算法</h3><p>AdaBoost算法工作机制同上。</p>
<p>对于弱分类器的组合，AdaBoost算法采取<strong>加权多数表决</strong>的方法——加大分类误差率小的弱分类器的权值，使其在表决中起到较大的作用；减小分类误差率大的弱分类器的权值，使其在表决中起较小的作用。</p>
<p>应用集中于<strong>提高分类准确率</strong>。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>对D训练集数据训练处一个分类器Ci</li>
<li>通过分类器Ci对数据进行分类，计算此时误差率</li>
<li>把上步骤中的分错的数据的权重提高，分对的权重降低，以此凸显了分错的数据。为什么这么做呢，后面会做出解释。</li>
</ol>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/1335428125_1739.png" alt="adaboost算法伪码"></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2>]]></content>
      <categories>
        <category>商务智能</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
      </tags>
  </entry>
  <entry>
    <title>文学与伦理</title>
    <url>/post/24263c33/</url>
    <content><![CDATA[<h1 id="文学与伦理19世纪俄罗斯文学"><a href="#文学与伦理——19世纪俄罗斯文学" class="headerlink" title="文学与伦理——19世纪俄罗斯文学"></a>文学与伦理——19世纪俄罗斯文学</h1><p>先前阅读了《罪与罚》《卡拉马佐夫兄弟》，《战争与和平》重新浏览了一遍，想借助这个网课加深理解这些作品里的伦理学观点。</p>
<h2 id="1-文学与伦理的关系与意义"><a href="#1-文学与伦理的关系与意义" class="headerlink" title="1. 文学与伦理的关系与意义"></a>1. 文学与伦理的关系与意义</h2><p>参考书目：</p>
<p>《罪与罚》</p>
<p>《卡拉马佐夫兄弟》：如果上帝死了，是不是什么都可以做？——旧的道德被打破，新的道德是什么？博爱是否可能？博爱还是怜悯？罪恶的原因是什么？</p>
<p>《安娜 · 卡列宁娜》</p>
<p>《战争与和平》</p>
<p><strong>《道德、上帝与人》 《伦理学是什么》</strong></p>
<p>普希金、莱蒙托夫、屠格涅夫、契克夫</p>
<p><strong>高峰体验</strong></p>
<h3 id="文学与伦理的关系"><a href="#文学与伦理的关系" class="headerlink" title="文学与伦理的关系"></a>文学与伦理的关系</h3><p>伦理学：价值问题、规范问题、信仰、渴望；善与正当之间是一种什么关系？</p>
<ul>
<li>传统伦理学：最高的“善”</li>
<li>现代伦理学：一切合理的价值追求应该都是平等的。-&gt; 社会的共识很难建立在价值的追求上，而建立在<strong>行为的规范</strong>上</li>
</ul>
<h3 id="文学与伦理的意义"><a href="#文学与伦理的意义" class="headerlink" title="文学与伦理的意义"></a>文学与伦理的意义</h3><p>文学最早进入，可能成为终生爱好</p>
<p>文学容易进入，不易退出</p>
<p>文学能够无需中介，直接给社会带来影响</p>
<p>创作与引述：诗歌、文学更依赖于天才</p>
<p>文学可以作为外行判断各个学科水平的指标</p>
<p>文学是生动、复杂、紧张、暧昧的，是最好的思考和分析材料</p>
<h3 id="西方文学"><a href="#西方文学" class="headerlink" title="西方文学"></a>西方文学</h3><p>古希腊：《荷马史诗》；悲剧——埃斯库罗斯、索罗克勒斯、欧里庇得斯</p>
<p>英国：莎士比亚——人性的百科全书、狄更斯：同情、成长</p>
<p>美国：惠特曼、狄金森《白鲸》</p>
<p>法国：巴尔扎克《人间悲剧》《高老头》、雨果《巴黎圣母院》《悲惨世界》、罗曼罗兰、萨特 戏剧、加缪《鼠疫》《正义者》</p>
<p>德国：歌德《浮士德》</p>
<p>… …</p>
<h2 id="2-19世纪俄罗斯文学和陀思妥耶夫斯基"><a href="#2-19世纪俄罗斯文学和陀思妥耶夫斯基" class="headerlink" title="2. 19世纪俄罗斯文学和陀思妥耶夫斯基"></a>2. 19世纪俄罗斯文学和陀思妥耶夫斯基</h2><h3 id="黄金时代"><a href="#黄金时代" class="headerlink" title="黄金时代"></a>黄金时代</h3><p>普希金、契克夫、托尔斯泰</p>
<h3 id="白银时代"><a href="#白银时代" class="headerlink" title="白银时代"></a>白银时代</h3><p>陀思妥耶夫斯基</p>
<h3 id="陀氏生平"><a href="#陀氏生平" class="headerlink" title="陀氏生平"></a>陀氏生平</h3><p>40年代-60年代：24岁《穷人》《白夜》《双重人格》</p>
<p>《死屋手记》《地下室手记》</p>
<p>60年代-70年代：《罪与罚》《卡拉马佐夫兄弟》</p>
<p><em>从超然的角度、从文学批评的角度，或是在专业人员给未曾阅读过某书的人介绍该书时，专业人士通常使用具有辨识度的标签来解释作品，如悬疑、侦探等等，但是在个人创作时，这种标签能成为我们的指导吗？</em></p>
<h3 id="陀氏作品的特点"><a href="#陀氏作品的特点" class="headerlink" title="陀氏作品的特点"></a>陀氏作品的特点</h3><p>思想者的形象：描绘思想本身、思想的过程；始终处在一种紧张的对话、思考之中；复调小说、思想与人物不可分割；理解思想应是对话性的；</p>
<p>十九世纪俄国思想家共有特性：</p>
<ol>
<li>笔下的“思想者”更多地具有一种<strong>只求真理、不计功利、不计成败、不惜性命</strong>的气质</li>
<li>“思想者”与一往无前的“行动家”、“活动家”相<strong>对立</strong></li>
</ol>
<p>陀思妥耶夫斯基作品特点：</p>
<ol>
<li>主要作品中不包括<strong>女性</strong>，而女性更作为象征美、激情、怜悯者或被怜悯者</li>
<li>不一定用相对正面的任务来表达自己赞成的思想，有时恰恰是那些“<strong>小人物</strong>”来说出</li>
<li>行动不一定极端，但把思想推到<strong>极端</strong></li>
</ol>
<p>困惑</p>
<ol>
<li>近代以来社会的<strong>道德基础</strong>是不是在分解乃至崩溃？</li>
<li>人类是否由于进入现代社会而面临了一个<strong>根本的转折点</strong>？</li>
<li>一个人or一个集体出于<strong>某些理由</strong>，常常是不失为高尚和优越的理由，在某些情况下是否就可<strong>逾越道德的界限</strong>？</li>
<li>如果没有永恒与不朽，<strong>道德禁令的绝对性</strong>是否无论如何要成为疑问？</li>
<li>假如“死去的上帝”重返人间，人间是否能如故？</li>
<li>人究竟应该对自己有何种<strong>期望</strong>？何种<strong>追求</strong>？</li>
</ol>
<h2 id="3-罪与罚与个人行为伦理"><a href="#3-《罪与罚》与个人行为伦理" class="headerlink" title="3. 《罪与罚》与个人行为伦理"></a>3. 《罪与罚》与个人行为伦理</h2><p>拉斯科尔尼科夫</p>
<p>理性杀人：手段理性、价值理性；纳粹屠杀情境</p>
<p>关键在于自己认为杀此人是否正当，理由是否具有个体认识上的真实——因此试图提出一个理由，<strong>获取良心的许可</strong>，渴望越界杀人<strong>不会引起良心的纷扰和痛苦</strong>，而仍然保持平安。</p>
<p>越界理由：<strong>优秀和平庸</strong>——优秀者为实现其伟大目标可以不择手段，甚至杀人。</p>
<p>紧接着一定会遇到的<strong>两个问题</strong>：</p>
<ul>
<li>人如何<strong>辨别</strong>两种人，这种内在的辨别，对人自我的辨别</li>
<li>如果内心有权杀人的第二种人很多怎么办？<strong>社会将要崩溃</strong>？</li>
</ul>
<p>需要注意的是：即使行为得到理论事实的承认（芸芸众生与精英），也要看是否符合伦理规范（杀人犯法）</p>
<p>所谓精英：观念的精英；行动的天才</p>
<p>《卡拉马佐夫兄弟》伊凡：将无神论、无政府主义、社会主义混淆在一起，把伊凡携程那桩弑父案的思想教唆这，一次来与革命民主派进行争论，否定社会主义。“<strong>既然没有上帝，则什么都可以做。</strong>”</p>
<p>重要的问题 多数和少数的问题</p>
<ul>
<li>上帝的问题</li>
<li>自由的问题</li>
<li>犯罪的问题</li>
<li>人的命运和前景的问题</li>
</ul>
<p>这更深层次的原因是<strong>社会的巨大转变</strong>：现代社会的<strong>平等</strong>（重要关键词），不仅仅是权利的平等，更被引申为智力的平等——极大调用人的<strong>欲望</strong>——道德</p>
<blockquote>
<p><em>现在俄罗斯谁不自以为是拿破仑呢？这是一个士兵都想当元帅，市民都想称为巨富罗特希尔德的时代。</em></p>
<p><em>平等的逐渐发展，是事所必至，天意使然。这种发展就有的主要特征是，它每时每刻都能摆脱人力的阻挠，<strong>所有的事和所有的人都在帮助它前进</strong>。</em> ——托克维尔《论美国的民主》</p>
</blockquote>
<p>参考《夺绳索》——理性的犯罪，杀人只是为了证明自己的某种优越性、为了验证他们的优越理论。</p>
<h2 id="4-罪与罚与反对的力量"><a href="#4-《罪与罚》与反对的力量" class="headerlink" title="4. 《罪与罚》与反对的力量"></a>4. 《罪与罚》与反对的力量</h2><p>杀人逻辑：他自认为所杀的对象是一个年老有财且被他是为社会累赘的将死之人</p>
<p>“自己没有罪责的，别人的痛苦”相较于“由于自己的原因而产生的痛苦分量要轻得多”。</p>
<p>自己要正视自己的责任，从而求得解脱。</p>
<blockquote>
<p><em>蜡烛头在破烛盘上闪烁着，在这穷相毕露的房间里，朦胧地照着这个凶手和这个妓女，他们那么奇怪地在一起读着这本不朽的书。</em></p>
</blockquote>
<h3 id="刑罚-心罚"><a href="#刑罚、心罚" class="headerlink" title="刑罚、心罚"></a>刑罚、心罚</h3><p>报的正义（古代）、分配的正义（现代）</p>
<p>权利、福利</p>
<p>刑罚——形式的平等、实质的平等：这就需要考虑心罚</p>
<blockquote>
<p><em>越是有教养、有良知的人越容易感到心罚，就越容易痛苦。</em> ——《死屋手记》</p>
</blockquote>
<p>要使一个人真正的<strong>获得新生</strong>，仅仅靠刑罚是不太可能的，一定要通过<strong>心罚</strong>去作用。</p>
<p>刑罚无法判断和衡量一个人因内心痛苦而获得的惩罚，因此它只能坚持一种<strong>程序的正义</strong>。但内心痛苦如何评判？考虑充满主观因素的“内心”，反而会影响到程序平等。</p>
<p>更重要的问题：<strong>犯罪到底归之于什么？</strong>个人、社会环境、社会制度分别应该承担多少责任？</p>
<p>两种不同的宽恕犯罪的途径：</p>
<ul>
<li>一种是不勾消个人的道德责任</li>
<li>另一种归咎于环境、归罪于社会</li>
</ul>
<h3 id="道德界限"><a href="#道德“界限”" class="headerlink" title="道德“界限”"></a>道德“界限”</h3><p>人的差异性理论：</p>
<p><strong>苏格拉底</strong></p>
<p><strong>米歇尔·蒙田</strong>——将事实和规范分开处理</p>
<ul>
<li>“人的差别”：某人和某人之间的差距比某人与某兽之间的差距还要远。以<strong>人的本身价值</strong>而不是从<strong>他的外观，他的外在社会地位</strong>来估价他们。</li>
<li>守法方为上：一切稀奇古怪的行为都是精神失常或妄想标新立异所致，而不可能是受真正理智的驱使。</li>
</ul>
<p><strong>亨利·伯格森</strong></p>
<ul>
<li>道德来源于两方面：一方面来自<strong>社会的压力</strong>（约束、规范），一方面来自<strong>道德英雄的感召力</strong>所启发下的抱负或热望。</li>
</ul>
<p>道德改革家<strong>耶稣</strong>：扭转古罗马和古希腊时的道德，强调怜悯和同情，而不是荣誉和勇敢</p>
<p>不同的对待他人的<strong>道德态度</strong>：</p>
<ul>
<li>既有可能采取与社会规范尽可能保持距离、甚至远离社会和人群的态度</li>
<li>又可能采取外表上一如常人，严格守法的态度</li>
<li>采取一种作为伟大的宗教和道德家的态度，或可称为一种“越界”，<strong>向上越界</strong>，不是破坏性的而是创造性的</li>
</ul>
<p><strong>“人的差异性”总结</strong>：从人分为优秀者和普通人的陈述，<strong>并不必然地逻辑地引申</strong>出优秀者内心可以有权利（即正当地）剥夺其他人的基本权利，尤其是剥夺他们生存权利的观点。</p>
<h2 id="5-集体行为的伦理及博爱怜悯"><a href="#5-集体行为的伦理及博爱怜悯" class="headerlink" title="5. 集体行为的伦理及博爱怜悯"></a>5. 集体行为的伦理及博爱怜悯</h2><p>集体行为的三个基本特征：<strong>团体意识性</strong>、<strong>团体认同感</strong>、团体组织</p>
<p><strong>道德焦点</strong>：<em>能否为实现社会理想采取不符合一般道德（乃至不合其理想）的手段，例如使用欺骗、隐瞒、谋杀伙伴或无辜者、恐怖主义和强制等手段？</em></p>
<blockquote>
<p>集体比个人更自私 ——尼布尔</p>
</blockquote>
<p>《群魔》中希加廖夫的理论体系：<strong>从无限的自由开始，却以无限的专制告终</strong>。他提出把人类分成不相同的两部分，其中十分之一的人享有个人的自由，对其余十分之久的人有无限的权利。</p>
<p>《革命者手册》</p>
<ol>
<li>革命家对自己的态度：一个革命家是命中注定要走这条道路的人，他既无个人需要，也无个人事务、感情、依恋、财产，甚至名字。他只知道一种科学，那就是毁灭的科学。<strong>凡是能促使革命胜利的，对他都是道德的。</strong></li>
<li>革命家对同志的态度：<strong>只能看他对事业的利弊</strong>。不能牵扯上任何与事业无关的友情或依恋，友谊的标准是由<strong>斗争中的有用性</strong>决定。</li>
<li>革命家对社会的态度：肮脏的社会所有成员分为<strong>六类</strong><ul>
<li>一、毫不延迟地处死的</li>
<li>二、应处死但暂且留着以便其行径促使更多的人走向革命的</li>
<li>三、平庸而有社会地位的人</li>
<li>四、有政治野心的人和各种自由主义者，对他们要假装跟随而实际上逐步控制</li>
<li>五、教条主义、革命思想家传播革命</li>
<li>六、妇女，轻浮而头脑空虚按三四种，对于有主见但不愿跟“我们”走按第五种，其中真正革命的才能当做自己的同志</li>
</ul>
</li>
<li>革命组织对人民的态度：除了“<strong>彻底的解放和人民的幸福</strong>”外，革命组织没有其他目的，但为此却必须先用一切手段去强化和加深人民的苦难，直到他们无法忍受的地步，从而迫<strong>使他们走向革命</strong>。同盗匪联合… …</li>
</ol>
<p>《他人的血》存在与虚无，由此阐释了存在主义理论</p>
<p>加缪《正义者》 、萨特《肮脏的手》</p>
<h3 id="怜悯与爱"><a href="#怜悯与爱" class="headerlink" title="怜悯与爱"></a>怜悯与爱</h3><blockquote>
<p><em>陀思妥耶夫斯基笔下的许多人物不仅折磨仇人，也折磨爱人；不仅折磨别人，也折磨自己；这其中许多痛苦是无缘无故、无目的和不必要的。</em></p>
<p><strong>恶毒的天才</strong></p>
<p><em>彻底绝望的虚无主义者的残酷的淫虐狂以及和这相反——被压溃的、被吓坏的、能够欣赏自己的苦难、幸灾乐祸地在大家面前和自己津津乐道这种苦难的一种人的被虐待狂。</em></p>
</blockquote>
<p>时代背景：水晶棺式的人间天堂被构建，物质的财富充分发展……</p>
<p>陀思妥耶夫斯基：</p>
<blockquote>
<p>人不是这样的，生命不是如此简单，人生也确实不是如此可以轻易打发，人的幸福并不就等同于一种动物性的满足，<strong>人不断期望着更高的东西，期望着终极的东西</strong>，达不到他就常常自我折磨。</p>
</blockquote>
<p>对人残酷的描写和解剖，是对一种正在广泛流行的、并即将变为集体行动的、过于简单和乐观的人性和社会改造方案的一种<strong>对抗和反拨</strong>——更深刻的真诚与怜悯</p>
<p>《极端的年代》：二十世纪对人的改造，对完美的狂热追求</p>
<p>《伊加利亚旅行记》</p>
<h3 id="怜悯or博爱爱如何实现"><a href="#怜悯or博爱，爱如何实现" class="headerlink" title="怜悯or博爱，爱如何实现"></a>怜悯or博爱，爱如何实现</h3><p>博爱：广博的爱，平等的爱，是没有等差的、没有级别的爱。</p>
<p>“博爱或者死亡！” 法国大革命，隐含的意思“你要成为我的兄弟，成为我的同志，否则就必须去死。”，走向恐怖主义，走向断头台… …</p>
<p>陀氏：<em>博爱不是植根利益计算的理性，而是要植根与感情和天性。</em></p>
<p>舍勒《爱的秩序》：将近代博爱主义与基督教的爱的理念进行比较。认为近代的博爱观念和运动的价值评价是源于<strong>怨恨</strong>。</p>
<blockquote>
<p>我爱人类，但是自己觉得奇怪的是我对全人类爱得越深，对单独的人，也就是对一个个个别的人就爱得越少，甚至对个别人恨得深。</p>
<p>仁爱自亲始</p>
</blockquote>
<p>抽象的人和具体的人</p>
<h2 id="6-终极关系人生的根本意义"><a href="#6-终极关系：人生的根本意义" class="headerlink" title="6. 终极关系：人生的根本意义"></a>6. 终极关系：人生的根本意义</h2><h3 id="上帝与人"><a href="#上帝与人" class="headerlink" title="上帝与人"></a>上帝与人</h3><p>是否有一种永恒的记忆和超越的存在</p>
<p>《道德 · 上帝与人》</p>
<p>神人还是“人神”</p>
<p>神人：耶稣，作为超越的存在、完美的存在，如何体验感受说明</p>
<blockquote>
<p>当人处境维艰时，无论是基督徒还是不信者，人们便走向神，神也走向每一个人；而当神处境维艰时，却只是有一些人走向神。 ——朋霍费尔</p>
</blockquote>
<p>人的有限性：</p>
<p>上帝的问题是在人那里产生的问题，按上帝的本意，这个问题在至高无上的存在那里不会诗歌问题，所有这仍然是一个人的问题，是因人而产生，为人所困惑的问题。 </p>
<p>知、意、情</p>
<p>人的差别：</p>
<p>数量差别，我们和他们，少数与多数</p>
<p>《卡拉马佐夫兄弟》 “<strong>宗教大法官传奇</strong>” 陀氏的作品制高点：即便给人无限的自由，多数人也会放弃自由</p>
<h3 id="为何放弃自由"><a href="#为何放弃自由" class="headerlink" title="为何放弃自由"></a>为何放弃自由</h3><ol>
<li>多数人比少数人更看重物质而不是精神（更看重地上的面包而不是天上的面包）</li>
<li>多数人比少数人更相信奇迹而不是理性</li>
</ol>
<p>对财富的价值目标的四种选择：唯一、最高、必要、非必要</p>
<h2 id="7-托尔斯泰的生平与创作"><a href="#7-托尔斯泰的生平与创作" class="headerlink" title="7. 托尔斯泰的生平与创作"></a>7. 托尔斯泰的生平与创作</h2><h3 id="生活与创作"><a href="#生活与创作" class="headerlink" title="生活与创作"></a>生活与创作</h3><p>特点：不断反省自身，不断完善自身的欲望</p>
<p>大学并不突出，但已经开始自己读书，尤其对哲学、道德哲学产生兴趣，喜爱卢梭的学说及其为人，并广泛阅读文学作品。（荷马、莎士比亚……</p>
<p>很多小说带有自传的痕迹。一边生活一边写作</p>
<p>真正进入文学界：《童年》《一个地主的早晨》《三死》《家庭幸福》《哥萨克》</p>
<p>《战争与和平》  《安娜·卡列尼娜》 </p>
<p>阿尔扎马斯的恐怖：见《忏悔录》；发现没有了生活下去的目标；”生命对于我已失去吸引力，我怎么能去吸引别人呢？”</p>
<p>《忏悔录》  《复活》</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>陀思妥耶夫斯基的思想，作为问题的思想，没有明确的结论，在思想性上更胜一筹</p>
<p>托尔斯泰的思想，构成一种矛盾和紧张；1880年左右思想发生重大的转变，以写《忏悔录》为标志来分界</p>
<h3 id="艺术与思想之间的矛盾"><a href="#艺术与思想之间的矛盾" class="headerlink" title="艺术与思想之间的矛盾"></a>艺术与思想之间的矛盾</h3><p>一边是文学艺术，作者在这方面具有最高天才，生命力洋溢；一边是思想教义，并非具有最高天才，但因前期获得的文学成就而拥有巨大影响力，开始压制生命，否定欢乐、政治、法律和财富、反对暴力、努力禁欲。</p>
<blockquote>
<p>思想家有两种类型，一种是<strong>刺猬</strong>，一种是<strong>狐狸</strong>。</p>
</blockquote>
<h3 id="托翁转变的原因"><a href="#托翁转变的原因" class="headerlink" title="托翁转变的原因"></a>托翁转变的原因</h3><p>多种解释</p>
<p>1，尝够了生活的快乐，转而对生活的无限希望，追求更高的东西</p>
<blockquote>
<p>他的前期后期并不矛盾，正是这样的精神让他经历了这种转变。 ——罗曼罗兰</p>
</blockquote>
<p>2，创作的危机，最高峰已经过去，开始走下坡路</p>
<p>3，厌倦了思想，觉得写作和思想是无力的，从而渴望用行动来影响世界</p>
<blockquote>
<p>我们不应该再写书，读书，讲话，而应该行动。 ——托尔斯泰</p>
</blockquote>
<p>… …</p>
<h3 id="什么是勇敢"><a href="#什么是勇敢？" class="headerlink" title="什么是勇敢？"></a>什么是勇敢？</h3><p>《袭击》：勇敢并不等同于无畏。</p>
<h2 id="8-战争-历史-生命-战争与和平"><a href="#8-战争、历史、生命-《战争与和平》" class="headerlink" title="8. 战争、历史、生命 《战争与和平》"></a>8. 战争、历史、生命 《战争与和平》</h2><h3 id="战争伦理"><a href="#战争伦理" class="headerlink" title="战争伦理"></a>战争伦理</h3><ul>
<li>开战伦理：战争权力的伦理</li>
<li>作战伦理：战争行为的伦理</li>
<li>战后伦理：战争结果的伦理</li>
</ul>
<p>马克斯·韦伯的“责任伦理”，从政者必须具备务实的态度，为自己言论行为的后果承担责任。</p>
<h3 id="历史哲学的阐释"><a href="#历史哲学的阐释" class="headerlink" title="历史哲学的阐释"></a>历史哲学的阐释</h3><blockquote>
<p>传统史学家用神意来解释历史，而新的历史科学转向英雄史观，且持一种历史目的论——这目的或是某民族的强盛，或是自由平等。其中专题史学家认为是英雄，主要是帝王将相在起主要作用，而新的通史家则认为起主要作用的是与时间有关的所有人的互动，是他们的合力，或许其中主要的还是群众或人们。文化史学家则认为动力还是他后面的从事文化和精神活动的人们。</p>
</blockquote>
<p>历史是谁创造的？</p>
<p>恩格斯：历史合力论</p>
<h3 id="三个主人公"><a href="#三个主人公" class="headerlink" title="三个主人公"></a>三个主人公</h3><p>安德烈：拥有军人的素质，渴望荣誉。参加两次战争。</p>
<p>皮埃尔：没有算计之心甚至防人之心，似乎从来不为自己的利益坚持斗争。</p>
<p>娜塔莎</p>
<h3 id="生命的沉思"><a href="#生命的沉思" class="headerlink" title="生命的沉思"></a>生命的沉思</h3><blockquote>
<p>爱一个亲人，用人类的爱来爱就行了，但是爱敌人，只有用上帝的爱才办得到……用人类的爱，这种爱可能转化成恨，但是，上帝的爱永无变化。</p>
</blockquote>
<h2 id="9-爱情-婚姻-家庭-安娜卡列尼娜"><a href="#9-爱情、婚姻、家庭-《安娜·卡列尼娜》" class="headerlink" title="9. 爱情、婚姻、家庭 《安娜·卡列尼娜》"></a>9. 爱情、婚姻、家庭 《安娜·卡列尼娜》</h2><h2 id="10-托尔斯泰后期作品"><a href="#10-托尔斯泰后期作品" class="headerlink" title="10. 托尔斯泰后期作品"></a>10. 托尔斯泰后期作品</h2><h2 id="11-陀思妥耶夫斯基与托尔斯泰"><a href="#11-陀思妥耶夫斯基与托尔斯泰" class="headerlink" title="11. 陀思妥耶夫斯基与托尔斯泰"></a>11. 陀思妥耶夫斯基与托尔斯泰</h2>]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>文艺学系列课程（一）文学文本解读</title>
    <url>/post/8c0b397b/</url>
    <content><![CDATA[<h1 id="文学文本解读"><a href="#文学文本解读" class="headerlink" title="文学文本解读"></a>文学文本解读</h1><h2 id="概说"><a href="#概说" class="headerlink" title="概说"></a>概说</h2><p>文学批评的目的是探求真理</p>
<p>文学欣赏：读者，再创造；</p>
<blockquote>
<p>方文山抒情模式有套路，“有眼无心”</p>
</blockquote>
<p>文本解读：西方<strong>现代</strong>文学术语；从某种理论出发，采用特定的方法，对文本进行详尽的分析研究；例 “细读” close reading</p>
<p>“细读”的特征：</p>
<ul>
<li>以文本为中心的“<strong>向心式批评</strong>”（与发散式不同 ）</li>
<li>只涉及孤立文本、不涉文类的“<strong>个体批评</strong>”</li>
<li>以<strong>语言技巧分析</strong>为核心的语言批评</li>
</ul>
<blockquote>
<p>文本指的是由<strong>语言符号</strong>组成的一个有限的、有结构的整体。 ——《叙述学》</p>
<p>把一个文本理解为一个文本，就是把它理解为存在于<strong>语言</strong>之中。 ——《谁在乎文本》</p>
</blockquote>
<h3 id="文学阅读的主体"><a href="#文学阅读的主体" class="headerlink" title="文学阅读的主体"></a>文学阅读的主体</h3><p>读者：普通、专业</p>
<p>追问“为什么”</p>
<blockquote>
<p>阅读在其深层意义上不是一种视觉经验。它是一种认知和审美的经验，是建立在<strong>内在听觉和活力充沛的心灵</strong>之上的。 ——《西方正典》</p>
</blockquote>
<p>对作品进行解析、研读，为文学批评、研究作准备</p>
<h4 id="应该具备的基本能力"><a href="#应该具备的基本能力" class="headerlink" title="应该具备的基本能力"></a>应该具备的基本能力</h4><ol>
<li>艺术感受力——语感能力</li>
<li>艺术推想力 ——再建性现象能力、情境性推究能力、生活阅历和相应的知识储备</li>
</ol>
<h3 id="几个基本问题"><a href="#几个基本问题" class="headerlink" title="几个基本问题"></a>几个基本问题</h3><h4 id="1-释义与辨味"><a href="#1-释义与“辨味”" class="headerlink" title="1. 释义与“辨味”"></a>1. 释义与“辨味”</h4><p>释义方法：</p>
<ul>
<li>“<strong>以上下文合参</strong>“，把具体的字词放在语境中参证</li>
<li>“<strong>以他为参证</strong>”，用同一作者表达相似情感和心境的其他作品来参证；亦可以其他作者作品来参证</li>
</ul>
<p>释义要领：</p>
<ul>
<li>注意特殊语境下的语词的特殊含义</li>
<li>主动调动知识储备和人生经验</li>
</ul>
<p>辨味要领：</p>
<ul>
<li>不离文字又不拘泥于文字，充分发挥艺术再创造能力</li>
<li>注意情意层深和语言浑成的<strong>两位一体</strong></li>
</ul>
<h4 id="2-意象与结构"><a href="#2-意象与结构" class="headerlink" title="2. 意象与结构"></a>2. 意象与结构</h4><p>文学创作的方式与方法</p>
<p>意象：指主观情意与客观物象的有机统一体；象：自然界、事象</p>
<p>西方现代诗歌的 image “<strong>客观对应物</strong>——心造物，与物象有区别</p>
<p>要有<strong>意象感</strong></p>
<p>结构：组织方式与内部构造</p>
<h4 id="3-有我与无我王国维人间词话"><a href="#3-“有我”与“无我”——王国维《人间词话》" class="headerlink" title="3. “有我”与“无我”——王国维《人间词话》"></a>3. “<strong>有我</strong>”与“<strong>无我</strong>”——王国维《人间词话》</h4><blockquote>
<p><em>有我之境，以我观物，故物我皆著我之色彩。无我之境，以物观物，故不知何者为我，何者为物。古人为词，写有我之境者为多，然未始不能写无我之境，此在豪杰之士能自树立耳。</em></p>
</blockquote>
<h4 id="4-理解与阐释"><a href="#4-理解与阐释" class="headerlink" title="4. 理解与阐释"></a>4. 理解与阐释</h4><p>后现代艺术 “拼贴”</p>
<p>理解 <strong>多角度</strong>、阐释 <strong>多元化</strong></p>
<p>一部文学作品是否存在<strong>原意</strong>？</p>
<p><strong>接受美学</strong>：无原义，未进入传播欣赏的渠道并不算文学作品</p>
<p>经典作品：从未被“<strong>正确</strong>“阐释的作品</p>
<h4 id="5-高雅与通俗"><a href="#5-高雅与通俗" class="headerlink" title="5. 高雅与通俗"></a>5. 高雅与通俗</h4><ul>
<li><strong>动态的</strong>而不是凝固的眼光看到<strong>雅文学</strong>（中心位置，受到普遍的关注）与<strong>俗文学</strong>（边缘位置）的界限</li>
<li>雅文学常常代表着创作者在<strong>探索人类精神领域所能达到的高度</strong></li>
</ul>
<p>康定斯基《论艺术的精神》：精神思想的发展——金字塔形状</p>
<h2 id="第三讲-质朴无华的文字隽永深长的情思郑风中的情诗与诗经"><a href="#第三讲-质朴无华的文字，隽永深长的情思：《郑风》中的情诗与《诗经》" class="headerlink" title="第三讲 质朴无华的文字，隽永深长的情思：《郑风》中的情诗与《诗经》"></a>第三讲 质朴无华的文字，隽永深长的情思：《郑风》中的情诗与《诗经》</h2><blockquote>
<p><em>太师教六诗：曰风，曰赋，曰比，曰兴，曰雅，曰颂。</em> ——《周礼》</p>
<p><em>凡诗之所谓风者，多出于里巷歌谣之作，所谓男女相与泳歌，各言其情者也。</em> ——朱熹《诗集传序》</p>
</blockquote>
<h3 id="一-千种风情无以细说"><a href="#一、千种风情，无以细说" class="headerlink" title="一、千种风情，无以细说"></a>一、千种风情，无以细说</h3><ol>
<li>对象、语气与情感的特定性</li>
<li>层层递进的矛盾心理</li>
</ol>
<p><strong>《将仲子》</strong></p>
<blockquote>
<p>将仲子兮，无逾我里，无折我树杞。岂敢爱之？畏我父母。仲可怀也，父母之言亦可畏也。</p>
<p>将仲子兮，无逾我墙，无折我树桑。岂敢爱之？畏我诸兄。仲可怀也，诸兄之言亦可畏也。</p>
<p>将仲子兮，无逾我园，无折我树檀。岂敢爱之？畏人之多言。仲可怀也，人之多言亦可畏也。</p>
</blockquote>
<p>递进关系 ;封建礼教的束缚</p>
<p>詹安泰的引用：</p>
<blockquote>
<p>姐道：我郎呀！尔若半夜来时，没要捉个后门敲。只好捉我场上鸡来拔了毛，假做子黄鼠狼偷鸡，引得角角哩叫。好教我穿子单裙出来赶野猫。</p>
</blockquote>
<h3 id="二-一腔炽热付与戏谑"><a href="#二、一腔炽热，付与戏谑" class="headerlink" title="二、一腔炽热，付与戏谑"></a>二、一腔炽热，付与戏谑</h3><ol>
<li>怨怼中的情之切</li>
<li>戏谑中的情之困</li>
</ol>
<p>《<strong>狡童</strong>》</p>
<blockquote>
<p>彼狡童兮，不与我言兮。维子之故，使我不能餐兮。</p>
<p>彼狡童兮，不与我食兮。维子之故，使我不能息兮。</p>
</blockquote>
<p>《<strong>褰裳</strong>》</p>
<blockquote>
<p>子惠思我，褰裳涉溱。子不我思，岂无他人？狂童之狂也且！</p>
<p>子惠思我，褰裳涉洧。子不我思，岂无他士？狂童之狂也且！</p>
</blockquote>
<p>人：一般人；士：未婚男子</p>
<p>朱熹《诗集传》</p>
<h3 id="三-赋兴之中情景互生"><a href="#三、赋兴之中，情景互生" class="headerlink" title="三、赋兴之中，情景互生"></a>三、赋兴之中，情景互生</h3><p>“敷陈其事而直言之”</p>
<p>《<strong>风雨</strong>》</p>
<blockquote>
<p>风雨凄凄，鸡鸣喈喈，既见君子。云胡不夷！</p>
<p>风雨潇潇，鸡鸣胶胶。既见君子，云胡不瘳！</p>
<p>风雨如晦，鸡鸣不已。既见君子，云胡不喜！</p>
</blockquote>
<p>《<strong>唐诗综论</strong>》</p>
<h3 id="四-小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><ol>
<li>呼告手法凸显鲜明的“独白”“自白”，情感强烈动人。——感情达到高峰的表现</li>
<li>质朴无华语言——神婉曲折的情感与心理悸动——意在言外的艺术效果</li>
</ol>
<h2 id="第四讲-幻情奇彩中的人生悲泣苏小小墓与李贺"><a href="#第四讲-幻情奇彩中的人生悲泣：《苏小小墓》与李贺" class="headerlink" title="第四讲 幻情奇彩中的人生悲泣：《苏小小墓》与李贺"></a>第四讲 幻情奇彩中的人生悲泣：《苏小小墓》与李贺</h2><h3 id="一-苏小小其人本事"><a href="#一、苏小小其人本事" class="headerlink" title="一、苏小小其人本事"></a>一、苏小小其人本事</h3><p>杨柳枝词（其一） 白居易</p>
<p>苏小小墓 张岱</p>
<h3 id="二-解读幽怨的鬼魂动人的情愫"><a href="#二、解读：幽怨的鬼魂，动人的情愫" class="headerlink" title="二、解读：幽怨的鬼魂，动人的情愫"></a>二、解读：幽怨的鬼魂，动人的情愫</h3><blockquote>
<p><em>幽兰露，如啼眼。<br>无物结同心，烟花不堪剪。<br>草如茵，松如盖。<br>风为裳，水为佩。<br>油壁车，夕相待。<br>冷翠烛，劳光彩。<br>西陵下，风吹雨。</em></p>
</blockquote>
<h3 id="三-评说在荒诞诡异中寻觅虚妄的美丽"><a href="#三、评说：在荒诞诡异中寻觅虚妄的美丽" class="headerlink" title="三、评说：在荒诞诡异中寻觅虚妄的美丽"></a>三、评说：在荒诞诡异中寻觅虚妄的美丽</h3><p><strong>写景幻化出人物形象</strong>，写鬼魂</p>
<p>李贺遭遇——生与死“<strong>之间</strong>”的状态；病态之美 社会的病态</p>
<blockquote>
<p>《<strong>致酒行</strong>》</p>
<p>我有迷魂招不得，</p>
<p>雄鸡一声天下白。</p>
<p>少年心事当轻云，</p>
<p>谁念幽寒坐呜呃？ </p>
<p>《<strong>开愁歌</strong>》</p>
<p>秋风吹地百草干，华容碧影生晚寒。</p>
<p>我当二十不得意，一心愁谢如枯兰。</p>
<p>衣如飞鹑马如狗，临歧击剑生铜吼。</p>
<p>旗亭下马解秋衣，请贳宜阳一壶酒。</p>
<p>壶中唤天云不开，白昼万里闲凄迷。</p>
<p>主人劝我养心骨，莫受俗物相填豗。</p>
</blockquote>
<h2 id="第五讲-羁旅-登高-悲秋柳永八声甘州"><a href="#第五讲-羁旅-·-登高-·-悲秋：柳永《八声甘州》" class="headerlink" title="第五讲 羁旅 · 登高 · 悲秋：柳永《八声甘州》"></a>第五讲 羁旅 · 登高 · 悲秋：柳永《八声甘州》</h2><p>词的分类——小令：58字内、中调：59~90字、长调（慢词）：91字</p>
<p>长调需要配合曲谱填词 “fit in the words”</p>
<p>“豪苏腻柳”</p>
<p>两类最佳：相思离别、客居他乡</p>
<blockquote>
<p><em>对潇潇暮雨洒江天，一番洗清秋。渐霜风凄紧，关河冷落，残照当楼。是处红衰翠减，苒苒物华休。惟有长江水,无语东流。</em></p>
<p><em>不忍登高临远，望故乡渺邈，归思难收。叹年来踪迹，何事苦淹留？想佳人、妆楼颙望，误几回、天际识归舟。争知我，倚阑杆处，正恁凝愁！</em></p>
</blockquote>
<p>即景起兴、见景生情——诗歌的初心——<strong>情动于中而形于言</strong></p>
<h2 id="第六讲-现代人生存境遇的寓言预言卡夫卡变形记"><a href="#第六讲-现代人生存境遇的寓言-预言：卡夫卡《变形记》" class="headerlink" title="第六讲 现代人生存境遇的寓言/预言：卡夫卡《变形记》"></a>第六讲 现代人生存境遇的寓言/预言：卡夫卡《变形记》</h2><p>参考书 《<strong>西方正典</strong>》 </p>
<p>个人生活乏味平淡，但想象丰富，内转，写意识、潜意识；<strong>纯粹意义上的个人写作</strong>；闯入者的身份，得以直面内心？</p>
<p>从来没有分离，却又从来都是对抗的</p>
<p>《变形记》 开头：简单 突兀，紧张 压抑</p>
<h3 id="一-人物孤独与陌生的存在"><a href="#一、人物：孤独与陌生的存在" class="headerlink" title="一、人物：孤独与陌生的存在"></a>一、人物：孤独与陌生的存在</h3><p>叙事学把叙事者讲述故事时锁采取的角度或视角，称为<strong>叙事视角</strong>。即“叙事者与故事的关系”</p>
<ul>
<li>“全知”型叙事：上帝视角；如鲁迅的《药》</li>
<li>“限制”型叙事：叙事人站在特定角度或视点；<ul>
<li>“人物视角叙事”或“内聚焦叙事”：叙事者与人物合二为一</li>
<li>“外聚焦叙事”：叙事人只能以旁观者或局外人身份；他知道的事情少于故事中任何一个人</li>
<li>区别：后者不能深入人物的内心世界，不能去描写其意识或心理活动</li>
</ul>
</li>
</ul>
<p>《变形记》 <strong>内聚焦叙事</strong></p>
<p>“不安” “甲虫人”</p>
<ol>
<li><p><strong>在忧郁不安中咀嚼孤独</strong></p>
<p>《<strong>单向度的人</strong>》 不以异化为异化</p>
</li>
<li><p><strong>在人群中感受陌生与拒斥</strong></p>
<p>经典型忍耐，用善意和自我指责来反抗这个社会</p>
<blockquote>
<p>善在某种意义上是绝望的表现。 ——《卡夫卡书信日记选》</p>
<p>卡夫卡最独特、最富有创造性的天赋在于，他的故事似乎出自我们遗忘记忆的回归，并始终让我们觉得我们在继续忘掉所经历和感受到的陌生性。 ——《西方正典》</p>
</blockquote>
</li>
</ol>
<h3 id="二-笔法奇异的想象与冷静的写实"><a href="#二、笔法：奇异的想象与冷静的写实" class="headerlink" title="二、笔法：奇异的想象与冷静的写实"></a>二、笔法：奇异的想象与冷静的写实</h3><h4 id="1-以细节支撑想象的空间"><a href="#1-以细节支撑想象的空间" class="headerlink" title="1. 以细节支撑想象的空间"></a>1. 以细节支撑想象的空间</h4><p>卡夫卡有能力给予最不可思议的想象、幻觉，以最牢靠、最坚固的真实。</p>
<h4 id="2-以想象的细节对应生活的感受"><a href="#2-以想象的细节对应生活的感受" class="headerlink" title="2. 以想象的细节对应生活的感受"></a>2. 以想象的细节对应生活的感受</h4><p>想象的奇异，并不一定都在于想象本身的夸饰乖张，也在于想象中每一个细枝末节都与现实情境相吻合；想象也不一定都是延伸现实的触角，弥补现实的缺憾，更可能是以奇特的文字唤醒被遮蔽、被忽略的现实情境。</p>
<h3 id="三-问题寓言故事与预言功能"><a href="#三、问题：寓言故事与预言功能" class="headerlink" title="三、问题：寓言故事与预言功能"></a>三、问题：寓言故事与预言功能</h3><p>纳博科夫 《<strong>文学讲稿</strong>》</p>
<p><strong>甲虫形象</strong>：人类所不能容忍，与格里高尔的处境…；巨大的身形、无数可怜的细腿；坚硬的背甲、柔软的腹部；喜欢阴暗潮湿隐秘的生存环境</p>
<p>内在自我与外在自我的分裂</p>
<p><strong>小人物在现代社会中的形象</strong>，慢慢体会独属于这个文本的东西</p>
<p>《<strong>反对阐释</strong>》卡夫卡作品的三种阐释方法：社会寓言、宗教寓言、心理象征；这是大规模劫掠、简单地抽出文学作品的内容进行转换——破坏了艺术评的独立性</p>
<h4 id="寓言体故事与象征体故事的区别"><a href="#寓言体故事与象征体故事的区别" class="headerlink" title="寓言体故事与象征体故事的区别"></a>寓言体故事与象征体故事的区别</h4><blockquote>
<p><em>寓言是一种记叙体，通过人物、情节，有时包括场景的描写，构成完整的“字面”，也就是第一层的意义，同事，借此喻彼，表现另一层相关的人物、意念和事件。</em> ——艾布拉姆斯 《文学术语汇编》</p>
</blockquote>
<p>寓言：字面意传达字外意，寓言所讲的故事是直射故事外的人与物。</p>
<p>象征：是<strong>公共性</strong>、<strong>单一</strong>的，而不是灵活的，属于某个文化共同体中长久以来形成的共识。</p>
<h4 id="关注人的生存现状"><a href="#关注人的生存现状" class="headerlink" title="关注人的生存现状"></a>关注人的生存现状</h4><p>卡夫卡独特的寓言文体带来的是作品的预言功能，这些预言同其作品的寓意一样是多向度的。</p>
<p>就总体而言，他预言了二十世纪人类的生存境遇：孤独、离散、迷惘、绝望、无助，人的异化，自我人格的分裂，缺乏安全感和稳定感，荒凉感，“废墟”情结……</p>
<blockquote>
<p>一本书真正独立的生命要在作者死后才开始，因为这些血性的人在他们死后还会为他们的书斗争一番。然后书就慢慢孤单下来，只能依赖自己的心脏搏动了。 ——《卡夫卡书信日记选》</p>
</blockquote>
<p>书的生命比作者的生命要长得多！</p>
<h3 id="推荐书"><a href="#推荐书" class="headerlink" title="推荐书"></a>推荐书</h3><p>《卡夫卡口述》《卡夫卡书信日记选》《从卡夫卡到昆德拉——二十世纪的小说和小说家》《西方正典》</p>
<h2 id="第七讲-现代小说的叙事演变海明威白象似的群山"><a href="#第七讲-现代小说的叙事演变：海明威《白象似的群山》" class="headerlink" title="第七讲 现代小说的叙事演变：海明威《白象似的群山》"></a>第七讲 现代小说的叙事演变：海明威《白象似的群山》</h2><blockquote>
<p>对于不可言说的事情，我们最好的方式就是保持沉默。</p>
<p>自杀的发生有许多原因，总的说来，最清楚明显的原因并不是直接引起自杀的原因。人们极少(但不能排除)因为反思而自杀。</p>
</blockquote>
<p>讲什么—-&gt;怎么讲</p>
<p>开头…—-&gt; 全知型 限制型…</p>
<h3 id="一-限制型叙事视角及其运用"><a href="#一、“限制型”叙事视角及其运用" class="headerlink" title="一、“限制型”叙事视角及其运用"></a>一、“限制型”叙事视角及其运用</h3><p>典型的海明威文本风格</p>
<h4 id="1-特别重视人物对话描写以对话来结构文本用对话来推动故事发展"><a href="#1-特别重视人物对话描写，以对话来结构文本，用对话来推动故事发展" class="headerlink" title="1. 特别重视人物对话描写，以对话来结构文本，用对话来推动故事发展"></a>1. 特别重视人物对话描写，以对话来结构文本，用对话来推动故事发展</h4><h4 id="2-在叙事语言中叙事人往往采用某个人物视角来进行观察和描述但又自始至终以局外人身份自居"><a href="#2-在叙事语言中，叙事人往往采用某个人物视角来进行观察和描述，但又自始至终以“局外人”身份自居" class="headerlink" title="2. 在叙事语言中，叙事人往往采用某个人物视角来进行观察和描述，但又自始至终以“局外人”身份自居"></a>2. 在叙事语言中，叙事人往往采用某个人物视角来进行观察和描述，但又自始至终以“局外人”身份自居</h4><p>开篇景物描写：压抑紧张</p>
<h3 id="二-冰山理论及其叙事效果"><a href="#二、冰山理论及其叙事效果" class="headerlink" title="二、冰山理论及其叙事效果"></a>二、冰山理论及其叙事效果</h3><p><strong>探求叙事技巧和方法，以及作者为什么偏爱这种方法</strong></p>
<blockquote>
<p><em>如果一位散文作家对于他想写的东西心里很有数，那么他可以<strong>省略</strong>他所知道的东西，读者呢，只要作者写得真实，会很强烈地感觉到他所省略的地方，好像作者已经写出来似的。冰山在海里移动很庄严宏伟，这是因为它只有八分之一露在水面上。</em> ——海明威《午后之死》</p>
</blockquote>
<p>省略：中国古典诗词——言有尽而意无穷；海明威——读者也参与到文本的再创作中去</p>
<h4 id="1-以经验的省略调动读者参与文本的再创造"><a href="#1-以经验的省略调动读者参与文本的再创造" class="headerlink" title="1. 以经验的省略调动读者参与文本的再创造"></a>1. 以经验的省略调动读者参与文本的再创造</h4><p>当读者参与到文本的再创造活动中，一方面使得文本中不确定因素得到融合、统一。同时，不同读者依据不同的生活经验所做的想象和联想，又极大丰富和拓展了文本的艺术表现力。</p>
<p>叙事上的“张力”：有意进行经验的省略</p>
<p>白象：无用而累赘的东西？昆德拉反对</p>
<h4 id="2-简洁-明快的语言艺术"><a href="#2-简洁、明快的语言艺术" class="headerlink" title="2. 简洁、明快的语言艺术"></a>2. 简洁、明快的语言艺术</h4><p>海明威的小说多用短句，简洁、准确、生动，尽量删除多余的词藻。</p>
<p>“电报文体风格”与“冰山理论”相契合</p>
<blockquote>
<p><em>不管他有多好的一个词，或者多好的一个比喻，要是用在不是绝对必要、除它外无可替代的地方，那么他就因为<strong>突出自己而毁坏了他的作品</strong>。散文（非韵文的作品）是建筑物，不是内部装饰，巴洛克风格早已过时。</em> ——《海明威谈创作》</p>
</blockquote>
<p>删除某种炫耀、不必要的、怪诞的、华丽的、装饰性的元素（文字填料）；</p>
<p>海明威以前所未有的勇气把附着在文学上的<strong>乱毛</strong>剪得一干二净</p>
<blockquote>
<p><em>举止行为动机隐而不显，尤其因为他们的对话不带任何关于问答方式的描绘</em> ——《被背叛的遗嘱》</p>
</blockquote>
<h3 id="三-现代社会发展与小说观念的演变"><a href="#三、现代社会发展与小说观念的演变" class="headerlink" title="三、现代社会发展与小说观念的演变"></a>三、现代社会发展与小说观念的演变</h3><p><strong>叙事视角关系</strong>到小说的总体寓意。</p>
<p>谁占有视点，或者，小说借用谁的视角，关系到故事的呈现方式和小说展开的视域。同时，叙事视角的选择不是单纯的写作技巧问题，它与作家的文学理念及美学追求密切相关。</p>
<p>全知型叙事：上帝视角、自大、作家是掌握全局的</p>
<p>限制型视角：我们的世界是复杂的、多变的</p>
<blockquote>
<p><em>在我们的周围，世界的意义只是<strong>部分的</strong>、<strong>暂时的</strong>，甚至是<strong>矛盾的</strong>，而且总是<strong>有争议的</strong>。艺术作品又怎么能先知先觉预先提出某种意义，而不管是什么意义呢？</em> ——罗伯·格里耶</p>
</blockquote>
<p>生活本身有无限的可能性，小说写作也有无数的可能性</p>
<p>对于转变，海明威的应对方法：不做评论</p>
<p>接受美学：<strong>召唤结构</strong>、<strong>期待视野</strong>（要去了解）</p>
<h3 id="推荐书"><a href="#推荐书-1" class="headerlink" title="推荐书"></a>推荐书</h3><p>《海明威谈创作》 《美国现代七大小说家》余中先 《从卡夫卡到昆德拉》</p>
<h2 id="第八讲-在一刹那间攥住永恒顾城远和近"><a href="#第八讲-在一刹那间攥住永恒：顾城《远和近》" class="headerlink" title="第八讲 在一刹那间攥住永恒：顾城《远和近》"></a>第八讲 在一刹那间攥住永恒：顾城《远和近》</h2><p>最有名的</p>
<blockquote>
<p>黑夜给了我黑色的眼睛，我却用它寻找光明。——《一代人》</p>
</blockquote>
<p>《远和近》</p>
<blockquote>
<p><strong>你</strong></p>
<p><strong>一会看我</strong></p>
<p><strong>一会看云</strong></p>
<p><strong>我觉得</strong></p>
<p><strong>你看我时很远</strong></p>
<p><strong>你看云时很近</strong></p>
</blockquote>
<p>注意<strong>诗行排列</strong>，诗是“表情”，而不只是“表义“</p>
<h3 id="你和我"><a href="#你和我" class="headerlink" title="你和我"></a>你和我</h3><p>你、我的相互呼应——你、我之间非同寻常的关系——两个人的世界</p>
<p>你在你的世界是自由的，<strong>你的自在世界</strong>；我觉得是很主观的，<strong>我的自主世界</strong></p>
<p>抒情的重心转到下一节，“我觉得”暗自引入一种冲突，表达恋情的诗……</p>
<h3 id="远和近"><a href="#远和近" class="headerlink" title="远和近"></a>远和近</h3><h2 id="第九讲-诗歌的理想与诗人的宿命海子重建家园"><a href="#第九讲-诗歌的理想与诗人的宿命：海子《重建家园》" class="headerlink" title="第九讲 诗歌的理想与诗人的宿命：海子《重建家园》"></a>第九讲 诗歌的理想与诗人的宿命：海子《重建家园》</h2><p>“物质的短暂情人” </p>
<blockquote>
<p>如果有一种个人的命运，就不会有更高的命运，或至少可以说，只有一种被人看作是宿命的和应受到蔑视的命运。 ——加缪《西西弗的神话》</p>
</blockquote>
<h3 id="一-重建家园-返璞归真"><a href="#一、“重建家园”-返璞归真" class="headerlink" title="一、“重建家园” 返璞归真"></a>一、“重建家园” 返璞归真</h3><h3 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h3><ol>
<li>作为词根的“家园”</li>
<li>放弃与直面</li>
</ol>
<blockquote>
<p><strong>在水上 放弃智慧</strong></p>
<p><strong>停止仰望长空</strong></p>
<p><strong>为了生存你要流下屈辱的泪水</strong></p>
<p><strong>来浇灌家园</strong></p>
</blockquote>
<ul>
<li>孔子云：“知者乐水，仁者乐山；知者动，仁者静；知者乐，仁者寿。”</li>
<li>水是人类文明的发源地</li>
<li><p>家园的丧失与水有关。典出《旧约·创世纪》</p>
<p>“做一个诗人，你必须热爱人类的秘密，在神圣的黑夜中走遍大地，热爱人类的痛苦和幸福，忍受那些必须忍受的，歌唱那些应该歌唱的。” ——《我热爱的诗人——荷尔德林》</p>
</li>
</ul>
<h3 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h3><blockquote>
<p><strong>生存无须洞察</strong></p>
<p><strong>大地自己呈现</strong></p>
<p><strong>用幸福也用痛苦</strong></p>
<p><strong>来重建家乡的屋顶</strong></p>
</blockquote>
<ul>
<li>“洞察”比“观察”要动用更多智慧—&gt;对应放弃智慧</li>
</ul>
<ol>
<li>呈现与承担</li>
</ol>
<h3 id="第三节"><a href="#第三节" class="headerlink" title="第三节"></a>第三节</h3><blockquote>
<p><strong>放弃沉思和智慧</strong></p>
<p><strong>如果不能带来麦粒</strong></p>
<p><strong>请对诚实的大地</strong></p>
<p><strong>保持缄默 和你那幽暗的本性</strong></p>
</blockquote>
<ol>
<li>诚实的大地与幽暗的本性</li>
</ol>
<p>“一个人对于不能谈的事情就应当保持沉默。”</p>
<p>“确实有不能讲述的东西。这是自己表明出来的；这就是神秘的东西。” ——《逻辑哲学论》</p>
<p>日凿一窍，七日而混沌死。</p>
<p>“反智”倾向——<strong>老庄哲学</strong>、<strong>新旧约</strong></p>
<h3 id="第四节"><a href="#第四节" class="headerlink" title="第四节"></a>第四节</h3><blockquote>
<p><strong>风吹炊烟</strong></p>
<p><strong>果园就在身旁静静叫喊</strong></p>
<p>​    <strong>“双手劳动</strong></p>
<p>​        <strong>慰藉心灵”</strong></p>
</blockquote>
<p>赋予果园/家园，人的灵性；要靠体悟 入定</p>
<h3 id="二-大诗理想与夹缝状态"><a href="#二、“大诗”理想与“夹缝”状态" class="headerlink" title="二、“大诗”理想与“夹缝”状态"></a>二、“大诗”理想与“夹缝”状态</h3><p>海子是一位有远大抱负和高迈理想的过渡性诗人。</p>
<ul>
<li><p>海子生活在社会剧烈转型时期</p>
</li>
<li><p>海子的写作处在从“我之诗”到“人之诗”的转换时期。</p>
<blockquote>
<p>我的是个理想是在中国成就一种伟大的集体的诗。我不想称为一个抒情诗人，或一位戏剧诗人，甚至不想称为一名史诗诗人，我只想融合中国的行动成就一种民族和人类的结合，诗和真理合一的大诗。 ——海子</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>文艺学系列课程（二）文学理论</title>
    <url>/post/8d49d2bf/</url>
    <content><![CDATA[<h1 id="寻找文学理想的灯火"><a href="#寻找文学理想的灯火" class="headerlink" title="寻找文学理想的灯火"></a>寻找文学理想的灯火</h1><p>文学是不会终结的。只要人在，人的感情在，人的感情需要用语言传达及发泄，那么文学就在，文学就活着，文学就不会终结，文学也不会灭亡。</p>
<p>我们的文学缺乏文学理想，缺少体现时代精神的有艺术力量的作品。</p>
<p>文学的良心问题——肖洛霍夫《一个人的遭遇》</p>
<p>写苏联的卫国战争，之前的维度——歌颂战争英雄</p>
<p>文学理想形成于<strong>历史理性、人文关怀、审美升华</strong>三者的辩证关系中。</p>
<p><strong>《这里的黎明静悄悄》</strong>《静静的顿河》</p>
<h1 id="美在关系"><a href="#美在关系" class="headerlink" title="美在关系"></a>美在关系</h1><p>不同的角度</p>
<ul>
<li><p>美的对象：花鸟</p>
</li>
<li><p>美的素质（结构形式）：对称、平衡、多样统一</p>
</li>
<li><strong>美的本质</strong>：对美学问题的哲学探讨——美的显现需要哪些条件</li>
</ul>
<p>我们主要关注<strong>美的本质</strong>问题</p>
<p>新中国五种<strong>美论</strong></p>
<ul>
<li>美是客观的</li>
<li>美是主观的：感觉在表达自己</li>
<li>美是主观和客观的统一</li>
<li>美是实践 李泽厚：美是人的本质力量的具象化</li>
<li>美是评价 评价者 评价的个体</li>
</ul>
<p>狄德罗——美是关系</p>
<p>康德——美是无功利的判断</p>
<p>（）内为自己看书听课时的问题</p>
<h1 id="文学理论"><a href="#文学理论" class="headerlink" title="文学理论"></a>文学理论</h1><h2 id="第一章-文学的一般性质"><a href="#第一章-文学的一般性质" class="headerlink" title="第一章 文学的一般性质"></a>第一章 文学的一般性质</h2><h3 id="第一节-文学是指向自由的生存方式"><a href="#第一节-文学是指向自由的生存方式" class="headerlink" title="第一节 文学是指向自由的生存方式"></a>第一节 文学是指向自由的生存方式</h3><p>（所谓生存方式，不太认同，故略去）</p>
<h3 id="第二节-文学是指向超越的生存体验"><a href="#第二节-文学是指向超越的生存体验" class="headerlink" title="第二节 文学是指向超越的生存体验"></a>第二节 文学是指向超越的生存体验</h3><p>一、超越的生存体验</p>
<ul>
<li><strong>原始</strong>的体验方式：巫术 神话 解释世界，并无现代“人”的经验和科技的视野，主体与客体并未分化（<em>“天人合一”在这个语境下扮演了什么角色？“天人合一”的观念是一种人类幼稚的童年经验？主体客体的分化势必导致人与自然的对立？</em>）</li>
<li><strong>现实</strong>的体验方式：认知与意象的分离，理性的判断（<em>认识只建立理性的基础上，一定好吗</em>？）,局限：能解决生存问题，但不能解决更多的意义问题，如人为什么而活。科学与意识形态都不能。</li>
<li><strong>超越</strong>的体验方式：对生存意义的理解。艺术、宗教、哲学、或是审美… …<strong>作家应当对人的生存有一种超越性的体验</strong></li>
</ul>
<p>二、文学以现实生存体验为基础</p>
<ul>
<li>日常基本生活体验是素材：经过审美转化的“自传”</li>
<li>知性体验即科学和意识形态也影响文学体</li>
<li>现实生存体验是创作的动力、动机</li>
</ul>
<p>三、文学是指向超越的生存体验</p>
<h3 id="第三节-文学的语言性"><a href="#第三节-文学的语言性" class="headerlink" title="第三节 文学的语言性"></a>第三节 文学的语言性</h3><p>一、文学是一种以语言为媒介的艺术</p>
<ul>
<li>视觉艺术</li>
<li>听觉艺术</li>
</ul>
<p>二、语言艺术特征</p>
<ul>
<li>语言的强大表现力</li>
</ul>
<p>不记了</p>
<h3 id="第四节-文学的审美特性"><a href="#第四节-文学的审美特性" class="headerlink" title="第四节 文学的审美特性"></a>第四节 文学的审美特性</h3>]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>文心雕龙</title>
    <url>/post/672ab7ec/</url>
    <content><![CDATA[<p><a href="ss.chaoxing.com/search?sw=%E5%8C%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%20%E4%B8%AD%E5%9B%BD%E5%BD%93%E4%BB%A3%E6%96%87%E5%AD%A6%E5%8F%B2%20%E5%85%%8 ss.chaoxing.com/search?sw">课程链接</a></p>
<h2 id="一-概论"><a href="#一、概论" class="headerlink" title="一、概论"></a>一、概论</h2><p>重要，但难于理解把握，几乎每一篇都有一点疑难</p>
<h3 id="方法和内容"><a href="#方法和内容" class="headerlink" title="方法和内容"></a>方法和内容</h3><p>方法：解读原文、阐述含义，重点地方介绍学者不同的看法</p>
<p>内容 精读十八篇：《原道》《宗经》《辨骚》《明诗》《神思》《体性》《风骨》《通变》《定势》《情采》《隐秀》《养气》《总术》《时序》《物色》《知音》《序志》</p>
<p><strong>梁书·刘勰传</strong></p>
<p><strong>序志篇</strong></p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法</title>
    <url>/post/dd983d22/</url>
    <content><![CDATA[<h2 id="1-处理分类问题常用算法"><a href="#1-处理分类问题常用算法" class="headerlink" title="1. 处理分类问题常用算法"></a>1. 处理分类问题常用算法</h2><h3 id="11-交叉熵公式"><a href="#1-1-交叉熵公式" class="headerlink" title="1.1 交叉熵公式"></a>1.1 交叉熵公式</h3><p>交叉熵——设q(x) p(x)是X中取值的两个概率分布，则p对q的相对熵为</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/1.PNG" alt="1"></p>
<p>在一定程度上，相对熵可以度量两个随机变量的“距离”，且D(p||q) 与 D（q||p）不等。</p>
<p>两个随机变量X Y的互信息定义——X Y的联合分布和各自独立分布乘积的相对熵，用I(X,Y)表示：</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/2.PNG" alt="2"></p>
<h3 id="12-lr公式逻辑回归"><a href="#1-2-LR公式——逻辑回归" class="headerlink" title="1.2 LR公式——逻辑回归"></a>1.2 LR公式——逻辑回归</h3><h2 id="9-降维算法"><a href="#9-降维算法" class="headerlink" title="9. 降维算法"></a>9. 降维算法</h2><p>在机器学习中经常会碰到一些高维的数据集，而在高维数据情形下会出现数据样本稀疏，距离计算等困难，这类问题是所有机器学习方法共同面临的严重问题，称之为“ 维度灾难 ”。另外在高维特征中容易出现特征之间的线性相关，这也就意味着有的特征是冗余存在的。基于这些问题，降维思想就出现了。</p>
<h3 id="91-svd奇异值分解线性降维"><a href="#9-1-SVD奇异值分解（线性降维）" class="headerlink" title="9.1 SVD奇异值分解（线性降维）"></a>9.1 SVD奇异值分解（线性降维）</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>将矩阵A变换成一个双对角矩阵（除了两行对角线元素非零，剩下的都是零），这个过程的计算量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="8.984ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 3970.8 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="msup" transform="translate(2203,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mn" transform="translate(975.3,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3581.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，如果矩阵是稀疏的，可以大大缩短计算时间</li>
<li>将双对角矩阵变成奇异值分解的三个矩阵，这一步计算量只是第一步的零头。</li>
</ol>
<h4 id="svd算法的实现"><a href="#SVD算法的实现" class="headerlink" title="SVD算法的实现"></a>SVD算法的实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVDReduce</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, dimension=<span class="number">500</span></span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize the class with the parameters.</span></span><br><span class="line"><span class="string">        :param data: pd.DataFrame, the output data from the class DataPreprocess.</span></span><br><span class="line"><span class="string">        :param dimension: int, default 500. To specify the output dimension.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.target_dim = dimension</span><br><span class="line">        self.format_data_path = <span class="string">'.../.../data/format_2/'</span></span><br><span class="line">        self.field = [<span class="string">'user'</span>, <span class="string">'product'</span>, <span class="string">'context'</span>, <span class="string">'shop'</span>]</span><br><span class="line">        <span class="comment"># self.field = ['product']</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        方法：判读大领域的维度</span></span><br><span class="line"><span class="string">        标准维度判断：不足补0，大于转为svd()</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logger.info(<span class="string">"judge the dimension..."</span>)</span><br><span class="line">        field_matrix_shape = data.shape</span><br><span class="line">        dimension = field_matrix_shape[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> dimension &gt; self.target_dim:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>;</span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">svd</span>(<span class="params">self, field_matrix</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        方法：对大的领域数据进行降维</span></span><br><span class="line"><span class="string">        :param field_matrix: list(2d) or np.array, 每一行(list)表示一条record</span></span><br><span class="line"><span class="string">        :return: 返回领域的降维矩阵</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logger.info(<span class="string">"use svd to reduce the dimension"</span>)</span><br><span class="line">        indices = field_matrix.index</span><br><span class="line">        fm = field_matrix</span><br><span class="line">        field_matrix = np.array(field_matrix)</span><br><span class="line">        field_matrix_dim = field_matrix.shape</span><br><span class="line">        <span class="built_in">print</span>(field_matrix_dim)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对维度进行判断是否需要降维</span></span><br><span class="line">        <span class="keyword">if</span> field_matrix_dim[<span class="number">1</span>] &lt;= self.target_dim:</span><br><span class="line">            logger.info(<span class="string">'Filed_matrix_dim if smaller than the target, no need to perform reduction, thus we only add extra zero element to make up the dimension.'</span>)</span><br><span class="line">            dim_make_up = self.target_dim - field_matrix_dim[<span class="number">1</span>]</span><br><span class="line">            matrix_make_up = np.zeros([field_matrix_dim[<span class="number">0</span>], dim_make_up])</span><br><span class="line">            matrix_make_up = pd.DataFrame(matrix_make_up, index=indices)</span><br><span class="line">            <span class="keyword">return</span> pd.concat([fm, matrix_make_up], axis=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            svd = TruncatedSVD(n_components=self.target_dim)</span><br><span class="line">            <span class="keyword">return</span> pd.DataFrame(svd.fit_transform(field_matrix), index=indices)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        1. Extract the one-hot-form data from the self.new_data_one_hot according to the field-instruction.</span></span><br><span class="line"><span class="string">        2. Based on the given self.target_dimension, judge the field matrix whether satisfy the dimension requirement.</span></span><br><span class="line"><span class="string">        3. If so, do the svd method, else add extra zero element to achieve the self.target_dimension.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        output_matrix = []</span><br><span class="line">        <span class="keyword">for</span> i, field_data <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.data):</span><br><span class="line">            <span class="comment"># field_data = self.split_field(field=item)</span></span><br><span class="line">            svd_matrix = self.svd(field_matrix=field_data)</span><br><span class="line">            svd_matrix.to_csv(self.format_data_path + <span class="string">'svd_'</span> + self.field[i] + <span class="string">'.csv'</span>)</span><br><span class="line">            output_matrix.append(svd_matrix)</span><br><span class="line">        <span class="keyword">return</span> output_matrix</span><br></pre></td></tr></table></figure>
<h4 id="示例svd用于图像压缩"><a href="#示例：SVD用于图像压缩" class="headerlink" title="示例：SVD用于图像压缩"></a>示例：SVD用于图像压缩</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.linalg <span class="keyword">as</span> la</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImgAsMat</span>(<span class="params">index</span>):</span></span><br><span class="line">    ds = datasets.fetch_olivetti_faces()</span><br><span class="line">    <span class="keyword">return</span> np.mat(ds.images[index])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImgAsMatFromFile</span>(<span class="params">filename</span>):</span></span><br><span class="line">    img = io.imread(filename, as_grey=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> np.mat(img) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotImg</span>(<span class="params">imgMat</span>):</span></span><br><span class="line">    plt.imshow(imgMat, cmap=plt.cm.gray)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverBySVD</span>(<span class="params">imgMat, k</span>):</span></span><br><span class="line">    <span class="comment"># singular value decomposition</span></span><br><span class="line">    U, s, V = la.svd(imgMat)</span><br><span class="line">    <span class="comment"># choose top k important singular values (or eigens)</span></span><br><span class="line">    Uk = U[:, <span class="number">0</span>:k]</span><br><span class="line">    <span class="comment">#SK:二维数组</span></span><br><span class="line">    Sk = np.diag(s[<span class="number">0</span>:k])</span><br><span class="line">    Vk = V[<span class="number">0</span>:k, :]</span><br><span class="line">    <span class="comment"># recover the image</span></span><br><span class="line">    imgMat_new = Uk * Sk * Vk</span><br><span class="line">    <span class="keyword">return</span> imgMat_new</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------- main --------------------- #</span></span><br><span class="line">A = getImgAsMatFromFile(<span class="string">'D:/Movie/svd.jpg'</span>)</span><br><span class="line">plotImg(A)</span><br><span class="line">A_new = recoverBySVD(A, <span class="number">20</span>)</span><br><span class="line">plotImg(A_new)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="关于svd的结论"><a href="#关于SVD的结论" class="headerlink" title="关于SVD的结论"></a>关于SVD的结论</h4><p><img src="http://img.mukewang.com/5cf8010700019ce107260343.png" alt="图片描述"></p>
<h3 id="92-pca主成分分析"><a href="#9-2-PCA主成分分析" class="headerlink" title="9.2 PCA主成分分析"></a>9.2 PCA主成分分析</h3><h4 id="思路"><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>数据从原来坐标转换到新坐标，由数据本身决定。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>行业景气度分析</title>
    <url>/post/fd618b32/</url>
    <content><![CDATA[<h1 id="如何判断行业空间和景气度"><a href="#如何判断行业空间和景气度" class="headerlink" title="如何判断行业空间和景气度"></a>如何判断行业空间和景气度</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xueqiu.com/2524803655/196686913">论空间，开箱专精特新小巨人 来源： 华泰证券张馨元、王以 一、 前言： 新兴产业链比较框架探讨—SPPEC模型 美林 时钟的弱化、央行政策思路的演变… - 雪球 (xueqiu.com)</a>)</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>不可预测的系统风险、宏观调控</li>
<li>悲观者正确，乐观者自由</li>
</ul>
<h2 id="20后新趋势与切入点"><a href="#20后新趋势与切入点" class="headerlink" title="20后新趋势与切入点"></a>20后新趋势与切入点</h2><blockquote>
<ol>
<li>标的所处的行业空间有多大、人们的想象空间有多大</li>
<li>标的公司所处的身位优势有多强、成长速度有多快</li>
<li>不可单纯从企业财务数据看，理解真实的世界，关注真实的生意</li>
</ol>
</blockquote>
<p>与之对应，以往经典的低估值注重安全：</p>
<blockquote>
<ol>
<li>投资的安全边际</li>
<li>传统的价值理念</li>
<li>稳健的财务数据</li>
</ol>
</blockquote>
<p>年末避险需求导致该模式回归</p>
<h2 id="sppec模型"><a href="#SPPEC模型" class="headerlink" title="SPPEC模型"></a>SPPEC模型</h2><p><img src="https://xqimg.imedao.com/17bae18dc1645023fd08716f.png!800.jpg" alt="img"></p>
<ul>
<li><p>如何判断一个行业的成长空间</p>
</li>
<li><p>行业的空间是否代表公司的业绩空间，即标的公司业绩空间与行业空间的关系</p>
</li>
<li><p>不同产业链的市场估值情况现状</p>
</li>
<li><p>关键在于，不同行业的各因子权重不同</p>
</li>
<li>产业空间叠加 <strong><em>渗透率、国产率、市占率</em></strong> 分析公司</li>
</ul>
<h2 id="渗透率"><a href="#渗透率" class="headerlink" title="渗透率"></a>渗透率</h2><p>S型曲线：<strong>渗透率S型曲线的加速点大概率出现在10%左右。</strong></p>
<p><img src="https://xqimg.imedao.com/17bae18dc1e44af3fe37d2c1.png!800.jpg" alt="img"></p>
<blockquote>
<ol>
<li><p><strong>渗透率低于10%的，仍然处于“导入期”的产业链：生物育种、智能汽车、航空装备。</strong>此三大产业链处于技术或应用大规模推广的前期，从二级市场投资的角度而言，由于业绩的波动性可能较大，这样的产业链更适合主题或概念投资。</p>
</li>
<li><p><strong>渗透率位于10%与70%之间的，处于“加速期”的产业链：光伏、锂电、云计算与光通信、风电、机器人、CXO、半导体。</strong>上述产业中，光伏、锂电、云计算与光通信在2018-2020期间迈过10%渗透率阈值，从导入期切换到成长期的产业链；当前A股市场的热门投资赛道基本都集中在这个区间内，从二级市场投资的角度而言，由于这一阶段往往是高成长性的持续兑现阶段，业绩增速高且波动下降，适合进行赛道逻辑的投资，挖掘全产业链的机会。</p>
</li>
<li><p><strong>渗透率位于70%以上的，处于“成熟期”的产业链</strong></p>
</li>
</ol>
</blockquote>
<h2 id="国产率"><a href="#国产率" class="headerlink" title="国产率"></a>国产率</h2><ul>
<li>国产替代</li>
<li>国际出海</li>
</ul>
<p>国产率要求高的行业：军工、芯片</p>
<h2 id="市占率"><a href="#市占率" class="headerlink" title="市占率"></a>市占率</h2><h3 id="把握技术发展的方向把握龙头企业的集中度演变和进阶空间如图"><a href="#把握技术发展的方向，把握龙头企业的集中度演变和进阶空间，如图" class="headerlink" title="把握技术发展的方向，把握龙头企业的集中度演变和进阶空间，如图"></a>把握技术发展的方向，把握龙头企业的集中度演变和进阶空间，如图</h3><p><img src="https://xqimg.imedao.com/17bae18dc31456e3fd5b7659.png!800.jpg" alt="img"></p>
<h3 id="周期先降后升的行业集中度"><a href="#周期：先降后升的行业集中度" class="headerlink" title="周期：先降后升的行业集中度"></a>周期：先降后升的行业集中度</h3><ol>
<li>新兴行业出现 </li>
<li>政策补贴/利润高企，投机者涌入，鸡犬升天 </li>
<li>龙头把握先机 </li>
<li>行业集中度被搅局者稀释 </li>
<li>剧烈内卷，整体行业集中度下降 </li>
<li>死一批人 </li>
<li>龙头市占率缓步提升 </li>
</ol>
<p>客观原因：产业信息传递不及时，羊群效应</p>
<p>主观原因：<strong>人的欲望与认知的不匹配</strong></p>
<h4 id="行业集中度下降的时间内"><a href="#行业集中度下降的时间内" class="headerlink" title="行业集中度下降的时间内"></a>行业集中度下降的时间内</h4><p>内卷加剧，行业普遍亏损，如2015-2018年的光伏行业，<strong>注意行业的竞争格局、公司的技术身位优势</strong></p>
<h4 id="龙头进阶发生在30-70之间"><a href="#龙头进阶发生在30-70-之间" class="headerlink" title="龙头进阶发生在30%-70%之间"></a>龙头进阶发生在30%-70%之间</h4><p>技术路线不统一，技术力高，谁都可能成功，<strong>寻找最终有可能杀出重围、乱中取胜的龙头，但风险与收益并存</strong></p>
]]></content>
      <categories>
        <category>商业</category>
      </categories>
      <tags>
        <tag>business</tag>
      </tags>
  </entry>
  <entry>
    <title>查询优化器</title>
    <url>/post/82f873fc/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>基本形式</p>
<p>与其他模块的关系</p>
<p>MySQL</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/MySQL查询优化过程.png" alt></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/MySQL查询优化器架构图.png" alt></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/查询优化全过程.png" alt></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《数据库查询优化器的艺术》</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>optimizer</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构 笔记</title>
    <url>/post/afe9b55e/</url>
    <content><![CDATA[<h1 id="企业信息化-笔记"><a href="#企业信息化-笔记" class="headerlink" title="企业信息化 笔记"></a>企业信息化 笔记</h1><ol>
<li>信息系统的概念（*）</li>
<li>信息系统的类型（*）</li>
<li>信息系统生命周期（*）</li>
<li>系统建模（*）</li>
<li>信息系统战略规划（<em>*</em>）</li>
<li>政府信息化与电子政务（*）</li>
<li>企业信息化与电子商务（<em>*</em>）</li>
<li>企业应用集成（<em>*</em>）</li>
<li>企业门户（**）</li>
</ol>
<h2 id="1"><a href="#1" class="headerlink" title="1.*"></a>1.*</h2><h3 id="信息的定义"><a href="#信息的定义" class="headerlink" title="信息的定义"></a>信息的定义</h3><ul>
<li>香农：信息就是不确定性的减少</li>
<li>维纳：信息就是信息，既不是物质，也不是能量</li>
</ul>
<h3 id="信息的特点"><a href="#信息的特点" class="headerlink" title="信息的特点"></a>信息的特点</h3><ul>
<li>客观性</li>
<li>动态性</li>
<li>层次性</li>
<li>传递性</li>
<li>滞后性</li>
<li>扩压性</li>
<li>分享性</li>
</ul>
<h3 id="信息化的概念"><a href="#信息化的概念" class="headerlink" title="信息化的概念"></a>信息化的概念</h3><ul>
<li>信息化是从工业社会到信息社会的演进和变革</li>
<li>信息化主体是全体社会成员（政府、企业、团体、个人），时域是一个长期过程，空域是经济和社会的一切领域，手段是先进社会生产工具</li>
</ul>
<h3 id="信息化对组织的意义"><a href="#信息化对组织的意义" class="headerlink" title="信息化对组织的意义"></a>信息化对组织的意义</h3><ul>
<li>组织的结构创新</li>
<li>组织的管理创新</li>
<li>组织经营创新</li>
<li>三类人才：IT专业人才，业务人才，专家型人才</li>
</ul>
<h3 id="信息化标准-法律和规定"><a href="#信息化标准、法律和规定" class="headerlink" title="信息化标准、法律和规定"></a>信息化标准、法律和规定</h3><h3 id="信息系统的生命周期"><a href="#信息系统的生命周期" class="headerlink" title="信息系统的生命周期"></a>信息系统的生命周期</h3><ul>
<li>立项阶段：企业全局、形成概念、需求分析</li>
<li>开发阶段<ul>
<li>总体规划<ul>
<li>初步调查、分析系统目标、子系统组成、拟实施方案、可行性研究、制定系统建设方案</li>
<li>系统设计任务书（系统建设方案、实施计划）</li>
</ul>
</li>
<li>系统分析<ul>
<li>业务流程分析、数据与数据流程分析、软件需求分析、网络需求分析</li>
<li>系统需求规格说明书、软件需求规格说明书、确认测试计划、系统测试计划、初步的用户手册</li>
</ul>
</li>
<li>系统设计<ul>
<li>软件架构设计、软件概要设计、详细设计、网络设计</li>
<li>架构设计文档、概要设计说明书、详细设计说明书、程序规格说明书、概要测试计划、详细测试计划、各类设计圈</li>
</ul>
</li>
<li>系统实施<ul>
<li>软件编码、软件单元/集成/系统测试、综合布线</li>
<li>源码、单元测试、集成测试报告、操作手册</li>
</ul>
</li>
<li>系统验收<ul>
<li>确认测试、试运行</li>
<li>确认测试报告、项目验收报告</li>
</ul>
</li>
</ul>
</li>
<li>运维阶段：通过验收、移交之后</li>
<li>消亡阶段：更新改造、功能扩展、报废重建</li>
</ul>
<h3 id="信息系统战略规划-方法"><a href="#信息系统战略规划-方法" class="headerlink" title="信息系统战略规划 - 方法"></a>信息系统战略规划 - 方法</h3><ul>
<li>第一阶段：以数据处理为核心、围绕职能部门需求<ul>
<li>企业系统规划法（BSP）：自上而下识别系统目标，自下而上设计信息系统，对组织机构的变动具有适应性</li>
<li>关键成功因素法（CSF）：找实现目标的关键信息集合，从而确定开发优先次序</li>
<li>战略集合转化法（SST）：把战略“目标”看成“信息集合”，把战略目标转变成信息系统的战略目标。</li>
</ul>
</li>
<li>第二阶段：以企业内部MIS为核心，围绕企业整体需求<ul>
<li>战略数据规划法（SDP）</li>
<li>信息工程法（IE）</li>
<li>战略栅格法（SG）</li>
</ul>
</li>
<li>第三阶段：综合考虑企业内外环境，以集成为核心、围绕企业战略需求<ul>
<li>价值链分析法（VCA）</li>
<li>战略一致性模型（SAM）</li>
</ul>
</li>
</ul>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><h3 id="政府信息化和电子政务"><a href="#政府信息化和电子政务（-）" class="headerlink" title="政府信息化和电子政务（*）"></a>政府信息化和电子政务（*）</h3><h3 id="企业信息化与电子商务"><a href="#企业信息化与电子商务（-）" class="headerlink" title="企业信息化与电子商务（*）"></a>企业信息化与电子商务（<em>*</em>）</h3><h4 id="1-企业资源计划erp"><a href="#1-企业资源计划（ERP）" class="headerlink" title="1. 企业资源计划（ERP）"></a>1. 企业资源计划（ERP）</h4><p>物料需求计划（MRP）：物料单系统</p>
<p>制造资源计划（MRPII)：增加库存、分销等</p>
<p>企业资源计划（ERP）：打通了供应链，把财务、人力、销售管理等纳入</p>
<ul>
<li>管理思想的变革</li>
<li>软件产品：需要个性化的开发和部署</li>
<li>管理系统：存在众多的子系统，这些子系统有统一的规划，是互联互通的，便于事前事中监控</li>
</ul>
<p>第一层 经营计划：经营计划是企业总目标的具体体现</p>
<p>第二层 生产计划大纲：根据经营计划的生产目标制定的，是对企业经营计划的细化，用以描述企业在可用资源的条件下，在一定时期中的产量计划。</p>
<p>第三层 主生产计划：对企业生产计划大纲的细化，说明在一定十七内的</p>
<p>第四层 物料需求计划 ：对主生产计划的各个项目所需的全部制造件和全部采购件的网络支持计划和时间进度计划</p>
<p>能力需求计划：对物料需求计划所需能力进行核算的一种计算管理方法</p>
<p>第五层 车间生产控制：在MRP所产生的加工制造订单的基础上，按照交货期的前后和生产优先级选择原则以及车间的生产资源情况，将零部件的生产计划以订单的形式下达到适当的车间</p>
<h4 id="客户关系管理crm"><a href="#客户关系管理（CRM）" class="headerlink" title="客户关系管理（CRM）"></a>客户关系管理（CRM）</h4><p><strong>市场营销</strong>和<strong>客户服务</strong>是CRM的支柱性功能</p>
<ul>
<li>客户服务与支持</li>
<li>客户群维系</li>
<li>商机管理</li>
<li>自动化销售</li>
<li>自动化市场营销</li>
<li>自动化客户服务</li>
</ul>
<p>触发中心、挖掘中心</p>
<h4 id="供应链管理scm"><a href="#供应链管理（SCM）" class="headerlink" title="供应链管理（SCM）"></a>供应链管理（SCM）</h4><p>对象包括 供应商、制造商、零售商、分销商</p>
<p>功能包括 计划、采购、制造、配送、退货</p>
<p><strong>设计原则</strong></p>
<ul>
<li>自顶向下和自底向上结合</li>
<li>简洁性原则</li>
<li>互补性原则</li>
<li>协调性原则</li>
<li>动态性原则</li>
<li>创新性原则</li>
<li>战略性原则</li>
</ul>
<h4 id="商业智能bi"><a href="#商业智能（BI）" class="headerlink" title="商业智能（BI）"></a>商业智能（BI）</h4><p>数据仓库、数据挖掘、OLAP</p>
<ul>
<li>需求分析</li>
<li>数据仓库建模</li>
<li>数据抽取</li>
<li>建立BI分析报表</li>
<li>用户培训和数据模拟测试</li>
<li>系统改进和完善</li>
</ul>
<h4 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h4><p>特点</p>
<ul>
<li>面向主题：数据按主题组织</li>
<li>集成的：消除了源数据中的不一致性，提供整个企业的一致性全局信息</li>
<li>相对稳定的（非易失的）：主要进行查询操作，只有少量的修改和删除操作</li>
<li>反映历史变化（随时间变化）：记录了企业从过去某一时刻到当前各个阶段的信息，可对发展历程和未来趋势做定量分析和预测</li>
</ul>
<h4 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h4><p><strong>方法</strong></p>
<ul>
<li>决策树（构建树结构进行分析）</li>
<li>神经网络（类似统计学中的判别、回归、聚类等功能）</li>
<li>遗传算法（三个基本过程：繁殖、交叉、变异）</li>
<li>关联规则挖掘算法（关联规则是描述数据之间存在关系的规则）</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>关联分析：挖掘出隐藏在数据间的相互关系</li>
<li>序列模式分析：侧重点是分析数据间的前后关系（因果关系）</li>
<li>分类分析：为每一种记录赋予一个标记再按标记分类</li>
<li>聚类分析：分类分析法的逆过程</li>
</ul>
<h4 id="决策支持系统dss"><a href="#决策支持系统（DSS）" class="headerlink" title="决策支持系统（DSS）"></a>决策支持系统（DSS）</h4><h4 id="业务流程重组bpr"><a href="#业务流程重组（BPR" class="headerlink" title="业务流程重组（BPR)"></a>业务流程重组（BPR)</h4><h4 id="业务流程管理"><a href="#业务流程管理" class="headerlink" title="业务流程管理"></a>业务流程管理</h4><h4 id="企业门户"><a href="#企业门户" class="headerlink" title="企业门户"></a>企业门户</h4><h4 id="企业应用集成"><a href="#企业应用集成" class="headerlink" title="企业应用集成"></a>企业应用集成</h4><h4 id="电子商务"><a href="#电子商务" class="headerlink" title="电子商务"></a>电子商务</h4><ul>
<li>信息化的三流（*）<ul>
<li>信息流（核心）</li>
<li>资金流</li>
<li>物流</li>
</ul>
</li>
<li>电子商务的形式（*）<ul>
<li>企业对消费者</li>
<li>企业对企业</li>
<li>消费者对消费者</li>
<li>线上对线下</li>
</ul>
</li>
</ul>
<h1 id="软件工程-笔记"><a href="#软件工程-笔记" class="headerlink" title="软件工程 笔记"></a>软件工程 笔记</h1><ol>
<li>系统规划</li>
<li>软件开发方法<ul>
<li>软件开发方法（<em>*</em>)</li>
<li>软件开发模型（<em>** </em>）</li>
</ul>
</li>
<li>面向对象基础<ul>
<li>基础概念（**）</li>
<li>UML 4+1 视图（<strong> </strong>）</li>
<li>UML图（<strong> * </strong>）</li>
<li>UML关系（<strong> </strong>）</li>
</ul>
</li>
<li>需求工程<ul>
<li>需求获取（<em> *</em>）</li>
<li>需求分析（<em> *</em>）</li>
</ul>
</li>
<li>软件架构分析<ul>
<li>架构风格（**）</li>
<li>架构评估（**）</li>
</ul>
</li>
<li>系统设计<ul>
<li>界面设计（**）</li>
<li>业务流程设计（<em> *</em>）</li>
<li>面向对象设计原则（<strong> </strong>）</li>
<li>设计模式（<strong> * </strong>）</li>
</ul>
</li>
<li>测试与评审</li>
<li>软件开发环境与工具</li>
<li>系统运行与评价<ul>
<li>可维护性因素（<em> *</em>）</li>
<li>维护类型（<em> *</em>）</li>
</ul>
</li>
<li>软件过程改进</li>
</ol>
<h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h2><ul>
<li>结构化<ul>
<li>用户至上</li>
<li>严格区分工作阶段，每阶段有任务与成果</li>
<li>强调系统开发过程的整体性和全局性</li>
<li>系统开发过程工程化、文档资料标准化</li>
<li>自顶向下，逐步分解</li>
</ul>
</li>
<li>原型法<ul>
<li>适用需求不明确的开发</li>
<li>包括抛弃型原型、进化型原型</li>
</ul>
</li>
<li>面向对象方法<ul>
<li>更好的复用性</li>
<li>关键在于建立一个全面、合理、统一的模型</li>
<li>分析、设计、实现三个阶段，界限不明确</li>
</ul>
</li>
<li>面向服务的方法<ul>
<li>SO方法有三个主要的抽象级别：操作、服务、业务流程</li>
<li>SOAD分为三个层次：基础设计曾（底层服务构件）、应用结构层（服务之间的接口和服务级协定）、业务组织层（业务流程建模和服务流程编排）</li>
<li>服务建模：分为服务发现、服务规约、服务实现</li>
</ul>
</li>
</ul>
<h4 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h4><p>瀑布模型    演化模型    增量模型    螺旋模型    快速原型模型    喷泉模型    V模型    迭代模型    快速应用开发    购件组装模型/基于构件的开发方法    统一过程/统一开发方法    敏捷开发方法    模型驱动的开发方法    基于架构的开发方法</p>
<p><strong>迭代模型</strong></p>
<p><strong>瀑布模型</strong></p>
<p><strong>增量模型与螺旋模型</strong></p>
<p><strong>V模型</strong></p>
<p><strong>购件组装模型</strong></p>
<p><strong>统一过程</strong></p>
<p><strong>敏捷方法</strong></p>
<p><strong>逆向工程</strong></p>
<p><strong>净室软件工程</strong></p>
<h2 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>软件需求是指，用户对系统在功能、行为、性能、设计约束等方面的期望</li>
<li>软件需求是指，用户解决问题或达到目标所需的条件或能力，是系统或系统不见要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明</li>
</ul>
<p>需求管理（变更控制、版本控制、需求跟踪、需求状态跟踪）</p>
<p>支持 需求开发（需求获取、需求分析、需求定义、需求验证）</p>
<h3 id="2-需求开发"><a href="#2-需求开发" class="headerlink" title="2. 需求开发"></a>2. 需求开发</h3><h4 id="21-需求获取"><a href="#2-1-需求获取" class="headerlink" title="2.1 需求获取"></a>2.1 需求获取</h4><p>需求分类</p>
<ul>
<li>业务需求、用户需求、系统需求</li>
<li>功能需求、性能需求、设计约束</li>
<li>基本需求、期望需求、兴奋需求</li>
</ul>
<p><strong>获取方法</strong>：收集资料、联合讨论会、用户访谈、书面调查、现场观摩、参加业务时间、阅读历史文档、抽样调查</p>
<h4 id="22-需求分析"><a href="#2-2-需求分析" class="headerlink" title="2.2 需求分析"></a>2.2 需求分析</h4><h5 id="221-sa"><a href="#2-2-1-SA" class="headerlink" title="2.2.1 SA"></a>2.2.1 SA</h5><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/SA.PNG" alt="SA图"></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/DFD.PNG" alt="DFD图"></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/STD.PNG" alt="STD图"></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/E-R.PNG" alt="E-R图"></p>
<h5 id="222-ooa"><a href="#2-2-2-OOA（-）" class="headerlink" title="2.2.2 OOA（*）"></a>2.2.2 OOA（*）</h5><ul>
<li>对象</li>
<li>类<ul>
<li>实体类：映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息</li>
<li>控制类：用于控制用例工作的类</li>
<li>边界类：用于封装在用例内、外流动的信息或数据流</li>
</ul>
</li>
<li>抽象</li>
<li>封装</li>
<li>继承与泛化</li>
<li>多态</li>
<li>接口</li>
<li>消息</li>
<li>组件</li>
<li>模式和复用</li>
</ul>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/OOA.PNG" alt="OOA"></p>
<p>UML 2.0</p>
<ul>
<li>结构图（静态图）<ul>
<li>类图</li>
<li>对象图</li>
<li><strong>包图</strong></li>
<li><strong>组合结构图</strong></li>
<li>构件图</li>
<li>部署图：软硬件之间映射</li>
<li><strong>制品图</strong></li>
</ul>
</li>
<li>行为图（动态图）<ul>
<li>用例图：系统与外部参与者的交互</li>
<li>顺序图：强调按时间顺序</li>
<li>通信图（协作图）</li>
<li><strong>定时图</strong></li>
<li>状态图：状态转换变迁</li>
<li>活动图：类似程序流程图，并行行为</li>
<li><strong>交互概览图</strong></li>
</ul>
</li>
</ul>
<h4 id="23-需求定义"><a href="#2-3-需求定义" class="headerlink" title="2.3 需求定义"></a>2.3 需求定义</h4><p>严格定义法：所有需求都能够被预先定义、开发人员与用户之间能够准确而清晰地交流、采用图形文字可以充分体现最终系统</p>
<ul>
<li>用结构化、自然语言编写文本型文档</li>
<li>建立图形化模型</li>
<li>编写形式化规格说明</li>
</ul>
<p>原型法：并非所有地需求都能在开发前被准确说明、项目参加者站之间通常都存在交流上地困难、需要实际地可供用户参与地系统模型、有合适地系统开发环境、反复是完全需要和值得提倡地</p>
<h4 id="24-需求验证"><a href="#2-4-需求验证" class="headerlink" title="2.4 需求验证"></a>2.4 需求验证</h4><p>需求评审：正式、非正式</p>
<p>需求测试</p>
<p>用户签字确认… 验收标准之一</p>
<h3 id="3-需求管理"><a href="#3-需求管理" class="headerlink" title="3. 需求管理"></a>3. 需求管理</h3><h4 id="31-定义需求基线"><a href="#3-1-定义需求基线" class="headerlink" title="3.1 定义需求基线"></a>3.1 定义需求基线</h4><h4 id="32-需求跟踪"><a href="#3-2-需求跟踪" class="headerlink" title="3.2 需求跟踪"></a>3.2 需求跟踪</h4><h3 id="变更控制"><a href="#变更控制" class="headerlink" title="变更控制"></a>变更控制</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/变更控制.PNG" alt="变更控制"></p>
<h3 id="软件系统建模"><a href="#软件系统建模" class="headerlink" title="软件系统建模"></a>软件系统建模</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/软件系统建模.PNG" alt="软件系统建模"></p>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="1-人机界面设计"><a href="#1-人机界面设计" class="headerlink" title="1. 人机界面设计"></a>1. 人机界面设计</h3><ul>
<li>置于用户控制之下<ul>
<li>以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式</li>
<li>提供灵活的交互</li>
<li>允许用户交互可以被中断或撤销</li>
<li>当技能级别增加时可以使交互流水话并允许定制交互</li>
<li>使用户隔离内部技术细节</li>
<li>设计应允许用户和出现在屏幕上的对象直接交互</li>
</ul>
</li>
<li>减少用户的记忆负担<ul>
<li>减少对短期记忆的要求</li>
<li>建立有意义的缺省</li>
<li>定义直接性的捷径</li>
<li>界面的视觉布局应该基于真实世界的隐喻</li>
<li>以不断进展的方式揭示信息</li>
</ul>
</li>
<li>保持界面的一致性<ul>
<li>允许用户将当前任务放入有意义的语境</li>
<li>在应用系列内保持一致性</li>
<li>如过去的交互模型已建立起了用户期望，除非有迫不得已的理由，不要改变</li>
</ul>
</li>
</ul>
<h3 id="2-结构化设计"><a href="#2-结构化设计" class="headerlink" title="2. 结构化设计"></a>2. 结构化设计</h3><p>概要设计、详细设计</p>
<p>抽象化；自顶而下、逐步求精；信息隐蔽；模块独立（高内聚、低耦合）</p>
<ul>
<li>保持模块的大小适中</li>
<li>尽可能减少调用的深度</li>
<li>多扇入，少扇出</li>
<li>单入口，单出口</li>
<li>模块的作用域应该在模块之内</li>
<li>功能应该是可预测的</li>
</ul>
<h3 id="3-面向对象的设计"><a href="#3-面向对象的设计" class="headerlink" title="3. 面向对象的设计"></a>3. 面向对象的设计</h3><p>基本过程</p>
<p>分析模型：用例模型、分析模型（领域模型）</p>
<p>设计师：设计用例实现方案、设计技术支撑实施、设计用户界面、细化设计模型</p>
<p>设计模型：架构图（用包图表示）、用例实现图（用交互图表示）、类图（完整、精确）、其他（状态图、活动图）</p>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul>
<li>单一职责原则：设计目的单一的类</li>
<li>开放-封闭原则：对扩展开放，对修改封闭</li>
<li>Liskov替换原则：子类可以替换父类</li>
<li>依赖倒置原则：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程</li>
<li>接口隔离原则：使用多个专门的接口比使用单一的总接口要好</li>
<li>组合重用原则：要尽量使用组合，而不是继承关系达到重用目的</li>
<li>迪米特原则（最少知识法则）：一个对象应当对其他对象有尽可能少的了解</li>
</ul>
<h4 id="31-设计模式"><a href="#3-1-设计模式" class="headerlink" title="3.1 设计模式"></a>3.1 设计模式</h4><p>概念：</p>
<ul>
<li>架构模式：软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策</li>
<li>设计模式：主要关注软件系统的设计，与具体的实现语言无关</li>
<li>惯用法：用最底层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系</li>
</ul>
<p>包括：</p>
<ul>
<li>创建型模式<ul>
<li>工厂方法模式：定义一个创建对象的接口，但由子类决定需要实例化哪个类。工厂方法使得子类实例化的过程推迟。（<strong>动态生产对象</strong>）</li>
<li>抽象工厂模式：提供一个接口，可以创建一些列相关或相互依赖的对象，而无需指定它们具体的类（<strong>生成系列对象</strong>）</li>
<li>原型模式：用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象（<strong>克隆对象</strong>）</li>
<li>单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点（<strong>单实例</strong>）</li>
<li>构建器模式：将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同得表示（<strong>复杂对象构建</strong>）</li>
</ul>
</li>
<li>结构型模式<ul>
<li>配适器模式：<strong>转换接口</strong></li>
<li>桥接模式：<strong>继承树拆分</strong></li>
<li>组合模式：<strong>树形目录结构</strong></li>
<li>装饰模式：<strong>附加职责</strong></li>
<li>外观模式：<strong>对外统一接口</strong></li>
<li>享元模式：<strong>汉字编码</strong></li>
<li>代理模式：<strong>快捷方式</strong></li>
</ul>
</li>
<li>行为型模式<ul>
<li>职责链模式：<strong>传递职责</strong></li>
<li>命令模式：<strong>日志记录，可撤销</strong></li>
<li>解释器模式：<strong>虚拟机的机制</strong></li>
<li>迭代器模式：<strong>数据集</strong></li>
<li>中介者模式：<strong>不直接引用</strong></li>
<li>备忘录模式</li>
<li>观察者模式：<strong>联动</strong></li>
<li>状态模式：<strong>状态变成类</strong></li>
<li>策略模式：<strong>多方案切换</strong></li>
<li>模块方法模式</li>
<li>访问者模式</li>
</ul>
</li>
</ul>
<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h3><p>动态测试：黑盒测试法、白盒测试法、灰盒测试法</p>
<p>静态测试：桌前测试、代码审查、代码走查</p>
<ul>
<li>尽早、不断地进行测试</li>
<li>程序员避免测试在自己设计的程序</li>
<li>既要选择有效、合理的数据，也要选择无效、不合理的数据</li>
<li>修改后要进行回归测试</li>
<li>尚未发现的错误数量与该程序已发现错误数成正比</li>
</ul>
<h3 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h3><p>黑盒测试法：等价类划分、边界值分析、错误推测、因果图</p>
<p>白盒测试法：基本路径测试、循环覆盖测试、逻辑覆盖测试</p>
<h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><ol>
<li>冒烟测试</li>
<li><ul>
<li>单元测试</li>
<li>集成测试<ul>
<li>一次性组装</li>
<li>增量式组装<ul>
<li>自顶向下</li>
<li>自底向上</li>
<li>混合式</li>
</ul>
</li>
</ul>
</li>
<li>确认测试<ul>
<li>内部确认测试</li>
<li>Alpha测试</li>
<li>Beta测试</li>
<li>验收测试</li>
</ul>
</li>
<li>系统测试<ul>
<li>恢复测试</li>
<li>安全性测试<ul>
<li>负载测试、强度测试、容量测试</li>
</ul>
</li>
<li>压力测试</li>
<li>性能测试</li>
<li>可靠性测试</li>
<li>可用性测试</li>
<li>可维护性测试</li>
<li>安装测试</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>V模型测试</p>
<ul>
<li>单元测试：模块测试，模块功能、性能、接口等</li>
<li>集成测试：模块间的接口</li>
<li>确认测试：验证软件与需求的一致性。内部确认测试、Alpha测试、Beta测试、验收测试</li>
<li>系统测试：真实环境下，验证完整的软件配置之项能否与系统正确连接</li>
<li>回归测试：测试软件变更之后，变更部分的正确性对变更需求的符合性</li>
</ul>
<h3 id="面向对象测试"><a href="#面向对象测试" class="headerlink" title="面向对象测试"></a>面向对象测试</h3><ul>
<li>算法层（单元测试）：包括等价类划分测试、组合功能测试（基于判定表的测试）、递归函数测试、多态消息测试</li>
<li>类层（模块测试）：包括不变式边界测试、模态类测试、非模态类测试</li>
<li>模块层/类树层（集成测试）：包括多态服务测试、展平测试</li>
<li>系统层（系统测试）</li>
</ul>
<h3 id="软件调试"><a href="#软件调试" class="headerlink" title="软件调试"></a>软件调试</h3><ul>
<li>软件调试方法<ul>
<li>蛮力法：主要思想是通过计算机找错，低效、耗时</li>
<li>回溯法：从出错处人工沿控制流程往会追踪，直至发现出错的根源。复杂程序由于回溯路径多，难以实施</li>
<li>原因排除法：主要思想是演绎和归纳，用二分法实现</li>
</ul>
</li>
<li>软件测试与调试的区别<ul>
<li>测试的目的是找出存在的错误，调试的目的是定位错误并修改程序以修正错误</li>
<li>调试是测试之后的活动，目标、方法、思路都有所不同</li>
<li>测试从一个已知的条件开始，使用预先定义的过程，有预知的结果；调试从一个未知的条件开始，结束的过程不可预计</li>
<li>测试过程可以实现设计，进度可以事先确认；调试不能描述过程或持续时间</li>
</ul>
</li>
</ul>
<h2 id="系统运行与软件维护"><a href="#系统运行与软件维护" class="headerlink" title="系统运行与软件维护"></a>系统运行与软件维护</h2><h3 id="数据转换与迁移"><a href="#数据转换与迁移" class="headerlink" title="数据转换与迁移"></a>数据转换与迁移</h3><p>从旧数据库到新数据库：抽取、转换、装载</p>
<ul>
<li>系统切换前通过工具迁移</li>
<li>系统切换前采用手工录入</li>
<li>系统切换后通过新系统生产</li>
</ul>
<h3 id="系统运行与维护"><a href="#系统运行与维护" class="headerlink" title="系统运行与维护"></a>系统运行与维护</h3><p>软件维护是生命周期的一个完整部分</p>
<p>可以将软件维护定义为需要提供软件支持的全部活动，这些活动包括在交付前完成的活动，以及交付后完成的活动。</p>
<p>交付前完成的活动包括交付后运行的计划和维护计划等；交付后的活动包括软件修改、培训、帮助资料等</p>
<h1 id="软件架构设计"><a href="#软件架构设计" class="headerlink" title="软件架构设计"></a>软件架构设计</h1><p>概念-&gt; 风格 -&gt; 设计 -&gt; 评估</p>
<h2 id="1-软件架构的概念"><a href="#1-软件架构的概念" class="headerlink" title="1. 软件架构的概念"></a>1. 软件架构的概念</h2><h3 id="11-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>需求分析 ——架构——软件设计</p>
<p>架构设计就是需求分配，即将满足需求的职责分配到组件上</p>
<ul>
<li><h3 id="12-发展史"><a href="#1-2-发展史" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h3></li>
</ul>
<ol>
<li>无架构阶段（汇编语言）</li>
<li>萌芽阶段（程序结构设计）</li>
<li>初级阶段（统一建模语言）</li>
<li>高级阶段（4+1视图）</li>
</ol>
<h3 id="13-软件架构建模"><a href="#1-3-软件架构建模" class="headerlink" title="1.3 软件架构建模"></a>1.3 软件架构建模</h3><ul>
<li>结构模型：以架构的构件、连接件和其他概念来刻画结构</li>
<li>架构模型：不太侧重描述结构的细节而更侧重于整体的结构</li>
<li>动态模型：系统的“大颗粒”的行为性质</li>
<li>过程模型：构建系统的步骤和过程</li>
<li>功能模型：由一组功能构件按层次组成，下层向上层提供服务</li>
</ul>
<p><img src alt></p>
<h2 id="2-体系结构描述语言adl"><a href="#2-体系结构描述语言（ADL）" class="headerlink" title="2. 体系结构描述语言（ADL）"></a>2. 体系结构描述语言（ADL）</h2><h2 id="3-软件架构风格"><a href="#3-软件架构风格" class="headerlink" title="3. 软件架构风格"></a>3. 软件架构风格</h2><ul>
<li>架构设计的一个核心问题是<strong>能否达到架构级的软件复用</strong></li>
<li>架构风格反映了领域众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整地系统</li>
<li>架构风格定义了用于描述系统地术语表和一组指导构件系统的规则</li>
</ul>
<p>风格包括</p>
<ul>
<li>数据流风格：批处理序列、管道-过滤器</li>
<li>调用/返回风格：主程序/子程序、面向对象、层次结构</li>
<li>独立构件风格：进程通信、事件驱动系统（隐式调用）</li>
<li>虚拟机风格：解释器、基于规则的系统</li>
<li>仓库风格：数据库系统、超文本系统、黑板系统</li>
</ul>
<h3 id="31-数据流风格"><a href="#3-1-数据流风格" class="headerlink" title="3.1 数据流风格"></a>3.1 数据流风格</h3><h4 id="311-批处理序列"><a href="#3-1-1-批处理序列" class="headerlink" title="3.1.1 批处理序列"></a>3.1.1 批处理序列</h4><p>构件为一系列固定顺序的计算单元，构件之间只通过数据传递交互。</p>
<p>每个处理步骤是一个独立的程序，每一步必须在其前一步结束后才能开始，数据必须是完整的，以整体的方式传递。</p>
<h4 id="312-管道-过滤器"><a href="#3-1-2-管道-过滤器" class="headerlink" title="3.1.2 管道-过滤器"></a>3.1.2 管道-过滤器</h4><p>每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常是通过对输入数据流的变换或计算来完成的，包括通过计算和增加信息以丰富数据、通过浓缩和删除以精简数据、通过改变记录方式以转换数据和递增地转化数据等。这里地构件称为过滤器，连接件就是数据流传输地管道，将一个过滤器地输出传到另一个过滤器地输入。</p>
<h3 id="32-调用返回风格"><a href="#3-2-调用-返回风格" class="headerlink" title="3.2 调用/返回风格"></a>3.2 调用/返回风格</h3><h4 id="321-主程序子程序"><a href="#3-2-1-主程序-子程序" class="headerlink" title="3.2.1 主程序/子程序"></a>3.2.1 主程序/子程序</h4><p>单线程控制，把问题划分为若干个处理步骤，构件即为主程序和子程序，子程序通常可合成为模块。</p>
<p>过程调用作为交互机制，即充当连接件地角色。</p>
<p>调用关系具有层次性，其语义逻辑表现为主程序的正确性取决于它调用的子程序的正确性。</p>
<h4 id="322-面向对象"><a href="#3-2-2-面向对象" class="headerlink" title="3.2.2 面向对象"></a>3.2.2 面向对象</h4><p>构件是对象，对象是抽象数据类型的实例。在抽象数据类型中，数据的表示和它们的相应操作被封装起来，对象的行为体现在其接受和请求的动作。</p>
<p>连接件即是对象间交互的方式，对象是通过函数和过程的调用来交互的。</p>
<h4 id="323-层次结构"><a href="#3-2-3-层次结构" class="headerlink" title="3.2.3 层次结构"></a>3.2.3 层次结构</h4><p>构件组织成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一次提供服务，使用下一层的服务，只能见到与自己邻接的层。</p>
<p>通过层次结构，可以将大的问题分解为若干个渐进的小问题逐步解决，可以隐藏问题的复杂度。修改一层，最多影响相邻的两层。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>这种风格支持基于可增加抽象层地设计，允许将一个复杂问题分解成一个增量步骤序列地实现</li>
<li>不同的层次处于不同的抽象级别</li>
<li>由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件复用提供强大的支持</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>并不是每个系统都可以很容易地划分为分层地模式</li>
<li>很难找到一个合适的、正确地层次抽象方法</li>
</ol>
<h3 id="33-独立构件风格"><a href="#3-3-独立构件风格" class="headerlink" title="3.3 独立构件风格"></a>3.3 独立构件风格</h3><h4 id="331-进程通信"><a href="#3-3-1-进程通信" class="headerlink" title="3.3.1 进程通信"></a>3.3.1 进程通信</h4><p>构件是独立的过程，连接件是消息传递。</p>
<p>构件通常是命名过程，消息传递的方式可以是点对点、异步或同步方式、远程过程（方法）调用等</p>
<h4 id="332-事件驱动系统隐式调用"><a href="#3-3-2-事件驱动系统（隐式调用）" class="headerlink" title="3.3.2 事件驱动系统（隐式调用）"></a>3.3.2 事件驱动系统（隐式调用）</h4><p>构件不直接调用一个过程，而是出发或广播一个或多个事件。构件中的过程在一个或多个事件中注册，当某个事件被触发时，系统自动调用在这个事件中注册的所有过程。</p>
<h3 id="34-虚拟机风格"><a href="#3-4-虚拟机风格" class="headerlink" title="3.4 虚拟机风格"></a>3.4 虚拟机风格</h3><h4 id="341-解释器"><a href="#3-4-1-解释器" class="headerlink" title="3.4.1 解释器"></a>3.4.1 解释器</h4><p>解释器通常包括一个完成解释工作的解释引擎、一个包含将被解释的代码的存储区、一个包含将被解释的代码的存储区、一个记录解释引擎当前工作状态的数据结构、以及一个记录源代码被解释执行的进度的数据结构。</p>
<p>具有解释器风格的软件中含有一个虚拟机，可以仿真硬件的执行过程和一些关键应用，缺点是执行效率比较低。</p>
<h4 id="342-基于规则的系统"><a href="#3-4-2-基于规则的系统" class="headerlink" title="3.4.2 基于规则的系统"></a>3.4.2 基于规则的系统</h4><p>基于规则的的系统包括规则集、规则解释器、规则/数据选择器和工作内存，一般用在人工职能领域和DSS中</p>
<h3 id="35-仓库风格以数据为中心的风格"><a href="#3-5-仓库风格（以数据为中心的风格）" class="headerlink" title="3.5 仓库风格（以数据为中心的风格）"></a>3.5 仓库风格（以数据为中心的风格）</h3><h4 id="351-数据库系统"><a href="#3-5-1-数据库系统" class="headerlink" title="3.5.1 数据库系统"></a>3.5.1 数据库系统</h4><p>构件主要由两大类，一类是中央共享数据源，保持当前系统的数据状态；另一类是多个独立处理单元，处理单元对数据元素进行操作</p>
<h4 id="352-黑板系统"><a href="#3-5-2-黑板系统" class="headerlink" title="3.5.2 黑板系统"></a>3.5.2 黑板系统</h4><p>包括<strong>知识源</strong>、<strong>黑板</strong>、<strong>控制</strong>三部分</p>
<p>知识源包括若干独立计算的不同单元，提供解决问题的知识。知识源响应黑板的变化，也只修改黑板；黑板是一个全局数据库，包含问题域解空间的全部状态，是知识源相互作用的唯一每阶；知识源响应是通过黑板状态的变化来控制的。黑板系统通常应用在对于解决问题没有确定性算法的软件中（信号处理、问题规划、编译器优化等）</p>
<h4 id="353-超文本系统"><a href="#3-5-3-超文本系统" class="headerlink" title="3.5.3 超文本系统"></a>3.5.3 超文本系统</h4><p><strong>现代集成编译环境一般用这种架构风格。</strong></p>
<p>构件以网状链接方式相互连接，用户可以在构件之间进行按照人类的联想思维方式任何跳转到相关构件。超文本是一种非线性的网状信息组织方法，它以节点为基本单位，链作为结点之间的联想式关联。</p>
<h3 id="36-闭环控制架构过程控制"><a href="#3-6-闭环控制架构（过程控制）" class="headerlink" title="3.6 闭环控制架构（过程控制）"></a>3.6 闭环控制架构（过程控制）</h3><p>当软件被用来操作一个物理系统时，软件与硬件之间可以粗略地表示为一个反馈循环，这个反馈循环通过接受一个的输入，确定一系列的输出，最终使环境达到一个新的状态。适用于嵌入式系统，涉及连续的动作与状态。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6%E6%9E%B6%E6%9E%84.PNG" alt></p>
<h2 id="4-重要软件架构风格"><a href="#4-重要软件架构风格" class="headerlink" title="4. 重要软件架构风格"></a>4. 重要软件架构风格</h2><h3 id="41-层次架构风格"><a href="#4-1-层次架构风格" class="headerlink" title="4.1 层次架构风格"></a>4.1 层次架构风格</h3><h2 id="5-基于架构的软件开发方法"><a href="#5-基于架构的软件开发方法" class="headerlink" title="5. 基于架构的软件开发方法"></a>5. 基于架构的软件开发方法</h2><h2 id="6-软件架构评估"><a href="#6-软件架构评估" class="headerlink" title="6. 软件架构评估"></a>6. 软件架构评估</h2><ol>
<li>为什么要进行架构评估？</li>
<li>架构评估到底评什么？</li>
<li>架构评估怎么评？</li>
</ol>
<h3 id="61-质量属性"><a href="#6-1-质量属性" class="headerlink" title="6.1 质量属性"></a>6.1 质量属性</h3><h4 id="611-性能"><a href="#6-1-1-性能" class="headerlink" title="6.1.1 性能"></a>6.1.1 性能</h4><p>performance 是指系统的响应能力，即经过多长时间才能对某个事件制作出响应，或者在某段时间内系统所能处理的事件个数</p>
<p>代表参数：响应事件、吞吐量</p>
<p>设计策略：优先级队列、资源调度</p>
<h4 id="612-可靠性"><a href="#6-1-2-可靠性" class="headerlink" title="6.1.2 可靠性"></a>6.1.2 可靠性</h4><p>reliability 是软件系统在应用或系统错误面前，在意外或错误使用的情况下维持软件系统的功能特性的基本能力</p>
<p>代表参数：MTTF、MTBF</p>
<p>设计策略：冗余、心跳线</p>
<h4 id="613-可用性"><a href="#6-1-3-可用性" class="headerlink" title="6.1.3 可用性"></a>6.1.3 可用性</h4><p> availability 是系统能够正常运行的事件比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。</p>
<p>代表参数：故障间隔时间</p>
<p>设计策略：冗余、心跳线</p>
<h4 id="614-安全性"><a href="#6-1-4-安全性" class="headerlink" title="6.1.4 安全性"></a>6.1.4 安全性</h4><p>security 是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。安全性可划分为机密性、完整性、不可否认性以及可控性等特性。</p>
<p>设计策略：追踪审计、信息隐藏</p>
<h4 id="615-可修改性"><a href="#6-1-5-可修改性" class="headerlink" title="6.1.5 可修改性"></a>6.1.5 可修改性</h4><p>modifiability 是指能够快速地以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性。</p>
<h4 id="616-功能性"><a href="#6-1-6-功能性" class="headerlink" title="6.1.6 功能性"></a>6.1.6 功能性</h4><p>functionality 是系统所能完成所期望的工作的能力。一项任务的完成需要系统中许多或大多数构件的相互协作。</p>
<h4 id="617-可变性"><a href="#6-1-7-可变性" class="headerlink" title="6.1.7 可变性"></a>6.1.7 可变性</h4><p>changeability 是指体系结构经扩充或变更而成为新体系结构的能力。这种新体系结构应该符合预先定义的规则，在某些具体方面不同于原有的体系结构。当要将某个体系结构作为一系列相关产品的基础时，可变性是很重要的。</p>
<h4 id="618-互操作性"><a href="#6-1-8-互操作性" class="headerlink" title="6.1.8 互操作性"></a>6.1.8 互操作性</h4><p>interoperation 软件体系结构必须为外部可视的功能特性和数据结构提供精心设计的软件入口。程序和用其他编程语言编写的软件系统的交互作用就是互操作性的问题.</p>
<h4 id="具体举例"><a href="#具体举例" class="headerlink" title="具体举例"></a>具体举例</h4><ol>
<li>用户提交搜索请求后,系统必须在1秒内显示结果</li>
<li>用户信息数据库授权必须保证99.9%可用</li>
<li>系统由MySQL数据库升级为Oracle数据库,必须在1人月内完成</li>
<li>主服务器出现严重问题无法提供服务时,备用系统10分钟内能接替工作</li>
<li>需要在3人周内为系统添加一种新的支付方式</li>
<li>视频点播时,超清模式必须保证画面具有1280*720的分辨率</li>
<li>主站点断电后,需要在3s内将访问请求重定向到备用站点</li>
</ol>
<p><strong>风险点</strong>: 指架构设计中潜在的 存在问题的架构决策所带来的隐患.</p>
<p><strong>敏感点</strong>:指为了实现某种特定的质量属性,一个或多个构件所具有的特性</p>
<p><strong>权衡点</strong>:影响多个质量属性的特性,是多个在质量属性的敏感点</p>
<h3 id="62-基于场景的方式"><a href="#6-2-基于场景的方式" class="headerlink" title="6.2 基于场景的方式"></a>6.2 基于场景的方式</h3><h4 id="621-atam"><a href="#6-2-1-ATAM" class="headerlink" title="6.2.1 ATAM"></a>6.2.1 ATAM</h4><h4 id="622-cbam"><a href="#6-2-2-CBAM" class="headerlink" title="6.2.2 CBAM"></a>6.2.2 CBAM</h4><h4 id="623-saam"><a href="#6-2-3-SAAM" class="headerlink" title="6.2.3 SAAM"></a>6.2.3 SAAM</h4><h4 id="624-质量效用树"><a href="#6-2-4-质量效用树" class="headerlink" title="6.2.4 质量效用树"></a>6.2.4 质量效用树</h4><h2 id="7-软件产品线"><a href="#7-软件产品线" class="headerlink" title="7. 软件产品线"></a>7. 软件产品线</h2><h2 id="8-中间件技术"><a href="#8-中间件技术" class="headerlink" title="8. 中间件技术"></a>8. 中间件技术</h2><h2 id="9-典型应用架构"><a href="#9-典型应用架构" class="headerlink" title="9. 典型应用架构"></a>9. 典型应用架构</h2><h1 id="系统安全分析与设计"><a href="#系统安全分析与设计" class="headerlink" title="系统安全分析与设计"></a>系统安全分析与设计</h1><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h1 id="系统架构设计案例分析"><a href="#系统架构设计案例分析" class="headerlink" title="系统架构设计案例分析"></a>系统架构设计案例分析</h1><h1 id="系统架构设计论文"><a href="#系统架构设计论文" class="headerlink" title="系统架构设计论文"></a>系统架构设计论文</h1><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><h2 id="1-计算机体系结构分类"><a href="#1-计算机体系结构分类" class="headerlink" title="1. 计算机体系结构分类"></a>1. 计算机体系结构分类</h2><h3 id="11-flynn"><a href="#1-1-Flynn" class="headerlink" title="1.1 Flynn"></a>1.1 Flynn</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">体系结构类型</th>
<th style="text-align:center">结构</th>
<th style="text-align:center">关键特性</th>
<th style="text-align:center">代表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单指令流单数据流SISD</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">单指令流多数据流SIMD</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">多指令流单数据流MISD</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">多指令流多数据流MIMD</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="系统配置与性能评价"><a href="#系统配置与性能评价" class="headerlink" title="系统配置与性能评价"></a>系统配置与性能评价</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h1><h1 id="数学与经济管理"><a href="#数学与经济管理" class="headerlink" title="数学与经济管理"></a>数学与经济管理</h1><h1 id="知识产权与标准化"><a href="#知识产权与标准化" class="headerlink" title="知识产权与标准化"></a>知识产权与标准化</h1>]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>查询性能优化——《高性能MySQL》第六章</title>
    <url>/post/ce4af811/</url>
    <content><![CDATA[<h1 id="前言-关于时间"><a href="#前言-关于时间" class="headerlink" title="前言 关于时间"></a>前言 关于时间</h1><p>数据库优化，最重要的目标是时间，最大的敌人也是时间。</p>
<p>套用经济学的概念，数据库优化就像一辆三驾马车，而它的三匹马分别是<strong>查询优化</strong>、<strong>索引优化</strong>、<strong>库表结构优化</strong>。要获取最佳的数据库性能需要三匹马齐头并进、一个不落。</p>
<h1 id="1-为什么查询速度会慢"><a href="#1-为什么查询速度会慢" class="headerlink" title="1. 为什么查询速度会慢"></a>1. 为什么查询速度会慢</h1><p>查询会在不同的地方花费时间，包括网络、CPU计算、生成统计及信息和执行计划、锁等待（互斥等待）等操作，尤其是<strong>向底层存储引擎检索数据的调用</strong>操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。可能会产生<strong>大量的上下文切换以及系统调用</strong>。</p>
<p>不必要的额外操作、某些操作被额外地重复了很多次、某次操作执行得太慢等。优化查询的目的就是<strong>减少和消除这些操作花费时间</strong>。</p>
<h1 id="2-慢查询基础优化数据访问"><a href="#2-慢查询基础：优化数据访问" class="headerlink" title="2. 慢查询基础：优化数据访问"></a>2. 慢查询基础：优化数据访问</h1><p>基础：大部分性能低下的查询都可以通过<strong>减少访问的数据量的方式</strong>进行优化。</p>
<p>有效的两步：</p>
<ul>
<li>确认application是否在检索大量超过需要的数据</li>
<li>确认MySQL server是否在分析大量超过需要的数据行</li>
</ul>
<h2 id="21-是否向数据库请求了不需要的数据"><a href="#2-1-是否向数据库请求了不需要的数据" class="headerlink" title="2.1 是否向数据库请求了不需要的数据"></a>2.1 是否向数据库请求了不需要的数据</h2><h3 id="错误案例尽量避免"><a href="#错误案例，尽量避免" class="headerlink" title="错误案例，尽量避免"></a>错误案例，尽量避免</h3><h4 id="查询不需要的记录"><a href="#查询不需要的记录" class="headerlink" title="查询不需要的记录"></a>查询不需要的记录</h4><p>Mysql会先返回全部结果集再进行计算</p>
<h4 id="多表关联时返回全部列"><a href="#多表关联时返回全部列" class="headerlink" title="多表关联时返回全部列"></a>多表关联时返回全部列</h4><h4 id="总是取出全部列"><a href="#总是取出全部列" class="headerlink" title="总是取出全部列"></a>总是取出全部列</h4><p>（想起了索引作业返回所有列）取出全部列，会<strong>让优化器无法完成索引覆盖扫描这类优化</strong>！还会<strong>为服务器带来额外的I/O、内存、CPU的消耗</strong>。</p>
<p>注：虽然会浪费数据库资源，但有时候可以简化开发，提高代码复用性。但要注意使用缓存机制。</p>
<h4 id="重复查询相同的数据"><a href="#重复查询相同的数据。" class="headerlink" title="重复查询相同的数据。"></a>重复查询相同的数据。</h4><p>注意利用缓存。（查询缓存之后之后要看看）</p>
<h2 id="22-mysql是否在扫描额外的记录"><a href="#2-2-MySQL是否在扫描额外的记录" class="headerlink" title="2.2 MySQL是否在扫描额外的记录"></a>2.2 MySQL是否在扫描额外的记录</h2><h3 id="简单的衡量查询开销的三个指标"><a href="#简单的衡量查询开销的三个指标" class="headerlink" title="简单的衡量查询开销的三个指标"></a>简单的衡量查询开销的三个指标</h3><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>包括<strong>服务时间</strong>、<strong>排队时间</strong>之和。</p>
<ul>
<li>服务时间——数据库处理这个查询真正花了多长时间</li>
<li>排队时间——服务器因为等待某些资源而没有真正执行查询的时间——可能等I/O操作完成，也可能是等待行锁等。</li>
</ul>
<h4 id="扫描的行数和返回的行数"><a href="#扫描的行数和返回的行数" class="headerlink" title="扫描的行数和返回的行数"></a>扫描的行数和返回的行数</h4><p>查看查询扫描的行数是非常有帮助的，在一定程度能够说明该查询找到需要的数据的效率高不高。</p>
<h3 id="扫描的行数和访问类型"><a href="#扫描的行数和访问类型" class="headerlink" title="扫描的行数和访问类型"></a>扫描的行数和访问类型</h3>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>booknote</tag>
      </tags>
  </entry>
  <entry>
    <title>欧洲中世纪史 法英德</title>
    <url>/post/74fc2242/</url>
    <content><![CDATA[<h1 id="中世纪法国"><a href="#中世纪法国" class="headerlink" title="中世纪法国"></a>中世纪法国</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/16/Frankish_Empire_481_to_814-en.svg/1920px-Frankish_Empire_481_to_814-en.svg.png" alt="墨洛温王朝到卡洛林王朝的法兰克王国"></p>
<h2 id="2-中世纪盛期的法国987-1314"><a href="#2-中世纪盛期的法国（987-1314）" class="headerlink" title="2. 中世纪盛期的法国（987-1314）"></a>2. 中世纪盛期的法国（987-1314）</h2><h3 id="21-新王朝面临的困境"><a href="#2-1-新王朝面临的困境" class="headerlink" title="2.1 新王朝面临的困境"></a>2.1 新王朝面临的困境</h3><p>加洛林王朝在西法兰克王朝存在了100多年后王统终绝，被卡佩王朝取代，新王朝面临的困境： <strong>领地狭小、诸侯林立、王室宗主权等</strong></p>
<p>但是，卡佩王朝经过几代人的励精图治，首先在自己的管辖区内取得了建树：<br><strong>采邑义务的再确认；领地内的铸币权和集市权；主教和修道院长的任命；</strong></p>
<h3 id="22-腓力二世1165-1223"><a href="#2-2-腓力二世（1165-1223）" class="headerlink" title="2.2 腓力二世（1165-1223）"></a>2.2 腓力二世（1165-1223）</h3><ul>
<li>腓力二世被成为腓力奥古斯都，1180-1223年在位。</li>
<li>奉行国家集权化的政策:力图抑制强大诸侯。争取小封建领主和教会的支持，与经济繁荣的城市维持良好关系。</li>
<li>收回原属于法国的领地：<br>1204年诺曼底。<br>1206年阿基坦和安茹。<br>1207年普瓦图。<br>1214年布汶战役</li>
</ul>
<h3 id="23-路易九世1214-1270"><a href="#2-3-路易九世（1214-1270）" class="headerlink" title="2.3 路易九世（1214-1270）"></a>2.3 路易九世（1214-1270）</h3><p>路易九世被尊为“圣路易”，法国卡佩王朝第九任国王，1226—1270年在位。</p>
<ol>
<li>虔诚的基督教信仰：<ul>
<li>惩处异端、征伐穆斯林、迫害犹太人</li>
<li>1249年、1254年率十字军东侵</li>
</ul>
</li>
<li>公正和宽大原则处理国际的争端：</li>
<li>文化发展的顶峰：<ul>
<li>哥特式教堂的建立；巴黎大学人才辈出。</li>
</ul>
</li>
</ol>
<h3 id="24-腓力四世1268-1314"><a href="#2-4-腓力四世（1268-1314）" class="headerlink" title="2.4 腓力四世（1268-1314）"></a>2.4 腓力四世（1268-1314）</h3><p>腓力四世1285年—1314年在位。他当政时期，是王朝无休止侵略邻国土地，反对教皇，反对法国新贵的传统特权时代。</p>
<ul>
<li>1294年腓力四世侵入金雀花王朝在法国的关键领地基恩（即阿基坦）， 1300年起持续进攻佛兰德。</li>
<li>1296年—1303年，腓力四世与主张教权高于王权的教皇卜尼法斯八世发生严重冲突。</li>
<li>阿维农之囚：1303年，法王腓力四世将罗马教皇从罗马迁移到法国的阿维农，此后的70年五任教皇都是法国人担任，成为法王的御用工具，史称阿维农之囚。（1303-1337年）</li>
<li>腓力四世取缔圣殿骑士团并对成员进行残酷的捕杀（大多被以异端罪名处死）。</li>
<li>召开三级会议</li>
</ul>
<h2 id="3-中世纪晚期的法国"><a href="#3-中世纪晚期的法国" class="headerlink" title="3. 中世纪晚期的法国"></a>3. 中世纪晚期的法国</h2><h3 id="百年战争1337-1453"><a href="#百年战争-1337-1453" class="headerlink" title="百年战争(1337-1453)"></a>百年战争(1337-1453)</h3><p>14世纪30年代到15世纪50年代，法国与英国发生了100多年的战争，史称“百年战争”。</p>
<ul>
<li>王位要求：1328年卡佩王朝的查理四世死后王朝绝嗣。瓦罗亚王朝的腓力继位；英王亨利要求以法王外孙的资格继承法国王位。</li>
<li>大陆领地：在腓力二世收复了法国在英国的领地后，仍然有很少的领地在英国；同时，英国试图夺回失去的领地</li>
<li>弗兰德斯：弗兰德斯伯爵不愿意承认法王的宗主权，与英国有大量的羊毛交易。</li>
</ul>
<h4 id="第一阶段1337-1360"><a href="#第一阶段-1337-1360" class="headerlink" title="第一阶段(1337 - 1360)"></a>第一阶段(1337 - 1360)</h4><ul>
<li>1340年英军打败法军，夺取制海权，以防止法军入侵。</li>
<li>1346年8月所发生的克雷西会战中，英军取得陆地上的优势。</li>
<li>1356年英国再度开战，攻取了法国的西南部的基思和加斯科涅。</li>
<li>1360年《布勒丁尼和约》将卢瓦尔河以南至比利牛斯山脉的领土全部割让予英国。</li>
<li>第一阶段英国取得了决定性的胜利。</li>
</ul>
<h4 id="第二阶段1360-1400"><a href="#第二阶段-1360-1400" class="headerlink" title="第二阶段(1360 - 1400)"></a>第二阶段(1360 - 1400)</h4><ul>
<li>法王查理五世重组军队以雇佣步兵代替大部份骑兵，并建立了野战炮兵和重建舰队。</li>
<li>内政方面整顿税制，以安抚民心。</li>
<li>以突袭和游击战术攻击英军，在多场战役中均大败英军，1380年时已将英军迫退至沿海地带。</li>
<li>英王为免法国的领地全部丢失，与法国签署停战协定，只保有五个港口，分别是波尔多、巴约纳、布雷斯特、瑟堡和加莱及和波尔多与巴约纳间的部份连接地区。</li>
</ul>
<h4 id="第三阶段1415-1453"><a href="#第三阶段（1415-1453）" class="headerlink" title="第三阶段（1415-1453）"></a>第三阶段（1415-1453）</h4><ul>
<li>1415年，英军于阿赞库尔战役中大败法军，并随即与勃艮地公爵结盟，攻占法国北部大部份地区。</li>
<li>1420年5月21日《特鲁瓦和约》。法国沦为英法联合王国的一部分。英王亨利五世随即宣布自己为法国的摄政王，并有权于查理六世死后承继法国王。</li>
<li>1428年10月，英军与勃艮地派进逼至奥尔良，并包围了此城。</li>
<li>1429年5月解除了英国对奥尔良的包围，从而扭转了整个战争的形势。</li>
<li>1437年法军光复首都巴黎，于1441年收复香槟，又于1450年解放曼恩和诺曼底，1453年10月19日，波尔多的英军投降，法国收复了除加莱外的全部领土，百年战争至此完全结束。</li>
</ul>
<h1 id="中世纪英国"><a href="#中世纪英国" class="headerlink" title="中世纪英国"></a>中世纪英国</h1><h2 id="1-诺曼征服前的三次征服"><a href="#1-诺曼征服前的三次征服" class="headerlink" title="1. 诺曼征服前的三次征服"></a>1. 诺曼征服前的三次征服</h2><h3 id="征服之一罗马征服前55年-公元440年"><a href="#征服之一：罗马征服（前55年-公元440年）" class="headerlink" title="征服之一：罗马征服（前55年-公元440年）"></a>征服之一：罗马征服（前55年-公元440年）</h3><p>凯尔特人社会：</p>
<ul>
<li>军事贵族；普通农民；祭司巫师</li>
<li>特点：好勇斗狠；内部残杀</li>
</ul>
<p>前55年、前54年，凯撒入侵不列颠，无功而返。公元43年，4个军团的罗马军队（4000人）在克劳狄的带领下进军不列颠。结果11个不列颠王向罗马皇帝投降。47年不列颠成为罗马帝国的正式行省。罗马人任命总督、贵族议事会、财政掌官；不列颠人承担征兵、供奉好其他的帝国义务。</p>
<p>生活方式罗马化：说拉丁语；穿托嘎（Toga)<br>城市建设罗马化：市中心建立；罗马的洗浴传统；罗马剧场和竞技场</p>
<p>帝国的防卫：公元122年，罗马皇帝哈德良(公元76-138年)巡视不列颠，决定在英格兰北部修建长城，抵御北方的敌人。</p>
<h3 id="征服之二盎格鲁撒克逊征服440-1066"><a href="#征服之二：盎格鲁撒克逊征服（440-1066）" class="headerlink" title="征服之二：盎格鲁撒克逊征服（440-1066）"></a>征服之二：盎格鲁撒克逊征服（440-1066）</h3><p>氏族忠诚是社会的核心</p>
<ul>
<li>贵族会议、军事首领</li>
<li>血亲复仇、赔偿金制度</li>
<li>贝奥武甫（Beowulf）：7-8世纪英格兰英雄史诗，描绘6世纪盎格鲁萨克逊人在欧洲大陆的生活。第一部分写瑞典南部的贵族青年贝奥武甫渡海至丹麦，为当地人民消灭巨魔；第二部分写贝奥武甫任国王后，为杀危害人民的火龙而牺牲的事迹。</li>
<li>七国时代：公元7世纪日耳曼人在英格兰建立的七个小国：埃塞克斯、苏塞克斯、威塞克斯、东盎格利亚、麦西亚、诺森布利亚和肯特。各国交兵混战，分合无常。9世纪初，威塞克斯国王兼并各国，第一次建立统一的英格兰王国，七国时代结束。</li>
</ul>
<h3 id="征服之三维京人征服"><a href="#征服之三：维京人征服" class="headerlink" title="征服之三：维京人征服"></a>征服之三：维京人征服</h3><p>维京时代：</p>
<ul>
<li>维京人从公元790年开始扩张，到公元1066年丹麦人的后裔征服英格兰，一般称为“维京时代”。</li>
<li>维京人是著名的航海家，他們在雪德群兰岛、法罗群岛、冰岛、格陵兰岛，都設立了殖民地。他們不仅是海盜，也同时进行贸易。</li>
<li>他們的殖民地遍布欧洲，包括英格兰的丹麦区、基辅罗斯、法国的诺曼底等等。</li>
<li>只是到了維京時代的末期，北欧才出现独立的国家和国王，同时接受基督教。到欧洲各国王权強大，有能力抵抗维京海盗之后，他们靠抢掠而创立的霸业方才逐渐开始消亡。</li>
</ul>
<p>抗击维京人：</p>
<ul>
<li>877年，丹麦王向威塞克斯阿尔弗烈德大举进攻，阿尔弗烈德一度被逼到威塞克斯西部边境靠近威尔士一带，次年取得了著名的爱丁顿战役的胜利，成为整个战争的转折点。最后，阿尔弗烈德与丹麦人划界而治，东北部划归丹麦人，成为“丹法区”，阿尔弗烈德则统治西南部</li>
<li>阿尔弗烈德在位期间，兴办贵族学校、奖掖学术。最为人称道的是他的《阿尔弗烈德法典》；阿尔弗烈德邀请各国学者到他的宫中研究学问，主持编修了《盎格鲁萨克森编年史》。</li>
</ul>
<p>维京人的统治：</p>
<ul>
<li>1016年４月面对丹麦大军的攻击，爱德蒙率领军民展开了保卫伦敦的战斗，并在与丹麦国王战斗中夺回了牛津和肯特，但是在埃塞克斯之战中失利。他被迫和卡努特签署和平协议，由爱德蒙二世治理威塞克斯，卡努特统治麦西亚和诺森布里亚。埃德蒙死后，全英格兰就都归于卡努特一世的统治之下，史称卡努特大帝。他一人兼任丹麦、英格兰和挪威三国国王。<br>卡努特大帝在位期间，采取比较柔性的政策，成功统治英格兰近二十年。　　 </li>
</ul>
<h2 id="2-威廉征服与末日审判"><a href="#2-威廉征服与末日审判" class="headerlink" title="2. 威廉征服与末日审判"></a>2. 威廉征服与末日审判</h2><p><img src="https://th.bing.com/th/id/OIP.ykJaZMxB7b2bQAQ6cmEyfgAAAA?pid=ImgDet&amp;rs=1" alt="征服者威廉"></p>
<p>威廉一世 WilliamⅠ（1027—1087年），英格兰诺曼王朝第一任国王（1066—1087年在位），绰号“征服者威廉”。</p>
<h3 id="威廉征服的后果"><a href="#威廉征服的后果" class="headerlink" title="威廉征服的后果"></a>威廉征服的后果</h3><p>威廉下令没收英格兰贵族的地产，将其七分之一留给自己，其他的分封给随他来的诺曼贵族；同时抵制罗马教皇的压力，顽强地保留了对英格兰各主教的任命权。</p>
<p>1086年的“索尔兹伯里盟誓”，威廉要求各级封建主都必须向他本人行臣服礼，确立了“我的附庸的附庸还是我的附庸”的原则；</p>
<p>为掌握全国的土地、财产和收入状况，为征收赋税提供依据，确保王室收入，他派人到全国各地清查，制定《土地赋税调查书》。  </p>
<p>服饰、饮食、语言受到法国的极大影响。</p>
<h3 id="末日审判书"><a href="#末日审判书" class="headerlink" title="末日审判书"></a>末日审判书</h3><p><strong>11世纪英格兰土地、农业人口调查清册</strong>。1085年，威廉一世下令对全国土地、农民状况进行普查，作为征收土地税和确定封臣义务的证据。</p>
<p>调查内容：土地所有者的身份、土地面积及用途、农民人数及地位、土地的价值、作坊、鱼塘家畜等。该清册是中世纪欧洲有关财产状况最为广泛和详尽的调查记录，也是研究11世纪英格兰社会状况的珍贵史料。</p>
<h2 id="3-亨利二世与安哲文帝国"><a href="#3-亨利二世与安哲文帝国" class="headerlink" title="3. 亨利二世与安哲文帝国"></a>3. 亨利二世与安哲文帝国</h2><p><img src="https://pic3.zhimg.com/v2-a5971c71e86d8d6eea5713517bec62bf_r.jpg?source=1940ef5c" alt="亨利二世"></p>
<p>亨利二世（1133年－1189年）英格兰国王，1154年—1189年在位。他也是法国的诺曼底公爵、安茹伯爵和阿基坦公爵。他所创立的金雀花王朝是英格兰中世纪最强大的一个封建王朝。</p>
<h3 id="亨利二世的主要建树"><a href="#亨利二世的主要建树" class="headerlink" title="亨利二世的主要建树"></a>亨利二世的主要建树</h3><ul>
<li><strong>版图扩展</strong>：1151年，亨利继承了父亲杰弗瑞的封邑(安茹、曼因与土伦)，成为了安茹伯爵；他和阿奎丹的女公爵埃莲诺成亲，获得阿奎丹公爵领地；1154年成为英格兰国王，诺曼底公爵。</li>
<li><strong>司法改革</strong>：他废止了“神判法” 的野蛮判决方式，改以巡回法庭与陪审团制，以减少冤案的发生，他的改革，也奠定了现在英国法律的基础。</li>
<li><strong>对外扩张</strong>：亨利二世向北击败了来犯的苏格兰国王“狮子”威廉，使得苏格兰王国成为了亨利二世的附佣；大举入侵爱尔兰。</li>
</ul>
<h3 id="亨利二世和贝克特"><a href="#亨利二世和贝克特" class="headerlink" title="亨利二世和贝克特"></a>亨利二世和贝克特</h3><ul>
<li>传教士奥古斯丁于597年来英格兰传教，成为第一位坎特伯雷大主教，并把基督教传播到整个英格兰。坎特伯雷被人们喻为基督教信仰的摇篮。肯特郡的首府。</li>
<li>亨利二世颁布<strong>《克拉伦登宪章》</strong>，企图收回教会的司法权，贝克特却为了保护教会利益，不惜与昔日好友反目。亨利二世为此大表不满，他帐下的四位骑士却揣摩上意，跑到了坎特伯里大主教座堂中，砍杀了贝克特。这桩震惊基督教世界的事件，导致了<strong>亨利二世与教廷的对立</strong>，教皇立即为此向亨利二世与英格兰王国处以<strong>破门律</strong>。亨利二世面临这样的危机，只得亲身赤膊前往坎特伯里大主教座堂，向贝克特的尸骸忏悔，此举终于取得教廷的谅解，而撤销了破门律的惩罚。  </li>
</ul>
<h2 id="4-约翰与大宪章"><a href="#4-约翰与大宪章" class="headerlink" title="4. 约翰与大宪章"></a>4. 约翰与大宪章</h2><p><img src="https://bkimg.cdn.bcebos.com/pic/91529822720e0cf33bf33d5f0446f21fbe09aa0a?x-bce-process=image/resize,m_lfit,w_536,limit_1/format,f_jpg" alt="约翰一世"></p>
<p>约翰王（1167-1216）英格兰国王（1199-1216），外号“无地王约翰”</p>
<h3 id="签署大宪章"><a href="#签署大宪章" class="headerlink" title="签署大宪章"></a>签署大宪章</h3><p>杀害王位继承人；与教会交恶，干涉教会内部事务；失去领地；任意逮捕人，任意增加税收。</p>
<p>大宪章的主要内容：</p>
<ul>
<li>未经同级贵族的合法判决，国王不得任意逮捕监禁贵族或没收他们的财产；</li>
<li>未经贵族‘教士好骑士会议的同意，不得征收补助金好盾牌钱；</li>
<li>承认及教会自由，不干涉教职人员的选举；</li>
<li>保障领主好骑士的领地继承权，不得额外征收继承税；</li>
<li>统一度量衡，保障商业自由等共63条。</li>
</ul>
<h2 id="5-亨利三世与牛津条例"><a href="#5-亨利三世与牛津条例" class="headerlink" title="5. 亨利三世与牛津条例"></a>5. 亨利三世与牛津条例</h2><h3 id="牛津条例签署的背景"><a href="#牛津条例签署的背景" class="headerlink" title="牛津条例签署的背景"></a>牛津条例签署的背景</h3><ul>
<li>亨利有法国血统，其母是法国人，他又娶法国人为王后，许多法国亲戚在英格兰获得权势和财富。</li>
<li>为了夺回诺曼底等地，亨利三世于1230年和1242年，两次进攻大陆，但是，寸土未得，以失败告终。　 </li>
<li>亨利三世不断以大批钱财，供给教皇，以填充其在大陆战争的无底洞，而且教皇经常派其他国家的教士来英国领取教禄，这更使英国人不堪重负。</li>
<li>1254年，亨利三世与教皇英诺森四世达成一项协议，教皇允诺将西西里王位授予亨利三世的次子埃德蒙，同时，亨利三世则需向教皇提供西西里战争的军费。</li>
<li>其妹违背基督教原则，要求再婚，得到亨利的批准，冒犯教俗两界贵族。 </li>
</ul>
<h3 id="牛津条例"><a href="#牛津条例" class="headerlink" title="牛津条例"></a>牛津条例</h3><ul>
<li>1258年六月，亨利三世被迫在牛津召开了被称为“狂暴议会”的会议，会议上，贵族们迫使亨利三世接受了《牛津条例》。 </li>
<li>首席执法官主持15人委员会辅佐国王处理国家大事；</li>
<li>首席执法官首次被赋予管理地方事务、监督地方征服的职责；</li>
<li>贵族会议每年召开三次，并选择产生12人常务委员会；</li>
<li>条例有效期为12年，为英国第一个成文法。</li>
<li>1261年被宣布取消，导致贵族战争的爆发。</li>
</ul>
<h3 id="西门议会"><a href="#西门议会" class="headerlink" title="西门议会"></a>西门议会</h3><ul>
<li>1264年5月，西门•蒙特福特的贵族军队在刘易斯战役击败国王军队，俘获亨利三世和爱德华王子；</li>
<li>1265年，蒙特福特召开英国历史上第一次议会。参加者除了男爵，高级教士，和每郡两位骑士外，还增加各自由市每市两位市民代表。</li>
<li>贵族与市民阶层开始联合对付国王，市民阶层开始登上英国的政治舞台</li>
<li>1265年8月，两军对决，埃富萨姆会战。蒙特福特在战斗中被杀，王军获得大胜。亨利三世在爱德华的支持下，夺回了权力。</li>
</ul>
<h2 id="6-爱德华一世与英国议会"><a href="#6-爱德华一世与英国议会" class="headerlink" title="6. 爱德华一世与英国议会"></a>6. 爱德华一世与英国议会</h2><h3 id="征服威尔士"><a href="#征服威尔士" class="headerlink" title="征服威尔士"></a>征服威尔士</h3><ul>
<li>1267年《蒙哥马利条约》：亨利三世承认小卢埃林占领的领土和自封的“威尔士亲王”称号；小卢埃林交3000银马克的税纳；</li>
<li>1277年爱德华一世率军队向威尔士层层推进，年中签订《康韦条约》：小卢埃林行臣服礼，效忠英王，承认爱德华占领的土地，归还债务，保留“亲王”称号；</li>
<li>1284年《威尔士条例》：威尔士被分为几个郡，王室官员管理，刑法英格兰化，民法保留威尔士的传统。</li>
</ul>
<h3 id="苏格兰战争"><a href="#苏格兰战争" class="headerlink" title="苏格兰战争"></a>苏格兰战争</h3><ul>
<li>13世纪20-80年代是苏格兰历史上的黄金时代，1238年亚里山大二世向英格兰索要了诺森伯里亚和坎北兰；1249年亚里山大三世向英格兰行效忠礼，签订划界协定；</li>
<li>1294年英法开战；1296年爱德华一世派兵围攻特伦特河畔的贝里克，深入苏格兰腹地，引起了1296-1357年半个多世纪的“苏格兰独立战争。”</li>
<li>1298年苏格兰乡绅威廉•华莱士领导军队在斯特林桥打败英军；</li>
<li>1300年,1301年，1303年，1305年多次出兵镇压华莱士，迫使许多苏格兰贵族臣服；</li>
<li>1307年爱德华在再次征討由罗伯特布鲁斯领导的苏格兰途中，死在苏格兰边界的康伯兰。 </li>
</ul>
<h3 id="爱德华一世的法制"><a href="#爱德华一世的法制" class="headerlink" title="爱德华一世的法制"></a>爱德华一世的法制</h3><ul>
<li>司法权益的扩大：<ul>
<li>1278年《格洛斯特律令》（王室官员在场）</li>
<li>1290年《保证律令》（理查之前）</li>
</ul>
</li>
<li>封建关系的理顺：<ul>
<li>1279年《永久管业法》（限制教会土地权）</li>
<li>1285年《温切斯特法案》（15英镑以上）</li>
<li>1290年《第三号温切斯特法案》</li>
</ul>
</li>
</ul>
<h3 id="模范议会"><a href="#模范议会" class="headerlink" title="模范议会"></a>模范议会</h3><p>御前会议<br>狂暴议会（1258年）<br>西门议会（1265年）<br>模范议会（1295年）<br>行政、司法、立法和财产权</p>
<h3 id="玫瑰战争"><a href="#玫瑰战争" class="headerlink" title="玫瑰战争"></a>玫瑰战争</h3><ul>
<li><p>兰开斯特家族：金雀花家族的分支，始祖为冈特的约翰，父为英格兰国王爱德华的第三子，1340年出生在法兰德斯的冈特，故名。1362年成为兰开斯特公爵，从此开创此家系。因与其兄（黑太子爱德华）争夺王位被挫败。约翰之子亨利•波林布鲁克1399年发动叛乱，将其堂兄理查二世赶下王位，自立为英格兰国王，史称亨利四世，开创兰开斯特王朝，引起许多贵族的不满，特别是约克家族（始祖为冈特的约翰之弟）。兰开斯特家族的族徽为红玫瑰。</p>
</li>
<li><p>约克家族：始祖为爱德华三世的第四个儿子兰利的埃德蒙，1385年被封为约克公爵，为家族建立之始。1455年，因提出对英格兰王位的要求导致玫瑰战争。该家族的族徽为白玫瑰。</p>
</li>
</ul>
<h4 id="玫瑰战争的原因及进程"><a href="#玫瑰战争的原因及进程" class="headerlink" title="玫瑰战争的原因及进程"></a>玫瑰战争的原因及进程</h4><ul>
<li>百年战争中，一些英格兰贵族趁机扩大私人武装，为贵族间的局部冲突发展为内战提供了条件；百年战争后期，英格兰出现软弱国王面对强大贵族的局面；亨利六世幼主时期，贵族和议会的权力上升到新的高度，形成贵族既得利益集团；亨利六世长期不能亲政，约克家族以亨利六世与皇后玛格丽特的儿子是“外国人”，提出对英格兰王位的要求，导致战争的爆发。</li>
<li>1455年圣阿尔班战役，约克家族取得；1459年约克家族在卢德福桥和北安普顿大败兰开斯特家族，对王位的要求获得亨利六世的许可；</li>
<li>1460年兰开斯特家族突袭奥克菲尔德，杀死约克公爵理查；</li>
<li>1461年又在圣阿尔班战役打败约克家族；但是，兰开斯特家族约克之子迅速赶到伦敦举行加冕礼，立为爱德华四世，开创约克家族对英格兰的统治。</li>
</ul>
<h4 id="玫瑰战争的第二-三阶段"><a href="#玫瑰战争的第二、三阶段" class="headerlink" title="玫瑰战争的第二、三阶段"></a>玫瑰战争的第二、三阶段</h4><ul>
<li>爱德华当政的前4年，亨利六世的王后及他们的幼子仍然逍遥自在，伺机东山再起；约克家族失宠的沃里克伯爵与王弟克拉伦斯公爵联手在北方起事，并与流亡中的玛格丽特王后协议，废黜爱德华四世，使亨利六世复位（1470-71年）。</li>
<li>1471年爱德华借助勃艮第公爵的支持返回英格兰，杀死沃里克，生擒王后。约克王朝得以持续。</li>
<li>1483年爱德华驾崩，其弟摄政王理查成为国王，并通过议会宣布爱德华之子失去继承权。同年白金汉公爵和亨利都铎反生叛乱，被镇压；1485年亨利都铎再次叛乱，在博斯沃思击败理查三世，玫瑰战争结束。</li>
</ul>
<p>玫瑰战争使英格兰的旧贵族自相残杀殆尽，新家族建立起强大的王权以及统治基础——新贵族。</p>
<h1 id="中世纪德国"><a href="#中世纪德国" class="headerlink" title="中世纪德国"></a>中世纪德国</h1><h2 id="1-德意志国家的建立"><a href="#1-德意志国家的建立" class="headerlink" title="1. 德意志国家的建立"></a>1. 德意志国家的建立</h2><h3 id="加洛林王朝的衰落"><a href="#加洛林王朝的衰落" class="headerlink" title="加洛林王朝的衰落"></a>加洛林王朝的衰落</h3><p>部落公爵称雄的时代(9-10世纪)<br>萨克森(Saxony)<br>士瓦本(Swabia)<br>巴伐利亚(Bavaria)<br>法兰克尼亚(Franconia)<br>洛林(Lorraine)</p>
<h3 id="法兰克尼亚王朝"><a href="#法兰克尼亚王朝" class="headerlink" title="法兰克尼亚王朝"></a>法兰克尼亚王朝</h3><p>外部威胁：北面和西面是诺曼人，南面是萨拉逊人，东面是匈牙利人。<br>内部困扰：贵族世家力求削弱王权，扩大地盘；豪门王族之间尖锐的斗争，试图胜过对手；<br>911年法兰克尼亚人、萨克森人、巴伐利亚以及士瓦本人选举法兰克尼亚家族的康拉德为新国王，取代加洛林王朝成为新的居间权力。</p>
<h3 id="康拉德的居间权力"><a href="#康拉德的居间权力" class="headerlink" title="康拉德的居间权力"></a>康拉德的居间权力</h3><p>收复洛林的失败：西法兰克王国试图巩固对洛林的控制，出兵占领临近的阿尔萨斯，康拉德于912-913年发动三次战争不能收回洛林；<br>匈牙利人的大举入侵：912年袭击法兰克尼亚和图林根；913年入侵巴伐利亚和士瓦本，波及阿尔萨斯和洛林；<br>依靠教会抑制新的部族势力，加强王朝的力量。916年在霍恩阿尔特海姆举行德意志宗教会议，各地的高级教士参加，主题是“上帝挑选的国王”，不受叛逆者侵犯。</p>
<h2 id="2-萨克森王朝"><a href="#2-萨克森王朝" class="headerlink" title="2. 萨克森王朝"></a>2. 萨克森王朝</h2><h3 id="亨利一世的统治"><a href="#亨利一世的统治" class="headerlink" title="亨利一世的统治"></a>亨利一世的统治</h3><ul>
<li>通过婚姻增加财富并扩大地盘：利用教会的责难，与梅泽堡的埃尔温伯爵之女哈特堡离婚，扣留其嫁妆；与维杜金德家族的马蒂尔德结婚，继续增加财富；</li>
<li>采用同部族公爵联合，而非敌对的政策，保留公爵领地内的自主权；利用一切机会争取与教会的联合，任命美因茨大主教为大祭司，建立宫廷教堂，吸引主教和修道院长。</li>
<li>通过外交途径取得洛林的统治权，921年11月亨利作为“东法兰克王国的领袖”与“西法兰克王国的领袖”查理在莱茵河的船上会晤，并签订友好条约，查理承认亨利是莱茵河左岸洛林的主人。925年“全体洛林人均臣服于亨利”。</li>
<li>926年通过交出匈牙利俘虏和支付高额贡金，换取9年停战，933年匈牙利大军来犯，亨利取得胜利；928年秋亨利向北挺进，渡过易北河，冬天占领勃兰登堡；929年进军布拉格，轻易征服捷克公爵。</li>
</ul>
<h3 id="奥托一世"><a href="#奥托一世" class="headerlink" title="奥托一世"></a>奥托一世</h3><p>奥托一世，被尊为奥托大帝 Otto the great（912—973年），德意志国王（936—973年在位），神圣罗马帝国皇帝（962—973年在位）。</p>
<p>11世纪中期德意志是欧洲中央集权程度最高，统治最得力的地区。</p>
<p>德意志的力量来源于连续出现的统治者对政治分裂的抵制，以及王权和教会的紧密联盟。</p>
<h3 id="奥托王权的建立"><a href="#奥托王权的建立" class="headerlink" title="奥托王权的建立"></a>奥托王权的建立</h3><ul>
<li>奥托登上王位：936年亚琛大选，公爵和其他世俗贵族将奥托推到王位上，行效忠礼；美因茨大主教在教堂把“上帝挑选的、先王指定的、现由全体诸侯推举的奥托”介绍给民众；美因茨和科隆大主教共同为奥托涂油加冕。</li>
<li>重新调整王权与部落公国的关系，任命王室成员为公爵：亨利为巴伐利亚公爵，女婿为洛林公爵康拉德（红色）；兄长柳多夫为士瓦本公爵。953年“柳多夫叛乱”后，奥托的小弟布鲁恩任克隆大主教，兼任洛林大公。</li>
<li>布鲁恩培训遴选一些教士进入宫廷担任高级职务，一群新型精英兼任世俗和教会双重职能：主教和修道院长既有司法裁判权，又有税收、造币和管理市政的权力。这样，教会与国家形成了紧密的联系。</li>
</ul>
<h3 id="奥托的对外政策"><a href="#奥托的对外政策" class="headerlink" title="奥托的对外政策"></a>奥托的对外政策</h3><ul>
<li>950年波希米亚公爵对奥托称臣纳贡；</li>
<li>951年夏，奥托率领德国权贵越过阿尔卑斯山，9月底抵达伦巴德首府帕维亚，取得“伦巴德王”的荣誉；</li>
<li>955年，匈牙利人越过边境出现在巴伐利亚，并向士瓦本挺进，主力包围奥格斯堡。在附近的莱希菲尔德战役中，奥托率领萨克森、士瓦本、法兰克尼亚和波希米亚联军，几乎完全歼灭了匈牙利骑兵，从此解除了匈牙利人的威胁。这次胜利不仅保证了德意志境内的平安，而且保卫了神圣的基督教会（战胜异教徒），为奥托登上“罗马皇帝”的宝座奠定了基础。 </li>
</ul>
<h3 id="奥托加冕罗马皇帝"><a href="#奥托加冕“罗马皇帝”" class="headerlink" title="奥托加冕“罗马皇帝”"></a>奥托加冕“罗马皇帝”</h3><ul>
<li>959年罗马教皇约翰十二世受到伦巴德人的攻击，教皇派出使团向奥托求援。</li>
<li>961年8月奥托从奥格斯堡出发，962年1月抵达罗马；962年2月2日圣母圣烛节，受到教皇、教士和罗马市民的隆重迎接，并在圣彼得大教堂接受教皇的涂油加冕为“罗马人皇帝”；</li>
<li>962年2月13日奥托“特权书”出台，确认教皇国的产业；教皇由人民和教士选举，皇帝必须宣誓效忠，主教享有领主的一切世俗权利等，原则上厘清了皇帝和教皇的关系。</li>
</ul>
<h2 id="3-皇帝和教皇争夺主教叙任权的斗争"><a href="#3-皇帝和教皇争夺主教叙任权的斗争" class="headerlink" title="3. 皇帝和教皇争夺主教叙任权的斗争"></a>3. 皇帝和教皇争夺主教叙任权的斗争</h2><h3 id="主教叙任权争夺的背景"><a href="#主教叙任权争夺的背景" class="headerlink" title="主教叙任权争夺的背景"></a>主教叙任权争夺的背景</h3><ul>
<li>皇帝方面：皇帝依赖教会的支持，加强王权，削弱诸侯；主教和修道院长均由国王任命，而且干预教皇的选择和废立，王权高于教权。</li>
<li>教皇方面：公元5世纪,奥古斯丁的神学思想确立以来,宣扬教权高于王权；10世纪教会改革日益增强的世俗化倾向，提高教会的声望。</li>
<li>温和派的主张：整顿教会纪律，严守教士独身制度；禁止教职买卖。</li>
<li>激进派的观点：教权高于一切，世俗君主不得干预教皇的选举，主教由教皇任命。</li>
</ul>
<h3 id="格里高利七世与亨利四世"><a href="#格里高利七世与亨利四世" class="headerlink" title="格里高利七世与亨利四世"></a>格里高利七世与亨利四世</h3><h4 id="格里高利七世教会与国家的关系"><a href="#格里高利七世：教会与国家的关系" class="headerlink" title="格里高利七世：教会与国家的关系"></a>格里高利七世：教会与国家的关系</h4><p>格里高利七世（1020-1085）原名希尔德布兰，年轻时留学德国和法国，后入修道院成为修士，曾在教皇格里高利六世手下任职。1073年，当选教皇。他鼓吹教皇权力至高无上，反对世俗君主操纵主教叙任权。对于教会与国家关系的论述：</p>
<ul>
<li>“罗马教会由上帝一手创造”，“只有教皇一人有权被称为普世的主教”；</li>
<li>“只有他一人能够废立主教”，“只有他一人可以使用（处置）皇帝的徽记”；</li>
<li>“允许他废黜皇帝”，“他本人不为任何人所审判”，“他可以解除臣民对坏人的效忠”。 </li>
</ul>
<h4 id="格里高利七世与亨利四世的斗争"><a href="#格里高利七世与亨利四世的斗争" class="headerlink" title="格里高利七世与亨利四世的斗争"></a>格里高利七世与亨利四世的斗争</h4><ul>
<li>1075年格里高利七世召开罗马宗教会议；反对世俗授职权，反对圣职买卖和教士结婚；违反者割除教职，开除教籍；</li>
<li>1076年亨利四世召开沃尔姆斯宗教会议，废黜教皇；</li>
<li>同年教皇召开拉特兰宗教会议，开除亨利教籍，废除帝位，解除臣民效忠。</li>
<li>1077年卡诺莎城堡请罪。（亨利四世及妻儿赤脚前往卡诺萨请罪）</li>
<li>1084年，亨利出兵罗马，驱逐教皇，另立新教皇，重新加冕。</li>
</ul>
<h3 id="沃尔姆斯宗教协定"><a href="#沃尔姆斯宗教协定" class="headerlink" title="沃尔姆斯宗教协定"></a>沃尔姆斯宗教协定</h3><p>1122年9月8日皇帝、教廷特使、各路教会诸侯和世俗诸侯在沃尔姆斯召开宗教会议。皇帝放弃用权戒和权杖册封的权利，承认按教规进行的选举，但是，选举必须在国王和代表出席的情况下进行。</p>
<h2 id="4-霍亨斯陶芬王朝"><a href="#4-霍亨斯陶芬王朝" class="headerlink" title="4. 霍亨斯陶芬王朝"></a>4. 霍亨斯陶芬王朝</h2><h3 id="霍亨斯陶芬王朝1138-1254"><a href="#霍亨斯陶芬王朝（1138-1254）" class="headerlink" title="霍亨斯陶芬王朝（1138-1254）"></a>霍亨斯陶芬王朝（1138-1254）</h3><ul>
<li>霍亨斯陶芬王朝是德国中世纪历史上的一个封建王朝。霍亨斯陶芬家族是德国南部士瓦本的世袭伯爵。1079年与皇室联姻（娶亨利四世的女儿）使霍亨斯陶芬家族挤身于最高的统治阶层，由于亨利五世没有子嗣，法兰克尼亚王朝告终，霍亨斯陶芬家族成为理所当然的皇位继承人。1138年该家族取得德意志王位。</li>
<li>在红胡子腓特烈一世和腓特烈二世统治时期，霍亨斯陶芬家族权势最盛，与罗马教廷展开权力斗争，入侵意大利，取得意大利南方西西里的统治权。但在腓特烈二世死后，此家族日渐衰落。1254年德意志之霍亨斯陶芬王朝终结。</li>
</ul>
<h3 id="腓特烈一世红胡子1122-1190"><a href="#腓特烈一世，红胡子（1122-1190）" class="headerlink" title="腓特烈一世，红胡子（1122-1190）"></a>腓特烈一世，红胡子（1122-1190）</h3><ul>
<li>腓特烈一世 ，绰号红胡子（1122年—1190年6月10日）霍亨斯陶芬王朝的德意志国王（1152年—1190年在位）和神圣罗马帝国皇帝（1155年加冕）。</li>
<li><p>1158年颁布采邑法令，要求所有接受采邑者为皇帝服兵役；分割诸侯领地，1156年奥地利从巴伐利亚分离，成为独立公国；1180年腓特烈打败威尔夫家族的萨克森公爵狮子亨利，加强了对德国的控制。</p>
</li>
<li><p>1189年，腓特烈一世在与教皇和解后，与狮心王理查一世和腓力·奥古斯都一起领导了第三次十字军东征，在小亚细亚的萨列法河中意外溺死。</p>
</li>
</ul>
<h3 id="腓特烈二世1194-1250"><a href="#腓特烈二世（1194-1250）" class="headerlink" title="腓特烈二世（1194-1250）"></a>腓特烈二世（1194-1250）</h3><p>霍亨斯陶芬王朝的德意志国王（1211年—1250年在位）和神圣罗马帝国皇帝。</p>
<p>西西里国王（1198年起），耶路撒冷国王（1225年—1228年），意大利国王和勃艮第领主。</p>
<ul>
<li>治理西西里：统一法典，振兴农工商业，免除许多税收，建那不勒斯大学。<br>与教皇的斗争：1234年打败亨利七世的叛乱；征讨意大利南方的反皇帝城市联盟（1236年）；1241年他袭击了热那亚的舰队，俘虏了两红衣主教；1245年教皇对之采取绝罚，开除其教籍。</li>
<li>十字军：参加第四次十字军东侵，腓特烈二世避免战场上的交锋，通过谈判手段换回了耶路撒冷。根据和约，腓特烈二世重建了耶路撒冷王国并自任国王。 </li>
<li>1250年12月在行猎过程中，突然病倒，随后死于“百花之宫”（斐奥诺伦蒂诺城堡），穿重罪者忏悔的麻衣，而非皇帝华丽的寿衣。</li>
</ul>
<h2 id="5-从大空位到黄金诏书"><a href="#5-从大空位到黄金诏书" class="headerlink" title="5. 从大空位到黄金诏书"></a>5. 从大空位到黄金诏书</h2><h4 id="大空位时代1254-1273"><a href="#大空位时代（1254-1273）" class="headerlink" title="大空位时代（1254-1273）"></a>大空位时代（1254-1273）</h4><ul>
<li>1254年霍亨斯道芬王朝绝嗣，到1273年德意志王位虚悬的20年。期间，封建主极力将帝国的土地据为己有，德国分裂为许多独立的封建公国、伯国。</li>
</ul>
<p>1273年在教皇赞助下，哈布斯堡家族的鲁道夫登上王位，他试图重建王室领地，使资源超过权贵。他加冕时宣誓：维护帝国法律和秩序，并颁布国内和平法令，重建帝国的权力。他时常召开由诸侯、僧侣和城市代表参加的帝国会议；给以城市自治地位，向城市征收各种税收，增加帝国收入，使神圣罗马帝国得以暂时苟延残喘。但是，德意志的王公贵族不愿意坐视自己的领地和权益被王室扩张所侵吞，而是一心牺牲王室的利益，扩充他们的公国。德国不可逆转地逐渐趋向散漫的公国联邦和不健全的君主选择政体，这是从14世纪到19世纪德国立宪结构的特征。</p>
<h4 id="黄金诏书"><a href="#黄金诏书" class="headerlink" title="黄金诏书"></a>黄金诏书</h4><ul>
<li>1356年，神圣罗马帝国皇帝查理四世（1347-1378）颁布的诏书。</li>
<li>皇帝由选侯选举产生；</li>
<li>保证选侯领地的完整；</li>
<li>规定选侯的特权：包括矿产、赋税和造币等特权；</li>
<li>1806年失效。</li>
</ul>
<h2 id="6-汉萨同盟"><a href="#6-汉萨同盟" class="headerlink" title="6. 汉萨同盟"></a>6. 汉萨同盟</h2><h4 id="城市同盟"><a href="#城市同盟" class="headerlink" title="城市同盟"></a>城市同盟</h4><ul>
<li>城市同盟：德国于13至14世纪出现了繁荣的工商业城市，大多数集中在边境地区，从事对外贸易。<br>13-15世纪，德国有3个主要城市同盟：<ul>
<li>南部的多瑙河流域的士瓦本同盟；</li>
<li>西北部的莱茵河流域的莱茵同盟；</li>
<li>北方波罗的海地区的汉萨同盟。</li>
</ul>
</li>
<li>城市同盟形成的原因<ul>
<li>德国政治上的分裂影响了工商业的发展，德国城市没有形成全国的经济中心；</li>
<li>商人经常受到封建诸侯和骑士的抢劫和勒索；为了保护商路安全，对付外地商人的竞争，掌握垄断贸易的特权，有共同利益的城市建立城市同盟</li>
<li>德国南部城市靠近欧洲贸易的商路，与意大利和东方各国贸易联系密切；德国北部莱茵河流域和波罗的海沿岸的城市，与英、法、北欧和东欧有频繁的贸易往来。</li>
</ul>
</li>
</ul>
<h4 id="汉萨同盟的形成与发展"><a href="#汉萨同盟的形成与发展" class="headerlink" title="汉萨同盟的形成与发展"></a>汉萨同盟的形成与发展</h4><ul>
<li>汉萨同盟兴起于13世纪后半期，14世纪达到鼎盛，15世纪后逐渐衰亡。</li>
<li>该同盟的盟主是吕贝克，全盛时期入盟的城市达80多个，遍及西欧(伦敦)、东欧(诺夫哥罗德)和北欧(卑尔根).<br>1367-1370年，同丹麦进行了战争，占领丹麦南部地区。</li>
<li>新航路开辟，商路和贸易中心的转移（大西洋），汉萨同盟逐渐瓦解。</li>
</ul>
]]></content>
      <categories>
        <category>历史</category>
      </categories>
      <tags>
        <tag>history</tag>
      </tags>
  </entry>
  <entry>
    <title>欧洲中世纪史 西欧封建主义的渊源</title>
    <url>/post/c6cc2ad1/</url>
    <content><![CDATA[<h1 id="一-罗马帝国的遗产"><a href="#一、罗马帝国的遗产" class="headerlink" title="一、罗马帝国的遗产"></a>一、罗马帝国的遗产</h1><h2 id="1-使徒时代的基督教"><a href="#1-使徒时代的基督教" class="headerlink" title="1. 使徒时代的基督教"></a>1. 使徒时代的基督教</h2><ul>
<li><p><strong>施洗约翰</strong>：</p>
<p>公元28或29年，先知约翰宣称上帝的天国将临了，上帝公正的意志将获得无上的地位；没有罪人的立足之地，罪人将受到审判；要求人们忏悔他们的罪，取得上帝的宽恕。用约旦河的水洗去罪过。</p>
</li>
<li><p><strong>基督教的核心（耶稣基督）</strong>：</p>
<p>显示神迹；轻视犹太教的教规；耶稣的教训重要虔敬、道德和仁爱。承认上帝为王，服从他的法律是人的义务，实现他的意志，就能使上帝的统治变成现实。犹太教着眼于一个特定民族，基督教将教义扩大到全人类。</p>
</li>
<li><p><strong>保罗</strong>：</p>
<p>只有一位上帝，他是天父，宇宙万物本于他，也只有一位主，即耶稣。为了从束缚人类的死和罪中拯救人，上帝之子基督降生人间，死在十字架上，完成了救赎的任务；保罗认为律法只是训蒙的原则是一时的宗规。基督来了以后，恩典时期就开始了，律法属于过去的事物，太由于内在的局限性自然消失。</p>
</li>
</ul>
<p>基督教的早期组织和礼仪</p>
<ul>
<li><p>基督教早期组织的中心在<strong>耶路撒冷</strong>和<strong>安条克</strong></p>
<p>地方教会称为聚会所，会务由资历较深的人管理（默认、选举，指派）；主教、长老和执事。教会工作：讲道、传教、慈善，主持礼仪——圣餐、洗礼等等。</p>
</li>
<li><p>罗马基督教徒的礼拜仪式：</p>
<blockquote>
<p>礼拜日的集会是诵读一段使徒的回忆录（福音书），或先知的著作，接着主持人开始讲道，告诫他的听众，要照他们刚才听到的这些好的教导生活；然后全体会众起立，共同祷告；这部分仪式结束后，便举行圣餐礼：饼和渗水的酒送到主教那里；由以圣子好圣灵的名义，对万有的父奉献赞美，最后感谢上帝赐给我们这些恩惠，接着大家齐声应和：阿门！执事们即把切成小块的饼和酒，分给出席的人，也带给缺席的信徒。</p>
</blockquote>
</li>
</ul>
<h2 id="2-神学与教义"><a href="#2-神学与教义" class="headerlink" title="2. 神学与教义"></a>2. 神学与教义</h2><ul>
<li><p>早期护教者<br>上帝是永恒的，他的神性永远不变，他所处的这种至尊地位使他不可能与变幻无常的事物和人的世界发生直接联系，逻各斯成为上帝好尘世的桥梁，逻各斯是上帝的儿子，他本着上帝的意志所生；逻各斯以人的形象在人们面前显现，通过先知向人民宣示真理；逻各斯的活动不限于一个民族。</p>
</li>
<li><p>阿里乌斯教派：<br>阿里乌斯是早期基督教学者（256-336）认为基督乃受造之物， 与上帝并非同质，但也不全是人，是神与人之间的第三者。尼西亚宗教会议上被定为异端。</p>
<p>尼西亚宗教会议：</p>
<blockquote>
<p>我们信独一的上帝，全能的父，创造有形无形万物的主。我们信独一主耶稣基督，上帝的儿子，为父所生，是独身的，即由父的本质所生的。从神出来的神，从光出来的光，从真神出来的真神，受生而非被造，与父同质，天上、地上的万物都是藉着他而受造的。他拯救我们世人而降临，成了肉身的人，受难，第三日复活，升天。将来必再降临，审判活人死人。<br>确立了<strong>三位一体的教义</strong>，保存了上帝神性本质的统一性，使圣父、圣子、圣灵有所区别，圣灵被提高到平等的位置；道成肉身。</p>
</blockquote>
</li>
</ul>
<h2 id="3-拉丁神学-修隐生活"><a href="#3-拉丁神学-修隐生活" class="headerlink" title="3. 拉丁神学 修隐生活"></a>3. 拉丁神学 修隐生活</h2><h4 id="31-拉丁神学"><a href="#3-1-拉丁神学" class="headerlink" title="3.1 拉丁神学"></a>3.1 拉丁神学</h4><p>西方的基督教会起先是讲希腊语的教会，直到第二世纪末，在罗马和各省，教会的著述都使用希腊文。2末3世纪的前几十年，非洲教会出现一位著作家德尔图良开始了基督教的拉丁化。基督教早期神学家迦太基（155-222）曾任教会长老，他拥护公教传统，主张严格遵守教义。主要著作有《辩惑篇》，《论异端无权成立》等。三世纪末西方教会成为拉丁教会。</p>
<p><strong>奥古斯都（354-430）</strong></p>
<ul>
<li><strong>三位一体</strong>：上帝是第一性的存在，独一的无始无终的实体。圣父、圣子、圣灵是一体的，不可分割；“智慧，思想（语言）和欲望或爱”。</li>
<li><strong>原罪</strong>：亚当的罪不仅将上帝宣判的死带给了后代，而且将罪本身传给了他们。</li>
<li><strong>恩典</strong>：人没有择善的能力，“上帝通过耶稣赐给我们恩典，他用他本身的正义，而不是我们的正义使我们成为义人。”</li>
<li><strong>预定论</strong>：上帝的救恩并不施加给一切的人，只给予上帝所拣选的人，这种拣选不以他身上的任何东西为条件。</li>
</ul>
<h4 id="32-早期的修道制度"><a href="#3-2-早期的修道制度" class="headerlink" title="3.2 早期的修道制度"></a>3.2 早期的修道制度</h4><ul>
<li><p><strong>禁欲主义的倾向</strong>：<br>基督教的虔诚一开始带有禁欲主义的倾向，凡是想在基督教徒生活中得到更高成就的人，都多少按照通行的方式折磨自己的肉体。节欲无论对未婚还是已婚者来说都被提到德行的高度。</p>
</li>
<li><p><strong>埃及新型的禁欲主义</strong>：<br>在第三第四世纪，埃及形成了抑种新型的禁欲主义，很快传播道整个基督教世界。以安东尼为代表。同一时期，帕科米乌（292-346）创造了集体生活的修道模式。礼拜、劳动、饮食、斋戒，穿戴好举止都有详细规定。最终进入一那达到灵性之美的灵魂，洗净了一切情欲，同圣灵神交默契之种特别的境界：</p>
<blockquote>
<p>当后，它便也成了灵，与圣灵亲密结合在一起。由此它乃成为全光明、全洞见、全灵性；全喜乐、宏福和欢愉，全仁爱好怜悯，全善意好友好的了。 </p>
</blockquote>
</li>
</ul>
<p>本尼狄克修会</p>
<ul>
<li>世纪西欧修道院制度的奠基人、天主教本尼狄克派(又作本笃派)的创始人。</li>
<li>出身于意大利斯波莱托的一个贵族家庭。少年时代曾在罗马学习文学。18岁时，因不满罗马贵族腐朽的生活方式，离家出走，在罗马城附近的芬比亚高山隐修。3年后，任意大利维谷瓦洛修道院院长。</li>
<li>公元529年，兴建了著名的蒙特长西诺修道院。为了对修道院进行有效的管理，本尼狄克制定了一套规章制度，后世通常称之为《本尼狄克规程》或《本笃规程》。本尼狄克死后，被天主教会追封为“圣徒”，因此，在西方史学著作中，通常被称为<strong>圣本尼狄克（St.Benedict）</strong><blockquote>
<p>St Benedict’s Rule</p>
<ol>
<li>Concerning the Kinds of Monks and Their Manner of Living.</li>
<li>About Calling in the Brethren to Take Council</li>
<li>Concerning Obedience</li>
<li>Concerning Silence</li>
<li>Concerning Humility</li>
<li>Concerning the Divine Offices at Night</li>
<li>How Many Psalms Are to Be Said at Night. </li>
<li>In What Order the Pslams are To Be Sung </li>
<li>Concerning Reverence for Prayer </li>
<li>How the Monks Shall Sleep.</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="二-日耳曼人的影响"><a href="#二、日耳曼人的影响" class="headerlink" title="二、日耳曼人的影响"></a>二、日耳曼人的影响</h1><p><strong>日耳曼人名称的来源</strong>：公元前80年希腊史学家希波多尼最早使用“日耳曼人”一词；公元51年恺撒在《高卢战记》中将莱茵河以东的民族统称为日耳曼人。</p>
<p>塔西佗《日耳曼尼亚志》中详细描绘了日耳曼民族部落的居住地（从莱茵河到维斯瓦河，从多瑙河到北海和波罗的海之间）。这些民族分别为：斯堪的纳维亚人，汪达尔人，法兰克人、勃艮第人、盎格鲁撒克逊人，伦巴第人，荷兰人等</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0e/Imperium_Romanum_Germania.png" alt></p>
<h2 id="1部落等级制"><a href="#1-部落等级制" class="headerlink" title="1.部落等级制"></a>1.部落等级制</h2><ul>
<li><strong>部落等级制的出现</strong>：日耳曼人定居中欧以后，保持着氏族组织。男人打仗、狩猎、赌博；女人老人从事平凡的劳动；一夫一妻制盛行；随着生产和生活方式的演进，部落酋长、军事首领和侍从队长的地位和作用显著提高。他们开始脱离生产，占有优良土地，获取更多的财富。于是，高踞于部落成员之上的特权人物、贫富分配等不平等现象便逐渐产生。一些受到贫困或病魔困扰的人由于债务失去财产和自由，成为为有产阶级的附庸。</li>
<li><strong>军事首领</strong>：战时推选出的首领，战事结束则权力结束，某些首领成为王。军事首领与下属战士结成扈从关系，前者保护士兵有保护战士的责任，后者以绝对的服从和忠诚作为回报；</li>
<li><strong>长老会议</strong>：贵族年长者组成，处理部落内部的纠纷，土地的分配等事务；</li>
<li><strong>公民大会</strong>：所有成年男子组成，决定战争和和平或者部落的迁徙。</li>
<li><strong>法律</strong>是习惯的产物，各部落有法庭，任务是在原告和被告之间起调解作用，诉讼程序是起誓和神裁法。赔偿金制度和血亲复仇往往是解决内部冲突的有效手段。</li>
</ul>
<h3 id="2-日耳曼因素对封建主义的影响"><a href="#2-日耳曼因素对封建主义的影响" class="headerlink" title="2. 日耳曼因素对封建主义的影响"></a>2. 日耳曼因素对封建主义的影响</h3><ul>
<li>法律是习俗的产物，不是君主个人的意志表现；</li>
<li>统治者与臣民的契约关系（保护和服从的权利和义务关系）；</li>
<li>封主和封臣之间荣誉关系；</li>
<li>神裁法成为封建法庭普遍采用的审判法；</li>
<li>推选国王的传统。</li>
</ul>
<h3 id="3-日耳曼人的建国"><a href="#3-日耳曼人的建国" class="headerlink" title="3. 日耳曼人的建国"></a>3. 日耳曼人的建国</h3><h4 id="西哥特人"><a href="#西哥特人" class="headerlink" title="西哥特人"></a>西哥特人</h4><p>5世纪初，西哥特人在领袖阿拉里克率领下出现在意大利北方，并于410年在数万起义奴隶配合下攻陷首都罗马，大劫三日。</p>
<p>419年，西哥特人进入高卢南部和西班牙，建立以土鲁斯为中心的<strong>西哥特王国</strong>。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Iberia_700-zh.svg/1920px-Iberia_700-zh.svg.png" alt="公元700年的西哥特王国" style="zoom:50%;"></p>
<h4 id="旺达曼人"><a href="#旺达曼人" class="headerlink" title="旺达曼人"></a>旺达曼人</h4><p>原住在奥得河流域的日耳曼人部落汪达尔人，公元五世纪初，西迁进入西班牙。后受西哥特人进攻，被驱逐到伊比利亚半岛南部。</p>
<p>429年渡海进入北非，占领沿海富庶地区。</p>
<p>439年攻陷迦太基城，建立<strong>汪达尔王国</strong>。</p>
<p>后继续征服西西里岛西部、撒丁岛、科西嘉岛和巴利阿里群岛等西地中海岛屿。455年曾渡海攻陷罗马。</p>
<p>534年被东罗马帝国所灭<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Vandalic_War_campaign_map-zh.svg/1920px-Vandalic_War_campaign_map-zh.svg.png" style="zoom:50%;"></p>
<h4 id="勃艮第人"><a href="#勃艮第人" class="headerlink" title="勃艮第人"></a>勃艮第人</h4><p>5 世纪初勃艮第人在西罗马帝国境内高卢东南部建立的日耳曼国家。勃艮第人原住波罗的海南岸波恩荷尔姆岛，后移至维斯杜拉河下游。5 世纪初进抵莱茵河。约 457 年占据罗讷河和索恩河流域，以里昂为首都，建立<strong>勃艮第王国</strong>。  </p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Map_Burgundian_Kingdom_EN.png/1280px-Map_Burgundian_Kingdom_EN.png" alt="img" style="zoom:50%;"></p>
<h4 id="盎格鲁-撒克森和裘特人"><a href="#盎格鲁、撒克森和裘特人" class="headerlink" title="盎格鲁、撒克森和裘特人"></a>盎格鲁、撒克森和裘特人</h4><p>5世纪中叶住在日德兰半岛和今德国北方的盎格鲁、撒克森和裘特人渡海进入不列颠，建立许多小王国。<br>7世纪形成了7个王国：埃塞克斯、威塞克斯、苏塞克斯、东盎格利亚、诺森布利亚和朱特。<br>829年，威塞克斯王爱格伯特统一诸王国，始称英格兰。</p>
<h4 id="东哥特人"><a href="#东哥特人" class="headerlink" title="东哥特人"></a>东哥特人</h4><p>东哥特人原住在黑海草原西部地区，4世纪后半期形成部落联盟。375 年东哥特部落联盟被匈奴人击溃后 ，随匈奴人向西推进，居住在潘诺尼亚。453 年匈奴王阿提拉死后 ，东哥特人乘机摆脱匈奴人的统治。<br>488 年东哥特王狄奥多里克（493～526在位）出兵意大利，围困拉文纳，久攻不克；遂和当时意大利半岛的统治者奥多亚克订约，共同治理意大利。<br>493 年狄奥多里克在宴请奥多亚克时背信地杀死了他，收编其余部，建立了东哥特王国，以拉文纳为首都。领土包括意大利半岛、西西里岛、达尔马提亚和布罗温斯。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/83/Empire_of_Theodoric_the_Great_523.gif" alt="img" style="zoom:50%;"></p>
<p>554年为东罗马帝国皇帝查士丁尼所灭。</p>
<h4 id="法兰克人"><a href="#法兰克人" class="headerlink" title="法兰克人"></a>法兰克人</h4><p>486年，法兰克王克洛维率军大败罗马军队于苏瓦松，占领高卢大部分地区，建立了法兰克王国。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/Chlodwigs_taufe.jpg/200px-Chlodwigs_taufe.jpg" alt="圣雷米吉乌斯为克洛维一世施洗"></p>
<h4 id="伦巴第人"><a href="#伦巴第人" class="headerlink" title="伦巴第人"></a>伦巴第人</h4><p>568年伦巴德人攻入意大利北部建立伦巴德王国，是民族大迁徙的最后一幕。<br>伦巴德人原住易北河口，后迁潘诺尼亚。他们占领波河流域，建立以拉温那为中心的伦巴德王国。<br>774年被法兰克灭亡。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6c/Alboin%27s_Italy-zh.svg/1024px-Alboin%27s_Italy-zh.svg.png" alt="Alboin&#39;s Italy-zh.svg"></p>
<h1 id="三-西欧封建主义的特点"><a href="#三、西欧封建主义的特点" class="headerlink" title="三、西欧封建主义的特点"></a>三、西欧封建主义的特点</h1><ul>
<li>封建主义的定义：<ul>
<li>封建主义是一种社会结构。</li>
<li>作为一种政治制度，统治权属于任何一个采邑拥有者的财产权；</li>
<li>政府建立在契约的基础上；</li>
<li>有所限制的君权（封建政府被认为是法律的政府，不是人的政府。统治者没有权力制定法律，法律是习俗和上帝意志的产物）。</li>
</ul>
</li>
<li>采邑及封君封臣的关系：<ul>
<li>采邑多指世袭封地，但是并不专指土地，还包括职务，征税权，铸币权以及市场特权等。采邑是封君和封臣之间的纽带。</li>
<li>赏赐采邑的人被称为封君，接受和占有采邑的人被称为封臣。国王是最高的领主，直接隶属国王的是大贵族，他们分别叫做公爵、伯爵、侯爵和边境侯爵。大贵族将采邑赏赐给小贵族如子爵、男爵。</li>
</ul>
</li>
<li>封建的权利和义务<ul>
<li>封君的权利：接受封臣的宣誓效忠；有权成为未成年封臣的法律保护人；有权收回封臣死后无人继承的采邑（归公权）；有权没收违背契约封臣的采邑（没收权）；</li>
<li>封臣的义务：每年服一定期限的兵役；应招参加领主法庭；领主被俘必须缴纳赎金，继承或出售采邑，必须缴纳重税。</li>
<li>封君的义务：赏赐采邑给封臣（包括土地、职务、收税权等）；为封臣提供各种保护（经济，人身安全等）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>历史</category>
      </categories>
      <tags>
        <tag>history</tag>
      </tags>
  </entry>
  <entry>
    <title>法理学笔记</title>
    <url>/post/1f25e26b/</url>
    <content><![CDATA[<p>警惕动物的理想</p>
<p>区分主人和奴仆：享受闲暇</p>
<p>逻辑思维能力、想象力、关联能力、问题比知识更重要</p>
<p>明确的职业规划，主动阅读、主动建构知识体系，</p>
<p>知识是附着在能力上的，要知道创造知识的人是怎么想问题的（像科学家一样想问题）</p>
<p>读透书——对思维能力的训练</p>
<p>从知识的传承转向知识的创造</p>
<p>从当下的问题想到以后的生活</p>
<p>认识自己，做最好的自己</p>
<h1 id="第01讲-何为法律"><a href="#第01讲-何为法律" class="headerlink" title="第01讲 何为法律"></a>第01讲 何为法律</h1><p>通过学习法理培养一种理论思考能力，并不仅仅是逻辑思考能力。</p>
<p>认真学习 + 反思学习</p>
<p>对自己的职业和学术有一种最高的关切，但在思考国家问题时并非将自己的职业放在第一位，而是从职业视角出发思考和促进社会的发展。</p>
<ol>
<li>制定法</li>
</ol>
<p>2.习惯<br>3.法理与情理<br>4.自然法<br>5.权限内的裁量<br>6.定义之争</p>
<h1 id="第02讲-法律的功能及特点"><a href="#第02讲-法律的功能及特点" class="headerlink" title="第02讲 法律的功能及特点"></a>第02讲 法律的功能及特点</h1><p>既得利益者</p>
<p>从人性的角度观察社会，法律与人性</p>
<p>法律本身是保守的，</p>
<p>1.功能及功能主义<br>2.法律的功能<br>3.法律的特点<br>4.后果主义 </p>
<h1 id="第03讲-法理学问题法律起源-复仇"><a href="#第03讲-法理学问题-法律起源、复仇" class="headerlink" title="第03讲 法理学问题(法律起源、复仇)"></a>第03讲 法理学问题(法律起源、复仇)</h1><p>1.三种规则遵守方式<br>2.复仇<br>3.复仇的弱点<br>4.复仇弱点之校正<br>5.制度化的复仇<br>6.法律的发生</p>
<h1 id="第04讲-法律的起源法律的运转"><a href="#第04讲-法律的起源（法律的运转）" class="headerlink" title="第04讲 法律的起源（法律的运转）"></a>第04讲 法律的起源（法律的运转）</h1><p>一、前提条件<br>1.劳动分工<br>2.剩余劳动<br>3.国家统一<br>二、新问题<br>1.代理问题：懈怠、偏私、腐败<br>2.信息问题<br>3.意识形态问题</p>
<h1 id="第05讲-法系问题"><a href="#第05讲-法系问题" class="headerlink" title="第05讲 法系问题"></a>第05讲 法系问题</h1><p>1.法系作为法理学问题<br>2.英美法系与大陆法系特点<br>3.大陆法系的制度优点<br>4.英美法系的制度优点<br>5.中国在法系上的制度选择</p>
<h1 id="第06讲-自由主义个体主义"><a href="#第06讲-自由主义（个体主义）" class="headerlink" title="第06讲 自由主义（个体主义）"></a>第06讲 自由主义（个体主义）</h1><p>1.基本观点<br>2.自由主义的多种形态<br>3.法治<br>4.自由：消极与积极<br>5.自由的限度</p>
<h1 id="第07讲-自由主义个人主义续"><a href="#第07讲-自由主义-个人主义（续）" class="headerlink" title="第07讲 自由主义/个人主义（续）"></a>第07讲 自由主义/个人主义（续）</h1><p>6.自由与责任<br>7.个人主义<br>8.自由主义的发生<br>9.自由主义对法律的贡献<br>10.自由主义的理论与实践难题</p>
<h1 id="第08讲-社群主义法理学"><a href="#第08讲-社群主义法理学" class="headerlink" title="第08讲 社群主义法理学"></a>第08讲 社群主义法理学</h1><p>1.针对的问题（背景）<br>2.什么是社群<br>3.主要观点与主张<br>4.社群主义的理论困境<br>5.社群主义的实践难题<br>6.中国的社群主义问题</p>
<h1 id="第0910讲-利维坦法理学"><a href="#第09-10讲-利维坦法理学" class="headerlink" title="第09/10讲 利维坦法理学"></a>第09/10讲 利维坦法理学</h1><p>1.问题<br>2.被遗忘的利维坦<br>3.现代民族国家的利维坦问题<br>4.利维坦之后（人治到法治）<br>魅力型政治（人治）<br>传统型政治（法治）<br>法理学政治（法治）<br>5.经验总结（利维坦法理学） </p>
<h1 id="第11讲-职业主义法理学"><a href="#第11讲-职业主义法理学" class="headerlink" title="第11讲 职业主义法理学"></a>第11讲 职业主义法理学</h1><p>1.职业<br>2.职业主义及其发生<br>3.核心主张<br>法律的治理<br>司法独立<br>法律形式主义<br>法律论证及推理<br>4.贡献<br>解决常规问题<br>规训民众<br>淡化意识形态争论<br>累积专业知识<br>创造一批法律人<br>社会稳定保守<br>5.问题</p>
<h1 id="第12讲-法律与经济以传统农业社会为例"><a href="#第12讲-法律与经济（以传统农业社会为例）" class="headerlink" title="第12讲 法律与经济（以传统农业社会为例）"></a>第12讲 法律与经济（以传统农业社会为例）</h1><p>1.概述<br>2.传统农业社会的经济与社会组织<br>3.制度需求<br>4.法律制度供给<br>5.儒家思想（意识形态）作为制度<br>6.弱点</p>
<p>P25,P26 第十三讲 现代化与法治<br>一、现代化<br>\1. 经济发展  2. 人的解放（社会结构变化）<br>二、制度需求<br>\1. 防止各种机会主义  2. 管理各类新问题<br>\3. 立法、执法、司法的变化  4. 职业伦理<br>三、政府的法治<br>\1. 大政府  2. 控制权力<br>\3. 防止腐败  4. 知识与信息<br>四、中国的现代化与法治<br>\1. 传统法治（？） 2. 凝聚共识问题<br>\3. 国际竞争  4. 快变与全变<br>\5. 前提与缺乏</p>
<p>P27,P28 第十四讲 法治与空间<br>一、空间问题<br>二、大国与小国<br>\1. 古希腊罗马  2. 现代欧洲  3. 美国<br>三、中国作为大国<br>\1. 政治  2. 经济  3. 文化<br>四、农村与城市（发展不平衡）</p>
<p>P29,P30 第十五讲 法律与时间<br>一、法律中的时间变量<br>       核心量预期和成本问题<br>二、法律不溯及既往<br>       刑法、民事经济法律<br>三、法治中的时间维度<br>       稳定现状的神圣化<br>四、**、改革与时间<br>五、中国法治中的时间问题<br>\1. 时代问题  2. 理论逻辑与实践逻辑<br>\3. 社会心态调整  4. 空间问题的转移</p>
<p>P31,P32 第十六讲 法律的人性基础</p>
<p>P33,P34 第十七讲 法律与科技<br>一、法律为什么关心科技<br>二、科学对法律影响<br>三、法律限制科学因果关系<br>四、技术对法律影响<br>五、法律的因果关系</p>
<p>P35,P36 第十八讲 法律，国家，政治<br>一、什么是政治<br>\1. 政治  2. 国家  3. 政党政治<br>二、<strong>时期的法律与政治<br>\1. </strong>  2. 建国  3. 转型<br>三、常规时期的法律与政治<br>\1. 宪政  2. 经济建设<br>    \3. 管理公共事物  4. 民生与福利<br>P37,P38 第十九讲 司法的边界<br>一、校正正义与司法<br>       分配正义（立法）校正正义（司法）<br>       司法的特点<br>二、司法的社会制约<br>\1. 政府的资源  2. 信息获得的难易<br>\3. 交通与人员流动<br>三、制度供给与纠纷者的博奕。<br>       纠纷者、政府、解决纠纷者<br>       外在性问题、收费问题<br>四、原则<br>\1. 重大  2. 有利于非正式制度<br>\3. 正式与非正式制度的一致性</p>
<p>P39,P40 第二十讲 司法独立问题<br>一、两种司法独立<br>       宪政的、司法的<br>二、司法为什么独立<br>\1. 孟德斯鸠  2. 联邦党人  3. 比较制度能力<br>三、司法独立专业化、民主<br>\1. 专业化  2. 司法民主化？<br>四、司法的自我约束和限度</p>
<p>P41,P42 第二十一讲 法律解释与判断<br>一、为什么及何为法律解释<br>二、文义解释<br>       字面解释，特殊文义解释<br>三、法意解释<br>       原意解释、目的解释<br>四、体系解释<br>       语境解释<br>五、解释规则问题<br>六、重要的是判断<br>       关于后果<br>P43 第二十二讲 法治意识形态<br>一、中国传统法治意识形态<br>       先秦、秦、汉<br>二、当代法治意识形态构建<br>\1. 法治乌托邦  2.法律万能<br>\3. 司法是正义最后一道防线<br>\4. 实现正义哪管天塌下来<br>\5. 法律必须信仰<br>三、功过及对我们的期待</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《法理学》张文显，高等教育出版社，2003<br>《法理学》周旺生，人民法院出版社，2002<br>《法理学》〔美〕博登海默，华夏出版社，1999<br>《法理学》〔德〕伯恩·魏德士，法律出版社，2003<br>《法与国家的一般理论》拉扎列夫，法律出版社，1999<br>《黑格尔法哲学批判》马克思<br>《家庭、私有制和国家的起源》、《法学家社会主义》恩格斯<br>《德意志意识形态》、《共产党宣言》马克思恩格斯<br>《国家与革命》列宁<br>《董必武法学文集》董必武，法律出版社，2001<br>《二十世纪西方法哲学思潮研究》张文显，辽宁人民出版社，1996<br>《法学基础理论参考资料》王勇飞，北京大学出版社，1984</p>
]]></content>
      <categories>
        <category>法律</category>
      </categories>
      <tags>
        <tag>law</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构 笔记2</title>
    <url>/post/96a92b4b/</url>
    <content><![CDATA[<h1 id="第1章-操作系统"><a href="#第1章-操作系统" class="headerlink" title="第1章 操作系统"></a>第1章 操作系统</h1><h2 id="操作系统的类型与结构"><a href="#操作系统的类型与结构" class="headerlink" title="操作系统的类型与结构"></a>操作系统的类型与结构</h2><p>根据考试大纲要求，在操作系统方面，要求考生掌握以下知识点：</p>
<p>（1）操作系统的类型和结构；</p>
<p>（2）操作系统基本原理；</p>
<p>（3）网络操作系统及网络管理；</p>
<p>（4）嵌入式操作系统与实时操作系统。</p>
<p>本章主要介绍操作系统方面的基本知识，有关网络管理方面的知识，将在第4章中介绍；有关嵌入式操作系统与实时操作系统方面的知识，将在第3章介绍。操作系统是计算机系统中的核心系统软件，负责管理和控制计算机系统中硬件和软件资源，合理地组织计算机工作流程和有效利用资源，在计算机与用户之间起接口的作用。</p>
<h2 id="操作系统的类型"><a href="#操作系统的类型" class="headerlink" title="操作系统的类型"></a>操作系统的类型</h2><p>根据使用环境和对作业的处理方式，操作系统可分为<strong>批处理操作系统</strong>、<strong>分时操作系统</strong>、<strong>实时操作系统</strong>、<strong>网络操作系统</strong>和<strong>分布式操作系统</strong>。</p>
<p>（1）批处理操作系统把用户提交的作业分类，把一批中的作业编成一个作业执行序列。批处理又可分为联机批处理和脱机批处理。批处理系统的主要特征有：用户脱机使用计算机、成批处理、多道程序运行。批处理操作系统主要用在早起的大型机上，现在基本上已经被淘汰了。</p>
<p>（2）分时操作系统采用分时技术，使多个用户同时以会话方式控制自己程序的运行，每个用户都感到似乎各自有一台独立的、支持自己请求服务的系统。分时技术把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮时再继续运行。分时系统的主要特征有：交互性、多用户同时性、独立性。例如，Unix和Linux就是典型的分时操作系统。</p>
<p>（3）实时操作系统往往是专用的，系统与应用很难分离，常常紧密结合在一起。实时系统并不强调资源利用率，而更关心及时性(时间紧迫性)、可靠性和完整性。实时系统又分为实时过程控制与实时信息处理两种。实时系统的主要特征有：提供即时响应、高可靠性。例如，Windows CE、嵌入式Linux、VxWorks等都属于实时操作系统。</p>
<p>（4）网络操作系统按照网络架构的各个协议标准进行开发，包括网络管理、通信、资源共享、系统安全和多种网络应用服务等。在网络系统中，各计算机的操作系统可以互不相同，它需要一种机制来支持互连的网络环境下的异种计算机系统之间的进程通信，实现协同工作和应用集成。网络操作系统的主要特征有：互操作性、协作处理。例如，Windows Server、Unix等都可以看作是网络操作系统。</p>
<p>（5）分布式操作系统要求一个统一的操作系统，实现系统操作的统一性，负责全系统的资源分配和调度，为用户提供统一的界面。它是一个逻辑上紧密耦合的系统。目前还没有真正实现的分布式操作系统。</p>
<p>不管哪种操作系统，都应该具有五个基本功能，即<strong>处理机管理</strong>、<strong>存储管理</strong>、<strong>设备管理</strong>、<strong>文件管理</strong>和<strong>作业管理</strong>。</p>
<h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><p>操作系统的结构可以分为<strong>无序结构</strong>、<strong>层次结构</strong>、<strong>面向对象结构</strong>、<strong>对称多处理结构</strong>和<strong>微内核结构</strong>。</p>
<p>（1）无序结构，又称整体结构或模块组合结构。它以大型表格和队列为中心，操作系统的各部分程序围绕着表格运行，整个系统是一个程序。这种操作系统常称为面向过程的操作系统。操作系统由许多标准的、可兼容的基本单位构成（称为模块），各模块相对独立，模块之间通过规定的接口相互调用。模块化设计方法的优点是缩短了系统的开发周期，缺点是模块之间调用关系复杂、相互依赖，从而使分析、移植和维护系统较易出错。</p>
<p>（2）层次结构。把一个大型复杂的操作系统分解成若干个单向依赖的层次，由多层的正确性保证操作系统的可靠性。层次结构清晰，大大地简化了接口的设计，且有利于系统功能的增加或删改，易于保证可靠性，也便于维护和移植。</p>
<p>（3）面向对象结构。基于面向对象程序设计的概念，采用了各种不同的对象技术。在计算机系统中对象是操作系统管理的信息和资源的抽象，是一种抽象的数据类型。可以把对象作为系统中的最小单位，由对象、对象操作、对象保护组成的操作系统，就是面向对象的操作系统。如Windows Server中有执行体对象（例如，进程、线程、文件和令牌等）和内核对象（例如，时钟、事件和信号等）。面向对象结构的优点是适用于网络操作系统和分布式操作系统中。</p>
<p>（4）对称多处理结构。如果一个操作系统在系统中的所有处理机运行且共享同一内存（内存储器、主存、实存），这样的系统就是一个对称多处理系统。优点是适合共享存储器结构的多处理机系统，即紧耦合的多处理机系统。</p>
<p>（5）微内核结构。把系统的公共部分抽象出来，形成一个底层核心，提供最基本的服务，其他功能以服务器形式建立在微内核之上。它具有良好的模块化和结构化特征，模块之间和上下层之间通过消息来通信。建立在微内核上的服务器可以根据不同的需要构造，从而形成不同的操作系统。</p>
<p>现代操作系统大多拥有两种工作状态：核心态和用户态。我们使用的一般应用程序工作在用户态，而内核模块和最基本的操作系统核心工作在核心态。</p>
<p>微内核结构由一个非常简单的硬件抽象层和一组比较关键的原语或系统调用组成，这些原语仅仅包括了建立一个系统必需的几个部分，如线程管理，地址空间和进程间通信等。微内核的目标是将系统服务的实现和系统的基本操作规则分离开来。例如，进程的输入/输出锁定服务可以由运行在微内核之外的一个服务组件来提供。这些非常模块化的用户态服务用于完成操作系统中比较高级的操作，这样的设计使内核中最核心的部分的设计更简单。一个服务组件的失效并不会导致整个系统的崩溃，内核需要做的，仅仅是重新启动这个组件，而不必影响其它的部分。</p>
<p>微内核技术的主要优点如下：</p>
<p>（1）统一的接口，在用户态和核心态之间无需进程识别。</p>
<p>（2）可伸缩性好，能适应硬件更新和应用变化。</p>
<p>（3）可移植性好，所有与具体机器特征相关的代码，全部隔离在微内核中，如果操作系统要移植到不同的硬件平台上，只需修改微内核中极少代码即可。</p>
<p>（4）实时性好，微内核可以方便地支持实时处理。</p>
<p>（5）安全可靠性高，微内核将安全性作为系统内部特性来进行设计，对外仅使用少量应用编程接口。</p>
<p>（6）支持分布式系统，支持多处理器的架构和高度并行的应用程序。</p>
<p>（7）真正面向对象的操作系统。</p>
<p>由于操作系统核心常驻内存，而微内核结构精简了操作系统的核心功能，内核规模比较小，一些功能都移到了外存上，所以微内核结构十分适合嵌入式的专用系统，对于通用性较广的系统，将使CPU（Central Processing Unit，中央处理单元）的通信开销增大，从而影响到计算机的运行速度。</p>
<h2 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h2><p>在单用户多任务的操作系统中，或者多用户多任务的操作系统中，系统同时运行多个程序，这些程序的并行运行势必形成对系统资源的竞争使用。因此，操作系统必须能够处理和管理这种并行运行的程序，使之对资源的使用按照良性的顺序进行。</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>进程是一个程序关于某个数据集的一次运行。进程是程序的一次运行活动，是一个动态的概念，而程序是静态的概念，是指令的集合。进程具有动态性和并发性，程序是进程运行所对应的运行代码，一个进程对应于一个程序，一个程序可以同时对应于多个进程。在操作系统中进程是进行系统资源分配、调度和管理的最小单位（注意，现代操作系统中还引入了线程（thread）这一概念，它是处理器分配资源的最小单位）。从静态的观点看，进程由程序、数据和进程控制块（Process Control Block，PCB）组成；从动态的观点看，进程是计算机状态的一个有序集合。</p>
<p>PCB是进程存在的唯一标志，PCB描述了进程的基本情况。其中的内容可分成为调度信息和执行信息两大部分。调度信息供进程调度使用，包括进程当前的一些基本属性；执行信息即现场，规划了进程的执行情况。PCB随着进程的建立而产生，随着进程的完成而撤消。一个进程从创建而产生至撤销而消亡的整个生命周期，可以用一组状态加以刻画，为了便于管理进程，把进程划分为几种状态，分别有三态模型和五态模型。</p>
<h3 id="1三态模型"><a href="#1．三态模型" class="headerlink" title="1．三态模型"></a>1．三态模型</h3><p>按照进程在执行过程中的不同状况，至少可以定义三种不同的进程状态：</p>
<p>（1）运行态：占有处理器正在运行。</p>
<p>（2）就绪态：具备运行条件，等待系统分配处理器以便运行。</p>
<p>（3）等待态（阻塞态）：不具备运行条件，正在等待某个事件的完成。</p>
<p>一个进程在创建后将处于就绪状态。每个进程在执行过程中，任一时刻当且仅当处于上述三种状态之一。同时，在一个进程执行过程中，它的状态将会发生改变。图1-1表示进程的状态转换。</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps6.png" alt="img"> </p>
<p> 运行状态的进程将由于出现等待事件而进入等待状态，当等待事件结束之后等待状态的进程将进入就绪状态，而处理器的调度策略又会引起运行状态和就绪状态之间的切换。引起进程状态转换的具体原因如下：</p>
<p>（1）运行态→等待态：等待使用资源，如等待外设传输；等待人工干预。</p>
<p>（2）等待态→就绪态：资源得到满足，如外设传输结束；人工干预完成。</p>
<p>（3）运行态→就绪态：运行时间片到；出现有更高优先权进程。</p>
<p>（4）就绪态→运行态：CPU空闲时选择一个就绪进程。</p>
<h3 id="2五态模型"><a href="#2．五态模型" class="headerlink" title="2．五态模型"></a>2．五态模型</h3><p>在三态模型中，总是假设所有的进程都在内存中。事实上，可能出现这样一些情况，例如由于进程的不断创建，系统的资源已经不能满足进程运行的要求，这个时候就必须把某些进程挂起，对换到磁盘镜像区中，暂时不参与进程调度，起到平滑系统操作负荷的目的。引起进程挂起的原因是多样的，主要有：</p>
<p>（1）系统中的进程均处于等待状态，处理器空闲，此时需要把一些阻塞进程对换出去，以腾出足够的内存装入就绪进程运行。</p>
<p>（2）进程竞争资源，导致系统资源不足，负荷过重，此时需要挂起部分进程以调整系统负荷，保证系统的实时性或让系统正常运行。</p>
<p>（3）把一些定期执行的进程（如审计程序、监控程序、记账程序）对换出去，以减轻系统负荷。</p>
<p>（4）用户要求挂起自己的进程，以便根据中间执行情况和中间结果进行某些调试、检查和改正。</p>
<p>（5）父进程要求挂起自己的后代子进程，以进行某些检查和改正。</p>
<p>（6）操作系统需要挂起某些进程，检查运行中资源使用情况，以改善系统性能；或当系统出现故障或某些功能受到破坏时，需要挂起某些进程以排除故障。</p>
<p> 给出了具有挂起进程功能的系统中的进程状态。在此类系统中，进程增加了两个新状态：<strong>静止就绪态</strong>和<strong>静止阻塞态</strong>。为了区别，而把三态模型中的等待态改名为活跃阻塞态，就绪态改名为活跃就绪态。静止就绪态表明进程具备运行条件但目前在二级存储器（外存储器、外存、辅存）中，只有当它被对换到内存才能被调度执行。静止阻塞态则表明进程正在等待某一个事件且在二级存储器中。</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps7.png" alt="img"> </p>
<p> 具有挂起功能系统的进程状态及其转换引起进程状态转换的具体原因如下：</p>
<p> （1）活跃阻塞态→静止阻塞态：如果当前不存在活跃就绪进程，那么至少有一个等待态进程将被对换出去成为静止阻塞态；操作系统根据当前资源状况和性能要求，可以决定把活跃阻塞态进程对换出去成为静止阻塞态。</p>
<p>（2）静止阻塞态→静止就绪态：引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态。</p>
<p>（3）静止就绪态→活跃就绪态：当内存中没有活跃就绪态进程，或者静止就绪态进程具有比活跃就绪态进程更高的优先级，系统将把静止就绪态进程转换成活跃就绪态。</p>
<p>（4）活跃就绪态→静止就绪态：操作系统根据当前资源状况和性能要求，也可以决定把活跃就绪态进程对换出去成为静止就绪态。</p>
<p>（5）静止阻塞态→活跃阻塞态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是，当一个进程退出后，内存已经有了一大块自由空间，而某个静止阻塞态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。</p>
<p>不难看出：一个挂起进程等同于不在内存的进程，因此挂起的进程将不参与进程调度直到它们被对换进内存。一个挂起进程具有如下特征：</p>
<p>（1）该进程不能立即被执行。</p>
<p>（2）挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。</p>
<p>（3）进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。</p>
<p>（4）结束进程挂起状态的命令只能通过操作系统或父进程发出。</p>
<p>（5）阻塞态：进入阻塞态通常是因为在等待I/O完成或等待分配到所需资源。</p>
<h2 id="信号量与pv操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h2><p>对于本知识点的考查，重点在于理解信号量与PV操作的基本概念，能够正确地理解在互斥、同步方面的控制应用，并能够灵活地运用，相对来说是个难点。</p>
<p>在操作系统中，进程之间经常会存在<strong>互斥（都需要共享独占性资源时）</strong>和<strong>同步（完成异步的两个进程的协作）</strong>两种关系。为了有效地处理这两种情况，W·Dijkstra在1965年提出信号量和PV操作。</p>
<p>（1）信号量：是一种特殊的变量，表现形式是一个整型S和一个队列。</p>
<p>（2）P操作：S=S-1，若S&lt;0，进程暂停执行，进入等待队列。</p>
<p>（3）V操作：S=S+1，若S≤0，唤醒等待队列中的一个进程。</p>
<h3 id="1互斥控制"><a href="#1．互斥控制" class="headerlink" title="1．互斥控制"></a>1．互斥控制</h3><p>互斥控制是为了<strong>保护共享资源，不让多个进程同时访问这个共享资源</strong>，换句话说，就<strong>是阻止多个进程同时进入访问这些资源的代码段</strong>，这个代码段称为临界区，而这种一次只允许一个进程访问的资源称为临界资源。为了实现进程互斥地进入自己的临界区，代码可以如下所示：</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps9.png" alt="img"> </p>
<p>由于只允许一个进程进入，因此信号量S的初值应该为1。该值表示可以允许多少个进程进入，当S&lt;0时，其绝对值就是等待使用临界资源的进程数，也就是等待队列中的进程数。而当一个进程从临界区出来时，执行V操作（S=S+1），如果等待队列中还有进程（S≤0），则调入一个新的进程进入（唤醒）。</p>
<h3 id="2同步控制"><a href="#2．同步控制" class="headerlink" title="2．同步控制"></a>2．同步控制</h3><p>最简单的同步形式是<strong>进程A在另一个进程B到达L2以前，不应前进到超过点L1</strong>，这样就可以使用如下程序：</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps10.png" alt="img"> </p>
<p>因此，要确保进程B执行V操作之前，不让进程A的运行超过L1，就要设置信号量S的初值为0。这样，如果进程A先执行到L1，那么执行P操作（S=S-1）后，则S&lt;0，就停止执行。直到进程B执行到L2时，将执行V操作（S=S+1），唤醒A以继续执行。</p>
<h3 id="3生产者-消费者问题"><a href="#3．生产者-消费者问题" class="headerlink" title="3．生产者-消费者问题"></a>3．生产者-消费者问题</h3><p>生产者-消费者是一个经典的问题，它不仅要解决生产者进程与消费者进程的同步关系，还要处理缓冲区的互斥关系，因此通常需要三个信号量来实现，如表1-1所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号量</th>
<th>功能类别</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty</td>
<td>同步</td>
<td>说明<strong>空闲的缓冲区数量</strong>，因为程序开始时，缓冲区全部为空。所以，其初始值应为<strong>缓冲区的总个数</strong>。</td>
</tr>
<tr>
<td>full</td>
<td>同步</td>
<td>说明<strong>已填充的缓冲区数量</strong>，因为程序开始时，所有缓冲区都为空（未填充）。所以，其<strong>初始值为0</strong>。</td>
</tr>
<tr>
<td>mutex</td>
<td>互斥</td>
<td>保证同时只有一个进程在写缓冲区，因此其初始值为1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps11.png" alt="img"> </p>
<p>如果对缓冲区的读写无须进行互斥控制的话，那么就可以省去mutex信号量。</p>
<h3 id="4理解p-v操作"><a href="#4．理解P、V操作" class="headerlink" title="4．理解P、V操作"></a>4．理解P、V操作</h3><p>信号量与PV操作的概念比较抽象，在历年的考试中总是难倒许多考生，其实主要还是没有能够正确地理解信号量的含义。</p>
<p>（1）信号量与P、V操作是用来<strong>解决并发问题</strong>的，而在并发问题中最重要的是互斥与同步两个关系，也就是说只要有这两个关系存在，信号量就有用武之地。因此，在解题时，应该先从寻找互斥与同步关系开始。这个过程可以套用简单互斥、简单同步、生产者-消费者问题。</p>
<p>（2）通常来说，一个互斥或一个同步关系可以使用一个信号量来解决，但要注意经常会忽略一些隐藏的同步关系。例如：在生产者-消费者问题中，就有<strong>两个同步关系</strong>，<strong>一个是判断是否还有足够的空间给生产者存放产物</strong>，<strong>另一个是判断是否有足够的内容让消费者使用</strong>。</p>
<p>（3）信号量的初值通常就是表示资源的可用数。而且通常对于初始为0的信号量，会先做V操作。</p>
<p>（4）在资源使用之前，将会使用P操作；在资源用完之后，将会使用V操作。在互斥关系中，P、V操作是在一个进程中成对出现的；而在同步关系中，则P、V操作一定是在两个进程甚至是多个进程中成对出现的。</p>
<h3 id="5实际应用"><a href="#5．实际应用" class="headerlink" title="5．实际应用"></a>5．实际应用</h3><p>……</p>
<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>死锁是指<strong>多个进程之间互相等待对方的资源，而在得到对方资源之前又不释放自己的资源，这样，造成循环等待的一种现象</strong>。如果一个进程在等待一个不可能发生的事件，则进程就死锁了。如果一个或多个进程产生死锁，就会造成系统死锁。</p>
<h3 id="1死锁发生的必要条件"><a href="#1．死锁发生的必要条件" class="headerlink" title="1．死锁发生的必要条件"></a>1．死锁发生的必要条件</h3><p> 产生死锁的根本原因在于系统提供的资源个数少于并发进程所要求的该类资源数。产生死锁有四个必要条件：<strong>互斥条件</strong>，<strong>不可抢占条件</strong>，<strong>保持与等待条件（部分分配条件）</strong>、<strong>循环等待条件</strong>。</p>
<p>（1）互斥条件：即一个资源每次只能被一个进程使用。</p>
<p>（2）保持与等待条件：有一个进程已获得了一些资源，但因请求其他资源被阻塞时，对已获得的资源保持不放。</p>
<p>（3）不可抢占条件：有些系统资源是不可抢占的，当某个进程已获得这种资源后，系统不能强行收回，只能由进程使用完时自己释放。</p>
<p>（4）循环等待条件：若干个进程形成环形链，每个都占用对方要申请的下一个资源。</p>
<h3 id="2银行家算法"><a href="#2．银行家算法" class="headerlink" title="2．银行家算法"></a>2．银行家算法</h3><p>所谓银行家算法，是指在分配资源之前先看清楚，资源分配后是否会导致系统死锁。如果会死锁，则不分配，否则就分配。</p>
<p>按照银行家算法的思想，当进程请求资源时，系统将按如下原则分配资源：</p>
<p> （1）当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程。</p>
<p>（2）进程可以分期请求资源，但请求的总数不能超过最大需求量。</p>
<p>（3）当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源。</p>
<p>（4）当系统现有的资源能满足进程尚需资源数时，必须测试系统现存的资源能否满足该进程尚需的最大资源数，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h3 id="3解决死锁的策略"><a href="#3．解决死锁的策略" class="headerlink" title="3．解决死锁的策略"></a>3．解决死锁的策略</h3><p> 对待死锁的策略主要有：</p>
<p>（1）<strong>死锁预防</strong>：破坏导致死锁必要条件中的任意一个就可以预防死锁。例如，要求用户申请资源时一次性申请所需要的全部资源，这就破坏了保持和等待条件；将资源分层，得到上一层资源后，才能够申请下一层资源，它破坏了环路等待条件。预防通常会降低系统的效率。</p>
<p>（2）<strong>死锁避免</strong>：避免是指进程在每次申请资源时判断这些操作是否安全，例如，使用银行家算法。死锁避免算法的执行会增加系统的开销。</p>
<p>（3）<strong>死锁检测</strong>：死锁预防和避免都是事前措施，而死锁的检测则是判断系统是否处于死锁状态，如果是，则执行死锁解除策略。</p>
<p>（4）<strong>死锁解除</strong>：这是与死锁检测结合使用的，它使用的方式就是剥夺。即将某进程所拥有的资源强行收回，分配给其他的进程。</p>
<h2 id="管程与线程"><a href="#管程与线程" class="headerlink" title="管程与线程"></a>管程与线程</h2><p>管程由<strong>管程名</strong>、<strong>局部子管程的变量说明</strong>、<strong>使用共享资源并在数据集上进行操作的若干过程</strong>，以及<strong>对变量赋初值的语句</strong>等四个基本部分组成。每一个管程管理一个临界资源。当有几个进程调用某管程时，仅允许一个进程进入管程，其他调用者必须等待，也就是申请进程必须互斥地进入管程。方法是通过调用特定的管程入口进入管程，然后通过管程中的一个过程使用临界资源。当某进程通过调用请求访问某临界资源而未能满足时，管程调用相应同步原语使该进程等待，并将它排在等待队列上。当使用临界资源的进程访问完该临界资源并释放之后，管程又调用相应的同步原语唤醒等待队列中的队首进程。为了表示不同的等待原因，设置条件变量，条件变量是与普通变量不同的变量，条件变量不能取任何值，只是一个排队栈。</p>
<p>线程是进程的活动成分，是处理器分配资源的最小单位，它可以共享进程的资源与地址空间，通过线程的活动，进程可以提供多种服务（对服务器进程而言）或实行子任务并行（对用户进程而言）。每个进程创建时只有一个线程，根据需要在运行过程中创建更多的线程（前者也可称“主线程”）。显然，只有主线程的进程才是传统意义下的进程。内核负责线程的调度，线程的优先级可以动态地改变。采用线程机制的最大优点是节省开销，传统的进程创建子进程的办法内存开销大，而且创建时间也长。</p>
<p>在多线程系统中，一个进程可以由一个或多个线程构成，每一线程可以独立运行，一个进程的线程共享这个进程的地址空间。有多种方法可以实现多线程系统，一种方法是核心级线程，另一种方法是用户级线程，也可以把两者组合起来。</p>
<p>多线程实现的并行避免了进程间并行的缺点：创建线程的开销比创建进程要小，同一进程的线程共享进程的地址空间，所以线程切换（处理器调度）比进程切换快。例如，Windows Server内核采用基于优先级的方案选定线程执行的次序。高优先级线程先于低优先级线程执行，内核周期性地改变线程的优先级，以确保所有线程均能执行。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>文件管理是<strong>对外部存储设备上的以文件方式存放的信息的管理</strong>。文件的结构是指文件的组织形式，从用户观点所看到的文件组织形式，称为文件的逻辑结构。文件的物理结构是指文件在存储设备上的存放方法，侧重于提高存储器的利用效率和降低存取时间。文件的存储设备通常划分为大小相同的物理块，物理块是分配和传输信息的基本单位。用户通过对文件的访问（读写）来完成对文件的查找、修改、删除和添加等操作。常用的访问方法有两种，即顺序访问和随机访问。</p>
<h2 id="文件的逻辑组织"><a href="#文件的逻辑组织" class="headerlink" title="文件的逻辑组织"></a>文件的逻辑组织</h2><p>文件的逻辑组织是<strong>为了方便用户的使用</strong>，逻辑结构是用户可见的结构。文件的逻辑结构可以分为<strong>无结构的字符流文件</strong>和<strong>有结构的记录</strong>（有格式文件）文件两种。记录文件由记录组成，即文件的内容划分成多个记录，以记录为单位组织和使用信息。</p>
<p>常用的<strong>记录式结构</strong>有<strong>连续结构</strong>、<strong>多重结构</strong>、<strong>转置结构</strong>、<strong>顺序结构</strong>。</p>
<p>（1）连续结构：连续结构是一种把记录按生成的先后顺序排列的逻辑结构。连续结构的特点是适用性强，可用于所有文件，且记录的排列顺序与记录的内容无关。缺点是搜索性能较差。</p>
<p>（2）多重结构：多重文件把记录按键和记录名排列成行列式结构，一个包含n个记录名、m个键的文件构成一个m*n维行列式。</p>
<p>（3）转置结构：转置结构把含有相同键的记录指针全部指向该键，也就是说，把所有与同一键对应的记录的指针连续地置于目录中该键的位置下。转置结构最适合于给定键后的记录搜索。</p>
<p>（4）顺序结构：顺序结构把文件中的键按规定的顺序排列起来。</p>
<p> 用户通过对文件的存取来完成对文件的修改、追加和搜索等操作，常用的存取方法有顺序存取法、随机存取法（直接存取法）和按键存取法。</p>
<h2 id="文件的物理组织"><a href="#文件的物理组织" class="headerlink" title="文件的物理组织"></a>文件的物理组织</h2><p>在文件系统中，文件的存储设备通常划分为若干个大小相等的物理块。文件的物理结构是指文件在存储设备上的存储方法，常用的文件物理结构有连续文件、串联文件和索引文件。</p>
<p> （1）<strong>连续文件（顺序文件）</strong>：连续文件是一种最简单的物理文件结构，它把一个在逻辑上连续的文件信息依次存放到物理块中。连续文件的优点是一旦知道文件在文件存储设备上的起始位置和文件长度，就能进行存取。连续文件适合于顺序存取，在连续存取相邻信息时，存取速度快。其缺点是在文件建立时必须指定文件的信息长度，以后不能动态增长，一般不宜于需要经常修改的文件。</p>
<p>（2）<strong>串联文件（链接文件）</strong>：串联文件用非连续的物理块来存放文件信息，这些物理块之间没有顺序关系，其中每个物理块设有一个指针，指向下一个物理块的地址，这样，所有的物理块都被链接起来，形成一个链接队列。串联文件的优点是可以解决存储器的碎片问题，提高存储空间利用率。由于串联文件只能按照队列中的链接指针顺序查找，因此搜索效率低，一般只适用于顺序访问，不适用于随机存取。</p>
<p>（3）<strong>索引文件</strong>：索引文件是另一种<strong>对文件存储不连续分配</strong>的方法。为每个文件建立一张索引表，索引表中的每一表项指出文件信息所在的逻辑块号和与之对应的物理块号。索引文件既可以满足文件动态增长的要求，又可以方便而迅速地实现随机存取。对一些大的文件，当索引表的大小超过一个物理块时，会发生索引表的分配问题。一般采用多级（间接索引）技术，这时在由<strong>索引表指出的物理块中存放的不是文件地址而是存放文件信息的物理块地址</strong>。这样，如果一个物理块能存储n个地址，则一级间接索引，将使可寻址的文件长度变成n2块，对于更大的文件可以采用二级甚至三级间接索引（例如，Unix操作系统采用三级索引结构）。索引文件的优点是既适用于顺序存取，又适用于随机存取。缺点是索引表增加了存储空间的开销。另外，在存取文件时至少需要访问两次磁盘，一次是访问索引表，另一次是根据索引表提供的物理块号访问文件信息。为了提高效率，一种改进的方法是，在对某个文件进行操作之前，预先把索引表调入内存。这样，文件的存取就能直接从在内存的索引表中确定相应的物理块号，从而只需要访问一次磁盘。</p>
<h2 id="树形目录结构"><a href="#树形目录结构" class="headerlink" title="树形目录结构"></a>树形目录结构</h2><p>文件控制块的集合称为文件目录，文件目录也被组织成文件，常称为目录文件。文件管理的一个重要方面是对文件目录进行组织和管理。文件系统一般采用一级目录结构、二级目录结构和多级目录结构。DOS、Unix、Windows系统都是采用多级树形目录结构。</p>
<p>在多级树形目录结构中，整个文件系统有一个根，然后在根上分枝，任何一个分枝上都可以再分枝，枝上也可以长出树叶。根和枝称为目录或文件夹。而树叶则是一个个的文件。实践证明，这种结构的文件系统效率比较高。例如：图1-5就是一个树形目录结构，其中方框代表目录，圆形代表文件。</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps21.png" alt="img"> </p>
<p>在树形目录结构中，树的根节点为根目录，数据文件作为树叶，其他所有目录均作为树的节点。系统在建立每一个目录时，都会自动为它设定两个目录文件，一个是“.”，代表该目录自己，另一个是“..”，代表该目录的父目录。对于根目录，“.”和“..”都代表其自己。</p>
<p>从逻辑上讲，用户在登录到系统中之后，每时每刻都处在某个目录之中，此目录被称作工作目录或当前目录，工作目录是可以随时改变的。</p>
<p>对文件进行访问时，需要用到路径的概念。路径是指从树形目录中的某个目录层次到某个文件的一条道路。在树形目录结构中，从根目录到任何数据文件之间，只有一条唯一的通路，从树根开始，把全部目录文件名与数据文件名依次用“/”连接起来，构成该数据文件的路径名，且每个数据文件的路径名是唯一的。这样，可以解决文件重名问题，不同路径下的同名文件不一定是相同的文件。例如：在图1-5中，根目录下的文件f1和/D1/W1目录下的文件f1可能是相同的文件，也可能是不相同的文件。</p>
<p>用户在对文件进行访问时，要给出文件所在的路径。路径又分相对路径和绝对路径。绝对路径是指从根目录开始的路径，也称为完全路径；相对路径是从用户工作目录开始的路径。应该注意到，在树形目录结构中到某一确定文件的绝对路径和相对路径均只有一条。绝对路径是确定不变的，而相对路径则随着用户工作目录的变化而不断变化。用户要访问一个文件时，可以通过路径名来引用。例如：在图1-5中，如果当前目录是D1，则访问文件f2的绝对路径是/D1/W2/f2，相对路径是W2/f2。如果当前目录是W1，则访问文件f2的绝对路径仍然是/D1/W2/f2，但相对路径变为../W2/f2。在Windows系统中，有两种格式的文件，分别是FAT32（FAT16）文件和NTFS文件。NTFS在使用中产生的磁盘碎片要比FAT32少，安全性也更高，而且支持单个文件的容量更大，超过了4GB，特别适合现在的大容量存储。NTFS可以支持的分区（如果采用动态磁盘则称为卷）大小可以达到2TB，而Windows 2000中的FAT32支持分区的大小最大为32GB。</p>
<h2 id="存储空间管理"><a href="#存储空间管理" class="headerlink" title="存储空间管理"></a>存储空间管理</h2><p> 由于文件存储设备是分成许多大小相同的物理块，并以块为单位交换信息，因此，<strong>文件存储设备的管理，实质上是对空闲块的组织和管理问题，它包括空闲块的组织、空闲块的分配与空闲块的回收等问题。</strong></p>
<h3 id="1空闲表法"><a href="#1．空闲表法" class="headerlink" title="1．空闲表法"></a>1．空闲表法</h3><p>空闲表法属于<strong>连续分配</strong>，系统为外存上的所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项，包括序号、第一空闲盘块号和空闲盘块数。</p>
<h3 id="2空闲链表法"><a href="#2．空闲链表法" class="headerlink" title="2．空闲链表法"></a>2．空闲链表法</h3><p>将所<strong>有空闲盘区，拉成一条空闲链</strong>，根据构成链所用的基本元素的不同，可把链表分成两种形式：</p>
<p>（1）空闲盘块链。将磁盘上所有空闲区空间，以盘块为单位拉成一条链，当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块链给用户。当用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。空闲盘块链分配和回收一个盘块的过程非常简单，但在为一个文件分配盘块时，可能要重复多次操作。</p>
<p>（2）空闲盘区链。将磁盘上所有空闲盘区拉成一条链，在每个盘区上包含若干用于指示下一个空闲盘区的指针，指明盘区大小的信息。分配盘块时，通常采用首次适应算法（显式链接法）。在回收时，要将回收区与空闲盘区相合并。</p>
<h3 id="3位图法"><a href="#3．位图法" class="headerlink" title="3．位图法"></a>3．位图法</h3><p>位图（bitmap）用二进制位表示磁盘中的一个盘块的使用情况，0表示空闲，1表示已分配。磁盘上的所有盘块都与一个二进制位相对应，由所有的二进制位构成的集合，称为位图。位图法的优点是<strong>很容易找到一个或一组相邻的空闲盘块</strong>。位图小，可以把它保存在内存中，从而节省了磁盘的启动操作。</p>
<h3 id="4成组链接法"><a href="#4．成组链接法" class="headerlink" title="4．成组链接法"></a>4．成组链接法</h3><p>成组链接法将<strong>空闲表和空闲链表法结合</strong>形成的一种空闲盘块管理方法，适用于大型文件系统。</p>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>对于本知识点，主要考查虚拟存储器（虚存），特别是页式存储管理。所谓虚拟存储技术，即在内存中保留一部分程序或数据，在外存中放置整个地址空间的副本。程序运行过程中可以随机访问内存中的数据或程序，但需要的程序或数据不在内存时，就将内存中部分内容根据情况写回外存，然后从外存调入所需程序或数据，实现作业内部的局部转换，从而允许程序的地址空间大于实际分配的存储区域。它在内存和外存之间建立了层次关系，使得程序能够像访问内存一样访问外存，主要用于解决内存的容量问题。其逻辑容量由内存和外存容量之和以及CPU可寻址的范围来决定，其运行速度接近于内存速度，成本也下降。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、中、小型及微型机中。</p>
<h2 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h2><p>由进程中的目标代码、数据等的虚拟地址组成的虚拟空间称为虚拟存储器，虚拟存储器允许用户用比内存容量大得多的地址空间来编程，以运行比内存实际容量大得多的程序。<strong>用户编程所用的地址称为逻辑地址（虚地址</strong>），而<strong>实际的内存地址则称为物理地址（实地址）</strong>。每次访问内存时都要进行逻辑地址到物理地址的转换，这种转换是由硬件完成的，而内存和外存间的信息动态调度是硬件和操作系统两者配合完成的。</p>
<p>（1）<strong>静态重定位</strong>：静态重定位是<strong>在虚空间程序执行之前由装配程序完成地址影射工作</strong>。静态重定位的优点是不需要硬件的支持。缺点是无法实现虚拟存储器，必须占用连续的内存空间且难以做到程序和数据的共享。</p>
<p>（2）<strong>动态重定位</strong>：动态重定位是<strong>在程序执行过程中，在CPU访问内存之前，将要访问的程序或数据地址转换为内存地址</strong>。动态重定位依靠硬件地址变换机构完成，其优点主要有：可以对内存进行非连续分配；提供了虚拟存储器的基础；有利于程序段的共享。</p>
<h2 id="存储组织"><a href="#存储组织" class="headerlink" title="存储组织"></a>存储组织</h2><p> 虚拟存储器可以分为单一连续分区、固定分区、可变分区、可重定位分区、页式、段式、段页式7种。</p>
<p>（1）<strong>单一连续分区</strong>。把所有用户区都分配给唯一的用户作业，当作业被调度时，进程全部进入内存，一旦完成，所有内存恢复空闲，因此，它不支持多道程序设计。</p>
<p>（2）<strong>固定分区</strong>。这是支持多道程序设计的最简单的存储管理方法，它把内存划分成若干个固定的和大小不同的分区，每个分区能够装入一个作业，分区的大小是固定的，算法简单，但是容易生成较多的存储器碎片。</p>
<p>（3）<strong>可变分区</strong>。引入可变分区后虽然内存分配更灵活，也提高了内存利用率，但是由于系统在不断地分配和回收中，必定会出现一些不连续的小的空闲区，尽管这些小的空闲区的总和超过某一个作业要求的空间，但是由于不连续而无法分配，产生了碎片。解决碎片的方法是拼接（紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。</p>
<p>（4）<strong>可重定位分区</strong>。这是克服固定分区碎片问题的一种存储分配方法，它能够把相邻的空闲存储空间合并成一个完整的空区，还能够整理存储器内各个作业的存储位置，以达到消除存储碎片和紧缩存储空间的目的。紧缩工作需要花费大量的时间和系统资源。</p>
<p>（5）<strong>页式</strong>。页式存储组织的基本原理是将各进程的虚拟空间划分为若干个长度相等的页，把内存空间以与页相等的大小划分为大小相等的片或页面，采用请求调页或预调页技术实现内外存的统一管理。页式存储组织的主要优点是利用率高，产生的内存碎片小，内存空间分配及管理简单。主要缺点是要有相应的硬件支持，增加了系统开销；请求调页的算法如选择不当，有可能产生抖动现象。</p>
<p>（6）<strong>段式</strong>：一个作业是由若干个具有逻辑意义的段（如主程序、子程序、数据段等）组成。段式存储管理中，允许程序（作业）占据内存中若干分离的分区。分段系统中的虚地址是一个有序对（段号，段内位移）。系统为每一个作业建立一个段表，其内容包括段号与内存起始地址的对应关系、段长和状态等。状态指出这个段是否已调入内存，若已调入内存，则指出这个段的起始地址位置，状态同时也指出这个段的访问权限。如果该段尚未调入内存，则产生缺段中断，以便装入所需要的段。段式存储管理的主要优点是便于多道程序共享内存，便于对存储器的保护，各段程序修改互不影响。其缺点是内存利用率低，内存碎片浪费大。</p>
<p> （7）<strong>段页式</strong>。这是分段式和分页式结合的存储管理方法，充分利用了分段管理和分页管理的优点。作业按逻辑结构分段，段内分页，内存分块。作业只需部分页装入即可运行，所以支持虚拟存储，可实现动态连接和装配。现在，最常见的虚存组织有分段技术、分页技术、段页式技术三种。</p>
<p>表1-3 常见的虚存组织</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>段式管理</th>
<th>页式管理</th>
<th>段页式管理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>划分方式</strong></td>
<td>段（不定长），每个作业一张段表</td>
<td>页（定长），每个进程一张页表</td>
<td>先将内存分为等长页，每个作业一张段表（通常有一个基号指向它），每段对应一组页表</td>
</tr>
<tr>
<td><strong>虚地址</strong></td>
<td>(s,d), 即(段号，段内偏移)</td>
<td>(p,d), 即(页号，页内偏移)</td>
<td>(s,p,d)即(段号，段内页号，页内偏移)</td>
</tr>
<tr>
<td><strong>虚实转换</strong></td>
<td>段表内找出初始地址，然后+段内偏移</td>
<td>页表内找出其实地址+页内偏移</td>
<td>先在段表中找到页表的起始位置，然后在页表中找到起始地址，最后+页内偏移</td>
</tr>
<tr>
<td><strong>主要优点</strong></td>
<td>简化了任意增长和收缩的数据段管理，利于进程间共享过程和数据</td>
<td>消除了页外碎片</td>
<td>结合了段与页的优点；便于控制存取访问</td>
</tr>
<tr>
<td><strong>主要缺点</strong></td>
<td>段外碎片降低了利用率</td>
<td>存在页内碎片</td>
<td>增长复杂度，增加硬件；存在页内碎片</td>
</tr>
</tbody>
</table>
</div>
<p>说明：段内偏移也称为段内地址，页内偏移也称为页内地址。</p>
<p>例如：某页式存储系统的地址变换过程如图1-6所示。假定页面的大小为8K，图1-6中所示的十进制逻辑地址9612经过地址变换后，形成的物理地址a应为十进制多少呢？</p>
<p>因为8K=213，所以页内地址有13位。逻辑地址9612转换成二进制，得到10 0101 1000 1100，这里的低13位为页内偏移量，最高一位则为页号，所以逻辑地址9612的页号为1，根据图1-6的对照表，即物理块号为3（二进制形式为11）。把物理块号和页内偏移地址拼合得到110 0101 1000 1100，再转换为十进制，得到25996。</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps27.png" alt="img"></p>
<p>图1-6 页式存储系统的地址变换过程</p>
<p>在现行的虚存组织方面，最常见的就是段页式管理。在进行虚实地址转换时，可以采用的公式如下：</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps28.png" alt="img"> 其中x为基号，s为段号，p为段内页号，d为页内偏移，n的值为d的总位数，（x）表示x里的内容。</p>
<h2 id="存储管理"><a href="#存储管理-1" class="headerlink" title="存储管理"></a>存储管理</h2><p>在虚拟存储器的管理中，涉及载入（调入）、放置（放入分区）和置换（swapping）等问题。</p>
<p> （1）<strong>调入策略</strong>：即<strong>何时将一页或一段从外存中调入内存</strong>，通常有两种策略，一种是请求调入法，即需要使用时才调入；另一种是先行调入法，即将预计要使用的页/段先行调入内存。</p>
<p>（2）<strong>放置策略</strong>：也就是调入后，<strong>放在内存的什么位置</strong>，这与内存管理基本上是一致的。</p>
<p>（3）<strong>置换策略</strong>：由于实际内存是小于虚存的，因此可能会发生内存中已满，但需要使用的页不在内存中这一情况（称为缺页中断）。这时就需要进行置换，即将<strong>一些内存中的页淘汰到外存，腾出空间给要使用的页</strong>，这个过程也称为Swapping。</p>
<h3 id="1置换算法"><a href="#1．置换算法" class="headerlink" title="1．置换算法"></a>1．置换算法</h3><p>常见的置换算法如下：</p>
<p>（1）<strong>最优（Optimized，OPT）算法</strong>：选择淘汰不再使用或最将来才使用的页，这是理想的算法，但难以实现，常用于淘汰算法的比较。</p>
<p>（2）<strong>随机（Rand）算法</strong>：随机地选择淘汰的页，开销小，但可能选中立即就要访问的页。</p>
<p>（3）<strong>先进先出（First In and First Out，FIFO）算法</strong>：选择淘汰在内存驻留时间最长的页，似乎合理，但可能淘汰立即要使用的页。另外，使用FIFO算法时，在未给予进程分配足够的页面时，有时会出现给予进程的页面数越多，缺页次数反而增加的异常现象，这称为Belady现象。例如，若某个进程访问页面的顺序（称页面访问序列）是432143543215，当进程拥有3个主存页面时，发生缺页率比拥有4个主存页面时要小。</p>
<p>（4）<strong>最近最少使用（Least Recently Used，LRU）算法</strong>：选择淘汰离当前点时刻最近的一段内使用得最少的页。例如，若某个进程拥有3个主存页面，已访问页面的顺序是4314，现在如果要访问第2页，则需要淘汰第3页，因为第1、4页刚刚使用了。这个算法的主要出发点是，如果某页被访问了，则它可能马上就要被访问。OPT算法和LRU算法都不会发生Belady异常现象。</p>
<h3 id="2局部性原理"><a href="#2．局部性原理" class="headerlink" title="2．局部性原理"></a>2．局部性原理</h3><p>存储管理策略的基础是局部性原理，即进程往往会不均匀地高度局部化地访问内存。局部性分为<strong>时间局部性</strong>和<strong>空间局部性</strong>。时间局部性是指最近访问存储位置，很可能不久的将来还要访问；空间局部性是指存储访问有成组的倾向：当访问了某个位置后，很可能也要访问其附近的位置。</p>
<p>根据局部性原理的特征性，Denning阐述了程序性能的工作集理论。<strong>工作集</strong>是进程频繁访问的页面的集合。工作集理论指出，为使进程有效地运行，它的页面工作集应驻留内存中。否则，由于进程频繁地从外存请求页面，而出现称为“颠簸”（抖动）的过度的页面调度活动。此时，处理页面调度的时间超过了程序的执行时间。显然，此时CPU的有效利用率会急速下降。</p>
<p>通常用两种等价的方法确定进程的工作集，一种是将工作集确定为在定长的页面访问序列（工作集窗口）中的页面集合，另一种是将工作集确定为在定长时间间隔中涉及到页面的集合。工作集的大小依赖于工作集窗口的大小，在进程执行时，工作集会发生变化。有时，当进程进入另一个完全不同的执行阶段时，工作集会出现显著的变化。不过在一个进程的执行过程中，工作集的大小处于稳定状态的时间基本上占绝大多数。</p>
<p>另一种控制颠簸的技术是<strong>控制缺页率</strong>。操作系统规定缺页率的上下限，当一个进程的缺页率高于上限时，表明该进程需要更大的内存空间，则分配较多的内存页面给它，当进程的缺页率低于下限时，表明该进程占用的内存空间过大，可以适当地收回若干内存页面。</p>
<h2 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h2><p>操作系统中用来控制作业的进入、执行和撤销的一组程序称为作业管理程序，这些控制功能也能通过把作业细化，通过进程的执行来实现。在作业管理中，系统为每一个作业建立—个作业控制块（Job Control Block，JCB）。系统通过JCB感知作业的存在。JCB包括的主要内容有作业名、作业状态、资源要求、作业控制方式、作业类型以及作业优先权等。</p>
<h3 id="作业的状态"><a href="#作业的状态" class="headerlink" title="作业的状态"></a>作业的状态</h3><p> 一个作业从交给计算机系统到执行结束退出系统，一般都要经历<strong>提交、后备、执行和完成</strong>四个状态。其状态转换如图1-7所示。</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps32.png" alt="img"> （1）<strong>提交状态</strong>。作业由输入设备进入外存储器（也称输入井）的过程称为提交状态。处于提交状态的作业，其信息正在进入系统。</p>
<p>（2）<strong>后备状态</strong>。当作业的全部信息进入外存后，系统就为该作业建立一个作业控制块。</p>
<p>（3）<strong>执行状态</strong>。一个后备作业被作业调度程序选中分配了必要的资源并进入了内存，作业调度程序同时为其建立了相应的进程后，该作业就由后备状态变成了执行状态。</p>
<p>（4）<strong>完成状态</strong>：当作业正常运行结束，它所占用的资源尚未全部被系统回收时的状态为完成状态。</p>
<h2 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h2><p>处理器调度通常分为三级调度，即低级调度、中级调度和高级调度。</p>
<p>（1）<strong>高级调度</strong>。高级调度也称为<strong>作业调度</strong>。高级调度的主要功能是在<strong>批处理作业的后备作业队列中选择一个或者一组作业</strong>，为它们建立进程，分配必要的资源，使它们能够运行起来。</p>
<p>（2）<strong>中级调度</strong>。中级调度也称为<strong>交换调度</strong>，中级调度<strong>决定进程在内、外存之间的调入、调出</strong>。其主要功能是在内存资源不足时将某些处于等待状态或就绪状态的进程调出内存，腾出空间后，再将外存上的就绪进程调入内存。</p>
<p>（3）<strong>低级调度</strong>。低级调度也称为<strong>进程调度</strong>，低级调度的主要功能是<strong>确定处理器在就绪进程间的分配</strong>。</p>
<p> 作业调度主要完成从后备状态到执行状态的转变，及从执行状态到完成状态的转变。<strong>作业调度算法</strong>有：</p>
<p>（1）<strong>先来先服务（First Come and First Served，FCFS）</strong>。按作业到达的先后次序调度，它不利于短作业。</p>
<p>（2）<strong>短作业优先（Short Job First，SJF）</strong>。按作业的估计运行时间调度，估计运行时间短的作业优先调度。它不利于长作业，可能会使一个估计运行时间长的作业迟迟得不到服务。</p>
<p>（3）<strong>响应比高者优先（Highest Response_ratio Next，HRN）</strong>。对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。响应比R定义： <code>R = (W+T)/T = 1+W/T</code>. 其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。这样，即使是长作业，随着它等待时间的增加，W/T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRN方式时其吞吐量将小于采用SJF 法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。</p>
<p>（4）<strong>优先级调度</strong>。根据作业的优先级别，优先级高者先调度。</p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>在计算机系统中，除了处理器和内存之外，其他的大部分硬设备称为外部设备。它包括输入/输出设备，外存设备及终端设备等。为了完成上述主要任务，设备管理程序一般要提供下述功能：</p>
<p>（1）<strong>提供和进程管理系统的接口</strong>。当进程要求设备资源时，该接口将进程要求转达给设备管理程序。</p>
<p>（2）<strong>进行设备分配</strong>。按照设备类型和相应的分配算法把设备和其他有关的硬件分配给请求该设备的进程，并把未分配到所请求设备或其他有关硬件的进程放入等待队列。</p>
<p>（3）实现设备和设备、设备和CPU等之间的<strong>并行操作</strong>。</p>
<p>（4）<strong>进行缓冲区管理</strong>。主要减少外部设备和内存与CPU之间的数据速度不匹配的问题，系统中一般设有缓冲区(器)来暂放数据。设备管理程序负责进行缓冲区分配、释放及有关的管理工作。</p>
<h2 id="数据传输控制方式"><a href="#数据传输控制方式" class="headerlink" title="数据传输控制方式"></a>数据传输控制方式</h2><p>在计算机中，输入/输出（Input/Output，I/O）系统可以有5种不同的工作方式，分别是程序控制方式、程序中断方式、DMA（Direct Memory Access，直接内存存取）工作方式、通道方式、输入/输出处理机。</p>
<p>（1）<strong>程序控制方式</strong>。CPU直接利用I/O指令编程，实现数据的输入输出。CPU发出I/O命令，命令中包含了外设的地址信息和所要执行的操作，相应的I/O系统执行该命令并设置状态寄存器；CPU不停地（定期地）查询I/O系统以确定该操作是否完成。由程序主动查询外设，完成主机与外设间的数据传送，方法简单，硬件开销小。</p>
<p>（2）<strong>程序中断方式</strong>。CPU利用中断方式完成数据的输入/输出，当I/O系统与外设交换数据时，CPU无需等待也不必去查询I/O的状态，当I/O系统完成了数据传输后则以中断信号通知CPU。CPU然后保存正在执行程序的现场，转入I/O中断服务程序完成与I/O系统的数据交换。然后返回原主程序继续执行。与程序控制方式相比，中断方式因为CPU无需等待而提高了效率。在系统中具有多个中断源的情况下，常用的处理方法有：多中断信号线法、中断软件查询法、雏菊链法、总线仲裁法和中断向量表法。</p>
<p>（3）<strong>DMA方式</strong>。使用DMA控制器（Direct Memory Access Controler，DMAC）来控制和管理数据传输。DMAC和CPU共享系统总线，并且具有独立访问存储器的能力。在进行DMA时，CPU放弃对系统总线的控制而由DMAC控制总线；由DMAC提供存储器地址及必需的读写控制信号，实现外设与存储器之间的数据交换。DMAC获取总线的3种方式：暂停方式、周期窃取方式和共享方式。</p>
<p>（4）<strong>通道方式</strong>。通道是一种通过执行通道程序管理I/O操作的控制器，它使主机与I/O操作之间达到更高的并行程度。在具有通道处理机的系统中，当用户进程请求启动外设时，由操作系统根据I/O要求构造通道程序和通道状态字，将通道程序保存在内存中，并将通道程序的首地址放到通道地址字中，然后执行启动I/O指令。按照所采取的传送方式，可将通道分为字节多路通道、选择通道和数组多路通道三种。</p>
<p>（5）<strong>输入输出处理机</strong>。输入输出处理机也称为外围处理机，它是一个专用处理机，也可以是一个通用的处理机，具有丰富的指令系统和完善的中断系统。专用于大型、高效的计算机系统处理外围设备的输入输出，并利用共享存储器或其他共享手段与主机交换信息。从而使大型、高效的计算机系统更加高效地工作。与通道相比，输入输出处理机具有比较丰富的指令系统，结构接近于一般的处理机，有自己的局部存储器。</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>访问磁盘的时间由三部分构成，它们是<strong>寻道（查找数据所在的磁道）时间</strong>、<strong>等待（旋转等待扇区）时间</strong>和<strong>数据传输时间</strong>，其中<strong>寻道时间（查找时间）是决定因素</strong>。</p>
<p> （1）<strong>FCFS算法</strong>：有些文献称为FIFO算法。FCFS是一种最简单的磁盘调度算法，按先来先服务的次序，未作优化。这种算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不满足的情况。此算法未对寻道进行优化，致使平均寻道时间可能较长。</p>
<p>（2）<strong>SSTF（Shortest Seek Time First，最短寻道时间优先）算法</strong>：选择这样的进程，其要求访问的磁道距当前磁头所在的磁道距离最近，以使每次寻道的时间最短。FCFS会引起读写头在盘面上的大范围移动，SSTF查找距离磁头最短（也就是查找时间最短）的请求作为下一次服务的对象。SSTF查找模式有高度局部化的倾向，会推迟一些请求的服务，甚至引起无限拖延（这种现象称为“饥饿”）。</p>
<p>（3）<strong>SCAN（电梯）算法</strong>：不仅考虑到欲访问的磁道与当前磁道的距离，而且优先考虑的是磁头的当前移动方向，是在磁头前进方向上的最短查找时间优先算法，它排除了磁头在盘面局部位置上的往复移动。SCAN算法在很大程度上消除了SSTF算法的不公平性，但仍有利于对中间磁道的请求。SCAN算法的缺陷是当磁头刚由里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时进程必须等待，待磁头由里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被严重地推迟。</p>
<p>（4）<strong>N-SCAN（N步SCAN）算法</strong>：这是对SCAN算法的改良，磁头的移动与SCAN算法是一样的，不同的是扫描期间只对那些在扫描开始前已等待服务的请求提供服务。在服务期间，新到达的请求即使在磁头前进方向上也得不到服务，直到下一个新扫描周期开始。。N-SCAN算法的实质是把FCFS和SCAN的优点结合起来，以便取得较好的性能。如果新到达的请求按优化次序排列，则下一个扫描周期必然花费最少的磁头移动时间。</p>
<p>（5）<strong>C-SCAN（循环扫描）算法</strong>：这是对SCAN算法的另一种改良，是单向服务的N步SCAN算法，C-SCAN算法规定磁头单向移动。C-SCAN算法彻底消除了对两端磁道请求的不公平。</p>
<h2 id="虚设备与spooling技术"><a href="#虚设备与SPOOLING技术" class="headerlink" title="虚设备与SPOOLING技术"></a>虚设备与SPOOLING技术</h2><p>SPOOLing（Simultaneous Peripheral Operation On Line）的意思是外部设备同时联机操作，又称为假脱机输入输出操作或排队转储技术，采用一组程序或进程模拟一台输入输出处理器。它在输入和输出之间增加了“输入井”和“输出井”的排队转储环节，SPOOLing系统的组成如图</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps38.png" alt="img"> </p>
<p>从图1-8可以看出，SPOOLing系统主要包括以下3个部分：</p>
<p> （1）<strong>输入井和输出井</strong>：这是在<strong>磁盘上开辟出来的两个存储区域</strong>。输入井模拟脱机输入时的磁盘，用于存放I/O设备输入的数据；输出井模拟脱机输出时的磁盘，用于存放用户程序的输出数据。因此，SPOOLing系统必须有高速、大容量、随机存取的外存的支持。</p>
<p>（2）<strong>输入缓冲区和输出缓冲区</strong>：这是在<strong>内存中开辟的两个缓冲区</strong>。输入缓冲区用于<strong>暂存</strong>有输入设备送来的数据，以后在传送到输出井。输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备。</p>
<p>（3）<strong>输入进程和输出进程</strong>：输入进程模拟脱机输入时的外围控制机，将用户要求的数据有输入设备到输入缓冲区，再送到输入井。当CPU需要输入设备时，直接从输入井读入内存。输出进程模拟脱机输出时的外围控制机，把用户要求输入的数据，先从内存送到输出井，待输出设备空闲时，再将输出井中的数据，经过输出缓冲区送到输出设备上。</p>
<p>SPOOLing技术的<strong>主要特点</strong>如下：</p>
<p>（1）<strong>提高了I/O速度</strong>。从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作，如同脱机操作一样，提高了I/O速度，缓和了CPU与低速I/O设备速度不匹配的矛盾。</p>
<p>（2）<strong>设备并没有分配给任何进程</strong>。在输入井或输出井中，分配给进程的是一存储区和建立一张I/O请求表。</p>
<p>（3）<strong>实现了虚拟设备功能</strong>。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，不过，该设备是逻辑上的设备。采用SPOOLing技术，可以将低速的独占设备改造成一种可共享的设备，而且一台物理设备可以对应若干台虚拟的同类设备。</p>
<p>第 1 章：操作系统</p>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><p>网络操作系统是指能使网络上个计算机方便而有效的共享网络资源，为用户提供所需的各种服务的操作系统软件。</p>
<h2 id="网络操作系统概述"><a href="#网络操作系统概述" class="headerlink" title="网络操作系统概述"></a>网络操作系统概述</h2><p>如果网络操作系统相等地分布在网络上的所有节点，则称之为对等式网络操作系统；如果网络操作系统的主要部分驻留在中心节点，则称为集中式网络操作系统。集中式网络操作系统下的中心节点称为服务器，使用由中心节点所管理资源的应用称为客户。因此，集中式网络操作系统下的运行机制是C/S（Client/Server，客户/服务器）架构。</p>
<p>网络操作系统除了具备单机操作系统所需的功能外，还应具有下列功能：</p>
<p>（1）提供高效可靠的网络通讯能力。</p>
<p>（2）提供多项网络服务功能，例如，远程管理、文件传输、电子邮件、远程打印等。</p>
<p> 网络操作系统一般具有以下特征：</p>
<p>（1）硬件独立。网络操作系统应当独立于具体的硬件平台，即系统应该可以运行于各种硬件平台之上。为此，Microsoft提出了HAL（Hardware Abstraction Layer，硬件抽象层）的概念。HAL与具体的硬件平台无关，一旦改变具体的硬件平台，只要改变其HAL，系统就可以作平稳转换。</p>
<p>（2）网络特性。应当管理计算机资源并提供良好的用户界面。</p>
<p>（3）可移植性和可集成性。</p>
<p>（4）多用户、多任务。在多进程系统中，为了避免两个进程并行处理所带来的问题，可以采用多线程的处理方式。支持多处理机技术是对现代网络操作系统的基本要求。</p>
<h2 id="网络操作系统的组成"><a href="#网络操作系统的组成" class="headerlink" title="网络操作系统的组成"></a>网络操作系统的组成</h2><p>网络操作系统由网络驱动程序、子网协议和应用层协议等3个方面组成。网络操作系统通过网络驱动程序与网络硬件通信，因此它是作为网卡和子网协议间的联系体来工作的。子网协议是经过网络发送应用和系统管理信息所必须的通信协议。应用层协议则与子网协议进行通信，并实现网络操作系统对网络用户的服务。</p>
<p>（1）<strong>网络驱动程序</strong>。网络驱动程序涉及OSI/RM（Open System Interconnection ReferenceModel，开放系统互连参考模型）的第2层（数据链路层）和第3层（网络层），是网卡和高层协议间的接口。网络驱动程序把网卡如何对来自和发往高层的包所使用的方法进行了屏蔽，使高层不必了解收发操作的复杂性，而网络驱动程序本身则必须对网卡的操作有详细的了解。由于对标准的具体实现不同，网络驱动程序也就不同。正因为这样，网络集成商对所使用的网卡必须选择配对的驱动程序，并将所用的网络驱动程序同网络操作系统集成到一起。</p>
<p>（2）<strong>子网协议</strong>。子网协议涉及OSI/RM的第3层、第4层（传输层）和第5层（会话层）。第3层建立在第2层提供的点到点连接上，主要任务是如何对通信量进行路由选择，提供拥塞和流量控制，提供统一的网络寻址方法，以便令牌环和以太网络能理解。第4层可对第3层提供的服务进行提高，能确保可靠的数据交付。第5层提供有序的会话服务，如在会话上可提供会话控制，权标管理和活动管理</p>
<p>（3）<strong>应用层协议</strong>。应用层协议最重要的是NCP（Netware Core Proeocol）。NCP作为应用层的协议，提供了下述主要功能：在不同方式下打开文件；关闭打开的文件；从打开的文件读取数据块；将数据块写入打开的文件；获取目录项表；处理服务器数据库；提供高级连接服务；提供同步操作。</p>
<h1 id="第2章-数据库系统"><a href="#第2章-数据库系统" class="headerlink" title="第2章 数据库系统"></a>第2章 数据库系统</h1><h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><p>现在的大型系统几乎都是基于数据库的系统，作为系统架构设计师，要深入了解数据库方面的知识，系统掌握有关数据库建模和设计的技术。根据考试大纲，本章要求考生掌握以下知识点：</p>
<p>（1）<strong>信息系统综合知识</strong>：包括数据库管理系统的类型、数据库管理系统结构和性能评价、常用的关系型数据库管理系统、数据库模式、数据库规范化、分布式数据库系统、并行数据库系统、数据仓库与数据挖掘技术、数据库工程、备份恢复。</p>
<p>（2）<strong>系统架构设计案例分析和论文</strong>：数据库建模、数据库设计、数据库系统的备份与恢复。数据管理技术的发展大致经历了人工管理阶段、文件系统阶段、数据库阶段和高级数据库技术阶段。数据库是长期储存在计算机内的、有组织的、可共享的数据的集合。</p>
<p>数据库管理系统（DataBase Management System，DBMS）是一种负责数据库的定义、建立、操作、管理和维护的软件系统。其目的是保证数据安全可靠，提高数据库应用的简明性和方便性。DBMS的工作机理是把用户对数据的操作转化为对系统存储文件的操作，有效地实现数据库三级之间的转化。数据库管理系统的主要职能有：数据库的定义和建立、数据库的操作、数据库的控制、数据库的维护、故障恢复和数据通信。</p>
<p> 数据库系统（DataBase System，DBS）是实现有组织地、动态地存储大量关联数据、方便多用户访问的计算机软件、硬件和数据资源组成的系统。一个典型的DBS包括数据库、硬件、软件（应用程序）和数据库管理员（DataBase Administrator，DBA）四个部分。根据计算机的系统结构，DBS可分成集中式、客户/服务器式、并行式和分布式四种。</p>
<p>与文件系统阶段相比，数据库技术的数据管理方式具有以下特点：</p>
<p>（1）采用复杂的数据模型表示数据结构，数据冗余小，易扩充，实现了数据共享。</p>
<p>（2）具有较高的数据和程序独立性。包括数据库的独立性有物理独立性和逻辑独立性。</p>
<p>（3）数据库系统为用户提供了方便的用户接口。</p>
<p>（4）数据库系统提供四个方面的数据控制功能，分别是并发控制、恢复、完整性和安全性。数据库中各个应用程序所使用的数据由数据库系统统一规定，按照一定的数据模型组织和建立，由系统统一管理和集中控制。</p>
<p>（5）增加了系统的灵活性。</p>
<p>高级数据库技术阶段的主要标志是<strong>分布式数据库系统</strong>和<strong>面向对象数据库系统</strong>的出现。分布式数据库系统的主要特点是数据在物理上分散存储，在逻辑上是统一的。分布式数据库系统的多数处理就地完成，各地的计算机由数据通信网络相联系；面向对象数据库系统是面向对象的程序设计技术与数据库技术相结合的产物。面向对象数据库系统的主要特点是具有面向对象技术的封装性和继承性，提高了软件的可重用性。</p>
<h2 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h2><p>DBS的设计目标是<strong>允许用户逻辑地处理数据</strong>、而不必涉及这些数据在计算机中是怎样存放的，在数据组织和用户应用之间提供某种程度的独立性。数据库技术中采用分级的方法，将数据库的结构划分为多个层次。最著名的是美国ANSI/SPARC数据库系统研究组1975年提出的三级划分法，如图2-1所示。</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps43.png" alt="img"> </p>
<h3 id="1三级模式"><a href="#1．三级模式" class="headerlink" title="1．三级模式"></a>1．三级模式</h3><p> 数据库系统可以分为外模式、概念模式和内模式三个层次。</p>
<p>（1）<strong>概念模式（模式、逻辑模式）</strong>：用以<strong>描述整个数据库中数据库的逻辑结构，描述现实世界中的实体及其性质与联系，定义记录、数据项、数据的完整性约束条件及记录之间的联系，是数据项值的框架。</strong>概念模式通常还包含有访问控制、保密定义、完整性检查等方面的内容，以及概念/物理之间的映射。概念模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个概念模式。</p>
<p>（2）<strong>外模式（子模式、用户模式）</strong>：用以<strong>描述用户看到或使用的那部分数据的逻辑结构，用户根据外模式用数据操作语句或应用程序去操作数据库中的数据。</strong>外模式主要描述组成用户视图的各个记录的组成、相互关系、数据项的特征、数据的安全性和完整性约束条件。外模式是数据库用户（包括程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。一个数据库可以有多个外模式。一个应用程序只能使用一个外模式。</p>
<p>（3）<strong>内模式</strong>：是<strong>整个数据库的最低层表示，不同于物理层，它假设外存是一个无限的线性地址空间。</strong>内模式定义的是存储记录的类型、存贮域的表示、存贮记录的物理顺序，指引元、索引和存贮路径等数据的存贮组织。内模式是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。概念模式是数据库的中心与关键；内模式依赖于概念模式，独立于外模式和存储设备；外模式面向具体的应用，独立于内模式和存储设备；应用程序依赖于外模式，独立于概念模式和内模式。</p>
<h3 id="2三个级别"><a href="#2．三个级别" class="headerlink" title="2．三个级别"></a>2．三个级别</h3><p>与三级模式相对应，数据库系统可以划分为三个抽象级，分别是用户级、概念级和物理级。</p>
<p>（1）<strong>用户级数据库</strong>：对应于外模式，是最接近于用户的一级数据库，是用户看到和使用的数据库，又称用户视图。用户级数据库主要由外部记录组成，不同用户视图可以互相重叠，用户的所有操作都是针对用户视图进行。一个数据库可有多个不同的用户视图，每个用户视图由数据库某一部分的抽象表示所组成。 </p>
<p>（2）<strong>概念级数据库</strong>：对应于概念模式，介于用户级和物理级之间，是所有用户视图的最小并集，是DBA看到和使用的数据库，所以又称为DBA视图。概念级数据库由概念记录组成，一个数据库应用系统只有一个DBA视图，它把数据库作为一个整体的抽象表示。概念级模式把用户视图有机地结合成一个整体，综合平衡考虑所有用户要求，实现数据的一致性、最大限度降低数据冗余、准确地反映数据间的联系。</p>
<p>（3）<strong>物理级数据库</strong>：对应于内模式，是数据库的低层表示，它描述数据的实际存储组织，是最接近于物理存储的级，又称为内部视图。<strong>物理级数据库由内部记录组成，物理级数据库并不是真正的物理存储，而是最接近于物理存储的级。</strong></p>
<h3 id="3两级独立性"><a href="#3．两级独立性" class="headerlink" title="3．两级独立性"></a>3．两级独立性</h3><p>DBS两级独立性是指物理独立性和逻辑独立性。三个抽象级间通过两级映射（外模式/模式映射，模式/内模式映射）进行相互转换，使得数据库的三级形成一个统一的整体。</p>
<p>（1）<strong>物理独立性</strong>。物理独立性是指用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的。当数据的物理存储改变时，应用程序不需要改变。物理独立性存在于概念模式和内模式之间的映射转换，说明物理组织发生变化时应用程序的独立程度。</p>
<p>（2）<strong>逻辑独立性</strong>。逻辑独立性是指用户的应用程序与数据库中的逻辑结构是相互独立的。当数据的逻辑结构改变时，应用程序不需要改变。逻辑独立性存在于外模式和概念模式之间的映射转换，说明概念模式发生变化时应用程序的独立程度。</p>
<p>逻辑独立性比物理独立性更难实现。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>设计DBS时，一般先用图或表的形式抽象地反映数据彼此之间的关系，称为建立数据模型。现有的数据库系统均是基于某种数据模型的，因此，了解数据模型的基本概念是学习数据库系统的基础。</p>
<h2 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h2><p>数据模型主要有两大类，分别是<strong>概念数据模型（实体联系模型）</strong>和<strong>基本数据模型（结构数据模型）</strong>。 </p>
<p>概念数据模型是按照用户的观点来对数据和信息建模，主要用于数据库设计。概念模型主要用实体-联系方法（Entity-Relationship Approach）表示，所以也称E-R模型。有关E-R模型的设计方法，请阅读2.5节。 </p>
<p>基本数据模型是按照计算机系统的观点来对数据和信息建模，主要用于DBMS的实现。基本数据模型是数据库系统的核心和基础，通常由数据结构、数据操作和完整性约束三部分组成，其中数据结构是对系统静态特性的描述，数据操作是对系统动态特性的描述，完整性约束是一组完整性规则的集合。</p>
<p>常用的基本数据模型有层次模型、网状模型、关系模型和面向对象模型。</p>
<p>（1）<strong>层次模型</strong>：用树型结构表示实体类型及实体间联系。层次模型的优点是记录之间的联系通过指针来实现，查询效率较高。层次模型的缺点是只能表示1:n联系，虽然有多种辅助手段实现m:n联系，但较复杂，用户不易掌握。由于层次顺序的严格和复杂，引起数据的查询和更新操作很复杂，应用程序的编写也比较复杂。</p>
<p>（2）<strong>网状模型</strong>：用有向图表示实体类型及实体间联系。网状模型的优点是记录之间的联系通过指针实现，m:n联系也容易实现，查询效率高。其缺点是编写应用程序比较复杂，程序员必须熟悉数据库的逻辑结构。</p>
<p>（3）<strong>关系模型</strong>：用表格结构表达实体集，用外键（外码）表示实体间联系。其优点有：建立在严格的数学概念基础上；概念单一（关系），结构简单、清晰，用户易懂易用；存取路径对用户透明，从而数据独立性、安全性好，简化数据库开发工作。关系模型的缺点主要是由于存取路径透明，查询效率往往不如非关系数据模型。</p>
<p>（4）<strong>面向对象模型</strong>：用面向对象观点来描述现实世界实体的逻辑组织、对象间限制、联系等的模型。一个面向对象数据库系统是一个持久的、可共享的对象库的存储和管理者，而一个对象库是由一个面向对象模型所定义的对象的集合体。面向对象数据库模式是类的集合，面向对象模型提供了一种类层次结构。在面向对象数据库模式中，一组类可以形成一个类层次，一个面向对象数据库可能有多个类层次。在一个类层次中，一个类继承其所有超类的全部属性、方法和消息。面向对象的数据库系统在逻辑上和物理上从面向记录上升为面向对象、面向可具有复杂结构的一个逻辑整体。允许用自然的方法，并结合数据抽象机制在结构和行为上对复杂对象建立模型，从而大幅度提高管理效率，降低用户使用复杂性。</p>
<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>我们先学习几个相关的基本概念。</p>
<p>（1）<strong>域</strong>：一组具有相同数据类型的值的集合。</p>
<p>（2）<strong>笛卡尔积</strong>：给定一组域D1、D2、…、Dn，这些域中可以有相同的。它们的笛卡尔积为：D1×D2×…×Dn = {(d1，d2，…，dn)|dj∈Dj，j＝1，2，…，n}。其中每一个元素（d1，d2，…，dn）叫作一个n元组（简称为元组）。元组中的每一个值dj叫作一个分量。</p>
<p>（3）<strong>关系</strong>：D1×D2×…×Dn的子集叫作在域D1、D2、…、Dn上的关系，用R(D1，D2，…，Dn)表示。这里R表示关系的名字，n是关系的目或度。</p>
<p>关系中的每个元素是关系中的元组，通常用t表示。关系是笛卡尔积的子集，所以关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性。</p>
<p> 若关系中的某一属性组（一个或多个属性）的值能唯一地标识一个元组，则称该属性组为候选码（候选键）。若一个关系有多个候选码，则选定其中一个作为主码（主键）。主码的所有属性称为主属性。不包含在任何侯选码中的属性称为非码属性（非主属性）。在最简单的情况下，侯选码只包含一个属性。在最极端的情况下，关系模式所有属性的组合构成关系模式的侯选码，称为全码。</p>
<p>关系可以有三种类型：基本关系（基本表、基表）、查询表和视图表。基本表是实际存在的表，它是实际存储数据的逻辑表示。查询表是查询结果对应的表。视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。</p>
<p> 基本关系具有以下<strong>六条性质</strong>：</p>
<p>（1）列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。</p>
<p>（2）不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</p>
<p>（3）列的顺序无所谓，即列的次序可以任意交换。</p>
<p>（4）任意两个元组不能完全相同。但在大多数实际关系数据库产品中，例如ORACLE等，如果用户没有定义有关的约束条件，它们都允许关系表中存在两个完全相同的元组。</p>
<p>（5）行的顺序无所谓，即行的次序可以任意交换。</p>
<p>（6）分量必须取原子值，即每一个分量都必须是不可分的数据项。关系的描述称为关系模式，一个关系模式应当是一个五元组，它可以形式化地表示为：R(U，D，DOM，F)。其中R为关系名，U为组成该关系的属性名集合，D为属性组U中属性所来自的域，DOM为属性向域的映象集合，F为属性间数据的依赖关系集合。关系模式通常可以简记为R(A1，A2，…，An)。其中R为关系名，A1、A2、…、An为属性名。</p>
<p>关系实际上就是关系模式在某一时刻的状态或内容。也就是说，关系模式是型，关系是它的值。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。但在实际当中，常常把关系模式和关系统称为关系，读者可以从上下文中加以区别。</p>
<p>在关系模型中，实体以及实体间的联系都是用关系来表示。在一个给定的现实世界领域中，相应于所有实体及实体之间的联系的关系的集合构成一个关系数据库。</p>
<p>关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述，是关系模式的集合。关系数据库的值也称为关系数据库，是关系的集合。关系数据库模式与关系数据库通常统称为关系数据库。</p>
<h2 id="规范化理论"><a href="#规范化理论" class="headerlink" title="规范化理论"></a>规范化理论</h2><p>设有一个关系模式R（SNAME，CNAME，TNAME TADDRESS），其属性分别表示学生姓名、选修的课程名、任课教师姓名和任课教师地址。仔细分析一下，我们就会发现这个模式存在下列存储异常的问题：</p>
<p>（1）数据冗余：如果某门课程有100个学生选修，那么在R的关系中就要出现100个元组，这门课程的任课教师姓名和地址也随之重复出现100次。</p>
<p>（2）修改异常：由于上述冗余问题，当需要修改这个教师的地址时，就要修改100个元组中的地址值，否则就会出现地址值不一致的现象。</p>
<p>（3）插入异常：如果不知道听课学生名单，这个教师的任课情况和家庭地址就无法进入数据库；否则就要在学生姓名处插入空值。</p>
<p>（4）删除异常：如果某门课程的任课教师要更改，那么原来任课教师的地址将随之丢失。因此，关系模式R虽然只有四个属性，但却是性能很差的模式。如果把R分解成下列两个关系模式：R1（SNAME，CNAME）和R2（CNAME，TNAME，TADDRESS），则能消除上述的存储异常现象。</p>
<p>为什么会产生这些异常呢？与关系模式属性值之间的联系直接有关。在模式R中，学生与课程有直接联系，教师与课程有直接联系，而教师与学生无直接联系，这就产生了模式R的存储异常。因此，模式设计强调“每个联系单独表达”是一条重要的设计原则，把R分解成R1和R2是符合这条原则的。</p>
<h3 id="1函数依赖"><a href="#1．函数依赖" class="headerlink" title="1．函数依赖"></a>1．函数依赖</h3><p>设R(U)是属性U上的一个关系模式，X和Y是U的子集，r为R的任一关系，如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X，记为X→ Y。</p>
<p>从函数依赖的定义可以看出，如果有X→U在关系模式R(U)上成立，并且不存在X的任一真子集‘X′使X′→U成立，那么称X是R的一个候选键。也就是X值惟一决定关系中的元组。由此可见，函数依赖是键概念的推广，键是一种特殊的函数依赖。</p>
<p> 在R(U)中，如果X→Y，并且对于X的任何一个真子集X′，都有X′→Y不成立，则称Y对X完全函数依赖。若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖。在R(U)中，如果X→Y（Y不是X的真子集），且Y→X不成立，Y→Z，则称Z对X传递函数依赖。设U是关系模式R的属性集，F是R上成立的只涉及到U中属性的FD集，则有以下三条推理规则：</p>
<p>（1）自反性：若X Y U，则X→Y在R上成立；</p>
<p>（2）增广性：若X→Y在R上成立，且Z U，则XZ→YZ在R上成立；</p>
<p>（3）传递性：若X→Y和Y→Z在R上成立，则X→Z在R上成立。这里XZ，YZ等写法表示X∪Z，Y∪Z。</p>
<p>上述三条推理规则是函数依赖的一个正确的和完备的推理系统。</p>
<p>根据上述三条规则还可以推出其他三条常用的推理规则：</p>
<p>（1）合并规则：若X→Y和X→Z在R上成立，则X→YZ在R上成立；</p>
<p>（2）分解规则：若X→Y在R上成立，且Z∈Y，则X→Z在R上成立；</p>
<p>（3）伪传递规则：若X→Y和WY→Z在R上成立，则WX→Z在R上成立。 在关系模式R(U，F)中为F所逻辑蕴含的函数依赖全体叫做F的闭包，记作F+。</p>
<p>设F为属性集U上的一组函数依赖，X是U的子集，那么相对于F属性集X的闭包用X+表示，它是一个从F集使用推理规则推出的所有满足X→A的属性A的集合：X+={属性A|X→A在F+中}</p>
<p>如果G+=F+，就说函数依赖集F覆盖G（F是G的覆盖，或G是F的覆盖），或F与G等价。如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集，也称为最小依赖集或最小覆盖。</p>
<p>（1）F中任一函数依赖的右部仅含有一个属性；</p>
<p>（2）F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价；</p>
<p>（3）F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}∪{Z→A}与F等价。</p>
<h3 id="2范式"><a href="#2．范式" class="headerlink" title="2．范式"></a>2．范式</h3><p>（1）第一范式（1NF）：如果关系模式R的每个关系r的属性值都是不可分的原子值，那么称 R是第一范式的模式，r是规范化的关系。关系数据库研究的关系都是规范化的关系。</p>
<p>（2）第二范式（2NF）：若关系模式R是1NF，且每个非主属性完全函数依赖于候选键，那么称R是2NF模式。</p>
<p>（3）第三范式（3NF）: 如果关系模式R是2NF，且每个非主属性都不传递依赖于R的候选码，则称R是3NF。</p>
<p>（4）BC范式（BCNF）：若关系模式R是1NF，且每个属性都不传递依赖于R的候选键，那么称R是BCNF模式。</p>
<p>上述四种范式之间有如下联系：</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps50.png" alt="img"> </p>
<h3 id="3关系模式分解"><a href="#3．关系模式分解" class="headerlink" title="3．关系模式分解"></a>3．关系模式分解</h3><p>如果某关系模式存在存储异常问题，则可通过分解该关系模式来解决问题。把一个关系模式分解成几个子关系模式，需要考虑的是该分解是否保持函数依赖，是否是无损联接。</p>
<p>无损联接分解的形式定义如下：设R是一个关系模式，F是R上的一个函数依赖（FD）集。R分解成数据库模式δ={R1，……，RK}。如果对R中每一个满足F的关系r 都有下式成立：</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps51.png" alt="img"> 那么称分解δ相对于F是无损联接分解，否则称为损失联接分解。</p>
<p>下面是一个很有用的无损联接分解判定定理。</p>
<p>设ρ=｛R1，R2｝是R的一个分解，F是R上的FD集，那么分解ρ相对于F是无损分解的充分必要条件是：(R1∩R2)→(R1-R2)或(R1∩R2)→(R2-R1)。希赛教育专家提示：这两个条件只要有任意一个条件成立就可以了。</p>
<p>设数据库模式δ={R1……，RK}是关系模式R的一个分解，F是R上的FD集，δ中每个模式Ri上的FD集是Fi。如果{F1，F2，……，Fk}与F是等价的（即相互逻辑蕴涵），那么我们称分解δ保持FD。如果分解不能保持FD，那么δ的实例上的值就可能有违反FD的现象</p>
<h2 id="反规范化理论"><a href="#反规范化理论" class="headerlink" title="反规范化理论"></a>反规范化理论</h2><p>前文已经介绍了规范化理论，在对数据模型进行规范化时，主要通过<strong>拆分</strong>的方式达到目的，而不断的拆分带来了新的问题。因为<strong>对多个拆分后的表进行查询操作时，需要涉及大量的连接操作，这使得查询变得费时与低效</strong>。为了有效的解决此问题，提出了反规范化技术，该技术与规范化理论做法刚好相反，而希望达到的目标主要是<strong>提高查询效率</strong>。</p>
<p>常用的反规范技术包括：<strong>增加冗余列</strong>、<strong>增加派生列</strong>、<strong>重新组表</strong>、<strong>分割表</strong>。</p>
<h3 id="1增加派生列"><a href="#1．增加派生列" class="headerlink" title="1．增加派生列"></a>1．增加派生列</h3><p>加派生列指<strong>增加的列由表中其它数据计算生成</strong>。它的作用是<strong>在查询时减少连接操作，避免使用集函数</strong>。例如，表中有单价，也有数量，此时增加列“总额”，由于总额=单价*数量，所以总额就是一个派生列。 </p>
<h3 id="2增加冗余列"><a href="#2．增加冗余列" class="headerlink" title="2．增加冗余列"></a>2．增加冗余列</h3><p>增加冗余列是指在多个表中具有相同的列，它常用来在查询时避免连接操作。</p>
<h3 id="3重新组表"><a href="#3．重新组表" class="headerlink" title="3．重新组表"></a>3．重新组表</h3><p> 重新组表指如果许多用户需要查看两个表连接出来的结果数据，则<strong>把这两个表重新组成一个表来减少连接而提高性能</strong>。</p>
<h3 id="4分割表"><a href="#4．分割表" class="headerlink" title="4．分割表"></a>4．分割表</h3><p>有时对表做分割可以提高性能。表分割有两种方式：</p>
<p><strong>水平分割</strong>：根据一列或多列数据的值把数据行放到两个独立的表中。水平分割通常在下面的情况下使用：</p>
<p>① 表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度。</p>
<p>② 表中的数据本来就有独立性。例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</p>
<p>③ 需要把数据存放到多个介质上。水平分割会给应用增加复杂度，它通常在查询时需要多个表名，查询所有数据需要union操作。</p>
<p>在许多数据库应用中，这种复杂性会超过它带来的优点，因为只要索引关键字不大，则在索引用于查询时，表中增加两到三倍数据量，查询时也就增加读一个索引层的磁盘次数。</p>
<p><strong>垂直分割</strong>：把主码和一些列放到一个表，然后把主码和另外的列放到另一个表中。如果一个表中某些列常用，而另外一些列不常用，则可以采用垂直分割，另外垂直分割可以使得数据行变小，一个数据页就能存放更多的数据，在查询时就会减少I/O次数。其缺点是需要管理冗余列，查询所有数据需要join操作。</p>
<h3 id="数据库的控制功能"><a href="#数据库的控制功能" class="headerlink" title="数据库的控制功能"></a>数据库的控制功能</h3><p>DBMS运行的基本工作单位是事务，事务是用户定义的一个数据库操作序列，这些操作序列要么全做要么全都不做，是一个不可分割的工作单位。事务具有以下特性（ACID特性）：</p>
<p>（1）原子性（Atomicity）：事务是数据库的逻辑工作单位，事务的所有操作在数据库中要么全做要么全都不做。</p>
<p>（2）一致性（Consistency）：事务的执行使数据库从一个一致性状态变到另一个一致性状态。</p>
<p>（3）隔离性（Isolation）：一个事务的执行不能被其他事务干扰。</p>
<p>（4）持续性（Durability，永久性）：指一个事务一旦提交，它对数据库的改变必须是永久的，即便系统出现故障时也是如此。</p>
<p>事务通常以BEGIN TRANSACTION（事务开始）语句开始，以COMMIT或ROLLBACK语句结束。COMMIT称为事务提交语句，表示事务执行成功地结束，把事务对数据库的修改写入磁盘（事务对数据库的操作首先是在缓冲区中进行的）。ROLLBACK称为事务回滚语句，表示事务执行不成功地结束，即把事务对数据库的修改进行恢复。</p>
<p>从<strong>终端用户</strong>来看，<strong>事务是一个原子，是不可分割的操作序列</strong>。事务中包括的所有操作要么都做，要么都不做（就效果而言）。事务不应该丢失，或被分割地完成。</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>在多用户共享系统中，许多事务可能同时对同一数据进行操作，称为并发操作，此时数据库管理系统的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，同时避免用户得到不正确的数据。</p>
<h3 id="1并发操作的问题"><a href="#1．并发操作的问题" class="headerlink" title="1．并发操作的问题"></a>1．并发操作的问题</h3><p>数据库的并发操作带来的主要问题有：丢失更新问题，不一致分析问题（读过时的数据），依</p>
<p>赖于未提交更新的问题（读脏数据）。这3个问题需要DBMS的并发控制子系统来解决。</p>
<p>（1）丢失更新（丢失修改）：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，T1的修改被丢失。</p>
<p>（2）读过时的数据（不可重复读）：事务T1读取某一数据，事务T2读取并修改了同一数据，T1为了对读取值进行校对再读此数据，得到了不同的结果。例如，T1读取B＝100，T2读取B并把B改为200，T1再读B得200，与第一次读取值不一致。</p>
<p>（3）读脏数据。事务T1修改某一数据，事务T2读取同一数据，而T1由于某种原因被撤销，则T2读到的数据就为“脏”数据，即不正确的数据。例如，T1把C由100改为200，T2读到C为200，而事务T1由于被撤销，其修改宣布无效，C恢复为原值100，而T2却读到了C为200，与数据库内容不一致。</p>
<p>例如，假设某3个事务T1、T2和T3并发执行的过程如表2-1所示。</p>
<p>表2-1事务并发执行的过程</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>T1</th>
<th>T2</th>
<th>T3</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>读D1=50</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t2</td>
<td>读D2=100</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t3</td>
<td>读D3=300</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t4</td>
<td>X1=D1+D2+D3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t5</td>
<td></td>
<td>读D2=100</td>
<td></td>
</tr>
<tr>
<td>t6</td>
<td></td>
<td>读D3=300</td>
<td></td>
</tr>
<tr>
<td>t7</td>
<td></td>
<td></td>
<td>读D2=100</td>
</tr>
<tr>
<td>t8</td>
<td></td>
<td>D2=D3-D2</td>
<td></td>
</tr>
<tr>
<td>t9</td>
<td></td>
<td>写D2</td>
<td></td>
</tr>
<tr>
<td>t10</td>
<td>读D1=50</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t11</td>
<td>读D2=200</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t12</td>
<td>D3=300读</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t13</td>
<td>X1=D1+D2+D3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t14</td>
<td>验算不对</td>
<td></td>
<td>D2=D2+50</td>
</tr>
<tr>
<td>t15</td>
<td></td>
<td></td>
<td>写D2</td>
</tr>
</tbody>
</table>
</div>
<p>在表2-1中，事务T1、T2分别对数据D1、D2和D3进行读写操作，在t4时刻，事务T1将D1、D2和D3相加存入X1，X1等于450。在t8时刻，事务T2将D3减去D2存入D2，D2等于200。在t13时刻，事务T1将D1、D2和D3相加存入X1，X1等于550，验算结果不对。这种情况就属于<strong>不可重复读</strong>。在t14时刻事务T3将D2加50存入D2，D2等于150。这样，就丢失了事务T2对D2的修改，这种情况就属于<strong>丢失更新</strong>。</p>
<h3 id="2封锁的类型"><a href="#2．封锁的类型" class="headerlink" title="2．封锁的类型"></a>2．封锁的类型</h3><p>处理并发控制的主要方法是采用封锁技术，主要有有两种类型的封锁，分别是<strong>X封锁</strong>和<strong>S封锁</strong>。</p>
<p>（1）排他型封锁（X封锁）：如果事务T对数据A（可以是数据项、记录、数据集以至整个数据库）实现了X封锁，那么只允许事务T读取和修改数据A，其他事务要等事务T解除X封锁以后，才能对数据A实现任何类型的封锁。可见X封锁只允许一个事务独锁某个数据，具有排他性。</p>
<p>（2）共享型封锁（S封锁）：X封锁只允许一个事务独锁和使用数据，要求太严。需要适当从宽，如可以允许并发读，但不允许修改，这就产生了S封锁概念。S封锁的含义是：如果事务T对数据A实现了S封锁，那么允许事务T读取数据A，但不能修改数据A，在所有S封锁解除之前决不允许任何事务对数据A实现X封锁。</p>
<h3 id="3封锁协议"><a href="#3．封锁协议" class="headerlink" title="3．封锁协议"></a>3．封锁协议</h3><p> 在多个事务并发执行的系统中，主要采取封锁协议来进行处理。</p>
<p>（1）一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。一级封锁协议可防止丢失更新，并保证事务T是可恢复的。但不能保证可重复读和不读脏数据。</p>
<p>（2）二级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，读完后即可释放S锁。二级封锁协议可防止丢失更新，还可防止读脏数据。但不能保证可重复读。</p>
<p>（3）三级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，直到事务结束才释放。三级封锁协议可防止丢失更新、防止读脏数据与数据重复读。</p>
<p>（4）两段锁协议：所有事务必须分两个阶段对数据项加锁和解锁。其中扩展阶段是在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；收缩阶段是在释放一个封锁之后，事务不能再申请和获得任何其他封锁。若并发执行的所有事务均遵守两段封锁协议，则对这些事务的任何并发调度策略都是可串行化的（可以避免丢失更新、不可重复读和读脏数据问题）。遵守两段封锁协议的事务可能发生死锁。</p>
<p>所谓封锁的粒度即是被封锁数据目标的大小，在关系数据库中封锁粒度有属性值、属性值集、元组、关系、某索引项（或整个索引）、整个关系数据库、物理页（块）等几种。</p>
<p><strong>封锁粒度小则并发性高，但开销大；封锁粒度大则并发性低，但开销小，综合平衡照顾不同需求以合理选取适当的封锁粒度是很重要的。</strong></p>
<h3 id="4死锁"><a href="#4．死锁" class="headerlink" title="4．死锁"></a>4．死锁</h3><p>采用封锁的方法固然可以有效防止数据的不一致性，但封锁本身也会产生一些麻烦，最主要就是死锁问题。</p>
<p>死锁是指<strong>多个用户申请不同封锁，由于申请者均拥有一部分封锁权而又需等待另外用户拥有的部分封锁而引起的永无休止的等待</strong>。</p>
<p>死锁是可以避免的，目前采用的办法有如下几种。</p>
<p>（1）<strong>预防法</strong>：采用一定的操作方式以避免死锁的出现，顺序申请法、一次申请法等即是此类方法。顺序申请法是指对封锁对象按序编号，用户申请封锁时必须按编号顺序（从小到大或反之）申请，这样能避免死锁发生；一次申请法是指用户在一个完整操作过程中必须一次性申请它所需要的所有封锁，并在操作结束后一次性归还所有封锁，这样能避免死锁的发生。</p>
<p>（2）<strong>死锁的解除法</strong>：允许产生死锁，并在死锁产生后通过解锁程序以解除死锁。这种方法中需要有两个程序，一个是死锁检测程序，用它测定死锁是否发生；另一个是解锁程序，一旦检测到系统已产生死锁，则启动解锁程序以解除死锁。</p>
<h2 id="备份与恢复技术"><a href="#备份与恢复技术" class="headerlink" title="备份与恢复技术"></a>备份与恢复技术</h2><p>数据库系统中可能发生各种各样的故障，大致可以分以下几类：</p>
<p>（1）<strong>事务内部的故障</strong>。事务内部的故障有的是可以通过事务程序本身发现的，有的是非预期的，不能由事务程序处理。例如，输入数据违反完整性约束、运算溢出、并行事务发生死锁而被选中撤销该事务等。事务故障意味着事务没有到达预期的终点（COMMIT或者显式的ROLLBACK），因此，数据库可能处于不正确状态。这样，系统就要强行回滚此事务，即撤销该事务已经做出的任何对数据库的修改，使得该事务好像根本没有启动一样。</p>
<p>（2）<strong>系统范围内的故障</strong>。系统故障是指造成系统停止运转的任何事件，使得系统要重新启动。例如，中央处理器故障、操作系统故障、突然停电等，这类故障影响正在运行的所有事务，但不破坏数据库。这时内存中的内容，尤其是数据库缓冲区中的内容都将丢失，使得运行事务都非正常终止，从而造成数据库可能处于不正确的状态，数据库恢复子系统必须在系统重新启动时让所有非正常终止的事务回滚，把数据库恢复到正确的状态。</p>
<p>（3）<strong>介质故障</strong>。系统故障常称为软故障（SoftCrash），介质故障称为硬故障（HardCrash）。硬故障指外存故障，如磁盘的磁头碰撞、瞬时的强磁场干扰等。这类故障将破坏数据库或部分数据库，并影响正存取这部分数据的所有事务，这类故障比前两类故障发生的可能性小得多，但破坏性最大。</p>
<p>（4）<strong>计算机病毒</strong>。计算机病毒是一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序，这种程序与其他程序不同，它像微生物学所称的病毒一样可以繁殖和传播，并造成对计算机系统包括数据库的危害。</p>
<p>总结各类故障，对数据库的影响有两种可能性，<strong>一是数据库本身被破坏</strong>，<strong>二是数据库没有被破坏，但数据可能不正确，这是因为事务的运行被终止所造成的</strong>。</p>
<h3 id="1数据备份"><a href="#1．数据备份" class="headerlink" title="1．数据备份"></a>1．数据备份</h3><p>备份（转储）是指DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本（后援副本）。当数据库遭到破坏后就可以利用后备副本把数据库恢复，这时，数据库只能恢复到备份时的状态，从那以后的所有更新事务必须重新运行才能恢复到故障时的状态。备份可分为静态备份（冷备份）和动态备份（热备份）。静态备份是指备份期间不允许（或不存在）对数据库进行任何存取、修改活动。静态备份简单，但备份必须等待用户事务结束才能进行，同样，新的事务必须等待备份结束才能执行。显然，这会降低数据库的可用性；动态备份是指备份期间允许对数据库进行存取或修改，即备份和用户事务可以并发执行。动态备份可克服静态备份的缺点，但是，备份结束时后援副本上的数据并不能保证正确有效。备份还可以分为海量备份和增量备份。海量备份是指每次备份全部数据库。增量备份则指每次只备份上次备份后更新过的数据。如果数据库很大，事务处理又十分频繁，则增量备份方式是很有效的。</p>
<h3 id="2日志文件"><a href="#2．日志文件" class="headerlink" title="2．日志文件"></a>2．日志文件</h3><p>事务日志是针对数据库改变所做的记录，它可以记录针对数据库的任何操作，并将记录结果保存在独立的文件中。这种文件就称为日志文件。对于任何一个事务，事务日志都有非常全面的记录，根据这些记录可以将数据文件恢复成事务前的状态。从事务动作开始，事务日志就处于记录状态，事务执行过程中对数据库的任何操作都记录在内，直到用户提交或回滚后才结束记录。日志文件是用来记录对数据库每一次更新活动的文件，在动态备份方式中，必须建立日志文件，后援副本和日志文件综合起来才能有效地恢复数据库；在静态备份方式中，也可以建立日志文件，当数据库毁坏后可重新装入后援副本把数据库恢复到备份结束时刻的正确状态，然后利用日志文件，把已完成的事务进行重做处理，对故障发生时尚未完成的事务进行撤销处理。这样不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态。例如，在热备份期间的某时刻t1，系统把数据A=100备份到了磁带上，而在时刻t2，某一事务对A进行了修改使A=200。备份结束，后备副本上的A已是过时的数据了。为此，必须把备份期间各事务对数据库的修改活动登记下来，建立日志文件。这样，后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态。事务在运行过程中，系统把事务开始、事务结束（包括COMMIT和ROLLBACK），以及对数据库的插入、删除、修改等每一个操作作为一个登记记录存放到日志文件中。每个记录包括的主要内容有：执行操作的事务标识、操作类型、更新前数据的旧值（对插入操作而言此项为空值）、更新后的新值（对删除操作而言此项为空值）。登记的次序严格按并行事务操作执行的时间次序，同时遵循“先写日志文件”的规则。写一个修改到数据库中和写一个表示这个修改的日志记录到日志文件中是两个不同的操作，有可能在这两个操作之间发生故障，即这两个写操作只完成了一个，如果先写了数据库修改，而在日志记录中没有登记这个修改，则以后就无法恢复这个修改了。因此，为了安全，应该先写日志文件，即首先把修改记录写到日志文件上，然后再写数据库的修改。这就是“先写日志文件”的原则。</p>
<h3 id="3数据恢复"><a href="#3．数据恢复" class="headerlink" title="3．数据恢复"></a>3．数据恢复</h3><p>把数据库从错误状态恢复到某一个已知的正确状态的功能，称为数据库的恢复。数据恢复的基本原理就是冗余，建立冗余的方法有数据备份和登录日志文件等。可根据故障的不同类型，采用不同的恢复策略。</p>
<h4 id="1事务故障的恢复"><a href="#（1）事务故障的恢复" class="headerlink" title="（1）事务故障的恢复"></a>（1）事务故障的恢复</h4><p>事务故障的恢复是由<strong>系统自动完成</strong>的，对用户是透明的（不需要DBA的参与）。其步骤如下：</p>
<p>①反向扫描日志文件，查找该事务的更新操作。</p>
<p>②对该事务的更新操作执行逆操作。</p>
<p>③继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</p>
<p>④如此处理下去，直至读到此事务的开始标记，事务故障恢复完成。</p>
<h4 id="2系统故障的恢复"><a href="#（2）系统故障的恢复" class="headerlink" title="（2）系统故障的恢复"></a>（2）系统故障的恢复</h4><p>系统故障的恢复在系统重新启动时自动完成，不需要用户干预。其步骤如下：</p>
<p>①正向扫描日志文件，找出在故障发生前已经提交的事务，将其事务标识记入重做（Redo）队列。同时找出故障发生时尚未完成的事务，将其事务标识记入撤销（Undo）队列。</p>
<p>②对撤销队列中的各个事务进行撤销处理：反向扫描日志文件，对每个Undo事务的更新操作执行逆操作。</p>
<p>③对重做队列中的各个事务进行重做处理：正向扫描日志文件，对每个Redo事务重新执行日志文件登记的操作。</p>
<h4 id="3介质故障与病毒破坏的恢复"><a href="#（3）介质故障与病毒破坏的恢复" class="headerlink" title="（3）介质故障与病毒破坏的恢复"></a>（3）介质故障与病毒破坏的恢复</h4><p>介质故障与病毒破坏的恢复步骤如下：</p>
<p>①装入最新的数据库后备副本，使数据库恢复到最近一次备份时的一致性状态。</p>
<p>②从故障点开始反向扫描日志文件，找出已提交事务标识并记入Redo队列。</p>
<p>③从起始点开始正向扫描日志文件，根据Redo队列中的记录，重做已完成的任务，将数据库恢复至故障前某一时刻的一致状态。</p>
<h4 id="4有检查点的恢复技术"><a href="#（4）有检查点的恢复技术" class="headerlink" title="（4）有检查点的恢复技术"></a>（4）有检查点的恢复技术</h4><p>检查点记录的内容可包括建立检查点时刻所有正在执行的事务清单，以及这些事务最近一个日志记录的地址。采用检查点的恢复步骤如下：</p>
<p>①从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。</p>
<p>②由该检查点记录得到检查点建立时所有正在执行的事务清单队列（A）。</p>
<p>③建立重做队列（R）和撤销队列（U），把A队列放入U队列中，R队列为空。</p>
<p>④从检查点开始正向扫描日志文件，若有新开始的事务T1，则把T1放入U队列；若有提交的事务T2，则把T2从U队列移到R队列；直至日志文件结束。</p>
<p>⑤对U队列的每个事务执行Undo操作，对R队列的每个事务执行Redo操作。</p>
<h2 id="数据库的安全性"><a href="#数据库的安全性" class="headerlink" title="数据库的安全性"></a>数据库的安全性</h2><p>DBS的信息安全性在技术上可以依赖于两种方式，一种是DBMS本身提供的用户身份识别、视图、使用权限控制、审计等管理措施，例如，大型数据库管理系统如Oracle和Sybase等均有此功能；另一种就是靠数据库的应用程序来实现对数据库访问进行控制和管理，例如，Dbase、Foxbase、Foxpro等开发的数据库应用程序，很多数据的安全控制都由应用程序里面的代码来实现。</p>
<h3 id="1用户认证"><a href="#1．用户认证" class="headerlink" title="1．用户认证"></a>1．用户认证</h3><p>用户的身份认证是用户使用DBMS系统的第一个环节，用户的身份鉴别是DBMS识别什么用户能做什么事情的依据。</p>
<h4 id="1口令认证"><a href="#（1）口令认证。" class="headerlink" title="（1）口令认证。"></a>（1）口令认证。</h4><p>口令（password，密码）是一种身份认证的基本形式，用户在建立与DBMS的访问连接前必须提供正确的用户账号（userid）和口令，DBMS与自身保存的用户列表中的用户标识和口令比较，如果匹配则认证成功，允许用户使用数据库系统；如果不匹配则返回拒绝信息。这种认证判断过程往往是数据库登录的第一步，用户账户（account）的账号和口令是口令认证方式中的核心，用户信息可以保存在数据库内、操作系统内或者集中的目录服务器（DirectoryServer）用户身份证书库内。</p>
<h4 id="2强身份认证"><a href="#（2）强身份认证。" class="headerlink" title="（2）强身份认证。"></a>（2）强身份认证。</h4><p>在网络环境下，客户端到DBMS服务器可能经过多个环节，在身份认证期间，用户的信息和口令可能会经过很多不安全的结点（如路由器和服务器），而被信息的窃听者窃取。强身份认证过程使认证可以结合信息安全领域一些更深入的技术保障措施，来强化用户身份的鉴别，例如，与用户证书、智能卡、用户指纹识别等多种身份识别技术相结合。</p>
<h3 id="2用户角色"><a href="#2．用户角色" class="headerlink" title="2．用户角色"></a>2．用户角色</h3><p>按每个用户指定操作权限在用户数目比较多的时候往往是一项非常繁重的工作，所以DBMS提供角色来描述具有相同操作权限的用户集合，不同角色的用户授予不同的数据管理和访问操作权限。一般可以将权限角色分为3类，分别是数据库登录权限类、资源管理权限类和DBA权限类。</p>
<p>有了数据库登录权限的用户才能进入DBMS，才能使用DBMS所提供的各类工具和实用程序。同时，数据对象的创建者（owner）可以授予这类用户以数据查询、建立视图等权限。这类用户只能查阅部分数据库信息，不能修改数据库中的任何数据。</p>
<p>具有资源管理权限的用户，除了拥有上一类的用户权限外，还有创建数据库表、索引等数据对象的管理权限，可以在权限允许的范围内修改、查询数据库，还能将自己拥有的权限授予其他用户，可以申请审计。具有DBA权限的用户将具有数据库管理的全部权限，包括访问任何用户的任何数据，授予（或回收）用户的各种权限，创建各种数据对象，完成数据库的整库备份、装入重组及进行全系统的审计等工作。</p>
<p>当然，不同的DBMS，可能对用户角色的定义不尽相同，权限的划分的细致程度也远超过上面3种基本的类型，而基于角色的用户权限管理是现在每个主流数据库产品（例如，IBMDB2、Oracle、Sybase、MSSQLServer等）和一些专用的数据库产品（例如，NCRTeradata、HyperionEssbase等）都具有的特性。</p>
<h3 id="3数据授权"><a href="#3．数据授权" class="headerlink" title="3．数据授权"></a>3．数据授权</h3><p>同一类功能操作权限的用户，对数据库中数据对象管理和使用的范围又可能是不同的，因此DBMS除了要提供基于功能角色的操作权限控制外，还提供了对数据对象的访问控制，访问控制可以根据对控制用户访问数据对象的粒度从大到小分为4个层次。</p>
<p>（1）<strong>数据库级别</strong>：判断用户是否可以使用访问数据库里的数据对象，包括表、视图、存储过程。</p>
<p>（2）<strong>表级</strong>：判断用户是否可以访问关系里面的内容。</p>
<p>（3）<strong>行级</strong>：判断用户是否能访问关系中的一行记录的内容。</p>
<p>（4）<strong>属性级</strong>：判断用户是否能访问表关系中的一个列（属性、字段）的内容。</p>
<p>管理员把某用户可查询的数据和元素在逻辑上归并起来，简称一个或多个用户视图，并赋予名称，再把该视图的各种使用权限授予该用户（也可以授予多个用户）。DBMS对于用户的访问存取控制有以下两个基本的原则：</p>
<p>（1）<strong>隔离原则</strong>：用户只能存取他自己所有的和已经取得授权的数据对象。</p>
<p>（2）<strong>控制原则</strong>：用户只能按他所取得的数据存取方式存取数据，不能越权。</p>
<p>数据库授权可以分为静态授权和动态授权。一般意义上，可以把静态授权理解成为是DBMS的隐性授权，也就是说用户（或DBA）对他自己拥有的信息是不需要有指定的授权动作就拥有全权管理和操作的权限的。与静态授权相对应，只有数据对象的所有者或者DBA默认地拥有对数据的存取权，动态授权则允许这些用户把这些权力授予其他的用户，现在DBMS支持的SQL（StructuredQueryLanguage，结构化查询语言）语言里面有专门的授权语句。</p>
<h3 id="4数据库视图"><a href="#4．数据库视图" class="headerlink" title="4．数据库视图"></a>4．数据库视图</h3><p>视图可以被看成是虚拟表或存储查询。可通过视图访问的数据不作为独特的对象存储在数据库内。数据库内存储的是SELECT语句。SELECT语句的结果集构成视图所返回的虚拟表。用户可以用引用表时所使用的方法，在SQL语句中通过引用视图名称来使用虚拟表。使用视图可以实现下列功能：</p>
<p>（1）将用户限定在表中的特定行上。例如，只允许雇员看见工作跟踪表内记录其工作的行。</p>
<p>（2）将用户限定在特定列上。例如，对于那些不负责处理工资单的雇员，只允许他们看见雇员表中的姓名、工作电话和部门列，而不能看见任何包含工资信息或个人信息的列。</p>
<p>（3）将多个表中的列连接起来，使它们看起来像一个表。</p>
<p>（4）聚合信息而非提供详细信息。例如，显示一个列的和，或者列的最大值和最小值。</p>
<p>如果需要限制用户使用的数据，可以将视图作为一种安全机制。通过定义SELECT语句以检索将在视图中显示的数据来创建视图。SELECT语句引用的数据表称为视图的基表。</p>
<h3 id="5审计功能"><a href="#5．审计功能" class="headerlink" title="5．审计功能"></a>5．审计功能</h3><p>如果身份认证是一种事前的防范措施，审计则是一种事后监督的手段。跟踪也是DBMS提供的监视用户动作的功能，然而，审计和跟踪是两个不同的概念，主要是两者的目的不同。跟踪主要是满足系统调试的需要，捕捉到的用户行为记录往往只用于分析，而并不长久地保存，而审计作为一种安全检查的措施，会把系统的运行状况和用户访问数据库的行为记录以日志保存下来，这种日志往往作为一种稽查用户行为的一种证据。</p>
<p>根据审计对象的区分，有两种方式的审计，即用户审计和系统审计。用户审计时，DBMS的审计系统记下所有对自己表或视图进行访问的企图（包括成功的和不成功的）及每次操作的用户名、时间、操作代码等信息。这些信息一般都被记录在操作系统或DBMS的日志文件里面，利用这些信息可以对用户进行审计分析。系统审计由DBA进行，其审计内容主要是系统一级命令及数据对象的使用情况。</p>
<h2 id="数据库的完整性"><a href="#数据库的完整性" class="headerlink" title="数据库的完整性"></a>数据库的完整性</h2><p>数据库的完整性是指数据的正确性和相容性。数据库是否具备完整性关系到DBS能否真实地反映现实世界，因此维护数据库的完整性是非常重要的。</p>
<h3 id="1完整性约束条件"><a href="#1．完整性约束条件" class="headerlink" title="1．完整性约束条件"></a>1．完整性约束条件</h3><p>保证数据完整性的方法之一是设置完整性检查，即对数据库中数据设置一些约束条件，这是数据的语义体现。数据的完整性约束条件一般在数据模式中给出，并在运行时做检查，当不满足条件时立即向用户通报以便采取措施。</p>
<p>完整性约束条件一般指的是对数据库中数据本身的某些语法、语义限制，数据间的逻辑约束，以及数据变化时应遵守的规则等。所有这些约束条件一般均以谓词逻辑形式表示，即以具有真假值的原子公式及命题连接词（并且、或者、否定）所组成的逻辑公式表示。完整性约束条件作用对象可以是关系、元组、列三种。</p>
<p>数据库中数据的语法、语义限制与数据间的逻辑约束称为静态约束。它反映了数据及数据间的固有的逻辑特性，是最重要的一类完整性约束。静态约束包括静态列级约束（对数据类型的约束、对数据格式的约束、对取值范围或取值集合的约束、对空值的约束、其他约束）、静态元组约束、静态关系约束（实体完整性约束、参照完整性约束、函数依赖约束、统计约束）。</p>
<p>数据库中的数据变化应遵守的规则称为数据动态约束，它反映了数据库状态变迁的约束。动态约束包括动态列级约束（修改列定义时的约束、修改列值时的约束）、动态元组约束、动态关系约束。</p>
<h3 id="2完整性控制"><a href="#2．完整性控制" class="headerlink" title="2．完整性控制"></a>2．完整性控制</h3><p>完整性控制机制应该具有定义功能（提供定义完整性约束条件的机制）和检查功能（检查用户发出的操作请求是否违背了完整性约束条件）。如果发现用户的操作请求违背了约束条件，则采取一定的动作来保证数据的完整性。数据库的完整性可分为实体完整性、参照完整性和用户定义的完整性。</p>
<h4 id="1实体完整性"><a href="#（1）实体完整性" class="headerlink" title="（1）实体完整性"></a>（1）实体完整性</h4><p>实体完整性要求主码中的任一属性不能为空，所谓空值是“不知道”或“无意义”的值。之所以要保证实体完整性，主要是因为在关系中，每一个元组的区分是依据主码值的不同，若主码值取空值，则不能标明该元组的存在。</p>
<h4 id="2参照完整性"><a href="#（2）参照完整性" class="headerlink" title="（2）参照完整性"></a>（2）参照完整性</h4><p>若基本关系R中含有与另一基本关系S的主码PK相对应的属性组FK（FK称为R的外码），则参照完整性要求，对R中的每个元组在FK上的值必须是S中某个元组的PK值，或者为空值。参照完整性的合理性在于，R中的外码只能对S中的主码引用，不能是S中主码没有的值。例如，对于学生和选课表两个关系，选课表中的学号是外码，它是学生表的主键，若选课表中出现了某个学生表中没有的学号，即某个学生还没有注册，却已有了选课记录，这显然是不合理的。</p>
<p>对于参照完整性，需要明确以下问题：</p>
<p>①外码能否接受空值问题，根据实际应用决定。</p>
<p>②在被参照关系中删除元组的问题。</p>
<ul>
<li>级联删除：将参照关系中所有外码值与被参照关系中要删除元组主码值相同的元组一起删除。如果参照关系同时又是另一个关系的被参照关系，则这种删除操作会继续级联下去。</li>
<li>受限删除（一般系统默认）：仅当参照关系中没有任何元组的外码值与被参照关系中要删除元组的主码值相同时，系统才可以执行删除操作，否则拒绝执行删除操作。</li>
<li>置空删除：删除被参照关系的元组，并将参照关系中相应元组的外码值置为空值。</li>
</ul>
<p>③在参照关系中插入元组的问题。</p>
<ul>
<li>受限插入：仅当被参照关系中存在相应的元组时，其主码值与参照关系插入元组的外码值相同时，系统才执行插入操作，否则拒绝此操作.</li>
<li>递归插入：首先向被参照关系中插入相应的元组，其主码值等于参照关系插入元组的外码值，然后向参照关系插入元组。</li>
</ul>
<h4 id="3用户定义的完整性"><a href="#（3）用户定义的完整性" class="headerlink" title="（3）用户定义的完整性"></a>（3）用户定义的完整性</h4><p>实体完整性和参照完整性适用于任何关系型DBMS。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。</p>
<p>如果在一条语句执行完后立即检查，则称立即执行约束；如果在整个事务执行结束后再进行检查，则称延迟执行约束。完整性规则的五元组表示为（D，O，A，C，P），其中D表示约束作用的数据对象，O表示触发完整性检查的数据库操作，A表示数据对象必须满足的断言或语义约束，C表示选择A作用的数据对象值的谓词，P表示违反完整性规则时触发的过程。</p>
<h4 id="4触发器"><a href="#（4）触发器" class="headerlink" title="（4）触发器"></a>（4）触发器</h4><p>触发器是在关系型DBMS中应用得比较多的一种完整性保护措施。触发器的功能一般比完整性约束要强得多。一般而言，在完整性约束功能中，当系统检查出数据中有违反完整性约束条件时，则仅给出必要提示以通知用户，仅此而已。而触发器的功能则不仅仅起提示作用，它还会引起系统内自动进行某些操作以消除违反完整性约束条件所引起的负面影响。</p>
<p>所谓触发器，其抽象的含义即是一个事件的发生必然触发（或导致）另外一些事件的发生，其中前面的事件称为触发事件，后面的事件称为结果事件。触发事件一般即为完整性约束条件的否定。而结果事件即为一组操作用以消除触发事件所引起的不良影响。在目前数据库中事件一般表示为数据的插入、修改、删除等操作。希赛教育专家提示：触发器除了有完整性保护功能外，还有安全性保护功能。</p>
<h2 id="数据库性能"><a href="#数据库性能" class="headerlink" title="数据库性能"></a>数据库性能</h2><p>数据库性能的调整是数据库管理员的日常工作之一。性能调整工作可以从逻辑上和物理上两个方面进行。</p>
<h3 id="1sql的性能优化"><a href="#1．SQL的性能优化" class="headerlink" title="1．SQL的性能优化"></a>1．SQL的性能优化</h3><p>SQL（STructuredQueryLanguage，结构化查询语言）语句是用户访问关系数据库中数据的唯一方法，通常在一个关系数据库上，服务器的SQL进程会使用该服务器60%～90%的资源，大部分数据库效率的问题都是由于SQL语句编写不善引起的，所以SQL语句的性能优化十分重要。</p>
<p>为了编写出高效的SQL语句，首先应按照一定的具体规范来编写SQL语句，我们建议每一个DBA都应该收集和整理一份SQL编码规范。其次是在真实数据库上对这些SQL语句进行性能测试和跟踪并不断调整，达到最优后才正式上线运行。最后需要强调的是，随着数据量的变化和数据库版本升级后，往往会导致部分SQL性能下降，所以对SQL的跟踪优化是DBA的一项持续不断的工作。</p>
<h3 id="2数据库的性能优化"><a href="#2．数据库的性能优化" class="headerlink" title="2．数据库的性能优化"></a>2．数据库的性能优化</h3><p>DBS是一组程序作用在数据文件上对外提供服务，所以其本身的性能优化也十分重要，对其的优化工作主要是相应的参数调整，步骤一般如下：</p>
<p>（1）通过监视DBS的内存对象，获得系统性能指标，发现系统的性能缺陷及原因。</p>
<p>（2）针对导致系统性能缺陷的原因，进行相应的参数调整（如增加数据缓冲区的大小）。</p>
<p>（3）跟踪参数调整后系统的各项性能指标，看是否达到预期要求，否则继续调整。</p>
<p>以上3步反复循环迭代，持续进行，保证数据库本身运行状态的最优。</p>
<p>例如，Oracle通常利用定时执行statspacke.snap包收集数据库的运行状态，然后利用程序spreport.sql对两个采集点之间的数据产生报表，以分析这段时间数据库的各种运行指标。Sybase数据库用sp_sysmon、sp_monitor、sp_configure命令来采集和分析一定时间段内数据库的各种运行指标。</p>
<h3 id="3查询优化"><a href="#3．查询优化" class="headerlink" title="3．查询优化"></a>3．查询优化</h3><p>可以通过如下方法来优化查询：</p>
<p>（1）把数据、日志、索引放到不同的I/O设备上，增加读取速度。数据量（尺寸）越大，提高I/O越重要。</p>
<p>（2）纵向、横向分割表，减少表的尺寸。</p>
<p>（4）根据查询条件，建立索引，优化索引、优化访问方式，限制结果集的数据量。注意填充因子要适当（最好是使用默认值0）。索引应该尽量小，使用字节数小的列建索引好，不要对有限的几个值的列建单一索引。</p>
<p>（5）用OR的子句可以分解成多个查询，并且通过UNION连接多个查询。它们的速度只与是否使用索引有关，如果查询需要用到联合索引，用UNIONall执行的效率更高。</p>
<p>（6）在查询SELECT语句中用WHERE子句限制返回的行数，避免表扫描。如果返回不必要的数据，浪费了服务器的I/O资源，加重了网络的负担降低性能。如果表很大，在表扫描的期间将表锁住，禁止其他的联接访问表，后果严重。</p>
<p>（7）注意使用DISTINCT，在没有必要时不要用，它同UNION一样会使查询变慢。</p>
<p>（8）在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p>
<p>（9）一般在GROUPBY和HAVING子句之前就能剔除多余的行，所以尽量不要用它们来做剔除行的工作。</p>
<p>（10）尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句（存储过程是数据库服务器端的一段程序），是控制流语言的集合，速度当然快。存储过程有两种类型。一种类似于SELECT查询，用于检索数据，检索到的数据能够以数据集的形式返回给客户。另一种类似于INSERT或DELETE查询，它不返回数据，只是执行一个动作。有的服务器允许同一个存储过程既可以返回数据又可以执行动作。</p>
<p>（11）不要在一句话里再三地使用相同的函数，浪费资源，将结果放在变量里再调用更快。另外，还可以针对大量只读查询操作进行优化，常见的方法有：</p>
<ol>
<li>数据量小的数据，可以考虑不存储在数据库中，而是通过程序常量的方式解决。</li>
<li>需要存储在数据库中的数据，可以考虑采用物化视图（索引视图）。当DBA在视图上创建索引时，这个视图就被物化（执行）了，并且结果集被永久地保存在唯一聚簇索引中，保存方式与一个有聚簇索引的表的保存方式相同。物化视图减除了为引用视图的查询动态建立结果集的管理开销，优化人员可以在查询中使用视图索引，而不需要在FROM子句中直接指定视图。</li>
<li>数据存储时可以考虑适当的数据冗余，以减少数据库表之间的连接操作，提高查询效率。</li>
<li>针对数据的特点，采取特定的索引类型。例如位图索引等。</li>
</ol>
<h2 id="数据库工程"><a href="#数据库工程" class="headerlink" title="数据库工程"></a>数据库工程</h2><p>数据库工程是指基于DBS生存周期的所有活动的集合，其中包括数据库的规划、设计、实现和管理等。在DBS的管理方面，主要是对数据库进行控制，也就是2.4节所讨论的内容。</p>
<p>数据库设计是指对一个给定的应用环境，提供一个确定最优数据模型与处理模式的逻辑设计，以及一个确定数据库存储结构与存取方法的物理设计，建立起能反映现实世界信息和信息联系及满足用户数据要求和加工要求，以能够被某个DBMS所接受，同时能实现系统目标并有效存取数据的数据库。</p>
<h2 id="数据库设计阶段"><a href="#数据库设计阶段" class="headerlink" title="数据库设计阶段"></a>数据库设计阶段</h2><p>基于DBS生存期的数据库设计分成5个阶段，分别为<strong>规划</strong>、<strong>需求分析</strong>、<strong>概念设计</strong>、<strong>逻辑设计</strong>和<strong>物理设计</strong>。</p>
<h3 id="1规划"><a href="#1．规划" class="headerlink" title="1．规划"></a>1．规划</h3><p>规划阶段的主要任务是进行建立数据库的必要性及可行性分析，确定DBS在组织中和信息系统中的地位，以及各个数据库之间的联系。有关这方面的详细知识，请阅读8.5节。</p>
<h3 id="2需求分析"><a href="#2．需求分析" class="headerlink" title="2．需求分析"></a>2．需求分析</h3><p>需求分析可以通过3步来完成，即需求信息的收集、分析整理和评审，其目的在于对系统的应用情况做全面详细的调查，确定企业组织的目标，收集支持系统总的设计目标的基础数据和对这些数据的要求，确定用户的需求，并把这些要求写成用户和数据设计者都能够接受的文档。有关这方面的详细知识，请阅读8.6节。</p>
<h3 id="3概念设计"><a href="#3．概念设计" class="headerlink" title="3．概念设计"></a>3．概念设计</h3><p>概念设计（概念结构设计）阶段的目标是对需求说明书提供的所有数据和处理要求进行抽象与综合处理，按一定的方法构造反映用户环境的数据及其相互联系的概念模型，即用户的数据模型或企业数据模型。这种概念数据模型与DBMS无关，是面向现实世界的、极易为用户所理解的数据模型。为保证所设计的概念数据模型能正确、完全地反映用户的数据及其相互关系，便于进行所要求的各种处理，在本阶段设计中可吸收用户参与和评议设计。在进行概念结构设计时，可先设计各个应用的视图，即各个应用所看到的数据及其结构，然后再进行视图集成，以形成一个单一的概念数据模型。这样形成的初步数据模型还要经过数据库设计者和用户的审查与修改，最后形成所需的概念数据模型。</p>
<p>有关概念模型的建立，请阅读2.6节。对概念模型的要求是：</p>
<p>（1）概念模型是对现实世界的抽象和概括，它应真实、充分地反映现实世界中事物和事物之间的联系，有丰富的语义表达能力，能表达用户的各种需求，包括描述现实世界中各种对象及其复杂联系、用户对数据对象的处理要求和手段。</p>
<p>（2）概念模型应简洁、明晰，独立于机器、容易理解、方便数据库设计人员与应用人员交换意见，使用户能积极地参与数据库的设计工作。</p>
<p>（3）概念模型应易于变动。当应用环境和应用要求改变时，容易对概念模型修改和补充。</p>
<p>（4）概念模型应很容易向关系、层次或网状等各种数据模型转换，易于从概念模式导出与DBMS有关的逻辑模式。</p>
<h3 id="4逻辑设计"><a href="#4．逻辑设计" class="headerlink" title="4．逻辑设计"></a>4．逻辑设计</h3><p>逻辑设计（逻辑结构设计）主要是把概念模式转换成DBMS能处理的模式。转换过程中要对模式进行评价和性能测试，以便获得较好的模式设计。逻辑设计的主要内容包括初始模式的形成、子模式设计、应用程序设计梗概、模式评价、修正模式（通过模式分解或模式合并来实现规范化）。</p>
<p>逻辑设计的目的是把概念设计阶段设计好的基本E-R图转换为与选用的具体机器上的DBMS所支持的数据模型相符合的逻辑结构，包括数据库模式和外模式。</p>
<p>逻辑设计过程中的输入信息有：</p>
<p>（1）独立于DBMS的概念模式，即概念设计阶段产生的所有局部和全局概念模式。</p>
<p>（2）处理需求，即需求分析阶段产生的业务活动分析结果。</p>
<p>（3）约束条件，即完整性、一致性、安全性要求及响应时间要求等。</p>
<p>（4）DBMS特性，即特定的DBMS所支持的模式、子模式和程序语法的形式规则。</p>
<p>逻辑设计过程输出的信息有DBMS可处理的模式、子模式、应用程序设计指南、物理设计指南。</p>
<h3 id="5物理设计"><a href="#5．物理设计" class="headerlink" title="5．物理设计"></a>5．物理设计</h3><p>物理设计（物理结构设计）是指对一个给定的逻辑数据模型选取一个最适合应用环境的物理结构的过程，所谓数据库的物理结构主要指数据库在物理设备上的存储结构和存取方法。</p>
<p>物理设计的步骤为：</p>
<p>（1）设计存储记录结构，包括记录的组成、数据项的类型和长度，以及逻辑记录到存储记录的映射。</p>
<p>（2）确定数据存储安排。</p>
<p>（3）设计访问方法，为存储在物理设备上的数据提供存储和检索的能力。</p>
<p>（4）进行完整性和安全性的分析、设计。</p>
<p>（5）程序设计。</p>
<h2 id="设计约束和原则"><a href="#设计约束和原则" class="headerlink" title="设计约束和原则"></a>设计约束和原则</h2><p>在进行数据库设计的过程中，性能标准和性能约束的要求是设计者必须考虑的。通常性能约束也被看做需求的一部分，而性能标准是从不同的性能约束中推导出来的。一些典型的约束有：查询响应时间的上限，系统破坏后的恢复时间，为维护安全性和完整性而需要的特殊数据，等等。对最终结构进行性能标准的估价除了上述的响应时间外，还有更新、存储，以及再组织的代价。数据库设计过程的输出，主要有两部分：一部分是完整的数据库结构，其中包括逻辑结构与物理结构；另一部分是基于数据库结构和处理需求的应用程序的设计准则。这些输出都是以说明书的形式出现的。</p>
<p>为了使数据库设计更合理有效，需要有效的指导原则，这种指导原则称为数据库设计方法学。一个好的数据库设计方法学应该能在合理的期限内，以合理的工作量，产生一个有实用价值的数据库结构。这里“实用价值”是指满足用户关于功能、性能、安全性、完整性及发展需求等诸方面的要求，同时又服从于特定DBMS的约束，且可用简单的数据模型来表示。方法学还具有足够的通用</p>
<p>性、灵活性和可再生产性（不同的设计者应用同一方法学于同一设计问题时，应得到相同或类似的结果）。它有自顶向下、逐步求精的数据库结构设计过程，它对数据库结构和应用软件采取“多步设计评审方法”，其目的是要尽早发现系统设计中的错误，并在生存期的早期阶段给予纠正，以减少系统研制的成本。它有分析式、启发式或过程式的设计技术和定量（前面已讲到的如查询响应时间等）及定性的数据库评价原则。数据库定性分析是指其灵活性、适应性、新用户对设计的可理解性、与其他系统兼容性、对新环境的可改变性、恢复和重启动能力、对模块增生的分割和接受能力等。在数据库设计方法学中，信息需求渗透到数据库设计的整个过程，并且需要有3种基本类型的描述机制：</p>
<p>（1）实现设计过程的最终结果将用DBMS的DDL（DataDefinitionLanguage，数据定义语言）表示。DDL完全是针对现有的DBMS而言的。</p>
<p>（2）信息输入的描述。包括需求信息的收集和分析，数据元素及其联系的同义词、异义词和重叠定义等。这些都不容易用软件工具实现，可能要用一些人工方式。</p>
<p>（3）在信息输入和DDL描述之间的其他中间步骤的结果的描述。主要的中间结果是实体联系图，它是概念设计的产物，在概念设计和逻辑设计之间起桥梁作用。</p>
<p><strong>基于生存期的设计方法学进行设计并不是数据库设计的唯一途径。近年来由于设计辅助工具、第四代语言和程序自动生成技术的发展，快速原型法也是数据库设计中常用的方法。</strong></p>
<p>为了使数据库结构能适应应用中可能发生的变化，在数据库设计中，要充分注意数据库结构的可扩充性。例如，在设计数据库的时候要考虑到哪些数据字段将来可能会发生变更；给文本字段留足余量；估算未来5～10年的扩充数据量等。</p>
<h2 id="数据库建模"><a href="#数据库建模" class="headerlink" title="数据库建模"></a>数据库建模</h2><p>本知识点主要考查E-R图的画法，各实体之间的关系，如何消除冲突，E-R图向关系模式的转换等。</p>
<h2 id="e-r图的画法"><a href="#E-R图的画法" class="headerlink" title="E-R图的画法"></a>E-R图的画法</h2><p>E-R模型简称E-R图，它是描述概念世界，建立概念模型的实用工具。E-R图包括三个要素：</p>
<p>（1）实体（型）：用矩形框表示，框内标注实体名称。</p>
<p>（2）属性：用椭圆形表示，并用连线与实体连接起来。</p>
<p>（3）实体之间的联系：用菱形框表示，框内标注联系名称，并用连线将菱形框分别与有关实体相连，并在连线上注明联系类型。</p>
<p>例如，图2-2就是一个教学系统的E-R图（为了简单起见，省略了部分实体的属性和联系的属性）。<img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps10.png" alt="img">图2-2某教学系统E-R图</p>
<p>E-R图中的联系归结为三种类型：</p>
<p>（1）一对一联系（1:1）。设A、B为两个实体集。若A中的每个实体至多和B中的一个实体有联系，反过来，B中的每个实体至多和A中的一个实体有联系，称A对B或B对A是1:1联系。注意：1:1联系不一定都是一一对应的关系。可能存在着无对应。例如，在图2-2中，一个班只有一个班主任，一个班主任不能同时在其他班再兼任班主任，由于老师紧缺，某个班的班主任也可能暂缺。</p>
<p>（2）一对多联系（1:n）。如果A实体集中的每个实体可以和B中的几个实体有联系，而B中的每个实体至少和A中的一个实体有联系，那么A对B属于1:n联系。例如，在图2-2中，一个班级有多个学生，而一个学生只能编排在一个班级，班级与学生属于一对多的联系。</p>
<p>（3）多对多联系（m:n）。若实体集A中的每个实体可与和B中的多个实体有联系，反过来，B中的每个实体也可以与A中的多个实体有联系，称A对B或B对A是m:n联系。例如，在图2-2中，一个学生可以选修多门课程，一门课程由多个学生选修，学生和课程间存在多对多的联系。希赛教育专家提示：有时联系也有属性，这类属性不属于任一实体，只能属于联系。</p>
<h2 id="e-r图的集成"><a href="#E-R图的集成" class="headerlink" title="E-R图的集成"></a>E-R图的集成</h2><p>在数据库的概念结构设计过程中，先设计各子系统的局部E-R图，设计过程可分为以下几个步骤：</p>
<p>（1）确定局部视图的范围。</p>
<p>（2）识别实体及其标识。</p>
<p>（3）确定实体间的联系。</p>
<p>（4）分配实体及联系的属性。</p>
<p>各子系统的局部E-R图设计好后，下一步就是要将所有的分E-R图综合成一个系统的总体E-R图，一般称为视图的集成。视图集成通常有两种方式：（1）多个局部E-R图一次集成。这种方式比较复杂，做起来难度较大。（2）逐步集成，用累加的方式一次集成两个局部E-R图。这种方式每次只集成两个局部E-R图，可以降低复杂度。</p>
<p>由于各子系统应用所面临的问题不同，且通常是由不同的设计人员进行局部视图设计，这就导致各个局部E-R图之间必定会存在许多不一致的问题，称之为冲突。因此合并E-R图时并不能简单地将各个局部E-R图画到一起，而是必须着力消除各个局部E-R图中的不一致，以形成一个能为全系统中所有用户共同理解和接受的统一的概念模型。</p>
<p>各局部E-R图之间的冲突主要有三类：</p>
<p>（1）属性冲突：包括属性域冲突和属性取值冲突。属性冲突理论上好解决，只要换成相同的属性就可以了，但实际上需要各部门协商，解决起来并不简单。</p>
<p>（2）命名冲突：包括同名异义和异名同义。处理命名冲突通常也像处理属性冲突一样，通过讨论和协商等行政手段加以解决。</p>
<p>（3）结构冲突：包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部E-R图中所包含的属性个数和属性排列次序不完全相同。对于前者的解决办法是把属性变换为实体或实体变换为属性，使同一对象具有相同的抽象。对于后者的解决办法是使该实体的属性取各局部E-R图中属性的并集，再适当调整属性的次序。</p>
<p>另外，实体间的联系在不同的局部E-R图中可能为不同的类型，其解决方法是根据应用的语义对实体联系的类型进行综合或调整。</p>
<p>在初步的E-R图中，可能存在一些冗余的数据和实体间冗余的联系。冗余数据和冗余联系容易破坏数据库的完整性，给数据库维护增加困难，应当予以消除。消除冗余的主要方法为分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。</p>
<p>在集成之后，还需要对E-R模型进行评审。评审的作用在于确认建模任务是否全部完成，通过评审可以避免重大的疏漏或错误。</p>
<h2 id="图向关系模式的转换"><a href="#图向关系模式的转换" class="headerlink" title="图向关系模式的转换"></a>图向关系模式的转换</h2><p>E-R图向关系模式的转换属于数据库的逻辑设计阶段的工作，该阶段需要把E-R模型转换为某种DBMS能处理的关系模式，具体转换规则如下：</p>
<p>（1）一个实体转换为一个关系模式，实体的属性就是关系的属性，实体的码（关键字）就是关系的码。</p>
<p>（2）一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选键。如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。</p>
<p>（3）一个1:n联系可以转换为一个独立的关系模式，也可以与任意n端对应的关系模式合并。如果转换为一个独立的模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码。如果与n端实体对应的关系模式合并，则需要在该关系模式的属性中加入1端关系模式的码和联系本身的属性。</p>
<p>（4）一个m:n联系转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。</p>
<p>（5）三个以上实体间的一个多元联系可以转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。</p>
<p>另外，还有4种情况是需要特别注意的：</p>
<p>（1）多值属性的处理。如果E-R图中某实体具有一个多值属性，则应该进行优化，把该属性提升为一个实体。或者在转化为关系模式时，将实体的码与多值属性单独构成一个关系模式。</p>
<p>（2）BLOB型属性的处理。典型的BLOB是一张图片或一个声音文件，由于它们的容量比较大，必须使用特殊的方式来处理。处理BLOB的主要思想就是让文件处理器（如数据库管理器）不去理会文件是什么，而是关心如何去处理它。因此，从优化的角度考虑，应采用的设计方案是将BLOB字段与关系的码独立为一个关系模式。</p>
<p>（3）派生属性的处理。因为派生属性可由其他属性计算得到，因此，在转化成关系模式时，通常不转换派生属性。</p>
<p>（4）在对象-关系数据模型中，这里的关系模式就对应类，关系模式的属性就对应类的属性。</p>
<h2 id="常见的数据库管理系统"><a href="#常见的数据库管理系统" class="headerlink" title="常见的数据库管理系统"></a>常见的数据库管理系统</h2><p>目前，常见的DBMS主要有Oracle、Sybase、DB2、MSSQLServer等，本节简单介绍这些DBMS。</p>
<h2 id="oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><p>Oracle的结构包括数据库的内部结构、外存储结构、内存储结构和进程结构。在Oracle中，数据库不仅指物理上的数据，还包括处理这些数据的程序，即DBMS本身。Oracle提供了PL/SQL、Designer/2000、Forms等开发和设计工具。</p>
<p>除了以关系格式存储数据外，Oracle8以上的版本支持面向对象的结构（如抽象数据类型）。一个对象可以与其他对象建立联系，也可以包含其他对象，还可以用一个对象视图支持面向对象的接口数据而无须对表做任何修改。</p>
<p>无论是面向对象的结构还是关系结构，Oracle数据库都将其数据存储在物理的数据文件中。数据库结构提供数据存储到文件的逻辑图，允许不同类型的数据分开存储，这些逻辑划分即是表空间。在Oracle中，除了存储数据的文件外，还有DBMS的代码文件、日志文件和其他一些控制文件、跟踪文件等。外存储结构主要包括表空间和文件结构。</p>
<p>Oracle数据库在运行中使用两种类型的内存结构，分别是系统全局区和程序全局区。系统全局区是数据库运行时存放系统数据的内存区域，它由所有服务器进程和客户进程共享；程序全局区是单个存放Oracle进程工作时需要的数据和控制信息的，程序全局区不能共享。</p>
<h2 id="sybase"><a href="#Sybase" class="headerlink" title="Sybase"></a>Sybase</h2><p>为满足企业级分布式计算应用的要求，Sybase采用了基于构件方式的多层（常用三层）C/S架构。构件的主要优点是其自包含性和可重用性，系统中任何一个构件当被另一个具有同样功能的构件取代时，都无须对周围的构件进行重编码或修改。</p>
<p>第一层为客户应用程序。负责实现在客户系统上的数据显示和操作以及对用户输入做合理性检验。Sybase的开发工具产品系列（例如，PowerBuilder等）处在这一层。</p>
<p>第二层为基于构件方式的中间件层。该层能为分布式异构环境提供全局性的数据访问及事务管理控制。Sybase的中间件层产品主要有OmniConnect、OpenC1ient和OpenServer等。</p>
<p>第三层为服务器应用软件。它负责数据存取及完整性控制。Sybase数据库产品系列（例如，AdaptiveServerEnterprise、SybaseMPP、SybaseIQ和SQLAnywhere等）处于这一层。</p>
<p>Sybase这种架构的高适应性体现在企业可依据其特定的和变化中的分布式应用的需要来定制各个层次中的构件。Sybase的这些产品能优化地集成在一起协同运行，但它们彼此又是相互独立的，都能容易地与第三方产品实现集成，因而用户可灵活地构建一个完整的异构分布式系统。</p>
<h2 id="informix"><a href="#Informix" class="headerlink" title="Informix"></a>Informix</h2><p>Informix是美国Informix公司（已被IBM公司收购）的主要产品。Informix是一个跨平台、全功能的关系型DBMS，后改造为面向对象型DBMS，它具有各种特性，并且能够十分方便地与各种图形用户界面前端工具相连接。</p>
<p>Informix动态服务器采用多线程架构实现，这意味着只需较少的进程完成数据库活动，同时也意味着一个数据库进程可以通过线程形式为多于一个的应用服务。通常称这样一组进程为数据库服务器。根据需要，可以为数据库服务器动态分配一个进程，故称之为动态服务器。多线程架构还可以有更好的可伸缩性。这意味着，当增加更多用户时，数据库服务器只需要少量额外资源，这得益于多线程服务器实现本质上的可伸缩性的效率。</p>
<p>Informix的软件开发工具主要有Informix-SQL、Informix-ESQL、Informix-4GL等，它们具有不同的功能和特点，既能单独使用，也可根据实际需要相互配合使用。</p>
<h2 id="sqlserver"><a href="#SQLServer" class="headerlink" title="SQLServer"></a>SQLServer</h2><p>SQLServer是微软公司的数据库产品，SQLServer的分布式架构把应用程序对数据库的访问和数据库引擎分离开来。SQLServer的核心数据库服务器运行在基于Windows的服务器之上。基于Windows的服务器一般通过以太局域网与多个客户机系统连接。这些客户机系统一般是运行SQLServer客户机软件的PC机。这些PC机既可以是单独的桌面系统，又可以是其他网络服务的平台，如IISWeb服务器。</p>
<p>SQLServer与流行的开发工具和桌面应用程序紧密集成，例如，可以从由VisualBasic、VisualC++、PowerBuilder、Delphi、VisualFoxPro和许多其他PC开发环境下开发的客户应用程序中访问SQLServer数据库。SQLServer与流行开发工具所使用的几种数据访问接口兼容，例如，可以通过MicrosoftJETEngine和DataAccessObjects（DAO）、RemoteDataObjects（RDO）、ActiveXDataObjects（ADO）、OLEDB、ODBC（OpenDatabaseConnectivity，开放数据库互连）、SQLServer内置DB-Library以及第三方开发工具来访问SQLServer数据库。对于无缝桌面数据库访问，SQLServer使用OLEDB提供者和ODBC驱动程序，这些驱动程序允许从任何与ODBC或者OLEDB兼容的桌面应用程序中访问SQLServer数据库。OLEDB和ODBC可以从数百个简化设计的桌面应用程序中为特定的查询、数据分析、自定义报表打开SQLServer数据库。桌面集成减少了自定义的编程工作。SQLSerevr对ODBC的支持允许其他平台，如Macintosh或各种Unix系统访问SQLServer数据库。</p>
<p>SQLServer的4个基本服务器组件包括OpenDataServices、MSSQLServer、SQLServerAgent和MSDTC。</p>
<h2 id="db2"><a href="#DB2" class="headerlink" title="DB2"></a>DB2</h2><p>DB2是IBM公司研制的一种关系型数据库系统。DB2主要应用于大型应用系统，具有较好的可伸缩性，可支持从大型机到单用户环境，应用于OS/2、Windows等平台下。</p>
<p>DB2提供了高层次的数据利用性、完整性、安全性、可恢复性，以及小规模到大规模应用程序的执行能力，具有与平台无关的基本功能和SQL命令。DB2采用了数据分级技术，能够使大型机数据很方便地下载到局域网数据库服务器，使得C/S用户和基于局域网的应用程序可以访问大型机数据，并使数据库本地化及远程连接透明化。它以拥有一个非常完备的查询优化器而著称，其外部连接改善了查询性能，并支持多任务并行查询。</p>
<p>DB2具有很好的网络支持能力，每个子系统可以连接十几万个分布式用户，可同时激活上千个活动线程，对大型分布式应用系统尤为适用。</p>
<h2 id="mysql"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL是一个开放源码的小型关联式数据库管理系统，开发者为瑞典MySQLAB公司。MySQL被广泛地应用在Internet上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库。</p>
<h2 id="并行数据库系统"><a href="#并行数据库系统" class="headerlink" title="并行数据库系统"></a>并行数据库系统</h2><p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps20.png" alt="img">并行DBS是在并行机上运行的具有并行处理能力的DBS。并行DBS是数据库技术与并行计算技术相结合的产物。并行计算技术利用多处理机并行处理产生的规模效益来提高系统的整体性能，为DBS提供了一个良好的硬件平台。</p>
<p>一个并行DBS应该实现如下目标：</p>
<p>（1）高性能：并行DBS通过将数据库管理技术与并行处理技术有机结合，发挥多处理机结构的优势，从而提供比相应的大型机系统要高得多的性能价格比和可用性。</p>
<p>（2）高可用性：并行DBS可通过数据复制来增强数据库的可用性。</p>
<p>（3）可扩充性：DBS的可扩充性指系统通过增加处理和存储能力而平滑地扩展性能的能力。</p>
<h2 id="并行数据库的结构"><a href="#并行数据库的结构" class="headerlink" title="并行数据库的结构"></a>并行数据库的结构</h2><p>从硬件结构来看，根据处理机与磁盘及内存的相互关系可以将并行计算机分为3种基本的架构，分别是共享内存（ShareMemory，SM）结构、共享磁盘（ShareDisk，SD）结构和无共享资源（Share-Nothing，SN）结构，并行DBS以这3种架构为基础。</p>
<h3 id="1sm结构"><a href="#1-SM结构" class="headerlink" title="1.SM结构"></a>1.SM结构</h3><p>SM结构由多个处理机、一个共享内存和多个磁盘存储器构成。多处理机和共享内存由高速通信网络连接，每个处理机可直接存取一个或多个磁盘，即所有内存与磁盘为所有处理机共享。SM结构如图2-3所示。<img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps22.png" alt="img">图2-3SM结构SM结构的优势在于实现简单和负载均衡，但是这种结构的系统由于硬件成员之间的互连很复杂，故成本比较高。由于访问共享内存和磁盘会成为瓶颈，为了避免访问冲突增多而导致系统性能下降，节点数目必须限制在100个以下，可扩充性比较差。另外，内存的任何错误都将影响到多个处理机，系统的可用性不是很好。</p>
<h3 id="2sd结构"><a href="#2-SD结构" class="headerlink" title="2.SD结构"></a>2.SD结构</h3><p>SD结构由多个具有独立内存的处理机和多个磁盘构成，每个处理机都可以读写任何磁盘，多个处理机和磁盘存储器由高速通信网络连接。SD结构如图2-4所示。<img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps23.png" alt="img">图2-4SD结构SD结构具有成本低、可扩充性好、可用性强，容易从单处理机系统迁移，以及负载均衡等优点。该结构的不足之处在于实现起来比较复杂，以及存在潜在的性能问题。</p>
<h3 id="3sn结构"><a href="#3-SN结构" class="headerlink" title="3.SN结构"></a>3.SN结构</h3><p>SN结构由多个处理节点构成，每个处理节点具有自己独立的处理机、内存和磁盘存储器，多个处理机节点由高速通信网络连接。SN结构如图2-5所示。</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps24.png" alt="img">图2-5SN结构在SN结构中，由于每个节点可视为分布式DBS中的局部场地（拥有自己的数据库软件），因此分布式数据库设计中的多数设计思路，如数据库分片、分布事务管理和分布查询处理等，都可以借鉴。SN结构成本较低，它最大限度地减少了共享资源，具有极佳的可伸缩性，节点数目可达数千个，并可获得接近线性的伸缩比。而通过在多个节点上复制数据又可实现高可用性。SN结构的不足之处在于实现比较复杂，以及节点负荷难以均衡。往往只是根据数据的物理位置而不是系统的实际负载来分配任务。并且，系统中新节点的加入将导致重新组织数据库以均衡负载。</p>
<h2 id="并行数据库的组织"><a href="#并行数据库的组织" class="headerlink" title="并行数据库的组织"></a>并行数据库的组织</h2><p>并行数据库的组织主要涉及到并行粒度和操作算法问题。</p>
<p>并行粒度是指查询执行的并行程度，按照粒度从粗到细，主要有不同用户事务间的并行、同一事务内不同查询间的并行、同一查询内不同操作间的并行、同一操作内的并行性4种。</p>
<p>并行操作算法有并行连接算法、并行扫描算法和并行排序算法等。由于连接运算是数据库系统中最常用且最耗时的操作，因此对并行连接操作的研究最多。学者们提出了基于嵌套循环的并行连接算法、基于合并扫描的并行连接算法、基于Hash的并行连接算法和基于索引的并行连接算法等。</p>
<p>并行数据库以提高系统性能为宗旨，强调数据分布的均匀性。数据划分是并行查询处理的重要基础，根据存放关系的节点数目的不同，数据划分技术可分为完全划分（完全分布）和变量划分（部分分布）两种类型。完全划分将每一个关系分布存储到所有节点上，这种方法不适合小关系及节点数目大的系统；变量划分将每一个关系只分布存储到部分节点上，其中节点数目是关系大小和访问频率的一个函数，从而使数据分布更为灵活。</p>
<p>划分数据时可以依据一个属性的值，也可以同时依据多个属性的值，前者称为一维数据划分，后者称为多维数据划分。常用的划分方法有轮转法、Hash法和值域划分法、用户定义划分法、模式划分法和Hybrid_Range划分法等。</p>
<h2 id="数据仓库与数据挖掘"><a href="#数据仓库与数据挖掘" class="headerlink" title="数据仓库与数据挖掘"></a>数据仓库与数据挖掘</h2><p>企业常见的数据处理工作大致可以分成两大类，分别是OLTP（On-LineTransactionProcessing，联机事务处理）和OLAP（On-LineAnalyticalProcessing，联机分析处理）。OLTP是传统的关系型数据库的主要应用，OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p>
<h2 id="联机分析处理"><a href="#联机分析处理" class="headerlink" title="联机分析处理"></a>联机分析处理</h2><p>OLTP是传统关系型数据库的重要应用之一，主要是基本的、日常的事务处理，例如银行交易、电信计费、民航订票等，对响应时间要求比较高，强调的是密集数据更新处理的性能和系统的可靠性及效率。OLTP用短小和中等复杂程度的查询语句，读取或修改数据库中一个比较小的部分，数据访问方式是小的随机磁盘访问。</p>
<p>OLTP是事件驱动、面向应用的。OLTP的基本特点是：对响应时间要求非常高；用户数量非常庞大，主要是操作人员；数据库的各种操作基于索引进行；对数据库的事务均已预先定义，查询简单，一般不牵涉到多表连接操作。</p>
<p>OLAP使得数据分析人员能够从多角度对数据进行快速、一致、交互地存取，从而获得对数据的更深入的了解。OLAP的目标是满足决策支持或者在多维环境下特定的查询和报表需求。</p>
<p>OLTP与OLAP之间的比较。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>OLTP</th>
<th>OLAP</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户</td>
<td>操作人员，低层管理人员</td>
<td>决策人员，高级管理人员</td>
</tr>
<tr>
<td>功能</td>
<td>日常操作处理</td>
<td>分析决策</td>
</tr>
<tr>
<td>DB设计</td>
<td>面向应用</td>
<td>面向主题</td>
</tr>
<tr>
<td>数据</td>
<td>当前的，最新的细节的，二维的分立的</td>
<td>历史的，聚集的，多维的集成的，统一的</td>
</tr>
<tr>
<td>存取</td>
<td>读/写数十条事务</td>
<td>读上百万条记录</td>
</tr>
<tr>
<td>工作单位</td>
<td>简单的事务</td>
<td>复杂的查询</td>
</tr>
<tr>
<td>用户数</td>
<td>上千个</td>
<td>上百个</td>
</tr>
<tr>
<td>DB大小</td>
<td>100MB-GB</td>
<td>100GB-TB</td>
</tr>
</tbody>
</table>
</div>
<p>OLAP是使分析人员、管理人员或执行人员能够从多角度对信息进行快速、一致、交互地存取，从而获得对数据的更深入了解的一类软件技术。OLAP的目标是满足决策支持或者满足在多维环境下特定的查询和报表需求，它的技术核心是“维”的概念。维是人们观察客观世界的角度，是一种高层次的类型划分。维一般包含着层次关系，这种层次关系有时会相当复杂。通过把一个实体的多项重要的属性定义为多个维，使用户能对不同维上的数据进行比较。因此OLAP也可以说是多维数据分析工具的集合。</p>
<p>OLAP的基本多维分析操作有钻取、切片和切块、旋转等。</p>
<p>（1）<strong>钻取</strong>：是改变维的层次，变换分析的粒度。它包括向上钻取和向下钻取。向上钻取是在某一维上将低层次的细节数据概括到高层次的汇总数据，或者减少维数；而向下钻取则相反，它从汇总数据深入到细节数据进行观察或增加新维</p>
<p>（2）<strong>切片和切块</strong>：是在一部分维上选定值后，关心度量数据在剩余维上的分布。如果剩余的维只有两个，则是切片；如果有三个，则是切块。</p>
<p>（3）<strong>旋转</strong>：是变换维的方向，即在表格中重新安排维的放置（例如行列互换）。</p>
<p>OLAP有多种实现方法，根据存储数据的方式不同，可以分为ROLAP（RelationalOLAP，基于关系数据库的OLAP实现）、MOLAP（MultidimensionalOLAP，基于多维数据组织的OLAP实现）、HOLAP（HybridOLAP，基于混合数据组织的OLAP实现）。</p>
<p>（1）ROLAP：以关系数据库为核心，以关系型结构进行多维数据的表示和存储。ROLAP将多维数据库的多维结构划分为两类表:一类是事实表，用来存储数据和维关键字;另一类是维表，即对每个维至少使用一个表来存放维的层次、成员类别等维的描述信息。维表和事实表通过主关键字和外关键字联系在一起，形成了“星型模式”。对于层次复杂的维，为避免冗余数据占用过大的存储空间，可以使用多个表来描述，这种星型模式的扩展称为“雪花模式”。</p>
<p>（2）MOLAP：以多维数据组织方式为核心，也就是说，MOLAP使用多维数组存储数据。多维数据在存储中将形成立方块（Cube）的结构，在MOLAP中对立方块的旋转、切块、切片是产生多维数据报表的主要技术。</p>
<p>（3）HOLAP：低层是关系型的，高层是多维矩阵型的；或者反之。这种方式具有更好的灵活性。</p>
<p>还有其他的一些实现OLAP的方法，如提供一个专用的SQLServer，对某些存储模式（如星型、雪片型）提供对SQL查询的特殊支持。</p>
<p>OLAP工具是针对特定问题的联机数据访问与分析，它通过多维的方式对数据进行分析、查询和报表。多维分析是指对以多维形式组织起来的数据采取切片、切块、钻取、旋转等各种分析动作，以求剖析数据，使用户能从多个角度、多侧面地观察数据库中的数据，从而深入理解包含在数据中的信息。</p>
<h2 id="数据仓库的概念"><a href="#数据仓库的概念" class="headerlink" title="数据仓库的概念"></a>数据仓库的概念</h2><p>数据仓库（DataWarehouse）是一个面向主题的、集成的、相对稳定的、且随时间变化的的数据集合，用于支持管理决策。</p>
<h3 id="1数据仓库的特征"><a href="#1．数据仓库的特征" class="headerlink" title="1．数据仓库的特征"></a>1．数据仓库的特征</h3><p>（1）面向主题。操作型数据库的数据组织面向事务处理任务（面向应用），各个业务系统之间各自分离，而数据仓库中的数据是按照一定的主题域进行组织。主题是一个抽象的概念，是指用户使用数据仓库进行决策时所关心的重点方面，一个主题通常与多个操作型信息系统相关。例如，一个保险公司所进行的事务处理（应用问题）可能包括汽车保险、人寿保险、健康保险和意外保险等，而公司的主要主题范围可能是顾客、保险单、保险费和索赔等。</p>
<p>（2）集成的。在数据仓库的所有特性中，这是最重要的。面向事务处理的操作型数据库通常与某些特定的应用相关，数据库之间相互独立，并且往往是异构的。而数据仓库中的数据是在对原有分散的数据库数据抽取、清理的基础上经过系统加工、汇总和整理得到的，必须消除源数据中的不一致性，以保证数据仓库内的信息是关于整个企业的一致的全局信息。</p>
<p>（3）相对稳定的（非易失的）。操作型数据库中的数据通常实时更新，数据根据需要及时发生变化。数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一旦某个数据进入数据仓库以后，一般情况下将被长期保留，也就是数据仓库中一般有大量的查询操作，但修改和删除操作很少，通常只需要定期的加载、刷新。</p>
<p>（4）随时间变化。操作型数据库主要关心当前某一个时间段内的数据，而数据仓库中的数据通常包含历史信息，系统记录了企业从过去某一时点（如开始应用数据仓库的时点）到目前的各个阶段的信息，通过这些信息，可以对企业的发展历程和未来趋势做出定量分析和预测。</p>
<p>数据仓库反映历史变化的属性主要表现在：</p>
<p>（1）数据仓库中的数据时间期限要远远长于传统操作型数据系统中的数据时间期限，传统操作型数据系统中的数据时间期限可能为数十天或数个月，数据仓库中的数据时间期限往往为数年甚至几十年。</p>
<p>（2）传统操作型数据系统中的数据含有“当前值”的数据，这些数据在访问时是有效的，当然数据的当前值也能被更新，但数据仓库中的数据仅仅是一系列某一时刻（可能是传统操作型数据系统）生成的复杂的快照。</p>
<p>（3）传统操作型数据系统中可能包含也可能不包含时间元素，如年、月、日、时、分、秒等，而数据仓库中一定会包含时间元素。</p>
<h3 id="2数据仓库与传统数据的区别"><a href="#2．数据仓库与传统数据的区别" class="headerlink" title="2．数据仓库与传统数据的区别"></a>2．数据仓库与传统数据的区别</h3><p>数据仓库虽然是从传统数据库系统发展而来，但是两者还是存在着诸多差异，如：从数据存储的内容看，数据库只存放当前值，而数据仓库则存放历史值；数据库数据的目标是面向业务操作人员的，为业务处理人员提供数据处理的支持，而数据仓库则是面向中高层管理人员的，为其提供决策支持等。表2-3详细说明了数据仓库与传统数据库的区别。</p>
<p>数据仓库与传统数据库的比较</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>比较项目</th>
<th>数据库</th>
<th>数据仓库</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据内容</td>
<td>当前值</td>
<td>历史的、归档的、归纳的、计算的数据（处理过的）</td>
</tr>
<tr>
<td>数据目标</td>
<td>面向业务操作程序、重复操作</td>
<td>面向主体域，分析应用</td>
</tr>
<tr>
<td>数据特性</td>
<td>动态变化、更新</td>
<td>静态、不能直接更新，只能定时添加、更新</td>
</tr>
<tr>
<td>使用频率</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>数据访问量</td>
<td>每个事务一般只访问少量记录</td>
<td>每个事务一般访问大量记录</td>
</tr>
<tr>
<td>数据访问量</td>
<td>每个事务一般只访问少量记录</td>
<td>每个事务一般访问大量记录</td>
</tr>
<tr>
<td>对响应事件的要求</td>
<td>记时单位小，如秒</td>
<td>记时单位相对较大，除了秒，还有分钟、小时</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3数据仓库的分类"><a href="#3．数据仓库的分类" class="headerlink" title="3．数据仓库的分类"></a>3．数据仓库的分类</h3><p>从结构的角度看，有三种数据仓库模型，分别是企业仓库、数据集市和虚拟仓库。</p>
<p>企业仓库收集跨越整个企业的各个主题的所有信息，它提供全企业范围的数据集成，数据通常来自多个操作型数据库和外部信息提供者，并且是跨多个功能范围的。它通常包含详细数据和汇总数据。</p>
<p>数据集市包含对特定用户有用的、企业范围数据的一个子集，它的范围限定选定的主题。虚拟仓库是操作型数据库上视图的集合。</p>
<h2 id="数据仓库的结构"><a href="#数据仓库的结构" class="headerlink" title="数据仓库的结构"></a>数据仓库的结构</h2><p>从数据仓库的概念结构来看，一般来说，数据仓库系统要包含数据源、数据准备区、数据仓库数据库、数据集市/知识挖掘库以及各种管理工具和应用工具，如图2-6所示。</p>
<p>数据仓库建立之后，首先要从数据源中抽取相关的数据到数据准备区，在数据准备区中经过净化处理后再加载到数据仓库数据库，最后根据用户的需求将数据导入数据集市和知识挖掘库中。当用户使用数据仓库时，可以利用包括OLAP在内的多种数据仓库应用工具向数据集市/知识挖掘库或数据仓库进行决策查询分析或知识挖掘。数据仓库的创建、应用可以利用各种数据仓库管理工具辅助完成。<img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps32.png" alt="img">图2-6数据仓库的概念结构</p>
<h3 id="1数据仓库的参考框架"><a href="#1．数据仓库的参考框架" class="headerlink" title="1．数据仓库的参考框架"></a>1．数据仓库的参考框架</h3><p>数据仓库的参考框架由数据仓库基本功能层、数据仓库管理层和数据仓库环境支持层组成。</p>
<p>（1）数据仓库基本功能层。数据仓库的基本功能层部分包含数据源、数据准备区、数据仓库结构、数据集市或知识挖掘库，以及存取和使用部分。本层的功能是从数据源抽取数据，对所抽取的数据进行筛选、清理，将处理过的数据导入或者说加载到数据仓库中，根据用户的需求设立数据集市，完成数据仓库的复杂查询、决策分析和知识的挖掘等。</p>
<p>（2）数据仓库管理层。数据仓库的正常运行除了需要数据仓库功能层提供的基本功能外，还需要对这些基本功能进行管理与支持的结构框架。数据仓库管理层由数据仓库的数据管理和数据仓库的元数据管理组成。数据仓库的数据管理层包含数据抽取、新数据需求与查询管理，数据加载、存储、刷新和更新系统，安全性与用户授权管理系统以及数据归档、恢复及净化系统等四部分。</p>
<p>（3）数据仓库的环境支持层。数据仓库的环境支持层由数据仓库数据传输层和数据仓库基础层组成。数据仓库中不同结构之间的数据传输需要数据仓库的传输层来完成。数据仓库的传输层包含数据传输和传送网络、客户/服务器代理和中间件、复制系统以及数据传输层的安全保障系统。</p>
<h3 id="2数据仓库的架构"><a href="#2．数据仓库的架构" class="headerlink" title="2．数据仓库的架构"></a>2．数据仓库的架构</h3><p>大众观点的数据仓库的架构如图2-7所示：</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps33.png" alt="img">图2-7数据仓库架构</p>
<p>（1）数据源。是数据仓库系统的基础，是整个系统的数据源泉。通常包括企业内部信息和外部信息。内部信息包括存放于RDBMS中的各种业务处理数据和各类文档数据。外部信息包括各类法律法规、市场信息和竞争对手的信息等等。</p>
<p>（2）数据的存储与管理。是整个数据仓库系统的核心。数据仓库的真正关键是数据的存储和管理。数据仓库的组织管理方式决定了它有别于传统数据库，同时也决定了其对外部数据的表现形式。要决定采用什么产品和技术来建立数据仓库的核心，则需要从数据仓库的技术特点着手分析。针对现有各业务系统的数据，进行抽取、清理，并有效集成，按照主题进行组织。数据仓库按照数据的覆盖范围可以分为企业级数据仓库和部门级数据仓库（通常称为数据集市）。</p>
<p>（3）OLAP服务器。对分析需要的数据进行有效集成，按多维模型予以组织，以便进行多角度、多层次的分析，并发现趋势。</p>
<p>（4）前端工具。主要包括各种报表工具、查询工具、数据分析工具、数据挖掘工具以及各种基于数据仓库或数据集市的应用开发工具。其中数据分析工具主要针对OLAP服务器，报表工具、数据挖掘工具主要针对数据仓库。</p>
<h2 id="数据挖掘的概念"><a href="#数据挖掘的概念" class="headerlink" title="数据挖掘的概念"></a>数据挖掘的概念</h2><p>数据挖掘（DataMining）技术是人们长期对数据库技术进行研究和开发的结果。</p>
<p>从技术上来看，数据挖掘就是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和知识的过程。这个定义包括好几层含义：数据源必须是真实的、大量的、含噪声的；发现的是用户感兴趣的知识；发现的知识要可接受、可理解、可运用；并不要求发现放之四海而皆准的知识，仅支持特定的发现问题。</p>
<p>从业务角度来看，数据挖掘是一种新的业务信息处理技术，其主要特点是对业务数据库中的大量业务数据进行抽取、转换、分析和其他模型化处理，从中提取辅助业务决策的关键性数据。</p>
<p>数据挖掘与传统的数据分析（如查询、报表、联机应用分析）的本质区别是数据挖掘是在没有明确假设的前提下去挖掘信息、发现知识。数据挖掘所得到的信息应具有先知、有效和可实用三个特征。先前未知的信息是指该信息是预先未曾预料到的，即数据挖掘是要发现那些不能靠直觉发现的信息或知识，甚至是违背直觉的信息或知识，挖掘出的信息越是出乎意料，就可能越有价值。</p>
<p>数据挖掘通过预测未来趋势及行为，做出前摄的、基于知识的决策。数据挖掘的目标是从数据库中发现隐含的、有意义的知识，主要有以下五类功能：</p>
<p>（1）<strong>自动预测趋势和行为。</strong>数据挖掘自动在大型数据库中寻找预测性信息，以往需要进行大量手工分析的问题如今可以迅速直接由数据本身得出结论。</p>
<p>（2）<strong>关联分析。</strong>数据关联是数据库中存在的一类重要的可被发现的知识。若两个或多个变量的取值之间存在某种规律性，就称为关联。关联可分为简单关联、时序关联、因果关联。关联分析的目的是找出数据库中隐藏的关联网。有时并不知道数据库中数据的关联函数，即使知道也是不确定的，因此关联分析生成的规则带有可信度。</p>
<p>（3）<strong>聚类。</strong>数据库中的记录可被划分为一系列有意义的子集，即聚类。聚类增强了人们对客观现实的认识，是概念描述和偏差分析的先决条件。聚类技术主要包括传统的模式识别方法和数学分类学。</p>
<p>（4）<strong>概念描述。</strong>概念描述就是对某类对象的内涵进行描述，并概括这类对象的有关特征。概念描述分为特征性描述和区别性描述，前者描述某类对象的共同特征，后者描述不同类对象之间的区别。生成一个类的特征性描述只涉及该类对象中所有对象的共性。生成区别性描述的方法很多，如决策树方法、遗传算法等。</p>
<p>（5）<strong>偏差检测。</strong>数据库中的数据常有一些异常记录，从数据库中检测这些偏差很有意义。偏差包括很多潜在的知识，如分类中的反常实例、不满足规则的特例、观测结果与模型预测值的偏差、量值随时间的变化等。偏差检测的基本方法是，寻找观测结果与参照值之间有意义的差别。</p>
<h2 id="数据挖掘常用技术"><a href="#数据挖掘常用技术" class="headerlink" title="数据挖掘常用技术"></a>数据挖掘常用技术</h2><p>常见和应用最广泛的数据挖掘方法有：</p>
<p>（1）<strong>决策树</strong>。利用信息论中的互信息（信息增益）寻找数据库中具有最大信息量的属性，建立决策树的一个结点，再根据该属性的不同取值建设树的分支；在每个分支子集中重复建立树的下层结点和分支的过程。国际上最早的、也是最有影响的决策树方法是Quiulan研究的ID3方法。</p>
<p>（2）<strong>神经网络</strong>。模拟人脑神经元结构，完成类似统计学中的判别、回归、聚类等功能，是一种非线性的模型，主要有三种神经网络模型，分别是前馈式网络、反馈式网络和自组织网络。人工神经网络最大的长处是可以自动地从数据中学习，形成知识，这些知识有些是我们过去未曾发现的，因此它具有较强的创新性。神经网络的知识体现在网络连接的权值上，神经网络的学习主要表现在神经网络权值的逐步计算上。</p>
<p>（3）<strong>遗传算法</strong>。模拟生物进化过程的算法，它由三个基本过程组成，分别是繁殖（选择）、交叉（重组）、变异（突变）。采用遗传算法可以产生优良的后代，经过若干代的遗传，将得到满足要求的后代即问题得解。</p>
<p>（4）<strong>关联规则挖掘算法</strong>。关联规则是描述数据之间存在关系的规则，一般分为两个步骤：首先求出大数据项集，然后用大数据项集产生关联规则。</p>
<p>除了上述的常用方法外，还有粗集方法、模糊集合方法、最邻近算法等。无论采用哪种方法完成数据挖掘，从功能上可以将数据挖掘的分析方法划分为6种，即关联分析、序列分析、分类分析、聚类分析、预测和时间序列分析。</p>
<p>（1）<strong>关联分析</strong>。关联分析主要用于发现不同事件之间的关联性，即一个事件发生的同时，另一个事件也经常发生。关联分析的重点在于快速发现那些有实用价值的关联发生的事件。其主要依据是事件发生的概率和条件概率应该符合一定的统计意义。</p>
<p>（2）<strong>序列分析</strong>。序列分析技术主要用于发现一定时间间隔内接连发生的事件。这些事件构成一个序列，发现的序列应该具有普遍意义，其依据除了统计上的概率之外，还要加上时间的约束。</p>
<p>（3）<strong>分类分析</strong>。分类分析通过分析具有类别的样本的特点，得到决定样本属于各种类别的规则或方法。利用这些规则和方法对未知类别的样本分类时应该具有一定的准确度。其主要方法有基于统计学的贝叶斯方法、神经网络方法、决策树方法等。</p>
<p>（4）<strong>聚类分析</strong>。聚类分析是根据物以类聚的原理，将本身没有类别的样本聚集成不同的组，并且对每一个这样的组进行描述的过程。其主要依据是聚到同一个组中的样本应该彼此相似，而属于不同组的样本应该足够不相似。</p>
<p>（5）<strong>预测</strong>。预测与分类分析相似，但预测是根据样本的已知特征估算某个连续类型的变量的取值的过程，而分类则只是用于判别样本所属的离散类别而已。预测常用的技术是回归分析。</p>
<p>（6）<strong>时间序列分析</strong>。时间序列分析的是随时间而变化的事件序列，目的是预测未来发展趋势，或者寻找相似发展模式或者是发现周期性发展规律。</p>
<h2 id="数据挖掘的流程"><a href="#数据挖掘的流程" class="headerlink" title="数据挖掘的流程"></a>数据挖掘的流程</h2><p>数据挖掘是指一个完整的过程，该过程从大型数据库中挖掘先前未知的，有效的，可实用的信息，并使用这些信息做出决策或丰富知识。数据挖掘的流程大致如下：</p>
<p>（1）<strong>问题定义</strong>。在开始数据挖掘之前最先的也是最重要的要求就是熟悉背景知识，弄清用户的需求。缺少了背景知识，就不能明确定义要解决的问题，就不能为挖掘准备优质的数据，也很难正确的解释得到的结果。要想充分发挥数据挖掘的价值，必须对目标要有一个清晰明确的定义，即决定到底想干什么。</p>
<p>（2）<strong>建立数据挖掘库</strong>。要进行数据挖掘必须收集要挖掘的数据资源。一般建议把要挖掘的数据都收集到一个数据库中，而不是采用原有的数据库或数据仓库。这是因为大部分情况下需要修改要挖掘的数据，而且还会遇到采用外部数据的情况；另外，数据挖掘还要对数据进行各种纷繁复杂的统计分析，而数据仓库可能不支持这些数据结构。</p>
<p>（3）<strong>分析数据</strong>。分析数据就是通常所进行的对数据深入调查的过程。从数据集中找出规律和趋势，用聚类分析区分类别，最终要达到的目的就是搞清楚多因素相互影响的、十分复杂的关系，发现因素之间的相关性。</p>
<p>（4）<strong>调整数据</strong>。通过上述步骤的操作，对数据的状态和趋势有了进一步的了解，这时要尽可能对问题解决的要求能进一步明确化、进一步量化。针对问题的需求对数据进行增删，按照对整个数据挖掘过程的新认识组合或生成一个新的变量，以体现对状态的有效描述。</p>
<p>（5）<strong>模型化</strong>。在问题进一步明确，数据结构和内容进一步调整的基础上，就可以建立形成知识的模型。这一步是数据挖掘的核心环节，一般运用神经网络、决策树、数理统计、时间序列分析等方法来建立模型。</p>
<p>（6）<strong>评价和解释</strong>。上面得到的模式模型，有可能是没有实际意义或没有实用价值的，也有可能是其不能准确反映数据的真实意义，甚至在某些情况下是与事实相反的，因此需要评估，确定哪些是有效的、有用的模式。评估的一种办法是直接使用原先建立的挖掘数据库中的数据来进行检验，另一种办法是另找一批数据并对其进行检验，再一种办法是在实际运行的环境中取出新鲜数据进行检验。</p>
<p>数据挖掘是一个多种专家合作的过程，也是一个在资金上和技术上高投入的过程。这一过程要反复进行，在反复过程中，不断地趋近事物的本质，不断地优选问题的解决方案。</p>
<h2 id="nosql"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>NoSQL即NotOnlySQL，可直译“不仅仅是SQL”，这项技术正在掀起一场全新的数据库革命性运动。</p>
<p>在本章2.3.1节曾提到数据的模式包括多种类型，如层次模型、网状模型、关系模型等，而在实际应用过程中，几乎都是在用关系模型，主流的数据库系统都是关系型的。但随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。这也就使得NoSQL技术进入了人们的视野。</p>
<p>NoSQL的出现打破了长久以来关系型数据库与ACID理论大一统的局面。NoSQL数据存储不需要固定的表结构，通常也不存在连接操作。在大数据存取上具备关系型数据库无法比拟的性能优势。</p>
<p>关系型数据库中的表都是存储一些格式化的数据结构，每个元组字段的组成都一样，即使不是每个元组都需要所有的字段，但数据库会为每个元组分配所有的字段，这样的结构可以便于表与表之间进行连接等操作，但从另一个角度来说它也是关系型数据库性能瓶颈的一个因素。而非关系型数据库以键值对存储，它的结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。</p>
<p>与关系型数据库相比，NoSQL数据库具有以下优点：</p>
<p>1．易扩展</p>
<p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p>
<p>2．大数据量，高性能</p>
<p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用QueryCache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。</p>
<p>3．灵活的数据模型</p>
<p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的web2.0时代尤其明显。</p>
<p>4．高可用</p>
<p>NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。比如Cassandra，HBase模型，通过复制模型也能实现高可用。</p>
<p>当然，NoSQL也存在很多缺点，例如，并未形成一定标准，各种产品层出不穷，内部混乱，各种项目还需时间来检验，缺乏相关专家技术的支持等。</p>
<h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><p>大数据（BigData），指的是所涉及的数据量规模巨大到无法通过目前主流软件工具，在合理时间内达到获取、管理、处理、并整理成为帮助企业经营决策目的的信息。</p>
<h3 id="1大数据的特点"><a href="#1．大数据的特点" class="headerlink" title="1．大数据的特点"></a>1．大数据的特点</h3><p>大数据有4大特点：Volume（大量）、Velocity（高速）、Variety（多样）、Value（价值），由于他们的英文首字母都是V，所以也称为“4V特点”。</p>
<p>Volume（大量）：大量主要体现在非结构化数据的超大规模增长，比结构化数据增长快10到50倍，同时数据的量级已超越传统数据仓库的很多倍。Velocity（高速）：大数据的分析是一种实时分析而非批量式分析，所以效果是立竿见影而非事后见效。</p>
<p>Variety（多样）：大数据存在异构与多样性的特点，因为他有很多不同形式的数据，如文本、图像、音频、视频等。</p>
<p>Value（价值）：大数据的价值特性是指大数据价值密度低，因为大数据是有着海量数据的，这里面存在大量不相关的信息，所以单位价值密度低。</p>
<h3 id="2传统数据与大数据的比较"><a href="#2．传统数据与大数据的比较" class="headerlink" title="2．传统数据与大数据的比较"></a>2．传统数据与大数据的比较</h3><p>传统数据与大数据的差异请参看表2-4。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>比较维度</th>
<th>传统数据</th>
<th>大数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据量</td>
<td>GB或TB</td>
<td>PB级或以上</td>
</tr>
<tr>
<td>结构化程度</td>
<td>结构化或半结构化数据</td>
<td>所有类型数据</td>
</tr>
<tr>
<td>数据分析需求</td>
<td>现有数据的分析与检测</td>
<td>深度分析（关联分析、回归分析）</td>
</tr>
<tr>
<td>硬件平台</td>
<td>高端服务器</td>
<td>集群平台</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3大数据处理关键技术"><a href="#3．大数据处理关键技术" class="headerlink" title="3．大数据处理关键技术"></a>3．大数据处理关键技术</h3><p>大数据处理关键技术一般包括：大数据采集、大数据预处理、大数据存储及管理、大数据分析及挖掘、大数据展现和应用（大数据检索、大数据可视化、大数据应用、大数据安全等）。</p>
<h3 id="4大数据应用"><a href="#4．大数据应用" class="headerlink" title="4．大数据应用"></a>4．大数据应用</h3><p>大数据可以各行各业应用，如金融服务、医疗保健、零售业、制造业、政府等。</p>
<h1 id="第4章-数据通信与计算机网络"><a href="#第4章-数据通信与计算机网络" class="headerlink" title="第4章 数据通信与计算机网络"></a>第4章 数据通信与计算机网络</h1><h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><p>（1）信息系统综合知识：包括数据通信的基础知识、开放系统互连参考模型、常用的协议标准、网络互连与常用网络设备、计算机网络的分类与应用、网络管理。</p>
<p>（2）系统架构设计案例分析：包括网络应用系统的设计。计算机网络是计算机技术与数据通信技术的产物，要想深入地了解网络通信的工作原理，就必须对信道特性、数据调制与编码技术等相关知识有深入的了解。</p>
<h2 id="信道特性"><a href="#信道特性" class="headerlink" title="信道特性"></a>信道特性</h2><p>本节介绍<strong>香农定理</strong>、<strong>奈奎斯特定理</strong>、<strong>数据传输速率与波特率的计算</strong>等基础知识。</p>
<h3 id="1-信道的最高码元传输速率"><a href="#1-信道的最高码元传输速率" class="headerlink" title="1. 信道的最高码元传输速率"></a>1. 信道的最高码元传输速率</h3><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。</p>
<p>根据奈氏准则，理想码元的传输速率<code>N=2W(Baud)</code>，其中W是立项低通信道的贷款，单位为赫兹Hz，Baud是波特，是码元传输速率的单元，1波特为每秒传送1个码元。</p>
<p><strong>注意</strong>：实际的信道所能传输的最高码元速率，要明显地低于奈氏准则给出的上限数值。波特（Baud）和比特（bit）是两个不同的概念。波特是码元传输的速率单位（每秒传输多少个码元）。码元传输速率也称为调制速率、波形速率或符号速率；比特是信息量的单位。比特速率为单位时间内传送数据量的多少，也称为数据传输速率。信息的传输速率bps（比特/秒）与码元的传输速率Baud在数量上有一定的关系。若1个码元只携带1bit的信息量，则bps和Baud在数值上相等。若1个码元携带nbit的信息量，则NBaud的码元传输速率所对应的信息传输速率为（N×n）bps。</p>
<h3 id="2信道的极限信息传输速率"><a href="#2．信道的极限信息传输速率" class="headerlink" title="2．信道的极限信息传输速率"></a>2．信道的极限信息传输速率</h3><p>香农（Shannon）用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。信道的极限信息传输速率C可表达为：</p>
<p>C=Wlog2(1+S/N)bps</p>
<p>其中W为信道带宽（以Hz为单位），S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率。</p>
<p>香农公式表明：信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。若信道带宽W或信噪比S/N没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率C也就没有上限。实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</p>
<h3 id="3码元与调制技术"><a href="#3．码元与调制技术" class="headerlink" title="3．码元与调制技术"></a>3．码元与调制技术</h3><p>码元是一个数据信号的基本单位，码元有多少个不同种类取决于其使用的调制技术。调制技术与码元、比特位间的关系如表4-1所示。</p>
<p>码元种类数N与其携带的比特位数n之间的关系为：比特位数n=log2N。</p>
<h3 id="4信道速率计算"><a href="#4．信道速率计算" class="headerlink" title="4．信道速率计算"></a>4．信道速率计算</h3><p>香农定理、奈奎斯特定理、数据传输速率与波特率的计算公式如图4-1所示。</p>
<p>图4-1三种常用公式比较</p>
<h2 id="数据调制与编码"><a href="#数据调制与编码" class="headerlink" title="数据调制与编码"></a>数据调制与编码</h2><p>数据调制与编码</p>
<p>人类在长期的社会活动中需要不断地交往和传递信息。这种传递信息的过程就叫做通信。在通过通信媒体发送信息之前，信息必须被编码形成信号。当将数据由一地传送到另一地时，必须将其转换为信号。</p>
<h3 id="1模拟通道传送模拟数据"><a href="#1．模拟通道传送模拟数据" class="headerlink" title="1．模拟通道传送模拟数据"></a>1．模拟通道传送模拟数据</h3><p>模拟数据通过模拟通道传送的调制方式主要有<strong>调幅</strong>（AmplitudeModulation，AM）、<strong>调频</strong>（FrequencyModulation，FM）和<strong>调相</strong>（PhaseModulation，PM）几种方式。</p>
<p>调幅技术最常见的应用是收音机，调幅是载波频率固定，载波的振幅随着原始数据的幅度变化</p>
<p>而变化；调频和调相都属于调度调制。调频即载波的频率随着基带数字信号而变化，调相即载波的</p>
<p>初始相位随着基带数字信号而变化。</p>
<h3 id="2数字通道传送模拟数据"><a href="#2．数字通道传送模拟数据" class="headerlink" title="2．数字通道传送模拟数据"></a>2．数字通道传送模拟数据</h3><p>模拟数据必须转变为数字信号，才能在数字通道上传送，这个过程称为“数字化”。脉码调制（PulseCodeModulation，PCM）是模拟数据数字化的主要方法，PCM要经过采样、量化、编码三个步骤。</p>
<p>（1）要据奈奎斯特采样定理，取样速率大于模拟信号的最高频率的2倍。例如，人耳能识别的最高频率为22KHz，因此，采样率一般必须达到44KHz。</p>
<p>（2）量化是将样本的连续值转换成离散值，采用的方法类似于求圆周长时用内切正多边形的方法。而我们平时提到的8位、16位的声音，指的就是28、216位量化。</p>
<p>（3）编码就是将量化后的样本值变成相应的二进制代码。</p>
<h3 id="3模拟通道传送数字数据"><a href="#3．模拟通道传送数字数据" class="headerlink" title="3．模拟通道传送数字数据"></a>3．模拟通道传送数字数据</h3><p>计算机拨号上网，电话网络传送的是模拟数据，而计算机只能收发数字数据，这就涉及到模拟信道传送数字信号的变换问题。也就是一个数据调制与解调的问题。数字数据调制为模拟信号，选取某一频率的正弦信号作为载波用以运载所要传送的数字数据。用待传送的数字数据改变载波的幅值、频率、或相位，到达目的地后进行分离。而在接收端则通过解调以还原信号。有关具体的调制技术，请参考表4-1。</p>
<h3 id="4数字通道传送数字数据"><a href="#4．数字通道传送数字数据" class="headerlink" title="4．数字通道传送数字数据"></a>4．数字通道传送数字数据</h3><p>在数据通信中，编码的作用是用信号来表示数字信息。例如，单极性编码、极化编码、双极性编码等。</p>
<p>（1）非归零编码（Non-ReturnZero，NRZ）。归零指的是编码信号量是否回归到零电平。非归零编码的码元信号的电压位或正或负（当“1”出现时电平翻转，“0”出现时电平不翻转）。与采用线路空闲态代表0比特的单极性编码法不同，在非归零编码系统中，如果线路空闲意味着没有任何信号正在传输中。非归零编码又可以分为非归零电平编码（NoReturnZero-Level，NRZ-L）和非归零反相编码（NoneReturnZero-Inverse，NRZ-I）。</p>
<p>在NRZ-L编码方式中，信号的电平是根据它所代表的比特位决定的。一个正电压值代表比特0，一个负电压代表比特1（或相反）。在NRZ-L中，当数据流中存在一连串1或0时，也会出现与单极性编码中同样的同步问题。</p>
<p>在NRZ-I编码方式中，信号电平的一次反转代表比特1。就是说是从正电平到负电平的一次跃迁（而不是电压值本身）来代表一个比特1。0比特由没有电平变化的信号代表。NRZ-I相对NRZ-L的优点在于：因为每次遇到比特1都发生电平跃迁，这能提供一种同步机制。</p>
<p>（2）归零编码（ReturnZero，RZ）。码元中间的信号回归到0电平（正电平到零电平的转换表示码元0，负电平到零电平的转换表示码元1）。</p>
<p>（3）双相位编码。现在对同步问题最好的解决方案就是双相位编码。通过不同方向的电平翻转（低到高代表0，高到低代表1），这样不仅可以提高抗干扰性，还可以实现自同步。双相位编码有两种方法，第一种是曼彻斯特编码，主要用在以太局域网中；第二种是差分曼彻斯特编码，主要用在令牌环局域网中。</p>
<p>曼彻斯特编码用低到高的电平转换表示0，用高到低的电平转换表示1（注意：某些文献中关于此定义有相反的描述，也是正确的）。差分曼彻斯特编码是在曼彻斯特编码的基础上加上了翻转特性，遇0翻转，遇1不变，常用于令牌环网。要注意的一个知识点是：使用曼彻斯特编码和差分曼彻斯特编码时，每传输1bit的信息，就要求线路上有2次电平状态变化（2Baud），因此要实现100Mbps的传输速率，就需要有200MHz的带宽，即编码效率只有50%。</p>
<p>（4）mBnX编码。正是因为曼彻斯特编码的编码效率不高，所以在带宽资源宝贵的广域网与高速局域网中，显得不能得到有效利用。mBnX编码是将m比特位编码成n位波特（代码位）的编码，</p>
<p>数据通信中还有另一类编码，称为差错控制编码（校验码）。它的作用是通过对信息序列作某种变换，使原来彼此独立、相关性极小的信息码元产生某种相关性，从而在接收端就利用这种特性，来检查或进而纠正信息码元在信道传输中所造成的差错。</p>
<h2 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h2><p>在网络架构方面，主要考查开放系统互连参考模型、网络地址与网络协议、子网掩码、网络分类、802.3系列协议、虚拟局域网，以及计算机网络系统平台的划分等。</p>
<h2 id="网络的分类"><a href="#网络的分类" class="headerlink" title="网络的分类"></a>网络的分类</h2><p>不同传输距离的网络可以分为局域网、城域网和广域网三种。局域网的相关技术是由处理近距离传输设计和发展而来的，而广域网的相关技术是由处理远距离传输设计和发展而来的，城域网则是为一个城市网络设计的相关技术。</p>
<h3 id="1局域网"><a href="#1．局域网" class="headerlink" title="1．局域网"></a>1．局域网</h3><p>局域网（LocalAreaNetwork，LAN）是在传输距离较短的前提下所发展的相关技术的集合，用于将小区域内的各种计算机设备和通信设备互联在一起组成资源共享的通信网络。在局域网中常见的传输媒介有双绞线、细/粗同轴电缆、微波、射频信号和红外线等。其主要特点如下：</p>
<p>（1）距离短：0.1km～25km，可以是一个建筑物内、一个校园内或办公室内。</p>
<p>（2）速度快：4Mbps～1Gbps，从早期的4Mbps、10Mbps及100Mbps发展到现在的1000Mbps（1Gbps），而且还在不断向前发展。</p>
<p>（3）高可靠性：由于距离很近，传输相当可靠，有极低的误码率。</p>
<p>（4）成本较低：由于覆盖的地域较小，因此传输媒介、网络设备的价格都相对较便宜，管理也比较简单。</p>
<p>根据技术的不同，局域网有以太网（Ethernet）、令牌环网络（TokenRing）、AppleTalk网络和ArcNet网络等几种类型。现在，几乎所有的局域网都是基于以太网实现的。当然，随着应用需求的不断提高，也对局域网技术提出了新的挑战，出现了一批像FDDI（FiberDistributedDataInterface，光纤分布式数据接口）一样的技术。</p>
<h3 id="2广域网"><a href="#2．广域网" class="headerlink" title="2．广域网"></a>2．广域网</h3><p>广域网（WideAreaNetwork，WAN）是在传输距离较长的前提下所发展的相关技术的集合，用于将大区域范围内的各种计算机设备和通信设备互联在一起组成一个资源共享的通信网络。</p>
<p>其主要特点如下：</p>
<p>（1）长距离：跨越城市，甚至联通全球进行远距离连接。</p>
<p>（2）低速率：这是与局域网的速度相比而言的，一般情况下，广域网的传输速率是以Kbps为单位的。现在也出现了许多ISDN（IntegratedServicesDigitalNetwork，综合业务数字网）和ADSL（AsymmetricDigitalSubscriberLine，非对称数字用户线路）这样的高速广域网，其传输速率也能达到Mbps，当然费用也大大地提高了。</p>
<p>（3）高成本：相对于城域网和局域网来说，广域网的架设成本是很昂贵的，当然它所带来的经济效益也是极大的。WAN由通信子网与资源子网两部分组成，通信子网通常由通信节点和通信链路组成。通信节点往往就是一台计算机，它一方面提供通信子网与资源子网的接口，另一方面对其他节点而言又是—个存储转发节点。作为网络接口节点，它能提供信息的接口，并对传输及网络信息进行控制。通信子网中，软件必须遵循网络协议，实现对链路及节点存储器的管理，还必须提供与主处理器、终端集中器进行信息交换的接口。资源子系统是指连在网上的各种计算机、终端和数据库等。这不仅指硬件，也包括软件和数据资源。通信子网主要使用分组交换技术，根据网络通信原理，局域网与广域网的互联一般是通过第三层设备路由器实现的。</p>
<h3 id="3城域网"><a href="#3．城域网" class="headerlink" title="3．城域网"></a>3．城域网</h3><p>城域网（MetropolitanAreaNetwork，MAN）的覆盖范围介于局域网和广域网之间，城域网的主要技术是DQDB（DistributedQueueDualBus，分布式队列双总线），即IEEE802.6。DQDB是由双总线构成的，所有的计算机都连接在上面。</p>
<p>所谓宽带城域网，就是在城市范围内，以IP（InternetProtocol，网际协议）和ATM（AsynchronousTransferMode，异步传输模式）电信技术为基础，以光纤作为传输媒介，集数据、语音和视频服务于一体的高带宽、多功能及多业务接入的多媒体通信网络。</p>
<h2 id="网络互连模型"><a href="#网络互连模型" class="headerlink" title="网络互连模型"></a>网络互连模型</h2><p>网络互连模型</p>
<p>在网络互连方面，国际上通用的模型是开放系统互连参考模型（OpenSystem Interconnection/ReferenceModel，OSI/RM），该模型最初用来作为开发网络通信协议族的一个工业参考标准，是各个层上使用的协议国际化标准。严格遵守OSI/RM模型，不同的网络技术之间可以轻而易举地实现互操作。整个OSI/RM模型共分7层，从下往上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<h3 id="1物理层"><a href="#1．物理层" class="headerlink" title="1．物理层"></a>1．物理层</h3><p>物理层的所有协议规定了不同种类的传输设备、传输媒介如何将数字信号从一端传送到另一端，而不管传送的是什么数据。它是完全面向硬件的，通过一系列协议定义了通信设备的机械、电气、功能和规程特征。</p>
<p>（1）机械特征：规定线缆与网络接口卡的连接头的形状、几何尺寸、引脚线数、引线排列方式和锁定装置等一系列外形特征。</p>
<p>（2）电气特征：规定了在传输过程中多少伏特的电压代表1，多少伏特代表0。</p>
<p>（3）功能特征：规定了连接双方每个连接线的作用，即哪些是用于传输数据的数据线，哪些是用于传输控制信息的控制线，哪些是用于协调通信的定时线，哪些是用于接地的地线。</p>
<p>（4）过程特征：具体规定了通信双方的通信步骤。</p>
<h3 id="2数据链路层"><a href="#2．数据链路层" class="headerlink" title="2．数据链路层"></a>2．数据链路层</h3><p>数据链路层在物理层已能将信号发送到通信链路中的基础上，负责建立一条可靠的数据传输通道，完成相邻结点之间有效地传送数据的任务。正在通信的两个站点在某一特定时刻，一个发送数据，一个接收数据。数据链路层通过一系列协议实现以下功能。</p>
<p>（1）封装成帧：把数据组成一定大小的数据块（帧），然后以帧为单位发送、接收和校验数据。</p>
<p>（2）流量控制：根据接收站的接收情况，发送数据的一方实时地进行传输速率控制，以免出现发送数据过快，接收方来不及处理而丢失数据的情况。</p>
<p>（3）差错控制：当接收到数据帧后，接收数据的一方对其进行检验，如果发现错误，则通知发送方重传。</p>
<p>（4）传输管理：在发送端与接收端通过某种特定形式的对话来建立、维护和终止一批数据的传输过程，以此对数据链路进行管理。</p>
<p>就发送端而言，数据链路层将来自上层的数据按一定规则转化为比特流送到物理层进行处理；就接收端而言，它通过数据链路层将来自物理层的比特流合并成完整的数据帧供上层使用。最典型的数据链路层协议是IEEE（InstituteofElectricalandElectronicsEngineers，美国电气和电子工程师协会）开发的802系列规范，在该系列规范中将数据链路层分成了两个子层：逻辑链路控制层（LogicLinkControl，LLC）和介质访问控制层（MediaAccessControl，MAC）。LLC层负责建立和维护两台通信设备之间的逻辑通信链路；MAC层控制多个信息通道复用一个物理介质。MAC层提供对网卡的共享访问与网卡的直接通信。网卡在出厂前会被分配给唯一的由12位十六进制数表示的MAC地址（物理地址），MAC地址可提供给LLC层来建立同一个局域网中两台设备之间的逻辑链路。</p>
<p>IEEE802规范目前主要包括以下内容。</p>
<p>（1）802.1：802协议概论，其中802.1A规定了局域网体系结构，802.1B规定了寻址、网络互连与网络管理。</p>
<p>（2）802.2：LLC协议。</p>
<p>（3）802.3：以太网的CSMA/CD（CarrierSenseMultipleAccess/CollisionDetect，载波监听多路访问/冲突检测）协议，其中802.3i规定了10Base-T访问控制方法与物理层规范，802.3u规定了100Base-T访问控制方法与物理层规范，802.3ab-规定了1000Base-T访问控制方法与物理层规范，802.3z规定了1000Base-SX和1000Base-LX访问控制方法与物理层规范。</p>
<p>（4）802.4：令牌总线（TokenBus）访问控制方法与物理层规范。</p>
<p>（5）802.5：令牌环访问控制方法。</p>
<p>（6）802.6：城域网访问控制方法与物理层规范。</p>
<p>（7）802.7：宽带局域网访问控制方法与物理层规范。</p>
<p>（8）802.8：FDDI访问控制方法与物理层规范。</p>
<p>（9）802.9：局域网上的语音/数据集成规范。</p>
<p>（10）802.10：局域网安全互操作标准。</p>
<p>（11）802.11：无线局域网（WirelessLocalAreaNetwork，WLAN）标准协议。</p>
<p>（12）802.12：100VG-Any局域网访问控制方法与物理层规范</p>
<p>（13）802.14：协调混合光纤同轴网络的前端和用户站点间数据通信的协议。</p>
<p>（14）802.15：无线个人网技术标准，其代表技术是蓝牙。</p>
<p>（15）802.16：无线MAN空中接口规范。</p>
<h3 id="3网络层"><a href="#3．网络层" class="headerlink" title="3．网络层"></a>3．网络层</h3><p>网络层用于从发送端向接收端传送分组，负责确保信息到达预定的目标。其存在的主要目的是</p>
<p>解决以下问题：</p>
<p>（1）通信双方并不相邻。在计算机网络中，通信双方可能是相互邻接的，但也可能并不是邻接的。当一个数据分组从发送端发送到接收端时，就可能要经过多个其他网络结点，这些结点暂时存储“路过”的数据分组，再根据网络的“交通状况”选择下一个结点将数据分组发出去，直到发送到接收方为止。</p>
<p>（2）由于OSI/RM模型出现在许多网络协议之后，因此，为了与使用这些已经存在的网络协议的计算机进行互联，就需要解决异构网络的互联问题。</p>
<h3 id="4传输层"><a href="#4．传输层" class="headerlink" title="4．传输层"></a>4．传输层</h3><p>传输层实现发送端和接收端的端到端的数据分组传送，负责保证实现数据包无差错、按顺序、无丢失和无冗余地传输。在传输层上，所执行的任务包括检错和纠错。它的出现是为了更加有效地利用网络层所提供的服务。它的作用主要体现在以下两方面：</p>
<p>（1）将一个较长的数据分成几个小数据包发送。在网络中实际传递的每个数据帧都是有一定大小限制的。假设如果要传送一个字串“123456789”，它太长了，网络服务程序一次只能传送一个数字（当然在实际中不可能这么小，这里仅是为了方便讲解所做的假设），因此网络就需要将其分成9次来传递。就发送端而言，当然是从1传到9的，但是由于每个数据分组传输的路径不会完全相同（因为它是要根据当时的网络“交通状况”而选择路径的），先传送出去的包，不一定会先被收到，因此接收端所收到的数据的排列顺序是与发送的顺序不同的。而传输层的协议就给每一个数据组加入排列组合的记号，以便接收端能根据这些记号将它们重组成原来的顺序。</p>
<p>（2）解决通信双方不只有一个数据连接的问题。这个问题从字面上可能不容易理解，来看一个例子，比如用一台电脑与另一台电脑连接复制数据的同时，又通过一些交谈程序进行对话。这个时候，复制的数据与对话的内容是同时到达的，传输的协议负责将它们分开，分别传给相应的程序端口，这也就是端到端的通信。</p>
<h3 id="5会话层"><a href="#5．会话层" class="headerlink" title="5．会话层"></a>5．会话层</h3><p>会话层主要负责管理远程用户或进程间的通信。该层提供名字查找和安全验证等服务，允许两个程序能够相互识别并建立和维护通信连接。会话层还提供数据同步和检查点功能，这样当网络失效时，会对失效后的数据进行重发。在OSI/RM模型中，会话层的规范具体包括通信控制、检查点设置、重建中断的传输链路、名字查找和安全验证服务。</p>
<h3 id="6表示层"><a href="#6．表示层" class="headerlink" title="6．表示层"></a>6．表示层</h3><p>表示层以下的各层只关心从源地到目的地可靠地传输数据，而表示层则关心的是所传送信息的语义与语法。它负责将收到的数据转换为计算机内的表示方法或特定程序的表示方法。也就是说，它负责通信协议的转换、数据的翻译、数据的加密、数据的压缩、字符的转换等工作。在OSI/RM模型中表示层的规范具体包括数据编码方式的约定和本地句法的转换。各种表示数据的格式的协议也属于表示层，例如，数据压缩和编码等。</p>
<h3 id="7应用层"><a href="#7．应用层" class="headerlink" title="7．应用层"></a>7．应用层</h3><p>应用层是直接提供服务给使用者的应用软件的层，比如电子邮件和在线交谈程序都属于应用层的范畴。应用层可实现网络中一台计算机上的应用程序与另一台计算机上的应用程序之间的通信，就像在同一台计算机上操作一样。在OSI/RM模型中应用层的规范具体包括各类应用过程的接口和用户接口。</p>
<h3 id="8模型的工作模式"><a href="#8．模型的工作模式" class="headerlink" title="8．模型的工作模式"></a>8．模型的工作模式</h3><p>当接收数据时，数据是自下而上传输的；当发送数据时，数据是自上而下传输的。在网络数据通信的过程中，每一层要完成特定的任务。当传输数据的时候，每一层接收上一层格式化后的数据，对数据进行操作，然后把它传给下一层。当接收数据的时候，每一层接收下一层传过来的数据，对数据进行解包，然后把它传给上一层。这就实现了对等层之间的逻辑通信。OSI/RM模型并未确切描述用于各层的协议和服务，它仅仅告诉我们每一层该做些什么。</p>
<h2 id="常用的网络协议"><a href="#常用的网络协议" class="headerlink" title="常用的网络协议"></a>常用的网络协议</h2><p>常用的网络协议</p>
<p>本节主要介绍TCP（TransmissionControlProtocol，传输控制协议）/IP协议族中的一些主要协议。TCP/IP不是一个简单的协议，而是一组小的、专业化协议。TCP/IP最大的优势之一是其可路由性，这也就意味着它可以携带能被路由器解释的网络编址信息。TCP/IP还具有灵活性，可在多个网络操作系统或网络介质的联合系统中运行。然而由于它的灵活性，TCP/IP需要更多的配置。TCP/IP协议族可被大致分为应用层、传输层、网际层和网络接口层四层。</p>
<p>分层只是一种“大致”的分法，各种文献的分法略有不同。特别是与OSI/RM层次的对应关系上，也是一种大致的对应关系，而不是严格的对应关系。图4-2中的虚线表示某个协议是基于哪个低层协议的，例如，TFTP（TrivialFileTransferProtocol，简单文件传输协议）是基于UDP（UserDatagramProtocol，用户数据报协议）的，而FTP（FileTransport</p>
<p>Protocol，文件传输协议）是基于TCP协议的，NFS（NetFileSystem，网络文件系统）即可基于UDP协议来实现，也可基于TCP协议来实现。</p>
<h3 id="1应用层"><a href="#1．应用层" class="headerlink" title="1．应用层"></a>1．应用层</h3><p>TCP/IP的应用层大致对应于OSI/RM模型的应用层和表示层，应用程序通过本层协议利用网</p>
<p>络。这些协议主要有FTP、TFTP、HTTP（HypertextTransferProtocol，超文本传输协议）、</p>
<p><strong>SMTP</strong>（SimpleMailTransferProtocol，简单邮件传输协议）、<strong>DHCP</strong>（DynamicHostConfigurationProtocol，动态主机配置协议）、<strong>NFS</strong>、<strong>Telnet</strong>（远程登录协议）、<strong>DNS</strong>（DomainNameSystem，域名系统）和<strong>SNMP</strong>（SimpleNetworkManagementProtocol，简单网络管理协议）等。</p>
<p><strong>FTP</strong>是网络上两台计算机传送文件的协议，是通过Internet把文件从客户机复制到服务器上的一</p>
<p>种途径。</p>
<p><strong>TFTP</strong>是用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传</p>
<p>输服务。TFTP协议设计的时候是进行小文件传输的，因此它不具备通常的FTP的许多功能，它只能</p>
<p>从文件服务器上获得或写入文件，不能列出目录，也不进行认证。</p>
<p><strong>HTTP</strong>是用于从WWW服务器传输超文本到本地浏览器的传送协议输。它可以使浏览器更加高</p>
<p>效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部</p>
<p>分，以及哪部分内容首先显示等。</p>
<p>SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建模在FTP文件传输服务上的一</p>
<p>种邮件服务，主要用于传输系统之间的邮件信息并提供与来信有关的通知。</p>
<p><strong>DHCP</strong>分为两个部分，一个是服务器端，另一个是客户端。所有的IP网络设定数据都由DHCP服</p>
<p>务器集中管理，并负责处理客户端的DHCP要求；而客户端则会使用从服务器分配下来的IP环境数</p>
<p>据。DHCP通过租约的概念，有效且动态地分配客户端的TCP/IP设定。DHCP分配的IP地址可以分为</p>
<p>三种方式，分别是固定分配、动态分配和自动分配。</p>
<p><strong>NFS</strong>是FreeBSD支持的文件系统中的一种，允许一个系统在网络上与他人共享目录和文件。通</p>
<p>过使用NFS，用户和程序可以像访问本地文件一样访问远端系统上的文件。</p>
<p><strong>Telnet</strong>是登录和仿真程序，它的基本功能是允许用户登录进入远程主机系统。以前，Telnet是</p>
<p>一个将所有用户输入送到远方主机进行处理的简单的终端程序。它的一些较新的版本在本地执行更</p>
<p>多的处理，于是可以提供更好的响应，并且减少了通过链路发送到远程主机的信息数量。</p>
<p><strong>DNS</strong>用于命名组织到域层次结构中的计算机和网络服务。在Internet上域名与IP地址之间是一一</p>
<p>对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名</p>
<p>解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。DNS通过</p>
<p>对用户友好的名称查找计算机和服务。当用户在浏览器中输入域名时，DNS服务可以将此名称解析</p>
<p>为与之相关的其他信息，如IP地址。</p>
<p><strong>SNMP</strong>是为了解决Internet上的路由器管理问题而提出的，指一系列网络管理规范的集合，包括</p>
<p>协议本身、数据结构的定义和一些相关概念。目前SNMP已成为网络管理领域中事实上的工业标</p>
<p>准，并被广泛支持和应用，大多数网络管理系统和平台都是基于SNMP的。</p>
<h3 id="2传输层"><a href="#2．传输层" class="headerlink" title="2．传输层"></a>2．传输层</h3><p>TCP/IP的传输层大致对应于OSI/RM模型的会话层和传输层，主要包括TCP和UDP，这些协议</p>
<p>负责提供流量控制、错误校验和排序服务。所有的服务请求都使用这些协议。</p>
<p><strong>TCP</strong>是整个TCP/IP协议族中最重要的协议之一，它在IP协议提供的不可靠数据服务的基础上，</p>
<p>采用了重发技术，为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务。TCP协议一</p>
<p>般用于传输数据量比较少，且对可靠性要求高的场合。</p>
<p><strong>UDP</strong>是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信，与同样处在传输层的</p>
<p>面向连接的TCP相比较，UDP是一种无连接的协议，它的错误检测功能要弱得多。可以这样说，TCP</p>
<p>有助于提供可靠性，而UDP则有助于提高传输的高速率。UDP协议一般用于传输数据量大，对可靠</p>
<p>性要求不是很高，但要求速度快的场合。</p>
<h3 id="3网际层"><a href="#3．网际层" class="headerlink" title="3．网际层"></a>3．网际层</h3><p>TCP/IP的网际层对应于OSI/RM模型的网络层，包括<strong>IP</strong>、<strong>ICMP（</strong>InternetControlMessageProtocol，网际控制报文协议）、<strong>IGMP</strong>（InternetGroupManagementProtocol，网际组管理协议），以及ARP<strong>（AddressResolutionProtocol，地址解析协议）和</strong>RARP**（ReverseAddressResolutionProtocol，反向地址解析协议）。这些协议处理信息的路由及主机地址解析。</p>
<p><strong>IP</strong>所提供的服务通常被认为是无连接的和不可靠的，因此把差错检测和流量控制之类的服务授权给了其他的各层协议，这正是TCP/IP能够高效率工作的一个重要保证。网际层的功能主要由IP来提供，除了提供端到端的分组分发功能外，IP还提供了很多扩充功能。例如，为了克服数据链路层对帧大小的限制，网络层提供了数据分块和重组功能，这使得很大的IP数据包能以较小的分组在网上传输。</p>
<p>网际层的另一个重要服务是在互相独立的局域网上建立互联网络，即网际网。网间的报文来往根据它的目的IP地址通过路由器传到另一网络。</p>
<p><strong>ARP</strong>用于动态地完成IP地址向物理地址的转换。物理地址通常是指主机的网卡地址（MAC地址），每一网卡都有唯一的地址；RARP用于动态完成物理地址向IP地址的转换。</p>
<p><strong>ICMP</strong>是一个专门用于发送差错报文的协议，由于IP协议是一种尽力传送的通信协议，即传送的数据可能丢失、重复、延迟或乱序传递，所以IP协议需要一种尽量避免差错并能在发生差错时报告的机制。</p>
<p><strong>IGMP</strong>允许Internet主机参加多播，也即是IP主机用做向相邻多目路由器报告多目组成员的协议。多目路由器是支持组播的路由器，向本地网络发送IGMP查询。主机通过发送IGMP报告来应答查询。组播路由器负责将组播包转发到网络中所有组播成员。</p>
<h3 id="4网络接口层"><a href="#4．网络接口层" class="headerlink" title="4．网络接口层"></a>4．网络接口层</h3><p>TCP/IP的网络接口层大致对应于OSI/RM模型的数据链路层和物理层，TCP/IP协议不包含具体的物理层和数据链路层，只定义了网络接口层作为物理层的接口规范。网络接口层处在TCP/IP协议的最底层，主要负责管理为物理网络准备数据所需的全部服务程序和功能。该层处理数据的格式化并将数据传输到网络电缆，为TCP/IP的实现基础，其中可包含IEEE802.3的CSMA/CD、IEEE802.5的TokenRing等。</p>
<h3 id="5端口"><a href="#5．端口" class="headerlink" title="5．端口"></a>5．端口</h3><p>在TCP/IP网络中，传输层的所有服务都包含端口号，它们可以唯一区分每个数据包包含哪些应用协议。端口系统利用这种信息来区分包中的数据，尤其是端口号使一个接收端计算机系统能够确定它所收到的IP包类型，并把它交给合适的高层软件。</p>
<p>端口号和设备IP地址的组合通常称作插口（socket）。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet号分配机构（InternetAssignedNumbersAuthority，IANA）来管理。例如，SMTP所用的TCP端口号是25，POP3所用的TCP端口号是110，DNS所用的UDP端口号为53，WWW服务使用的TCP端口号为80。FTP在客户与服务器的内部建立两条TCP连接，一条是控制连接，端口号为21；另一条是数据连接，端口号为20。</p>
<p>256～1023之间的端口号通常由Unix系统占用，以提供一些特定的UNIX服务。也就是说，提供一些只有Unix系统才有的、其他操作系统可能不提供的服务。</p>
<p>在实际应用中，用户可以改变服务器上各种服务的保留端口号，但要注意，在需要服务的客户端也要改为同一端口号。</p>
<h2 id="网络地址与掩码"><a href="#网络地址与掩码" class="headerlink" title="网络地址与掩码"></a>网络地址与掩码</h2><p>连接到Internet上的每台计算机都必须有一个唯一地址，称为IP地址。IP地址是一个4字节（共32位）的数字，被分为4段，每段8位，段与段之间用句点分隔。为了便于表达和识别，IP地址以十进制形式表示（例如212.152.200.12），每段所能表示的十进制数最大不超过255。IP地址由两部分组成，即网络号和主机号。网络号标识的是Internet上的一个子网，而主机号标识的是子网中的某台主机。</p>
<h3 id="1ip地址的分类"><a href="#1．IP地址的分类" class="headerlink" title="1．IP地址的分类"></a>1．IP地址的分类</h3><p>IP地址可分为5类，分别是A类、B类、C类、D类和E类，大量使用的仅为A类、B类、C类。</p>
<p>（1）A类地址：最前面1位为0，然后用7位来标识网络号，24位标识主机号。即A类地址的第一段取值介于1～126之间。A类地址通常为大型网络而提供，全世界总共只有126个可能的A类网</p>
<p>络，每个A类网络最多可以连接224-2台主机（两个保留地址）。</p>
<p>（2）B类地址：最前面2位是10，然后用14位来标识网络号，16位标识主机号。因此，B类地址的第一段取值介于128～191之间，第一段和第二段合在一起表示网络号。B类地址适用于中等规</p>
<p>模的网络，每个B类网络最多可以连接216-2台主机（两个保留地址）。</p>
<p>（3）C类地址：最前面3位是110，然后用21位来标识网络号，8位标识主机号。因此，C类地址的第一段取值介于192～223之间，前三段合在一起表示网络号。最后一段标识网络上的主机号。</p>
<p>C类地址适用于校园网等小型网络，每个C类网络最多可以有28-2台主机（两个保留地址）。</p>
<p>（4）D类地址：最前面4位为1110，D类地址不分网络地址和主机地址，它是一个专门保留的地址。它并不指向特定的网络，目前D类地址被用在多点广播中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。</p>
<p>（5）E类地址：最前面5位为11110，E类地址也不分网络地址和主机地址，为将来使用所保</p>
<p>留。</p>
<p>希赛教育专家提示：有几种特殊的情况需要注意，例如，主机号全为1的地址用于广播，称为广播地址。网络号全为0，则后面的主机号表示本网地址。主机号全为0，此时的网络号就是本网的地址。网络号全为1的地址和32位全为0的地址为保留地址。</p>
<p>2．子网掩码</p>
<p>子网指一个组织中相连的网络设备的逻辑分组。一般情况下，子网可表示为某地理位置内（某</p>
<p>大楼或相同局域网中）的所有机器。将网络划分成一个个逻辑段（即子网）的目的是便于更好地管</p>
<p>理网络，同时提高网络性能，增强网络安全性。另外，将一个组织内的网络划分成各个子网，只需</p>
<p>要通过单个共享网络地址，即可将这些子网连接到互联网上，从而减缓了互联网IP地址的耗尽趋</p>
<p>势。</p>
<p>掩码是一个32位二进制数字，用点分十进制来描述，默认情况下，掩码包含两个域，分别为网</p>
<p>络域和主机域。这些内容分别对应网络号和本地可管理的网络地址部分，通过使用掩码可将本地可</p>
<p>管理的网络地址部分划分成多个子网。</p>
<p>例如，假设某个IP地址为176.68.160.12/22，则表示使用22位作为网络地址，那么主机地址就</p>
<p>占10位。因此，此子网的主机数可以有210-2个。该IP地址是个B类地址，默认掩码为255.255.0.0</p>
<p>（B类地址的前16位为网络地址）。但这个地址中前22位作为网络地址，则子网掩码第三个字节的</p>
<p>前6位为子网域，用1表示；剩余的位数为主机域，用0表示。即1111110000000000，将这个二进</p>
<p>制信息转换成十进制作为掩码的后半部分，则可得出完整掩码为255.255.252.0。</p>
<p>3．IPv6</p>
<p>前面介绍的IP地址协议的版本号是4（简称为IPv4），它的下一个版本就是IPv6。IPv6正处在不</p>
<p>断发展和完善的过程中，它在不久的将来将取代目前被广泛使用的IPv4。</p>
<p>与IPV4相比，IPV6具有以下几点优势：</p>
<p>（1）IPv6具有更大的地址空间。IPv4中规定IP地址长度为32位，而IPv6中IP地址的长度为128</p>
<p>位。</p>
<p>（2）IPv6使用更小的路由表。IPv6的地址分配一开始就遵循聚类的原则，这使得路由器能在路</p>
<p>由表中用一条记录表示一个子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的</p>
<p>速度。</p>
<p>（3）IPv6增加了增强的组播支持及对流的支持，这使得网络上的多媒体应用有了长足发展的机</p>
<p>会，为服务质量（QualityofService，QoS）控制提供了良好的网络平台。</p>
<p>（4）IPv6加入了对自动配置的支持。这是对DHCP协议的改进和扩展，使得网络（尤其是局域</p>
<p>网）的管理更加方便和快捷。</p>
<p>（5）IPv6具有更高的安全性。在使用IPv6网络时用户可以对网络层的数据进行加密并对IP报文</p>
<p>进行校验，极大地增强了网络的安全性。</p>
<p>第4章：数据通信与计算机网络</p>
<p>虚拟局域网</p>
<p>虚拟局域网（VirtualLocalAreaNetwork，VLAN）是由一些主机、交换机或路由器等组成的</p>
<p>一个虚拟的局域网。虚拟局域网超越了传统的局域网的物理位置局限，终端系统可以分布于网络中</p>
<p>不同的地理位置，但都属于同一逻辑广播域。</p>
<p>1．VLAN的功能</p>
<p>管理员能够很容易地控制不同VLAN间的互相访问能力，可以将同一部门或属于同一访问功能组</p>
<p>的用户划分在同一VLAN中，VLAN内的用户之间可以通过交换机或路由器相互连通。网络管理员甚</p>
<p>至还可以通过VLAN的安全访问列表来控制不同VLAN之间的访问。</p>
<p>VLAN能够对广播信息进行有效的控制，最大限度地减少对终端工作站、网络服务器和处理关键</p>
<p>业务数据的骨干部分的性能影响。采用VLAN还便于管理的更改，而整个网络范围内与用户增加、移</p>
<p>动和物理位置变更相关的对管理工作的要求，也大为减少。这从很大程度上方便了网络系统的安全</p>
<p>访问控制管理。</p>
<p>通过VLAN运行机制，可以给网络安全带来很多好处，比如信息只到达应该到达的地点，因此可</p>
<p>防止大部分基于网络监听的入侵手段；通过VLAN设置的访问控制，也使在虚拟网外的网络节点不能</p>
<p>直接访问虚拟网内节点。但是，VLAN技术也带来了新的问题：执行虚拟网交换的设备越来越复杂，</p>
<p>从而成为被攻击的对象；基于网络广播原理的入侵监控技术在高速交换网络内需要特殊的设置；基</p>
<p>于MAC的VLAN不能防止MAC欺骗攻击，因此采用基于MAC的VLAN划分将面临假冒MAC地址的攻</p>
<p>击。因此，VLAN的划分最好基于交换机端口，但这要求整个网络桌面使用交换端口或每个交换端口</p>
<p>所在的网段机器均属于相同的VLAN。</p>
<p>如果一个VLAN跨越多个交换机，则属于同一VLAN的工作站要通过Trunk（干道）线路互相通</p>
<p>信。Trunk是一种封装技术，它是一条点到点的链路，主要功能就是仅通过一条链路就可以连接多个</p>
<p>交换机从而扩展已配置的多个VLAN。还可以采用通过Trunk技术和上级交换机级连的方式来扩展端</p>
<p>口的数量，达到近似堆叠的功能，节省了网络硬件的成本，从而扩展整个网络。Trunk承载的VLAN</p>
<p>范围，默认是1～1005，用户可以修改，但必须有一个Trunk协议。使用Trunk时，相邻端口上的协</p>
<p>议要一致。</p>
<p>VLAN的划分方法</p>
<p>目前，实现VLAN的划分有多种方法：</p>
<p>（1）按交换机端口号划分。将交换设备端口进行分组来划分VLAN，例如，一个交换设备上的</p>
<p>端口1、2、5、7所连接的客户工作站可以构成VLANA，而端口3、4、6、8则构成VLANB等。在</p>
<p>最初的实现中，VLAN是不能跨越交换设备的，后来进一步的发展使得VLAN可以跨越多个交换设</p>
<p>备。目前，按端口号划分VLAN仍然是构造VLAN的一个最常用的方法。这种方法比较简单并且非常</p>
<p>有效。但仅靠端口分组而定义VLAN将无法使得同一个物理分段（或交换端口）同时参与到多个</p>
<p>VLAN中，而且更重要的是当一个客户站从一个端口移至另一个端口时，网管人员将不得不对VLAN</p>
<p>成员进行重新配置。</p>
<p>（2）按MAC地址划分。由网管人员指定属于同一个VLAN中的各客户端的MAC地址。由于</p>
<p>MAC地址是固化在网卡中的，故移至网络中另外一个地方时将仍然保持其原先的VLAN成员身份而</p>
<p>无需网管人员对之进行重新的配置，从这个意义讲，用MAC地址定义的VLAN可以看成是基于用户</p>
<p>的VLAN。另外，在这种方式中，同一个MAC地址可以处于多个VLAN中。这种方法的缺点是所有的</p>
<p>用户在最初都必须被配置到（手工方式）至少一个VLAN中，只有在这种手工配置之后方可实现对</p>
<p>VLAN成员的自动跟踪。</p>
<p>（3）按第三层协议划分。在决定VLAN成员身份时，主要考虑协议类型（支持多协议的情况</p>
<p>下）或网络层地址（如TCP/IP网络的子网地址）。这种类型的VLAN划分需要将子网地址映射到</p>
<p>VLAN，交换设备则根据子网地址而将各机器的MAC地址同一个VLAN联系起来。交换设备将决定不</p>
<p>同网络端口上连接的机器属于同一个VLAN。在第三层定义VLAN有许多优点。首先，可以根据协议</p>
<p>类型进行VLAN的划分，这对于那些基于服务或基于应用VLAN策略的网管人员无疑是极具吸引力</p>
<p>的。其次，用户可以自由地移动他们的机器而无需对网络地址进行重新配置，并且在第三层上定义</p>
<p>VLAN将不再需要报文标识，从而可以消除因在交换设备之间传递VLAN成员信息而花费的开销。与</p>
<p>前两种方法相比，第三层VLAN方法的最大缺点就是性能问题。对报文中的网络地址进行检查将比对</p>
<p>帧中的MAC地址进行检查开销更大。正是由于这个原因，使用第三层协议进行VLAN划分的交换设</p>
<p>备一般都比使用第二层协议的交换设备更慢。但第三层交换机的出现，大大改善了VLAN成员间的通</p>
<p>信效率。</p>
<p>（4）IP组播VLAN。在这种方法中，各站点可以自由地动态决定（通过编程的方法）参加到哪</p>
<p>一个或哪一些IP组播组中。一个IP组播组实际上是用一个D类地址表示的，当向一个组播组发送一个</p>
<p>IP报文时，此报文将被传送到此组中的各个站点处。从这个意义上讲，可以将一个IP组播组看成是一</p>
<p>个VLAN。但此VLAN中的各个成员都只具有临时性的特点。由IP组播定义VLAN的动态特性可以达</p>
<p>到很高的灵活性，并且借助于路由器，这种VLAN可以很容易地扩展到整个WAN上。</p>
<p>（5）基于策略的VLAN。基于策略的方法允许网络管理员使用任何VLAN策略的组合来创建满</p>
<p>足其需求的VLAN。通过VLAN策略把设备指定给VLAN，当一个策略被指定到一个交换机时，该策</p>
<p>略就在整个网络上应用，而设备被置入VLAN中。从设备发出的帧总是经过重新计算，以使VLAN成</p>
<p>员身份能随着设备产生的流量类型而改变。基于策略的VLAN可以使用上面提到的任一种划分VLAN</p>
<p>的方法，并可以把不同方法组合成一种新的策略来划分VLAN。</p>
<p>（6）按用户定义、非用户授权划分。基于用户定义、非用户授权来划分VLAN是指为了适应特</p>
<p>别的VLAN网络，根据特殊的网络用户的特殊要求来定义和设计VLAN，而且可以让非VLAN群体用</p>
<p>户访问VLAN，但是需要提供用户密码，在得到VLAN管理的认证后才可以加入一个VLAN。</p>
<p>希赛教育专家提示：在上述6种划分方法中，各方法的侧重点不同，所达到的效果也不尽相同。</p>
<p>目前在网络产品中融合多种划分VLAN的方法，以便根据实际情况寻找最合适的途径。同时，随着管</p>
<p>理软件的发展，VLAN的划分逐渐趋向于动态化。</p>
<p>第4章：数据通信与计算机网络</p>
<p>通信设备</p>
<p>在介绍通信设备之前，我们需要了解多路复用技术。采用多路复用技术能把多个信号组合起来</p>
<p>在一条物理信道上进行传输，在远距离传输时可大大节省电缆的安装和维护费用。多路复用技术可</p>
<p>以分为频分多路复用（FrequencyDivisionMultiplexing，FDM）和时分多路复用（Time</p>
<p>DivisionMultiplexing，TDM）两种。</p>
<p>FDM按频谱划分信道，多路基带信号被调制在不同的频谱上。因此它们在频谱上不会重叠，即</p>
<p>在频率上正交，但在时间上是重叠的，可以同时在一个信道内传输。FDM的优点是信道复用率高，</p>
<p>允许复用路数多，分路也很方便。因此，FDM已成为现代模拟通信中最主要的一种复用方式，在模</p>
<p>拟式遥测、有线通信、微波接力通信和卫星通信中得到广泛应用。</p>
<p>TDM将一条物理信道按时间分成若干个时间片轮流地分配给多个信号使用。每一时间片由复用</p>
<p>的一个信号占用，而不像FDM那样，同一时间同时发送多路信号。这样，利用每个信号在时间上的</p>
<p>交叉，就可以在一条物理信道上传输多个数字信号。TDM不仅仅局限于传输数字信号，也可以同时</p>
<p>交叉传输模拟信号。</p>
<p>希赛教育专家提示：对于模拟信号，有时可以把时分多路复用和频分多路复用技术结合起来使</p>
<p>用。一个传输系统可以频分成许多条子通道，每条子通道再利用时分多路复用技术来细分。在宽带</p>
<p>局域网络中可以使用这种混合技术。</p>
<p>第4章：数据通信与计算机网络</p>
<p>传输介质</p>
<p>网络传输介质是指在网络中传输信息的载体，常用的传输介质分为有线传输介质和无线传输介</p>
<p>质两大类。无线传输介质是指在两个通信设备之间不使用任何物理连接，而是通过空间传输的一种</p>
<p>技术。无线传输介质主要有微波、红外线和激光等。它们的抗干扰性都比较差；有线传输介质是指</p>
<p>在两个通信设备之间实现的物理连接部分，它能将信号从一方传输到另一方，有线传输介质主要有</p>
<p>双绞线（Twist-Pair）、同轴电缆和光纤三种。</p>
<p>1．双绞线</p>
<p>（1）物理特性：双绞线由按规则螺旋结构排列的两对或四对绝缘线组成。一对线可以作为一条</p>
<p>通信电路，各个线对螺旋排列的目的是使各线对之间的电磁干扰最小。</p>
<p>（2）传输特性：双绞线最普遍的应用是语音信号的模拟传输。使用双绞线通过调制解调器</p>
<p>（Modem）传输模拟数据信号时，数据传输速率目前单向可达56Kbps，双向可达33.6Kbps，24条</p>
<p>音频通道总的数据传输速率可达230Kbps。使用双绞线发送数字数据信号，一般总的数据传输速率</p>
<p>可达2Mbps。</p>
<p>（3）连通性：双绞线可用于点对点连接，也可用于多点连接。</p>
<p>（4）地理范围：双绞线用于远程中继线时，最大距离可达15km；用于10Mbps局域网时，与</p>
<p>集线器的距离最大为100m。</p>
<p>（5）抗干扰性：在低频传输时，其抗干扰能力相当于同轴电缆。在10KHz～100kHz时，其抗</p>
<p>干扰能力低于同轴电缆。</p>
<p>（6）价格：双绞线的价格低于其他传输介质，并且安装、维护方便。</p>
<p>双绞线分为屏蔽双绞线(ShieldedTwistedPair，STP)与非屏蔽双绞线(UnshieldedTwisted</p>
<p>Pair，UTP)。屏蔽双绞线在双绞线与外层绝缘封套之间有一个金属层蔽层。屏蔽层可减少辐射，防止信息被窃听，也可阻止外部电磁干扰的进入，使屏蔽双绞线比同类的非屏蔽双绞线具有更高的传输速率。非屏蔽双绞线电缆具有以下优点：无屏蔽外套，直径小，节省所占用的空间；重量轻，易弯曲，易安装；将串扰减至最小或加以消除；具有阻燃性；具有独立性和灵活性，适用于结构化综合布线。</p>
<p>对于双绞线，用户最关心的是表征其性能的几个指标。这些指标包括衰减、近端串扰、阻抗特性、分布电容、直流电阻、衰减串扰比及回波损耗等。目前，常见的双绞线有三种线型，分别是5类线、超5类线和6类线，前者线径细而后者线径粗。</p>
<p>（1）5类线：电缆增加了绕线密度，外套一种高质量的绝缘材料，传输率为100MHz，用于语音传输和最高传输速率为100Mbps的数据传输，主要用于100BASE-T和10BASE-T网络。这是最常用的以太网电缆。</p>
<p>（2）超5类线：具有衰减小，串扰少，并且具有更高的衰减与串扰的比值和信噪比、更小的时延误差，性能得到很大提高。主要用于千兆位以太网。</p>
<p>（3）6类线：电缆的传输频率为1MHz～250MHz，6类布线系统在200MHz时综合衰减串扰比应该有较大的余量，它提供2倍于超5类的带宽。6类布线的传输性能远远高于超5类标准，最适用于传输速率高于1Gbps的应用。6类与超5类的一个重要的不同点在于：改善了在串扰以及回波损耗方面的性能，对于新一代全双工的高速网络应用而言，优良的回波损耗性能是极重要的。6类标准中取消了基本链路模型，布线标准采用星形的拓扑结构，要求的布线距离为：永久链路的长度不能超过90m，信道长度不能超过100m。</p>
<p>2．同轴电缆</p>
<p>（1）物理特性：同轴电缆也由两根导体组成，有粗细之分，它由套置单根内导体的空心圆柱体</p>
<p>构成。内导体是实芯或者是绞合的，外导体是整体的或纺织的。内导体用规则间距的绝缘环或硬的</p>
<p>电媒体材料来固定，外导体用护套或屏蔽物包着。</p>
<p>（2）传输特性：50<img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml17296\wps1.png" alt="img">电缆专用于数字传输，一般使用曼彻斯特编码，数据速率可达2Mbps。</p>
<p>CATV（CommunityAntennaTelevision，有线电视网）电缆可用于模拟和数字信号，对模拟信</p>
<p>号，高达300MHz～400MHz的频率是可能的；对数字信号，已能达到50Mbps。</p>
<p>（3）连通性：同轴电缆可用于点对点连接，也可用于多点连接。</p>
<p>（4）地理范围：典型基带电缆的最大距离限于数千米，而宽带网络则可以延伸到数十千米的范</p>
<p>围。</p>
<p>（5）抗干扰性：同轴电缆的结构使得它的抗干扰能力较强，同轴电缆的抗干扰性取决于应用和实现。一般对较高频率来说，它优于双绞线的抗干扰性。</p>
<p>（6）价格：安装质量好的同轴电缆的成本介于双绞线和光纤之间，维护方便。</p>
<p>3．光纤</p>
<p>（1）物理特性：光学纤维是一种直径极细（2～125<img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml17296\wps2.png" alt="img">m）、柔软、能传导光波的介质。各种玻璃和塑料都可用来制造光学纤维。光缆具有圆柱形的形状，由三个同心部分组成：纤芯、包层和护套。</p>
<p>（2）传输特性：光纤利用全内反射来传输经信号编码的光束。它分多模和单模方式两种，多模的带宽为200MHz～3GHz/km，单模的带宽为3GHz～50GHz/km。</p>
<p>（3）连通性：光纤最普通的使用是在点到点的链路上。</p>
<p>（4）地理范围：光纤信号衰减极小，它可以在6～8km的距离内不使用中继器实现高速率数据传输。</p>
<p>（5）抗干扰性：不受电磁干扰和噪声干扰的影响。</p>
<p>（6）价格：目前光纤系统比双绞线系统和同轴电缆系统贵，但随着技术的进步，它的价格会下降以与其他材料竞争。</p>
<p>单模光纤中，模内色散是比特率的主要制约因素。由于其比较稳定，如果需要的话，可以通过增加一段一定长度的“色散补偿单模光纤”来补偿色散。零色散补偿光纤就是使用一段有很大负色散系数的光纤来补偿在1550nm处具有较高色散的光纤，使得光纤在1550nm附近的色散很小或为零，从而可以实现光纤在1550nm处具有更高的传输速率。</p>
<p>多模光纤中，模式色散与模内色散是影响带宽的主要因素。技术工艺能够很好地控制折射率分布曲线，给出优秀的折射率分布曲线，对渐变型多模光纤，可限制模式色散而得到高的模式带宽。</p>
<p>单模光纤的光纤跳线一般用黄色表示，接头和保护套为蓝色，传输距离较长，窄芯线，需要激光源，耗散小，高效。多模光纤的光纤跳线一般用橙色表示，也有的用灰色表示，接头和保护套用米色或者黑色，传输距离较短，宽芯线，聚光好，耗散大，低效。</p>
<p>一般来说，多模光纤要比单模光纤便宜。如果对传输距离或传送数据的速率要求不严格，那么，多模光纤在大多情况下都可以表现得很好。单模光纤虽然成本高，但是具有散射小的特点，可以应用在长距离传输或者需要高速数据速率的场合。</p>
<p>为了便于记忆，我们把有线传输的介质归纳成表4-4。</p>
<p>表4-4有线传输介质比较</p>
<p>在有关传输介质方面，还需要掌握各种以太网所使用的介质类型，如表4-5所示。</p>
<p>表4-5以太网常用传输介质</p>
<p>第4章：数据通信与计算机网络</p>
<p>网络设备</p>
<p>常见的网络设备简介如下：</p>
<p>（1）网卡。也称为网络适配器或网络接口卡（NetworkInterfaceCard，NIC），工作于数据</p>
<p>链路层。网卡及其驱动程序已基本实现了网络协议中底部两层的功能。它们具体负责主机向媒体收/</p>
<p>发信号，实现帧一级协议的有关功能。</p>
<p>（2）集线器。也称为线集中器（Hub），工作于物理层，它收集多个端口传来的数据帧并广播</p>
<p>出去。集线器把结点都集中到总线上并相互连接在一起，也可以在Hub之间相互用双绞线进一步互</p>
<p>联接通。例如，可以先把每个小房间里的计算机连接在相应的一个Hub上，再把这些Hub互相连接</p>
<p>而构成一个LAN网络。Hub可分为共享式Hub、堆栈式Hub和交换式Hub。共享式Hub和堆栈式</p>
<p>Hub整体作为一个网段；而交换式Hub的每一个端口都允许作为一个网段，速度非常快。</p>
<p>（3）重发器。也称为中继器或转发器，工作在物理层。因为信号在传输媒体的线路上传输一段距离后必然会发生衰减或者畸变，通过重发器放大增强信号并进行转发就可以保证信号可靠传输。采用重发器把两条（或更多条）干线连接起来，可以使这两个干线段成为同一个局域网。重发器连接的两个网段，必须是同一种类型的局域网。</p>
<p>（4）网桥。也称为桥接器（Bridge），工作在数据链路层，把同类网络互相连接起来。在网桥中可以进行两个网段之间的数据链路层的协议转换。网桥最重要的功能是对数据进行过滤。即在网桥中保存着所连接的每个网段上所有站点的地址。当收到一个帧时，可以只让必要的数据信息通过网桥或只向相应的网段转发。</p>
<p>（5）交换机。也称为交换器。一台具有基本功能的以太网交换机的工作原理相当于一个具有很多个端口的多端口网桥，即是一种在LAN中互联多个网段，并可进行数据链路层和物理层协议转换的网络互联设备。当一个以太网的信息帧到达交换机的一个端口时，交换机根据在该帧内的目的地址，采用快速技术把该帧迅速地转发到另一个相应的端口（相应的主机或网段）。目前在以太网交换机中最常用的高速切换技术有直通式和存储转发式两类。交换机可以分为二层交换机、三层交换机和多层交换机。二层交换机工作在数据链路层，起到多端口网桥的作用，主要用于局域网互联。</p>
<p>三层交换机工作在网络层，利用IP地址进行交换，相当于带路由功能的二层交换机。多层交换机工</p>
<p>作在高层（传输层以上），这是带协议转换的交换机。</p>
<p>（6）路由器。在广域网通信过程中，需要采用一种称为路由的技术，根据地址来寻找到达目的</p>
<p>地的路径，路由器就是实现这个过程的网络设备。路由器在属于不同网络段的广域网和局域网间根</p>
<p>据地址建立路由，并将数据送到最终目的地。路由器工作于网络层，它根据IP地址转发数据报，处</p>
<p>理的是网络层的协议数据单元。路由器通过逻辑地址进行网络间的信息转发，可完成异构网络之间</p>
<p>的互联互通，但只能连接使用相同网络层协议的子网。</p>
<p>按应用范围的不同，路由协议可分为两类：在一个AS（AutonomousSystem，自治系统）内</p>
<p>的路由协议称为内部网关协议（InteriorGatewayProtocol，IGP），AS之间的路由协议称为外部</p>
<p>网关协议（ExteriorGatewayProtocol，EGP）。所谓自治系统，指一个互联网络，就是把整个</p>
<p>Internet划分为许多较小的网络单位，这些小的网络有权自主地决定在本系统中应采用何种路由选择</p>
<p>协议。常用的内部网关协议有RIP（RoutingInformationProtocol，路由信息协议）-1、RIP-2、</p>
<p>IGRP（InteriorGatewayRoutingProtocol，内部网关路由协议）、IS-IS和OSPF等。其中</p>
<p>RIP-1、RIP-2和IGRP采用的是距离向量算法，IS-IS和OSPF采用的是链路状态算法。还有一种称为</p>
<p>EIGRP（EnhancedIGRP）的协议，这是Cisco的私有路由协议，综合了距离矢量和链路状态的优</p>
<p>点，它的特点包括快速收敛、减少带宽占用、支持多种网络层协议、无缝连接数据链路层协议和拓</p>
<p>扑结构。</p>
<p>（7）网关。也称为网间连接器、信关或联网机，是网络层以上的中继系统。用网关连接两个不</p>
<p>兼容的系统要在高层进行协议转换，因此，网关也称为协议转换器。</p>
<p>（8）调制解调器。应用在广域网上，作为末端系统和通信系统之间信号转换的设备。它分为同</p>
<p>步和异步两种，分别连接路由器的同步端口和异步端口，同步用于专线、帧中继和X.25等高速网络</p>
<p>连接，异步用于PSTN的低速连接。调制解调器工作于物理层，它的主要作用是信号变换，即把模拟</p>
<p>信号变换成数字信号，或者把数字信号变换成模拟信号。</p>
<p>第4章：数据通信与计算机网络</p>
<p>网络接入技术</p>
<p>本节主要介绍几种常见的接入网技术，包括电话线、HFC、FDDx+LAN、xDSL接入技术等。</p>
<p>1．异步传输模式</p>
<p>电路交换网络都是按照时分多路复用的原理将信息从一个结点送到另一个结点的。根据工作模</p>
<p>式的不同，可以分为两种：</p>
<p>（1）同步传输模式：根据要求的数据速率，将一个逻辑信道分配为1个以上的时槽，在连接生</p>
<p>存期内，时槽是固定分配的，即采用的是同步时分复用模式。</p>
<p>（2）异步传输模式：则采用了与前面的不同方法分配时槽，它把用户数据组成为53位的信元，</p>
<p>信元随机到达，中间可以有间隙，信元准备好就可以进入信道，即采用的是统计时分复用模式。</p>
<p>在ATM中，信元不仅是传输的基本单位，也是交换的信息单位，它是虚电路式分组交换的一个</p>
<p>特例。与分组相比，由于信元是固定长度的，因此可以高速地进入处理和交换。ATM的典型数据速</p>
<p>率为150Mbps，ATM是面向连接的，所以在高速交换时要尽量减少信元的丢失。ATM建立了四层</p>
<p>架构，表4-6总结了它们的功能以及与OSI层次的对应关系。</p>
<p>表4-6ATM层次结构</p>
<p>2．帧中继</p>
<p>帧中继协议在数据链路层实现，没有专门定义物理层接口（可以使用X.21、V.35、G.703、</p>
<p>G.704等接口协议），在帧中继之上，可以承载IP数据报、而且其他协议甚至远程网桥协议都可以在</p>
<p>帧中继上透明传输。</p>
<p>帧中继使用的最核心协议是公共信道D进行信令传输控制协议（LinkAccessProcedureonthe</p>
<p>channel，LAPD）。帧中继支持交换虚电路（SwitchingVirtualCircuit，SVC）和固定虚电路（PermanentVirtualCircuit，PVC）两种虚电路技术。控制交换虚电路的信息是在信令信道上传送的。这些消息采用的是LAPF（LinkAccessProcedureontheFchannel）协议；帧中继协议在早期并没有建立交换虚电路的信令，只能够通过网络管理建立永久虚电路。PVC的管理协议控制端到端的连接，是通过带外信令的无编号信息帧传送的。</p>
<p>使用帧中继进行远程连网的主要优点是：透明传输、面向连接，帧长可变，速率高，能够应对突发数据传输、没有流量控制和重传、开销小。但它并不适于对延迟敏感的应用（音频和视频），无法保证可靠的提交。</p>
<p>3．综合业务数据网</p>
<p>ISDN可以分为窄带ISDN（N-ISDN）和宽带ISDN（B-ISDN）两种。其中N-ISDN是将数据、声音、视频信号集成进一根数字电话线路的技术。它的服务由两种信道构成：一是传送数据的运载信道（又称为B信道，每个信道64Kbps），二是用于处理管理信号及调用控制的信令信道（又称为</p>
<p>D信道，每个信道16Kbps或64Kbps）。然后将这两类信道进行组合，形成两种不同的ISDN服务，</p>
<p>分别是基速率接口（ISDNBRI）和主速率接口（ISDNPRI）。</p>
<p>（1）基速率接口：一般由2B+D组成，常用于小型办公室与家庭，用户可以用1B做数据通信，</p>
<p>另1B保留为语音通信，但无法使用D通道。当然，如果需要，也可以同时使用2B通道（128Kbps）</p>
<p>做数据通信。</p>
<p>（2）主速率接口：PRI包括两种，一是美国标准23B+1D（64Kbps的D信道），达到与T1相同</p>
<p>的1.544Mbps的DS1速度；二是欧洲标准30B+2D（64Kbps信道），达到与E1相同的2.048Mbps</p>
<p>的速度。另外，电话公司通常可以将若干个B信道组合成不同的H信道。</p>
<p>N-ISDN定义了物理层、数据链路层和网络层的部分功能。在物理层建立了一个64Kbps的线路</p>
<p>交换连接，还提供了网络终端适配器的物理接口；在数据链路层则使用了LAPD来管理所有的控制和</p>
<p>信令功能；其网络层处理所有的线路交换及分组交换服务。</p>
<p>B-ISDN的关键技术是ATM，采用5类双绞线或光纤，数据速率可达155Mbps，可以传输无压缩</p>
<p>的高清晰度电视。</p>
<p>4．同步光网络</p>
<p>同步光纤网络（SynchronousOpticalNetwork，SONET）和同步数字体系（Synchronous</p>
<p>DigitalHierarchy，SDH）是一组有关光纤信道上的同步数据传输的标准协议，常用于物理层构架</p>
<p>和同步机制，两者均为传输网络物理层技术，传输速率可高达10Gbps，除了使用的复用机制上有所</p>
<p>不同，而其余技术均相似。SDH的网络元素主要有同步光纤线路系统、终端复用器、分插复用器和</p>
<p>同步数字交叉连接设备。典型的SDH应用是在光纤上的双环应用。SDH每秒传送8KSDH帧，SDH</p>
<p>是提供字节同步的物理层介质。</p>
<p>IPoverSDH是以SDH网络作为IP数据网络的物理传输网络，它使用链路适配及成帧协议对IP数</p>
<p>据包进行封装，然后按字节同步的方式把封装后的IP数据包映射到SDH的同步净荷封装中。目前广</p>
<p>泛使用PPP（PointtoPointProtocol，点对点协议）对IP数据包进行封装，并采用HDLC（High-</p>
<p>LevelDataLinkControl，高级数据链路控制）的帧格式。PPP提供多协议封装、差错控制和链路</p>
<p>初始化控制等功能，而HDLC帧格式负责同步传输链路上的PPP封装的IP数据帧的定界。</p>
<p>5．Internet接入与接口层协议</p>
<p>Internet是世界上最大的互联网络，而一个端用户需要连接到Internet，就需要选择一个接入</p>
<p>点，而提供接入服务的运营商被称为ISP（InternetServiceProvider，Internet服务提供商），在</p>
<p>我国主要的ISP是各大电信运营机构。选择了接入点之后，就需要根据实际的情况来选择接入方式：终端方式或主机方式。而采用主机方式接入，根据通信线路的不同，可以分为SLIP（SerialLineInternetProtocol，串行线路网际协议）/PPP/PPPoE（PPPoverEthernet，以太网上的PPP）方式和DDN（DigitalDataNetwork，数字数据网）专线方式。</p>
<p>（1）终端方式：用户使用通信软件的拔号功能，通过Modem拔通对方主机（ISP的已经连接在Internet上的主机），然后输入用户名密码，成为其一个远程终端。它并没有实现真正意义上的Internet连接，因此只能够使用有限的服务（通常包括E-mail、Telnet，但不能够使用WWW服</p>
<p>务）。</p>
<p>（2）以SLIP/PPP/PPPoE方式：通过拔入ISP的远程访问服务器来实现连接。可以实现真正意义上的连接，通常是使用电话接入技术，通过电信运营商的PSTN资源。</p>
<p>（3）以DDN专线方式入网：就是申请一条DDN专线，连接到ISP的Internet主机上，它通常使用是的电信运营商的PDN资源。</p>
<p>在接入Internet时，需要对用户进行认证、分配IP地址、协商其他通信细节等，常见的接口层协议如下：</p>
<p>（1）SLIP协议：提供了提供串行通信线路上封装IP数据报的简单方法，但其具有以下不足：事先需要知道对方的IP地址，不支持动态IP地址分配；只支持IP协议；没有校验字段，需上层进行差错控制。</p>
<p>（2）PPP协议：有效的点对点通信协议，采用HDLC封装，可用于不同传输媒体，解决了SLIP的限制。远程服务器可以为本地客户机提供一个动态IP地址，支持IP、IPX（InternetworkPacketeXchangeprotocol，互联网分组交换协议）等多种网络协议，具有差错检测功能，提供一组网络</p>
<p>控制协议。</p>
<p>（3）PPPoE协议：它利用了PPP的优点、结合以太网的优势，可实现多台客户机同时接入</p>
<p>Internet。它继承的了以太网的快速和PPP拔号的简捷、用户验证、IP分配等方面的优势。PPPoE的</p>
<p>运行包含发现和PPP会话两个阶段。发现阶段以广播方式寻找可以连接的接入集线器，并获得其</p>
<p>MAC地址，然后选择需要连接的主机并确定所建立的PPP会话识别标记；在会话阶段，用户主机与</p>
<p>接入集线器运用PPP会话连接参数进行PPP会话。</p>
<p>6．FTTx和LAN接入</p>
<p>光纤通信是指利用光导纤维（光纤）传输光波信号的一种通信方法。相对于以电为媒介的通信方式而言，光纤通信的主要优点包括：传输频带宽，通信容量大；传输损耗小；抗电磁干扰能力强；线径细、重量轻；资源丰富等。随着光纤通信技术的平民化，以及高速以太网的发展，现在许多宽带智能小区就是采用以千兆以太网技术为主干、充分利用光纤通信技术完成接入的。</p>
<p>实现高速以太网的宽带技术常用的方式是FTTx+LAN，即光纤+局域网。根据光纤深入用户的程度，可以分为5种：FTTC（FiberToTheCurb，光纤到路边）、FTTZ（FiberToTheZone，光纤到小区）、FTTB（FiberToTheBuilding，光纤到大楼）、FTTF（FiberToTheFloor，光纤到楼层）和FTTH（FiberToTheHome，光纤到户）。</p>
<p>无源光纤网络（PassiveOpticalNetwork，PON）是实现FFTB的关键性技术，在光分支点不需要节点设备，只需安装一个简单的光分支器即可，因此具有节省光缆资源、带宽资源共享、节省机房投资、设备安全性高、建网速度快、综合建网成本低等优点。目前，PON技术主要有APON（ATM-PON，基于ATM的无源光网络）和EPON（Ethernet-PON，基于以太网的无源光网络）两种：</p>
<p>（1）APON：分别选择ATM和PON作为网络协议和网络平台，其上、下行方向的信息传输都</p>
<p>采用ATM传输方案，下行速率为622Mbps或155Mbps，上行速率为155Mbps。光节点到前端的距离可长达10～20km，或者更长。采用无源双星型拓扑，使用时分复用和时分多址技术，可以实现信元中继、局域网互联、电路仿真、普通电话业务等。</p>
<p>（2）EPON：是以太网技术发展的新趋势，其下行速率为1000Mbps或者100Mbps，上行为</p>
<p>100Mbps。在EPON中，传送的是可变长度的数据包，最长可为65535个字节；而在APON中，传</p>
<p>送的是53个字节的固定长度信元。它简化了网络结构、提高了网络速度。</p>
<p>7．电话线路接入</p>
<p>利用普通电话线接入是成本最低、应用最广的接入技术，表4-7总结了各种常见技术。</p>
<p>表4-7多种接入技术比较</p>
<p>8．同轴和光纤接入</p>
<p>同轴光纤技术（HybridFiber-Coaxial，HFC）是将光缆敷设到小区，然后通过光电转换结点，</p>
<p>利用CATV的总线式同轴电缆连接到用户，提供综合电信业务的技术。这种方式可以充分利用CATV</p>
<p>原有的网络，建网快、造价低，逐渐成为最佳的接入方式之一。HFC是由光纤干线网和同轴分配网</p>
<p>通过光结点站结合而成，一般光纤干网采用星型拓扑，同轴电缆分配网采用树形结构。</p>
<p>在同轴电缆的技术方案中，用户端需要使用一个称为CableModem（电缆调制解调器）的设</p>
<p>备，它不单纯是一个调制解调器，还集成了调谐器、加/解密设备、桥接器、网络接口卡、虚拟专网</p>
<p>代理和以太网集线器的功能于一身，它无须拔号、可提供随时在线的永远连接。其上行速度已达</p>
<p>10Mbps以上，下行速率更高。其采用的复用技术是FDM，使用的编码格式是64QAM调制。</p>
<p>9．无线接入</p>
<p>我们先介绍多址技术的概念。多址技术可以分为频分多址（FrequencyDivisionMultipleAccess，FDMA）、时分多址（TimeDivisionMultipleAccess，TDMA）和码分多址（CodeDivisionMultipleAccess，CDMA）。FDMA是采用调频的多址技术，业务信道在不同的频段分配给不同的用户；TDMA是采用时分的多址技术，业务信道在不同的时间分配给不同的用户；CDMA</p>
<p>是采用扩频的码分多址技术，所有用户在同一时间、同一频段上，根据不同的编码获得业务信道。</p>
<p>移动通信技术经历过了三个发展时期，第一代移动通信系统是模拟通信，采用的是FDMA调制</p>
<p>技术，其频谱利用率低；第二代移动通信系统是现在常用的数字通信系统，采用的是TDMA的数字</p>
<p>调制方式，对系统的容量限制较大；第三代移动通信（3rdGeneration，3G）技术则采用了CDMA</p>
<p>数字调制技术，能够满足大容量、高质量、综合业务、软切换的要求。3G的主流技术有</p>
<p>W-CDMA、CDMA2000和TD-SCDMA三种：</p>
<p>（1）W-CDMA（宽带CDMA）：这是基于GSM（GlobalSystemforMobile</p>
<p>Communications，全球移动通讯系统）网发展出来的3G技术规范，该标准提出了在GSM基础上的</p>
<p>升级演进策略：“GSM（2G）→GPRS→EDGE→W-CDMA（3G）”。</p>
<p>（2）CDMA2000：这是由窄带CDMA（CDMA-IS95）技术发展而来的宽带CDMA技术，该标</p>
<p>准提出了在CDMA-IS95的基础上的升级演进策略：“CDMAIS95（2G）→CDMA20001x→</p>
<p>CDMA20003x（3G）”。CDMA20003x与CDMA20001x的主要区别在于应用了多路载波技术，</p>
<p>通过采用三载波使带宽提高。</p>
<p>（3）TD-SCDMA（时分同步CDMA）由我国大唐电信公司提出的3G标准，该标准提出不经过</p>
<p>2.5代的中间环节，直接向3G过渡，非常适用于GSM系统向3G升级。</p>
<p>无线网络技术从服务范围上可以分为无线局域网、无线城域网和无线广域网技术。无线城域网</p>
<p>技术主要是在成熟的微波传输技术的基础上发展起来的，其中LMDS（LocalMultipoint</p>
<p>DistributionServices，区域多点分配服务）和MMDS（MultichannelMicrowaveDistribution</p>
<p>System，多通道微波分配系统）比较常见。无线广域网主要是卫星通信技术。表4-8对这三个技术</p>
<p>的关键知识点做了总结：</p>
<p>表4-8主要无线广域网技术</p>
<p>第4章：数据通信与计算机网络</p>
<p>网络存储技术</p>
<p>目前，主流的网络存储技术主要有三种，分别是直接附加存储（DirectAttachedStorage，</p>
<p>DAS）、网络附加存储（NetworkAttachedStorage，NAS）和存储区域网络（StorageArea</p>
<p>Network，SAN）。</p>
<p>第4章：数据通信与计算机网络</p>
<p>直接附加存储（DAS）</p>
<p>DAS是将存储设备通过SCSI（SmallComputerSystemInterface，小型计算机系统接口）电</p>
<p>缆直接连到服务器，其本身是硬件的堆叠，存储操作依赖于服务器，不带有任何存储操作系统。因</p>
<p>此，有些文献也把DAS称为SAS（ServerAttachedStorage，服务器附加存储）。</p>
<p>DAS的适用环境为：</p>
<p>（1）服务器在地理分布上很分散，通过SAN或NAS在它们之间进行互连非常困难时；</p>
<p>（2）存储系统必须被直接连接到应用服务器（例如，MicrosoftClusterServer或某些数据库</p>
<p>使用的“原始分区”）上时；</p>
<p>（3）包括许多数据库应用和应用服务器在内的应用，它们需要直接连接到存储器上时。</p>
<p>由于DAS直接将存储设备连接到服务器上，这导致它在传递距离、连接数量、传输速率等方面</p>
<p>都受到限制。因此，当存储容量增加时，DAS方式很难扩展，这对存储容量的升级是一个巨大的瓶</p>
<p>颈；另一方面，由于数据的读取都要通过服务器来处理，必然导致服务器的处理压力增加，数据处</p>
<p>理和传输能力将大大降低；此外，当服务器出现宕机等异常时，也会波及到存储数据，使其无法使</p>
<p>用。目前DAS基本被NAS所代替。</p>
<p>第4章：数据通信与计算机网络</p>
<p>网络附加存储（NAS）</p>
<p>采用NAS技术的存储设备不再通过I/O总线附属于某个特定的服务器，而是通过网络接口与网络直接相连，由用户通过网络访问。NAS存储系统的结构如图4-3所示。</p>
<p>图4-3NAS存储系统的结构</p>
<p>NAS存储设备类似于一个专用的文件服务器，它去掉了通用服务器的大多数计算功能，而仅仅</p>
<p>提供文件系统功能，从而降低了设备的成本。并且为方便存储设备到网络之间以最有效的方式发送</p>
<p>数据，专门优化了系统硬软件体系结构。NAS以数据为中心，将存储设备与服务器分离，其存储设</p>
<p>备在功能上完全独立于网络中的主服务器，客户机与存储设备之间的数据访问不再需要文件服务器</p>
<p>的干预，同时它允许客户机与存储设备之间进行直接的数据访问，所以不仅响应速度快，而且数据</p>
<p>传输速率也很高。</p>
<p>NAS技术支持多种TCP/IP网络协议，主要是NFS（NetFileSystem，网络文件系统）和CIFS</p>
<p>（CommonInternetFileSystem，通用Internet文件系统）来进行文件访问，所以NAS的性能特</p>
<p>点是进行小文件级的共享存取。在具体使用时，NAS设备通常配置为文件服务器，通过使用基于</p>
<p>Web的管理界面来实现系统资源的配置、用户配置管理和用户访问登录等。</p>
<p>NAS存储支持即插即用，可以在网络的任一位置建立存储。基于Web管理，从而使设备的安</p>
<p>装、使用和管理更加容易。NAS可以很经济地解决存储容量不足的问题，但难以获得满意的性能。</p>
<p>第4章：数据通信与计算机网络</p>
<p>存储区域网络（SAN）</p>
<p>SAN是通过专用交换机将磁盘阵列与服务器连接起来的高速专用子网。它没有采用文件共享存</p>
<p>取方式，而是采用块（block）级别存储。SAN是通过专用高速网将一个或多个网络存储设备和服务</p>
<p>器连接起来的专用存储系统，其最大特点是将存储设备从传统的以太网中分离了出来，成为独立的存储区域网络SAN的系统结构如图4-4所示。</p>
<p>图4-4SAN存储系统的结构</p>
<p>根据数据传输过程采用的协议，其技术划分为FCSAN和IPSAN。另外，还有一种新兴的IB</p>
<p>SAN技术。</p>
<p>（1）FCSAN。FC（FiberChannel，光纤通道）和SCSI接口一样，最初也不是为硬盘设计开</p>
<p>发的接口技术，而是专门为网络系统设计的，随着存储系统对速度的需求，才逐渐应用到硬盘系统</p>
<p>中。光纤通道的主要特性有：热插拔性、高速带宽、远程连接、连接设备数量大等。它是当今最昂</p>
<p>贵和复杂的存储架构，需要在硬件、软件和人员培训方面进行大量投资。</p>
<p>FCSAN由三个基本的组件构成，分别是接口（SCSI、FC)、连接设备（交换机、路由器）和协</p>
<p>议（IP、SCSI）。这三个组件再加上附加的存储设备和服务器就构成一个SAN系统。它是专用、高</p>
<p>速、高可靠的网络，允许独立、动态地增加存储设备，使得管理和集中控制更加简化。</p>
<p>FCSAN有两个较大的缺陷，分别是成本和复杂性，其原因就是因为使用了FC。在光纤通道上部</p>
<p>署SAN，需要每个服务器上都要有FC适配器、专用的FC交换机和独立的布线基础架构。这些设施使</p>
<p>成本大幅增加，更不用说精通FC协议的人员培训成本。</p>
<p>（2）IPSAN。IPSAN是基于IP网络实现数据块级别存储方式的存储网络。由于设备成本低，</p>
<p>配置技术简单，可共享和使用大容量的存储空间，因而逐渐获得广泛的应用。</p>
<p>在具体应用上，IP存储主要是指iSCSI（InternetSCSI）。作为一种新兴的存储技术，iSCSI基于</p>
<p>IP网络实现SAN架构，既具备了IP网络配置和管理简单的优势，又提供了SAN架构所拥有的强大功</p>
<p>能和扩展性。iSCSI是连接到一个TCP/IP网络的直接寻址的存储库，通过使用TCP/IP协议对SCSI指令</p>
<p>进行封装，可以使指令能够通过IP网络进行传输，而过程完全不依赖于地点。</p>
<p>iSCSI优势的主要表现在于，首先，建立在SCSI、TCP/IP这些稳定和熟悉的标准上，因此安装成</p>
<p>本和维护费用都很低；其次，iSCSI支持一般的以太网交换机而不是特殊的光纤通道交换机，从而减</p>
<p>少了异构网络和电缆；最后，ISCSI通过IP传输存储命令，因此可以在整个Internet上传输，没有距</p>
<p>离限制。</p>
<p>iSCSI的缺点在于，存储和网络是同一个物理接口，同时协议本身的开销较大，协议本身需要频</p>
<p>繁地将SCSI命令封装到IP包中以及从IP包中将SCSI命令解析出来，这两个因素都造成了带宽的占用</p>
<p>和主处理器的负担。但是，随着专门处理ISCSI指令的芯片的开发（解决主处理器的负担问题），以</p>
<p>及10G以太网的普及（解决带宽问题），iSCSI将有着更好的发展。</p>
<p>（3）IBSAN。IB（InfiniBand，无限带宽）是一种交换结构I/O技术，其设计思路是通过一套</p>
<p>中心机构（IB交换机）在远程存储器、网络以及服务器等设备之间建立一个单一的连接链路，并由IB</p>
<p>交换机来指挥流量。这种结构设计得非常紧密，大大提高了系统的性能、可靠性和有效性，能缓解</p>
<p>各硬件设备之间的数据流量拥塞。而这是许多共享总线式技术没有解决好的问题，因为在共享总线</p>
<p>环境中，设备之间的连接都必须通过指定的端口建立单独的链路。</p>
<p>IB主要支持两种环境：模块对模块的计算机系统（支持I/O模块附加插槽）；在数据中心环境中</p>
<p>的机箱对机箱的互连系统、外部存储系统和外部局域网/广域网访问设备。IB支持的带宽比现在主流</p>
<p>的I/O载体（例如，SCSI、FC等）还要高，另外，由于使用IPv6的报头，IB还支持与传统</p>
<p>Internet/Intranet设施的有效连接。用IB技术替代总线结构所带来的最重要的变化就是建立了一个</p>
<p>灵活、高效的数据中心，省去了服务器复杂的I/O部分。</p>
<p>IBSAN采用层次结构，将系统的构成与接入设备的功能定义分开，不同的主机可通过HCA</p>
<p>（HostChannelAdapter，主机通道适配器）、RAID等网络存储设备利用TCA（TargetChannel</p>
<p>Adapter，目标通道适配器）接入IBSAN。</p>
<p>IBSAN主要具有如下特性：可伸缩的SwitchedFabric互连结构；由硬件实现的传输层互连高</p>
<p>效、可靠；支持多个虚信道；硬件实现自动的路径变换；高带宽，总带宽随IBSwitch规模成倍增</p>
<p>长；支持SCSI远程DMA（DirectMemoryAccess，直接内存存取）协议；具有较高的容错性和抗</p>
<p>毁性，支持热拔插。</p>
<p>网络存储技术的目的都是为了扩大存储能力，提高存储性能。这些存储技术都能提供集中化的</p>
<p>数据存储并有效存取文件；都支持多种操作系统，并允许用户通过多个操作系统同时使用数据；都</p>
<p>可以从应用服务器上分离存储，并提供数据的高可用性；同时，都能通过集中存储管理来降低长期</p>
<p>的运营成本。</p>
<p>因此，从存储的本质上来看，它们的功能都是相同的。事实上，它们之间的区别正在变得模</p>
<p>糊，所有的技术都在用户的存储需求下接受挑战。在实际应用中，需要根据系统的业务特点和要求</p>
<p>（例如，环境要求、性能要求、价格要求等）进行选择。</p>
<p>第4章：数据通信与计算机网络</p>
<p>无线局域网</p>
<p>作为互联网的延伸手段，WLAN通过无线介质发送和接收数据，而无需线缆介质。WLAN的数</p>
<p>据传输速率可以达到11Mbps（802.11b标准），传输距离可远至20km以上。与有线网络相比，</p>
<p>WLAN具有以下特点。</p>
<p>（1）可移动性，不受布线接点位置的限制；</p>
<p>（2）数据传输速率高，大于1Mbps；</p>
<p>（3）抗干扰性强，能实现很低的误码率；</p>
<p>（4）保密性较强，可使用户进行有效的数据提取，又不至于泄密；</p>
<p>（5）高可靠性，数据传输几乎没有丢包现象产生；</p>
<p>（6）兼容性好，采用CSMA/CA（CarrierSenseMultipleAccesswithCollision</p>
<p>Avoidance，载波监听多路访问/冲突避免）介质访问协议，遵从IEEE802.3以太网协议。与标准以</p>
<p>太网及目前的几种主流网络操作系统完全兼容，用户已有的网络软件不做任何修改就可在无线网上</p>
<p>运行；</p>
<p>（7）快速安装，无线局域网的安装工作非常简单，它无需施工许可证，不需要布线或开挖沟</p>
<p>槽。</p>
<p>第4章：数据通信与计算机网络</p>
<p>无线局域网技术实现</p>
<p>目前常用的计算机无线通信手段有光波和无线电波。其中光波包括红外线和激光，红外线和激光易受天气影响，也不具备穿透能力，故难以实际应用。无线电波包括短波、超短波和微波等，其中采用微波通信具有很大的发展潜力。</p>
<p>微波扩展频谱通信（SpreadSpectrumCommunication，SSC）简称扩频通信，其基本特征是使用比发送的信息数据速率高许多倍的伪随机码把载有信息数据的基带信号的频谱进行扩展，形成宽带的低功率频谱密度的信号来发射。增加带宽可以在较低的信噪比情况下以相同的信息传输率来可靠地传输信息，甚至在信号被噪声淹没的情况下，只要相应地增加信号带宽，仍然能够保持可靠的通信，也就是可以用扩频方法以宽带传输信息来换取信噪比上的好处。</p>
<p>扩频通信技术在发射端以扩频编码进行扩频调制，在接收端以相关解调技术收取信息，这一过程使其具有许多优良特性，如抗干扰能力强；隐蔽性强，保密性好；多址通信能力强；抗多径干扰能力强；且有较好的安全机制。</p>
<p>实现扩频通信的基本工作方式有4种，分别是直接序列扩频（DirectSequenceSpreadSpectrum，DSSS）、跳变频率（FrequencyHopping，FH）、跳变时间（TimeHopping，TH）和线性调频（ChirpModulation，CM）。目前使用最多、最典型的扩频工作方式是DSSS方式。</p>
<p>第4章：数据通信与计算机网络</p>
<p>无线局域网国际标准</p>
<p>无线接入技术区别于有线接入的特点之一是标准不统一，不同的标准有不同的应用。目前比较</p>
<p>流行的有802.11标准、蓝牙标准以及HomeRF（家庭网络）标准等。</p>
<p>1．802.11标准</p>
<p>802.11是1997年IEEE最初制定的一个WLAN标准，主要用于解决办公室无线局域网和校园网中用户与用户终端的无线接入，其业务范畴主要限于数据存取，速率最高只能达2Mbps。由于它在速率、传输距离、安全性、电磁兼容能力及服务质量方面均不尽人意，从而产生了其系列标准。</p>
<p>（1）802.11b：将速率扩充至11Mbps，并可在5.5Mbps、2Mbps及1Mbps之间进行自动速率调整，也提供了MAC层的访问控制和加密机制，以提供与有线网络相同级别的安全保护，还提供了可选择的40位及128位的共享密钥算法，从而成为目前802.11系列的主流产品。而802.11b+还可将速率增强至22Mbps。</p>
<p>（2）802.11a：工作于5GHz频段，最高速率提升至54Mbps。</p>
<p>（3）802.11g：依然工作于2.4GHz频段，与802.11b兼容，最高速率亦提升至54Mbps。</p>
<p>（4）802.11c：为MAC/LLC性能增强。</p>
<p>（5）801.11d：对应802.11b版本，解决那些不能使用2.4GHz频段国家的使用问题。</p>
<p>（6）802.11e：则是一个瞄准扩展服务质量的标准，其分布式控制模式可提供稳定合理的服务质量，而集中控制模式可灵活支持多种服务质量策略。</p>
<p>（7）802.11f：用于改善802.11协议的切换机制，使用户能在不同无线信道或接入设备点间可漫游。</p>
<p>（8）802.11h：可用于比802.11a更好地控制发信功率（借助PC技术）和选择无线信道（借助动态频率选择技术），而与802.11e一起，可适应欧洲的更严格的标准。</p>
<p>（9）802.11i、802.1x：主要着重于安全性，802.11i能支持鉴别和加密算法的多种框架协议，支持企业、公众及家庭应用；802.1x的核心为具有可扩展认证协议，可对以太网端口鉴别，扩展至无线应用。</p>
<p>（10）802.11j：解决802.11a与欧洲HiperLAN/2网络的互连互通。</p>
<p>（11）802.11/WNG：解决IEEE802.11与欧洲电信标准化协会的BRAN-HiperLAN及日本的ARAB-iSWAN统一建成全球一致的WLAN公共接口。</p>
<p>（12）802.11n：已将速率增强至108/320Mbps，并已进一步改进其管理开销及效率。</p>
<p>（13）802.11/RRM：与无线电资源管理有关的标准，以增强802.11的性能。</p>
<p>（14）802.11/HT：用于进一步增强802.11的传输能力，取得更高的吞吐量。</p>
<p>（15）802.11Plus：拟制订802.11WLAN与GPRS/UMTS之类多频、多模运行标准，可有松耦</p>
<p>合及紧耦合两种类型。</p>
<p>2．HiperLAN</p>
<p>ETSI（EuropeanTelecommunicationsSdandardsInstitute，欧洲电信标准协会）的宽带无线电接入网络小组着手制定Hiper（HighPerformanceRadio）接入泛欧标准，已推出HiperLAN1和HiperLAN2。HiperLAN1推出时，数据速率较低，没有被人们重视。在2000年，HiperLAN2标</p>
<p>准制定完成，HiperLAN2标准的最高数据速率能达到54Mbps。HiperLAN2标准详细定义了WLAN的检测功能和转换信令，用以支持许多无线网络，支持动态频率选择、无线信元转换、链路自适应、多束天线和功率控制等。该标准在WLAN性能、安全性、服务质量QoS等方面也给出了一些定义。</p>
<p>HiperLAN1对应IEEE802.11b，HiperLAN2与IEEE802.11a具有相同的物理层，它们可以采用</p>
<p>相同的部件，并且HiperLAN2强调与3G整合。</p>
<p>3．蓝牙</p>
<p>对于802.11来说，蓝牙（IEEE802.15）的出现不是为了竞争而是相互补充。蓝牙是一种极其先</p>
<p>进的大容量近距离无线数字通信的技术标准，其目标是实现最高数据传输速度1Mbps（有效传输速</p>
<p>率为721Kbps）。它的最大传输距离为10cm～10m，通过增加发射功率可达到100m。蓝牙比</p>
<p>802.11更具移动性，比如，802.11限制在办公室和校园内，而蓝牙却能把一个设备连接到LAN和</p>
<p>WAN，甚至支持全球漫游。此外，蓝牙成本低、体积小，可用于更多的设备。</p>
<p>4．家庭网络的HomeRF</p>
<p>HomeRF主要为家庭网络而设计，是IEEE802.11与数字无绳电话标准的结合，旨在降低语音数</p>
<p>据成本。HomeRF也采用了扩频技术，工作在2.4GHz频带，能同步支持4条高质量语音信道。但目</p>
<p>前HomeRF的传输速率只有1～2Mbps，FCC建议增加到10Mbps。</p>
<p>5．WiMax</p>
<p>802.16标准定义了无线MAN空中接口规范（正式的名称为IEEEWirelessMAN*标准）。这一无</p>
<p>线宽带接入标准可以为无线城域网中的“最后一公里”连接提供缺少的一环。对于许多家用及商用</p>
<p>客户而言，通过DSL或有线基础设施的宽带接入仍然不可行。许多客户都在DSL服务范围之外和/或</p>
<p>不能得到宽带有线基础设施的支持（商业区通常没有布线）。但是依靠无线宽带，这些问题都可迎</p>
<p>刃而解。因为其无线特性，所以无线宽带部署速度更快，扩展能力更强，灵活性更高，因此能够为</p>
<p>那些无法享受到或不满意其有线宽带接入的客户提供服务。802.16的MAC层改善了系统总吞吐量和</p>
<p>带宽效率，并确保数据时延受到控制。</p>
<p>第4章：数据通信与计算机网络</p>
<p>无线局域网联接方式</p>
<p>常用的无线网络设备有网卡、AP（AccessPoint，访问点）、无线网桥和无线路由器等。无线</p>
<p>网络产品的多种使用方法可以组合出适合各种情况的无线联网设计，可以方便地解决许多以线缆方</p>
<p>式难以联网的用户需求。例如，数万米远的两个局域网相联，其间或有河流、湖泊相隔，拉线困难</p>
<p>且线缆安全难保障，或在城市中敷设专线要涉及审批复杂，周期很长的市政施工问题，无线网能以</p>
<p>比线缆低几倍的费用在几天内实现。无线网也可方便地实现不经过大的施工改建而使旧式建筑具有</p>
<p>智能大厦的功能。无线网络应用的典型方式有以下几种。</p>
<p>1．对等网方式</p>
<p>对等网方式有2种形式，即把2个局域网相联或把1个远程站点联入1个局域网。如果是两个局域</p>
<p>网相联，则在两个局域网中分别接入无线路由器或无线网桥。如一边是单机，则在其机内插入无线</p>
<p>网卡即可。视通信距离来联接相应天线，用无线网络软件设置相应的ID号、中断号和地址，即可调</p>
<p>试天线的方向、视角。当无线网络软件指示接收质量为良好或合用时，即认为无线链路接通，双方</p>
<p>就可做网络设置和操作了。如果网络中已有路由器，而且天线与网络有相当距离，如数十米至数百</p>
<p>米，则应使用无线网桥尽量靠近天线以缩短射频电缆长度，降低射频信号衰减，把无线网桥和路由</p>
<p>器以数字线缆相连。这种方式的一种扩展是在两点间的距离过远或有遮挡时，在中间增加一个无线</p>
<p>路由器来做中继，网络的设置也作相应变动。</p>
<p>2．无线HUB方式</p>
<p>在一个建筑物或不大的区域内有多个定点或移动点要联入一个局域网时，可用此方式。希赛教育专家提示：各站点要与无线HUB使用相同的网络ID以顺利互通，又要有各自的地址号以相互区别。</p>
<p>3．一点多址方式</p>
<p>当要把地理上有相当距离的多个局域网相联时，则可在每个局域网中接入无线网桥。这时主站</p>
<p>或转接站使用全向天线，各从站视距离使用定向或全向天线与之相联。各无线网桥均使用同样的网</p>
<p>络ID以支持扩频通信，使用各自的地址（网段）以相区别。正确的网络设置，可以使各工作站、服</p>
<p>务器之间互访。当需要把10km之内的多个定点站点或2km之内的多个活动站点（各站点均是单机）</p>
<p>联入网内时，可以用无线网桥的HUB工作方式来方便地实现。</p>
<p>4．不同协议网络间互联</p>
<p>在联网的两边各用与当地网络环境和对方网络环境相配套的设备和相应的网络设置即可实现。</p>
<p>上述只是几种典型的联网方式，在实际工作中可以组合使用，变化出所需要的方式。</p>
<p>第4章：数据通信与计算机网络</p>
<p>网络应用</p>
<p>在网络应用方面，主要考查邮件服务、电子商务、CDMA、3G、域名、带宽和URL（Uniform</p>
<p>ResourceLocator，统一资源定位符）地址等基本概念和应用。</p>
<p>1．万维网</p>
<p>WWW（万维网）是一个支持交互式访问的分布式超媒体系统。超媒体系统（在超文本的基础</p>
<p>上，结合语音、图形、图像和动画等信息）直接扩充了传统的超文本系统（非线性的、用“链接”</p>
<p>整合的信息结构）。Web文档用超文本标记语言（HyperTextMarkupLanguage，HTML）来撰</p>
<p>写。除了文本外，文档还包括指定文档版面与格式的标签，在页面中可以包含图形、音频和视频等</p>
<p>各种多媒体信息。</p>
<p>在WWW中，依赖于标准化的URL地址来定位信息的内容。在进行页面访问时采用的超文本传</p>
<p>送协议HTTP，其服务端口就是HTTP服务端口（80端口）。首先，浏览器软件与HTTP端口建立一个</p>
<p>TCP连接，然后发送GET命令，Web服务器根据命令取出文档，发送给浏览器；最后浏览器释放连</p>
<p>接，显示文档。</p>
<p>2．电子邮件</p>
<p>电子邮件（E-mail）是现在数据量、使用量最大的一个因特网应用，它用来完成人际之间的消</p>
<p>息通信。与它相关的有以下三个协议。</p>
<p>（1）SMTP：简单邮件传送协议，用于邮件的发送，工作在25号端口上。</p>
<p>（2）POP3（PostOfficeProtocol3，邮局协议的第3个版本）：用于接收邮件，工作在110</p>
<p>号端口上。</p>
<p>（3）IMAP（InteractiveMailAccessProtocol，交互式邮件存取协议）：邮件访问协议，是</p>
<p>用于替代POP3协议的新协议，工作在143号端口上。</p>
<p>3．DNS</p>
<p>网络用户希望用有意义的名字来标识主机，而不是IP地址。为了解决这个需求，应运而生的是</p>
<p>域名服务系统DNS。它运行在TCP协议之上，负责将域名转换成实际相对应的IP地址，从而在不改</p>
<p>变底层协议的寻址方法的基础上，为使用者提供一个直接使用符号名来确定主机的平台。</p>
<p>DNS是一个分层命名系统，名字由若干个标号组成，标号之间用圆点分隔。最右边的是主域</p>
<p>名，最左边的是主机名，中间的是子域名。</p>
<p>通常写域名时，最后是不加“.”的，其实这只是一个缩写，最后一个“.”代表的是“根”，如</p>
<p>果采用全域名写法，还需要加上这个小点。这在配置DNS时就会见到。</p>
<p>除了以上讲述的名字语法规则和管理机构的设立，域名系统中还包括一个高效、可靠、通用的</p>
<p>分布式系统用于名字到地址的映射。将域名映射到IP地址的机制由若干个称为名字服务器的独立、</p>
<p>协作的系统组成。</p>
<p>DNS实际上是一个服务器软件，运行在指定的计算机上，完成域名到IP地址的转换。它把网络</p>
<p>中的主机按树形结构分成域和子域，子域名或主机名在上级域名结构中必须是唯一的。每一个子域</p>
<p>都有域名服务器，它管理着本域的域名转换，各级服务器构成一棵树。这样，当用户使用域名时，</p>
<p>应用程序先向本地域名服务器请求，本地服务器先查找自己的域名库，如果找到该域名，则返回IP</p>
<p>地址；如果未找到，则分析域名，然后向相关的上级域名服务器发出申请；这样传递下去，直至有</p>
<p>一个域名服务器找到该域名，并返回IP地址。如果没有域名服务器能识别该域名，则认为该域名不</p>
<p>可知。</p>
<p>充分利用机器的高速缓存，暂存解析后的IP地址，可以提高DNS的查询效率；用户有时会连续</p>
<p>访问相同的因特网地址，DNS在第一次解析该地址后，将其存放在高速缓存中，当用户再次请求</p>
<p>时，DNS可直接从缓存中获得IP地址。</p>
<p>4．IIS</p>
<p>IIS（IntentetInformationServer，Intentet信息服务器）作为当今流行的Web服务器之一，提供了强大的Internet和Intranet服务功能。WindowsServer系统中自带Internet信息服务，在可靠性、方便性、安全性、扩展性和兼容性等方面进行了增强。</p>
<p>5．FTP</p>
<p>FTP的传输模式包括Bin（二进制）和ASCII（文本文件）两种，除了文本文件之外，都应该使用</p>
<p>二进制模式传输。FTP应用的连接模式是：在客户机和服务器之间需建立两条TCP连接，一条用于传</p>
<p>送控制信息（21端口），另一条用于传送文件内容（20端口）。匿名FTP的用户名一般为</p>
<p>anonymous。</p>
<p>7．其他应用</p>
<p>（1）Gopher：因特网早期的一种全文检索服务，WWW出现后，被取代。</p>
<p>（2）WebMail：是指利用浏览器通过Web方式来收发电子邮件的服务或技术。</p>
<p>（3）Usenet：新闻组是一个电子讨论组，用户可以在这里与遍及全球的用户共享信息及对某</p>
<p>些问题的看法。</p>
<p>（4）VOD：视频点播，通过视频压缩、流技术及组播协议实现。</p>
<p>（5）NetMeeting：网络会议，通过视频压缩、流技术及组播协议实现。</p>
<p>第4章：数据通信与计算机网络</p>
<p>网络管理</p>
<p>在网络管理方面，主要考查代理服务器、网络管理工具等。</p>
<p>第4章：数据通信与计算机网络</p>
<p>代理服务器</p>
<p>在网络管理方面，主要考查代理服务器是介于浏览器和Web服务器之间的一台服务器，当用户通过代理服务器上网浏览时，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，由代理服务器来取回浏览器所需要的信息并传送给用户的浏览器。</p>
<p>代理服务器的作用主要体现在以下5个方面：</p>
<p>（1）提高访问速度。因为客户要求的数据存于代理服务器的硬盘中，因此下次这个客户或其他客户再要求相同目的站点的数据时，就会直接从代理服务器的硬盘中读取，代理服务器起到了缓存的作用。对热门站点而言有很多客户访问时，代理服务器的优势更为明显。</p>
<p>（2）可以起到防火墙的作用。因为所有使用代理服务器的用户都必须通过代理服务器访问远程站点，因此在代理服务器上就可以设置相应的限制，以过滤或屏蔽掉某些信息。这是局域网网管对局域网用户访问范围限制最常用的办法，也是局域网用户为什么不能浏览某些网站的原因。拨号用户如果使用代理服务器，同样必须服从代理服务器的访问限制。</p>
<p>（3）通过代理服务器访问一些不能直接访问的网站。互联网上有许多开放的代理服务器，这些代理服务器的访问权限是不受限制的，客户在访问权限受到限制时，如果刚好代理服务器在客户的访问范围之内，那么客户通过代理服务器访问目标网站就成为可能。国内的高校多使用教育网，不能出国，但通过代理服务器，就能实现访问因特网，这就是高校内代理服务器热的原因所在。</p>
<p>（4）安全性得到提高。无论是上聊天室还是浏览网站，目的网站只能知道用户来自于代理服务器，而用户的真实IP则无法测知，这就使得用户的安全性得以提高。</p>
<p>（5）共享IP地址。由于中国的IP地址比较紧张，通过代理服务器，可以节约一些IP地址。</p>
<p>代理技术主要有以下6个方面的优点：</p>
<p>（1）代理易于配置。因为代理是一个软件，所以它较过滤路由器更易配置，配置界面十分友好。如果代理实现得好，可以对配置协议要求较低，从而避免配置错误。</p>
<p>（2）代理能生成各项记录。因代理工作在应用层，它检查各项数据，所以可以按一定准则，让代理生成各项日志、记录。这些日志、记录对于流量分析、安全检验是十分重要和宝贵的。当然，也可以用于计费等应用。</p>
<p>（3）代理能灵活、完全地控制进出流量和内容。</p>
<p>（4）代理能过滤数据内容。</p>
<p>（5）代理能为用户提供透明的加密机制。</p>
<p>（6）代理可以方便地与其他安全手段集成。</p>
<p>代理技术的缺点主要有以下6个方面：</p>
<p>（1）代理速度较路由器慢。</p>
<p>（2）代理对用户不透明。</p>
<p>（3）对于每项服务代理可能要求不同的服务器。</p>
<p>（4）代理服务通常要求对客户、过程之一或两者进行限制。</p>
<p>（5）代理服务不能保证免受所有协议弱点的限制。</p>
<p>（6）代理不能改进底层协议的安全性。</p>
<p>代理服务器、网络管理工具等。</p>
<p>第4章：数据通信与计算机网络</p>
<p>网络管理工具</p>
<p>现在网络管理平台有很多，而真正具有OSI定义的网管五大功能的系统却不多，典型的系统包括</p>
<p>HP的OpenView、IBM的NetView和Tivoli、SUN的SunNet、Cabletron的SPECTRUM。Cisco</p>
<p>Work则是最适用于Cisco网络设备密集的网络的实用性网络管理系统。</p>
<p>在进行网络维护时，经常需要监视网络数据流并对其进行分析，这也称为网络监视，而常见的</p>
<p>网络监视器包括Ethereal、NetXRay和Sniffer。</p>
<p>（1）Ethereal：提供了对TCP、UDP、SMB、Telnet和FTP等常用协议的支持，覆盖了大部分</p>
<p>应用需求。</p>
<p>（2）NetXRay：主要用做以太网中的网管软件，能够对IP、NetBEUI和TCP、UDP等协议进行</p>
<p>详细分析。</p>
<p>（3）Sniffer：它使网络接口处于混杂模式，以截获网络内容。它是最完善、应用最广泛的一种</p>
<p>网络监视器。</p>
<p>另外，在操作系统中有4个常用的网络管理工具。</p>
<p>（1）ping命令：基于ICMP协议，用于把一个测试数据包发送到规定的地址，如果一切正常则</p>
<p>返回成功响应，并且可以从时间戳中获得链路的状态信息。它常用于以下几种情形。</p>
<p>•验证TCP/IP协议是否正常安装：ping127.0.0.1，如果正常返回，说明安装成功。其中</p>
<p>127.0.0.1是回送地址。</p>
<p>•验证IP地址配置是否正常：ping本机IP地址。</p>
<p>•查验远程主机：ping远端主机IP地址。</p>
<p>（2）tracert：检查到达的目标IP地址的路径并记录结果。tracert命令显示用于将数据包从计算</p>
<p>机传递到目标位置的一组IP路由器，以及每个跳跃所需的时间。如果数据包不能传递到目标，</p>
<p>tracert命令将显示成功转发数据包的最后一个路由器。</p>
<p>（3）netstat：用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各</p>
<p>端口的网络连接情况。</p>
<p>（4）IPConfig：显示当前的TCP/IP配置，这些信息一般用来检验人工配置的TCP/IP设置是否</p>
<p>正确。</p>
<p>第4章：数据通信与计算机网络</p>
<p>综合布线系统</p>
<p>综合布线工程包括综合布线设备安装、布放线缆和缆线端接等三个环节。任何一个网络系统的</p>
<p>实施都至少包括两个部分，即逻辑设计与物理实现。网络系统的调试与安装通常分为以下几步：网</p>
<p>络系统的详细逻辑设计；全部网络设备加电测试；模拟建网调试及连通性测试；实际网络安装调</p>
<p>试。</p>
<p>综合布线系统（PremisesDistributedSystem，PDS）是一种集成化通用传输系统，是在楼宇和园区范围内，利用双绞线或光缆来传输信息，可以连接电话、计算机、会议电视和监视电视等设备的结构化信息传输系统。综合布线系统使用标准的双绞线和光纤，支持高速率的数据传输。这种系统使用物理分层星形拓扑结构，积木式、模块化设计，遵循统一标准，使系统的集中管理成为可能，也使每个信息点的故障、改动或增删不影响其他的信息点，使安装、维护、升级和扩展都非常方便，并节省了费用。</p>
<p>综合布线系统可分为6个独立的系统（模块），如图4-5所示。</p>
<p>图4-5综合布线系统</p>
<p>（1）工作区子系统。工作区子系统由终端设备连接到信息插座之间的设备组成，包括信息插座、插座盒、连接跳线和适配器。</p>
<p>（2）水平区子系统（水平干线子系统、水平子系统）。水平区子系统应由工作区用的信息插座，以及楼层分配线设备至信息插座的水平电缆、楼层配线设备和跳线等组成。一般情况下，水平电缆应采用4对双绞线电缆。在水平子系统有高速率应用的场合，应采用光缆，即光纤到桌面。水平子系统根据整个综合布线系统的要求，应在二级交接间、交接间或设备间的配线设备上进行连接，以构成电话、数据、电视系统和监视系统，并方便进行管理。</p>
<p>（3）管理间子系统。管理间子系统设置在楼层分配线设备的房间内。管理间子系统应由交接间的配线设备，以及输入/输出设备等组成，也可应用于设备间子系统中。管理间子系统应采用单点管理双交接。交接场的结构取决于工作区、综合布线系统规模和所选用的硬件。在管理规模大、复杂、有二级交接间时，才设置双点管理双交接。在管理点，应根据应用环境用标记插入条来标出各个端接场。</p>
<p>（4）垂直干线子系统（垂直子系统、干线子系统）。通常是由主设备间（如计算机房、程控交</p>
<p>换机房）提供建筑中最重要的铜线或光纤线主干线路，是整个大楼的信息交通枢纽。一般它提供位</p>
<p>于不同楼层的设备间和布线框间的多条连接路径，也可连接单层楼的大片地区。</p>
<p>（5）设备间子系统。设备间是在每一幢大楼的适当地点设置进线设备，进行网络管理及管理人</p>
<p>员值班的场所。设备间子系统应由综合布线系统的建筑物进线设备、电话、数据、计算机和不间断</p>
<p>电源等各种主机设备及其保安配线设备等组成。</p>
<p>（6）建筑群子系统（楼宇子系统）。建筑群子系统将一栋建筑的线缆延伸到建筑群内的其他建</p>
<p>筑的通信设备和设施。它包括铜线、光纤，以及防止其他建筑电缆的浪涌电压进入本建筑的保护设</p>
<p>备。在设计建筑群子系统时，应考虑地下管道辅设的问题。</p>
<p>在综合布线系统的技术指标和质量参数方面，要遵循《综合布线系统工程设计规范》</p>
<p>（GB50311-2007）和《综合布线系统工程验收规范》（GB50312-2007）的要求。</p>
<p>第4章：数据通信与计算机网络</p>
<p>网络规划与设计</p>
<p>我们在网络建设前都要做一个需求分析工作，否则，网络建立起来就带有盲目性，轻则造成网络资源浪费或网络瓶颈，重则使网络瘫痪，损失无法估量的数据资源。网络建设前的需求分析，就是要规划网络建设所要做的工作。根据用户提出的要求，进行网络的设计。可以这么说，网络建设的好坏、快慢、可持续发展性等，都将取决于网络实施前的规划工作。</p>
<p>（1）网络的功能要求。任何网络都不可能是一个可以进行各种各样工作的“万能网”，因此，必须针对每一个具体的网络，依据使用要求、实现成本、未来发展、总预算投资等因素仔细地反复推敲，尤其是分析出网络系统要完成的所有功能。</p>
<p>（2）网络的性能要求。根据对网络系统的相应时间、事物，处理的实时性进行研究，确定系统需要的存储量及备用的存储量。根据网络的工作站权限、容错程度、网络安全性方面的要求等，确定采取何种措施及方案。</p>
<p>（3）网络运行环境的要求。根据整个局域网运行时所需要的环境要求，确定使用哪种网络操作系统、应用系统以及相应的应用软件和共享资源。</p>
<p>（4）网络的可扩充性和可维护性要求。如何增加工作站、怎样与其他网络联网、对软件/硬件的升级换代有何要求与限制等，都要在网络设计时加以考虑，以保证网络的可扩充性和可维护性。通常新建网络时都会给这个局域网提出一些有关使用寿命、维护代价等的要求。</p>
<p>在网络设计方面，主要采用层次式方法。层次式网络设计在互联网组件的通信中引入了3个关键层的概念，分别是核心层、汇聚层和接入层。</p>
<p>通常将网络中直接面向用户连接或访问网络的部分称为接入层，将位于接入层和核心层之间的部分称为分布层或汇聚层。接入层的目的是允许终端用户连接到网络，因此接入层交换机具有低成本和高端口密度特性。</p>
<p>汇聚层交换机是多台接入层交换机的汇聚点，它必须能够处理来自接入层设备的所有通信量，并提供到核心层的上行链路，因此汇聚层交换机与接入层交换机比较，需要更高的性能，更少的接</p>
<p>口和更高的交换速率。汇聚层是核心层和终端用户接入层的分界面，汇聚层完成了网络访问策略控</p>
<p>制、数据包处理、过滤、寻址，以及其他数据处理的任务。</p>
<p>将网络主干部分称为核心层，核心层的主要目的在于通过高速转发通信，提供优化、可靠的骨</p>
<p>干传输结构，因此核心层交换机应拥有更高的可靠性，性能和吞吐量。核心层为网络提供了骨干组</p>
<p>件或高速交换组件，在纯粹的分层设计中，核心层只完成数据交换的特殊任务。</p>
<p>第4章：数据通信与计算机网络</p>
<p>物联网</p>
<p>物联网就是物物相连的互联网。其定义有两层意思：第一，物联网的核心和基础仍然是互联</p>
<p>网，是在互联网基础上的延伸和扩展的网络；第二，其用户端延伸和扩展到了任何物品与物品之</p>
<p>间，进行信息交换和通信。</p>
<p>物联网通过智能感知、识别技术与普适计算、广泛在网络的融合中应用，被称为继计算机、互</p>
<p>联网之后世界信息产业发展的第三次浪潮。物联网是互联网的应用拓展，与其说物联网是网络，不</p>
<p>如说物联网是业务和应用。因此，应用创新是物联网发展的核心，以用户体验为核心的创新2.0是物</p>
<p>联网发展的灵魂。</p>
<p>1．物联网分层</p>
<p>物联网可以分为三个层次：感知层、网络层和应用层。</p>
<p>感知层：用于识别物体、采集信息，就好比人通过视觉、嗅觉、听觉、触觉来感受事物一样，</p>
<p>采集各类信息。如：二维码、RFID、摄像头、传感器。</p>
<p>网络层：传递信息和处理信息。通信网与互联网的融合网络、网络管理中心、信息中心和智能</p>
<p>处理中心等。</p>
<p>应用层：解决信息处理和人机交互的问题。</p>
<p>2．物联网关键技术</p>
<p>物联网涉及到的技术非常多，其中常见且比较重要的包括：传感器技术、RFID、二维码等。</p>
<p>（1）传感器技术</p>
<p>大家都知道，到目前为止绝大部分计算机处理的都是数字信号。自从有计算机以来就需要传感器把模拟信号转换成数字信号计算机才能处理。传感器技术成为物联网关键技术，主要是因为物联网中经常要用到大量的传感器，如：温度传感器、温度传感器、光敏传感器等。</p>
<p>（2）RFID</p>
<p>射频识别技术（RadioFrequencyIdentification，RFID），又称电子标签，是一种通信技术，可通过无线电讯号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立机械或光学接触。该技术是物联网的一项核心技术，很多物联网应用都离不开它。</p>
<p>（3）二维码</p>
<p>二维码是一种使用特定几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的技术，如图4-6所示。在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、</p>
<p>“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理。</p>
<p>图4-6二维码示意图</p>
<p>（4）嵌入式系统技术</p>
<p>嵌入式系统技术是一种综合了计算机软硬件、传感器技术、集成电路技术、电子应用技术为一</p>
<p>体的复杂技术。经过几十年的演变，以嵌入式系统为特征的智能终端产品随处可见；小到人们身边</p>
<p>的MP3，大到航天航空的卫星系统。嵌入式系统正在改变着人们的生活，推动着工业生产以及国防</p>
<p>工业的发展。如果把物联网用人体做一个简单比喻，传感器相当于人的眼睛、鼻子、皮肤等感官，</p>
<p>网络就是神经系统用来传递信息，嵌入式系统则是人的大脑，在接收到信息后要进行分类处理。这</p>
<p>个例子很形象的描述了传感器、嵌入式系统在物联网中的位置与作用。</p>
<p>3．物联网应用</p>
<p>物联网技术目前可应用于众多的领域，如：智能交通、环境保护、政府工作、公共安全、平安家居、智能消防、工业监测、环境监测、路灯照明管控、景观照明管控、楼宇照明管控、广场照明管控、老人护理、个人健康、花卉栽培、水系监测、食品溯源、敌情侦查。</p>
<p>下面介绍几个具体的应用场景：</p>
<p>（1）门禁系统</p>
<p>一个完整的门禁系统由读卡器、控制器、电锁、出门开关、门磁、电源、处理中心这八个模块组成，无线物联网门禁将门点的设备简化到了极致：一把电池供电的锁具（锁具通过无线与主控设备通信，当通信受阻时，还可用离线模式刷卡开门）。除了门上面要开孔装锁外，门的四周不需要设备任何辅助设备。整个系统简洁明了，大幅缩短施工工期，也能降低后期维护的资金。</p>
<p>（2）ZigBee路灯控制系统</p>
<p>目前ZigBee无线路灯照明节能环保技术已广泛应用到了实际生活中。采用了ZigBee技术的无线路灯控制系统，不仅能根据需要调节路灯的亮度，还可以独立控制单个路灯。例如，在晚上6点钟，将马路上的单号或者双号路灯开启，到晚上8点钟，将全部路灯开启，晚上12点钟调节到半亮度，早上6点全部关闭。经相关部门测试，相对传统的控制方式可实现节能50%。每个路段的路灯都通过内置的ZigBee模块组成一个无线通信子网，而每个子网都通过一个ZigBee-GPRS网关连接到监控中心，而监控室的服务器只需连接到互联网，即可监控市区内的每一盏路灯的状态。</p>
<p>第4章：数据通信与计算机网络</p>
<p>例题分析</p>
<p>数据通信与计算机网络知识是系统架构设计师上午考试的一个重点，为了帮助考生了解在这方</p>
<p>面的试题题型和难度，本节分析6道典型的试题。</p>
<p>例题1</p>
<p>以下关于网络核心层的叙述中，正确的是<strong>(1)</strong>。</p>
<p>（1）A．为了保障安全性，应该对分组进行尽可能多的处理</p>
<p>B．在区域间高速地转发数据分组</p>
<p>C．由多台二、三层交换机组成</p>
<p>D．提供多条路径来缓解通信瓶颈</p>
<p>例题1分析</p>
<p>三层模型主要将网络划分为核心层、汇聚层和接入层，每一层都有着特定的作用：核心层提供不同区域或者下层的高速连接和最优传送路径；汇聚层将网络业务连接到接入层，并且实施与安全、流量负载和路由相关的策略；接入层为局域网接入广域网或者终端用户访问网络提供接入。其中核心层是互连网络的高速骨干，由于其重要性，因此在设计中应该采用冗余组件设计，使其具备高可靠性，能快速适应变化。</p>
<p>在设计核心层设备的功能时，应尽量避免使用数据包过滤、策略路由等降低数据包转发处理的特性，以优化核心层获得低延迟和良好的可管理性。</p>
<p>核心层应具有有限的和一致的范围，如果核心层覆盖的范围过大，连接的设备过多，必然引起网络的复杂度加大，导致网络管理性降低；同时，如果核心层覆盖的范围不一致，必然导致大量处理不一致情况的功能都在核心层网络设备中实现，会降低核心网络设备的性能。</p>
<p>对于那些需要连接因特网和外部网络的网络工程来说，核心层应包括一条或多条连接到外部网络的连接，这样可以实现外部连接的可管理性和高效性。</p>
<p>例题1答案</p>
<p>（1）B</p>
<p>例题2</p>
<p>网络系统设计过程中，逻辑网络设计阶段的任务是<strong>(2)</strong>。</p>
<p>（2）A．依据逻辑网络设计的要求，确定设备的物理分布和运行环境</p>
<p>B．分析现有网络和新网络的资源分布，掌握网络的运行状态</p>
<p>C．根据需求规范和通信规范，实施资源分配和安全规划</p>
<p>D．理解网络应该具有的功能和性能，设计出符合用户需求的网络</p>
<p>例题2分析</p>
<p>本题主要考查网络设计方面的基础知识。根据网络系统设计的一般规则，在逻辑网络设计阶段</p>
<p>的任务通常是根据需求规范和通信规范，实施资源分配和安全规划。其他几个选项都不是逻辑网络</p>
<p>设计阶段的任务。</p>
<p>本题考查网络设计各阶段的任务，网络设计主要分为逻辑网络设计与物理网络设计。</p>
<p>在逻辑网络设计阶段，需要描述满足用户需求的网络行为以及性能，详细说明数据是如何在网</p>
<p>络上阐述的，此阶段不涉及网络元素的具体物理位置。</p>
<p>网络设计者利用需求分析和现有网络体系分析的结果来设计逻辑网络结构。如果现有的软件、</p>
<p>硬件不能满足新网络的需求，现有系统就必须升级。如果现有系统能继续运行使用，可以将它们集</p>
<p>成到新设计中来。如果不集成旧系统，网络设计小组可以找一个新系统，对它进行测试，确定是否符合用户的需求。</p>
<p>此阶段最后应该得到一份逻辑网络设计文档，输出的内容包括以下几点：</p>
<p>（1）逻辑网络设计图</p>
<p>（2）IP地址方案</p>
<p>（3）安全方案</p>
<p>（4）具体的软件、硬件、广域网连接设备和基本的服务</p>
<p>（5）雇佣和培训新网络员工的具体说明</p>
<p>（6）初步对软件、硬件、服务、网络雇佣员工和培训的费用估计</p>
<p>物理网络设计阶段的任务是如何实现确定的逻辑网络结构。在这一阶段，网络设计者需要确定具体的软件、硬件、连接设备、服务和布线。</p>
<p>如何购买和安装设备，由网络物理结构这一阶段的输出作指导，所以网络物理设计文档必须尽可能详细、清晰，输出的内容如下：</p>
<p>（1）物理网络图和布线方案</p>
<p>（2）设备和部件的详细列表清单</p>
<p>（3）软件、硬件和安装费用的估计</p>
<p>（4）安装日程表，用以详细说明实际和服务中断的时间以及期限</p>
<p>（5）安装后的测试计划</p>
<p>（6）用户培训计划</p>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>特征工程</title>
    <url>/post/8ae97bf8/</url>
    <content><![CDATA[<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p><strong>从特征集合中挑选一组最具统计意义的特征子集，从而达到降维的效果</strong>。</p>
<ul>
<li>filter（刷选器）方法，主要侧重于单个特征跟目标变量的相关性<ul>
<li>优点是计算时间上较高效,对于过拟合问题也具有较高的鲁棒性。</li>
<li>缺点就是倾向于选择冗余的特征,因为他们不考虑特征之间的相关性,有可能某一个特征的分类能力很差，但是它和某些其它特征组合起来会得到不错的效果。</li>
</ul>
</li>
<li>wrapper（封装器）和Embeded(集成方法)<ul>
<li>优点是考虑了特征与特征之间的关联性</li>
<li>缺点是当观测数据较少时容易过拟合，而当特征数量较多时,计算时间又会增长。</li>
</ul>
</li>
<li>Embeded集成方法</li>
</ul>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p><strong>自动地构建新的特征，将原始特征转换为一组具有明显物理意义（Gabor、几何特征[角点、不变量]、纹理[LBP HOG]）或者统计意义或核的特征</strong>。</p>
<ul>
<li>PCA (Principal component analysis，主成分分析)</li>
<li>ICA (Independent component analysis，独立成分分析)</li>
<li>LDA （Linear Discriminant Analysis，线性判别分析）</li>
</ul>
<h3 id="特征构建"><a href="#特征构建" class="headerlink" title="特征构建"></a>特征构建</h3><p><strong>从原始数据中人工的构建新的特征</strong></p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>data mining</tag>
      </tags>
  </entry>
  <entry>
    <title>使用explain查看查询语句效率——《高性能sql》附录D</title>
    <url>/post/48b37dd6/</url>
    <content><![CDATA[<h1 id="1简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p><code>EXPLAIN</code> 命令可以对 <code>SELECT</code> 语句进行分析, 并输出 <code>SELECT</code> 执行的详细信息, 以供开发人员针对性优化。</p>
<p>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:​                      </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * from _info WHERE  id &lt; 300;</span><br></pre></td></tr></table></figure>
<h1 id="2explain输出格式"><a href="#2-EXPLAIN输出格式" class="headerlink" title="2.EXPLAIN输出格式"></a>2.<code>EXPLAIN</code>输出格式</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_info <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: user_info</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">8</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>各列含义：</p>
<ul>
<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT 查询的类型.</li>
<li>table: 查询的表名</li>
<li>partitions: 匹配的分区</li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引.</li>
<li>ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<h2 id="21-select_type"><a href="#2-1-select-type" class="headerlink" title="2.1 select_type"></a>2.1 select_type</h2><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p>
<ul>
<li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li>
<li>PRIMARY, 表示此查询是最外层的查询</li>
<li>UNION, 表示此查询是 UNION 的第二或随后的查询</li>
<li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li>
<li>UNION RESULT, UNION 的结果</li>
<li>SUBQUERY, 子查询中的第一个 SELECT</li>
<li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li>
</ul>
<h2 id="22-table"><a href="#2-2-table" class="headerlink" title="2.2 table"></a>2.2 table</h2><p>表示查询涉及的表或衍生表</p>
<h2 id="23-type"><a href="#2-3-type" class="headerlink" title="2.3 type"></a>2.3 type</h2><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p>
<h3 id="231-type-常用的取值"><a href="#2-3-1-type-常用的取值" class="headerlink" title="2.3.1 type 常用的取值"></a>2.3.1 type 常用的取值</h3><ul>
<li><code>system</code>: 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</li>
<li><code>const</code>: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. <strong>const 查询速度非常快, 因为它仅仅读取一次即可.</strong><br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</li>
<li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询,  表示<strong>对于前表的每一个结果, 都只能匹配到后表的一行结果.</strong> 并且查询的比较操作通常是 <code>=</code>, 查询效率较高. </li>
<li><code>ref</code>: 此类型通常出现在多表的 join 查询, <strong>针对于非唯一或非主键索引</strong>, 或者是<strong>使用了 <code>最左前缀</code> 规则索引的查询</strong>. </li>
<li><code>range</code>: 表示<strong>使用索引范围查询, 通过索引字段范围获取表中部分数据记录</strong>. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <strong><code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个</strong>.</li>
<li><code>index</code>: 表示全索引扫描(full index scan), <strong>和 ALL 类型类似</strong>, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code>.</li>
<li><code>ALL</code>: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询,<br>因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</li>
</ul>
<h3 id="232-type-类型的性能比较"><a href="#2-3-2-type-类型的性能比较" class="headerlink" title="2.3.2 type 类型的性能比较"></a>2.3.2 type 类型的性能比较</h3><p>通常来说, 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p>
<h2 id="24-possible_keys"><a href="#2-4-possible-keys" class="headerlink" title="2.4 possible_keys"></a>2.4 possible_keys</h2><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. <strong>MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定</strong>.</p>
<h3 id="241-key"><a href="#2-4-1-key" class="headerlink" title="2.4.1 key"></a>2.4.1 key</h3><p>此字段是 MySQL 在当前查询时所<strong>真正使用到的索引</strong>.</p>
<h3 id="242-key_len"><a href="#2-4-2-key-len" class="headerlink" title="2.4.2 key_len"></a>2.4.2 key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以<strong>评估组合索引是否完全被使用, 或只有最左部分字段被使用到</strong>.<br>key_len 的计算规则如下:</p>
<ul>
<li>字符串<ul>
<li>char(n): n 字节长度</li>
<li>varchar(n): 如果是 utf8 编码, 则是 3  <em>n + 2字节; 如果是 utf8mb4 编码, 则是 4</em>  n + 2 字节.</li>
</ul>
</li>
<li>数值类型:<ul>
<li>TINYINT: 1字节</li>
<li>SMALLINT: 2字节</li>
<li>MEDIUMINT: 3字节</li>
<li>INT: 4字节</li>
<li>BIGINT: 8字节</li>
</ul>
</li>
<li>时间类型<ul>
<li>DATE: 3字节</li>
<li>TIMESTAMP: 4字节</li>
<li>DATETIME: 8字节</li>
</ul>
</li>
<li>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</li>
</ul>
<h2 id="25-rows"><a href="#2-5-rows" class="headerlink" title="2.5 rows"></a>2.5 rows</h2><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, <strong>估算 SQL 要查找到结果集需要扫描读取的数据行数.</strong><br>这个值非常直观显示 SQL 的效率好坏, <strong>原则上 rows 越少越好</strong>.</p>
<h2 id="26-extra"><a href="#2-6-Extra" class="headerlink" title="2.6 Extra"></a>2.6 Extra</h2><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>
<ul>
<li><p>Using filesort<br>当 Extra 中有 <code>Using filesort</code> 时, 表示 <strong>MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果</strong>. 一般有 <code>Using filesort</code>, <strong>都建议优化去掉</strong>, 因为这样的查询 CPU 资源消耗大.</p>
</li>
<li><p>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明<strong>性能不错</strong></p>
</li>
<li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, <strong>建议优化</strong>.</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>社会学导论</title>
    <url>/post/b8a740eb/</url>
    <content><![CDATA[<p>学习课程</p>
<p><a href="https://www.bilibili.com/video/BV1dx411E7KY?p=14">耶鲁大学公开课集</a></p>
<h2 id="thomas-hobbes-权力-人权-社会秩序"><a href="#Thomas-Hobbes-权力、人权、社会秩序" class="headerlink" title="Thomas Hobbes: 权力、人权、社会秩序"></a>Thomas Hobbes: 权力、人权、社会秩序</h2><p>奠定了现代社会科学的基础</p>
<h3 id="一-生平"><a href="#一、生平" class="headerlink" title="一、生平"></a>一、生平</h3><p>伊丽莎白女王 与弗兰西斯 培根关系紧密</p>
<h4 id="培根的影响"><a href="#培根的影响" class="headerlink" title="培根的影响"></a>培根的影响</h4><p>反对亚里士多德逻辑体系的哲学家，基础是一些重要假说，通过演绎法来发展其哲学体系。</p>
<p>培根认为实验应该从归纳感官观察开始，而不能假设无法观察的事物存在，于是提出一套与亚里士多德演绎法相反的方法论——归纳法。</p>
<h4 id="游历欧洲-1635-36"><a href="#游历欧洲-1635-36" class="headerlink" title="游历欧洲 1635-36"></a>游历欧洲 1635-36</h4><p>认识伽利略、笛卡尔 </p>
<p>在伽利略那里学到 分析综合法(the resolutive-compositive method)——从演绎开始，然后开始观察、感官上的观察，而后归纳总结。</p>
<p>反对笛卡尔主张的二元论(dualism)——区分灵魂与肉体的二元论。Hobbes主张一定存在真正的客体，我们可以确定地看到他。</p>
<p>随后写了他的哲学三部曲，《论物体》《论人》《论公民》——试图建立以<strong>生物学和生物进程</strong>为前提的哲学理论体系，从生物学逐步建立起对社会和个人本性的认识，通过个人认识社会。</p>
<h4 id="政治上"><a href="#政治上" class="headerlink" title="政治上"></a>政治上</h4><p>对民主一直心存怀疑，相信必须有一个强大的中央权威</p>
<h4 id="时代风波"><a href="#时代风波" class="headerlink" title="时代风波"></a>时代风波</h4><p>正值乱世、宗教冲突频发。亨利八世……</p>
<h4 id="逃离英格兰前往法兰西-1640-1651"><a href="#逃离英格兰，前往法兰西-1640-1651" class="headerlink" title="逃离英格兰，前往法兰西 1640-1651"></a>逃离英格兰，前往法兰西 1640-1651</h4><p>与保皇派走得太近.</p>
<p>1651完成主要著作<strong>《利维坦》 <em>Leviathan</em></strong> 第一位理性选择理论家</p>
<p>理念：人性自私，我们需要一位拥有至高无上权利的君王，以避免人与人之间的敌对状态</p>
<h4 id="返回英格兰-各种争议-1651-1679"><a href="#返回英格兰-各种争议-1651-1679" class="headerlink" title="返回英格兰 各种争议 1651-1679"></a>返回英格兰 各种争议 1651-1679</h4><h3 id="二-利维坦"><a href="#二、利维坦" class="headerlink" title="二、利维坦"></a>二、利维坦</h3><p>Part 1 Human</p>
<ul>
<li>chapter 1-5：机械论 受伽利略的影响(sense imagination speech reason……)</li>
<li>chapter 6：关于 欲望、渴望、反感、恐惧以及自愿行为理论 </li>
<li>chapter 7-11：人与人之间的关系</li>
<li>chapter 12-16：自然状态论</li>
</ul>
<p>Part 2 Commonwealth 国家理论——政府和臣民的权利和责任</p>
<p>Part 3 4 神学理论</p>
<h4 id="第一部分-what-is-human-nature"><a href="#第一部分-What-is-human-nature" class="headerlink" title="第一部分 What is human nature?"></a>第一部分 What is human nature?</h4><ul>
<li><em>Men deliberate between appetites and aversions-acts voluntarily</em> 人通过熟思自身的好恶从而产生自觉的行为（人是否有自由意志）</li>
<li><em>seeks power-essence of human nature is struggle for power</em> 人性的本质是我们对权力的渴求</li>
<li><em>if one wants to survive-must obey all-powerful sovereign</em> 为了生存，我们需要一个强有力的政权</li>
</ul>
<ol>
<li><p>Voluntary action 自主行为，两种特定的运动</p>
<ul>
<li>自主运动实际上与欲望渴求或者嫌恶有关</li>
<li>appetites and aversions 欲望渴求和嫌恶——与之后的功利主义相似、亚当斯密的理论</li>
<li>deliberation and will 深思熟虑与意志</li>
</ul>
</li>
<li><p>desire for power </p>
<ul>
<li>生存所需，不得不追逐权力</li>
</ul>
</li>
<li><p>men born equal</p>
<ul>
<li>在心智上人们也是平等的，从这样的平等中衍生出来的是无限的战争，因为我们的渴求相同，而资源短缺，我们必须彼此争斗。与尼采类似</li>
</ul>
</li>
<li><p>war of everyone against every one</p>
</li>
</ol>
<h4 id="第二部分-nature-and-contract"><a href="#第二部分-nature-and-contract" class="headerlink" title="第二部分 nature and contract"></a>第二部分 nature and contract</h4><ol>
<li><p>两大原则</p>
<ul>
<li>你不能做伤害你自己的事</li>
<li>考虑别人：已所不欲勿施于人；没有制约，就没有文明；文明来自于隐忍，来自于对欲望的压抑</li>
</ul>
</li>
<li><p>contract/covenant</p>
<p>我们放弃自己的权利将其让渡给他人，这种权利的让渡存在互利关系。关于社会契约论的首个设想。</p>
<ul>
<li>我们处于恐惧而加入的契约也是有义务的，因恐惧而加入，并不意味着我们可以对契约为所欲为</li>
<li>先订立的契约效力高于后订立的契约</li>
</ul>
</li>
</ol>
<h4 id="第三部分-power-of-sovereign-justified"><a href="#第三部分-power-of-sovereign-justified" class="headerlink" title="第三部分 power of sovereign justified"></a>第三部分 power of sovereign justified</h4><p>臣民是否臣服极大取决于，统治者能为他们提供多大程度的安全感。</p>
<ol>
<li><p>Commonwealth/sovereign </p>
<p>承认最高统治者可以是一个合理组织的团体。</p>
</li>
<li><p>duty of sovereign </p>
</li>
</ol>
<h3 id="contributions-shortcomings"><a href="#contributions-shortcomings" class="headerlink" title="contributions / shortcomings"></a>contributions / shortcomings</h3><ul>
<li>统治者可能滥用权力，受到批评</li>
<li>并未涉及权力如何在监督下使用的理论，没有监督和权力平衡的理论（孟德斯鸠明确了权力的监督和制衡）</li>
</ul>
<hr>
<h2 id="john-locke-平等-自由-财产与权利的分歧"><a href="#John-Locke-平等、自由、财产与权利的分歧" class="headerlink" title="John Locke: 平等、自由、财产与权利的分歧"></a>John Locke: 平等、自由、财产与权利的分歧</h2><h3 id="一-生平"><a href="#一、生平-1" class="headerlink" title="一、生平"></a>一、生平</h3><h4 id="早年"><a href="#早年" class="headerlink" title="早年"></a>早年</h4><p>1652年进入牛津大学 “idle, unhappy and unremarkable”</p>
<p>1664年在学校的演讲——早期的洛克是传统主义者、独裁主义者</p>
<h4 id="from-cromwell-to-stuart-restoration"><a href="#from-Cromwell-to-Stuart-restoration" class="headerlink" title="from Cromwell to Stuart restoration"></a>from Cromwell to Stuart restoration</h4><p>查理一世被处决，克伦威尔成为英国的护国公；查理二世被召回。皇权复辟</p>
<h4 id="the-new-haven纽黑文-connection"><a href="#The-New-Haven-纽黑文-connection" class="headerlink" title="The New Haven(纽黑文) connection"></a>The New Haven(纽黑文) connection</h4><h4 id="遇见-anthony-ashley-cooper1666"><a href="#遇见-Anthony-Ashley-Cooper-1666" class="headerlink" title="遇见 Anthony Ashley Cooper,1666"></a>遇见 Anthony Ashley Cooper,1666</h4><p>Cooper加入了议会，在共和时代是国会的一员，1666-1673身居要职。</p>
<p>1667年 <em>Essay of Toleration</em>《论宽容》</p>
<p>1668年 洛克被选入英国皇家学会</p>
<h4 id="查理二世和议会的争议"><a href="#查理二世和议会的争议" class="headerlink" title="查理二世和议会的争议"></a>查理二世和议会的争议</h4><p>查理二世遣散议会</p>
<h4 id="光荣革命-1688"><a href="#光荣革命-1688" class="headerlink" title="光荣革命 1688"></a>光荣革命 1688</h4><p>威廉亲王入住英格兰，洛克1690年返回英格兰</p>
<h3 id="二-the-two-treatises-of-government政府论"><a href="#二、the-Two-Treatises-of-Government《政府论》" class="headerlink" title="二、the Two Treatises of Government《政府论》"></a>二、<em>the Two Treatises of Government</em>《政府论》</h3><h4 id="第一论"><a href="#第一论" class="headerlink" title="第一论"></a>第一论</h4><h4 id="第二论"><a href="#第二论" class="headerlink" title="第二论"></a>第二论</h4><ol>
<li>we are all born free and equal<ul>
<li>组成政治权力的三要素：制定法律的权力、执行法律的权力、政权为抵御外敌入侵的权力</li>
<li>平等源自何处<ul>
<li>人是由万能的上帝创造的，原则上应该没有人是任何人的上级；哲学从保守主义向自由主义演变，自由主义强调自由是最重要的权利</li>
<li>在自然条件下我们是<strong>理性</strong>的，这种理性是生来就有的。伤害彼此是不对的。</li>
</ul>
</li>
</ul>
</li>
<li>need for and nature of common superior(2-4) 共同的君主，其存在是为了避免战争<ul>
<li>洛克承认战争的危害，认同君主存在的必要性</li>
<li>虽然我们会服从君主，但前提是经过我们同意——必须持久地用法律来捍卫自由，并不仅仅是自由权</li>
<li>我们需要君主保护私有财产</li>
</ul>
</li>
<li>theory of property(5-11) 私有财产<ul>
<li>财产的起源</li>
<li>人拥有自己劳动的成果</li>
<li>私有财产的局限性——man can own as much as man can tilt</li>
<li>洛克观点的核心是<strong>充分性假设</strong>，我们的欲望是可以被充分满足的——与霍布斯的稀缺假设相反</li>
<li>劳动创造价值</li>
<li>但是随着货币的发明，财富积累成了可能</li>
<li>为了保护私人财产，需要把权力让渡给共同体或是君主</li>
<li>绝对君主制和君主立宪制的区别——在绝对君主制，你可以诉诸法律来约束另一个国民对你进行暴力行为，但无法对君主提起诉讼。</li>
</ul>
</li>
<li>社会依赖于多数决定原则(12-15) 分权和制衡<ul>
<li>我们需要通过国家范围内大多数人的同意来创建合理的法规。一旦大家都通过了，那么每个人都需遵守。</li>
<li>一个人只有经过认可才能成为政权主体</li>
<li>分权思想：立法权、<strong>联邦权</strong>（与孟德斯鸠与美国宪法不同）、执法权</li>
</ul>
</li>
</ol>
<hr>
<p>告别内战的十七世纪英国，来到一个世纪后的启蒙时代以及一个堕落不堪的时代。</p>
<p>Hobbes and Locke都是<strong>个人主义方法论者</strong>，欲知万物必先从解剖自己开始，英国式的个人主义和经验主义</p>
<p>法国学者则都是<strong>集体主义方法论者</strong>，他们坚信社会存在大于个体存在的单纯叠加，法国学者的law立于所有人之上</p>
<h2 id="montesquieu-权力分割"><a href="#Montesquieu-权力分割" class="headerlink" title="Montesquieu: 权力分割"></a>Montesquieu: 权力分割</h2><h3 id="一-生平"><a href="#一、生平-2" class="headerlink" title="一、生平"></a>一、生平</h3><p>太阳王路易十六 1647-1715：法国专制主义的代表人物</p>
<p>十八世纪：光明的年代</p>
<p>笛卡尔将哲学转变为生人勿进般的理性思辨，这场席卷十八世纪英国的思想风潮，直到法国大革命才结束。其中的两大突破：孟德斯鸠、卢梭</p>
<p>路易十五时期，启蒙革新、纵情乱性</p>
<ul>
<li><p>1721年 <em>“Persian Letters”</em> 《波斯人信札》</p>
</li>
<li><p>1748年 <em>The Spirit of Laws</em> 《论法的精神》</p>
</li>
</ul>
<h3 id="二-the-spirit-of-laws-论法的精神"><a href="#二、The-Spirit-of-Laws-《论法的精神》" class="headerlink" title="二、The Spirit of Laws 《论法的精神》"></a>二、<em>The Spirit of Laws</em> 《论法的精神》</h3><h4 id="书的部分"><a href="#书的部分" class="headerlink" title="书的部分"></a>书的部分</h4><p>Part1： 法的概述、不同形式的政体</p>
<ul>
<li>共和政府 Republic——全民众的统治，即民主；但更赞成贵族选举<ul>
<li>democratic 民主政治</li>
<li>aristocratic 贵族政治</li>
<li>合法基于美德 <strong>virtue</strong>，如果品格受到质疑，则其正当性也受到质疑</li>
</ul>
</li>
<li>君主制 Monarchy——被法律限制，君主立宪制<ul>
<li>王子拥有统治权（法律的来源），但是一旦法律成立，王子也必须执行（君主制）</li>
<li>合法基于荣誉 <strong>honor</strong></li>
</ul>
</li>
<li>专制国家——专制统治者根据个人意愿执行政策，统治者利于法律之上<ul>
<li>合法基于恐惧 <strong>fear</strong></li>
</ul>
</li>
</ul>
<p>Part2：法律和政治，三权分立 Separation of powerss</p>
<ul>
<li>行政法的实施，要以国家的权力和公民的权力为基础</li>
<li>“立法权是第一大的权力 first”，立法权可由国王或者地方行政官执行，也可由被选举的一个团体执行</li>
<li>司法权必须与前两者分立</li>
<li>当立法权和行政权都集中在同一个人身上时，国家就没有了自由，因为人们会害怕</li>
<li>怎样在多数人的专制下维护少数人的权力</li>
</ul>
<p>Part3：法律和风土人情</p>
<p>Part4：法律和商业</p>
<p>Part5：法律和宗教、历史</p>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><h5 id="政府的分类"><a href="#政府的分类" class="headerlink" title="政府的分类"></a>政府的分类</h5><ul>
<li>掌权者如何统治，政府是宽和或者暴虐</li>
<li>是否权力被分立</li>
<li>人们为什么要服从（合法性问题）</li>
<li>统治者是个人或者机构，对政府性质的问题</li>
<li>支持在立法基础上的君主制，即君主立宪制</li>
</ul>
<h5 id="三权分立"><a href="#三权分立" class="headerlink" title="三权分立"></a>三权分立</h5><ul>
<li>洛克——立法权、行政权、联邦权</li>
<li>孟德斯鸠——立法权、行政权、司法权</li>
<li>立法权应该由被选举的代表执行</li>
<li>少数人的权利应该被尊重</li>
<li>必须对立法权加以限制</li>
<li>行政机关要对立法机关进行监督</li>
<li>对行政机关的监督和平衡也是必需的</li>
</ul>
<h5 id="环境和社会法律结构"><a href="#环境和社会-法律结构" class="headerlink" title="环境和社会/法律结构"></a>环境和社会/法律结构</h5><ul>
<li>环境如何影响(shape)社会状况</li>
<li>普遍精神 “general spirit”</li>
<li>方法论上的集体主义者(Methodlogical “collectivist”)</li>
</ul>
<h2 id="jean-jacques-rousseau-主权在民与大众意志"><a href="#Jean-Jacques-Rousseau-主权在民与大众意志" class="headerlink" title="Jean Jacques Rousseau: 主权在民与大众意志"></a>Jean Jacques Rousseau: 主权在民与大众意志</h2><h2 id="jean-jacques-rousseau-自然状态与教育"><a href="#Jean-Jacques-Rousseau-自然状态与教育" class="headerlink" title="Jean Jacques Rousseau: 自然状态与教育"></a>Jean Jacques Rousseau: 自然状态与教育</h2><p><em>Emile</em></p>
<p>没有爱弥儿就没有教育理论的产生。</p>
<h2 id="adam-smith-看不见的手"><a href="#Adam-Smith-看不见的手" class="headerlink" title="Adam Smith: 看不见的手"></a>Adam Smith: 看不见的手</h2><p>主要理论贡献：利己主义、自私与公利的联系、劳动价值理论、看不见的手</p>
<h3 id="一-生平"><a href="#一、生平-3" class="headerlink" title="一、生平"></a>一、生平</h3><p>1759年 《道德情操论》</p>
<p>环游欧洲，结识伏尔泰、魁奈以及许多法国启蒙运动学者</p>
<p>《国富论》</p>
<p>要理解亚当，应当要理解《道德情操论》和《国富论》的差异</p>
<p>亚当斯密斯的两幅面孔：经济学家——推崇利己主义、看不见的手、私利会通向公利；道德哲学家——道德情操论</p>
<h3 id="二-道德情操论"><a href="#二、道德情操论" class="headerlink" title="二、道德情操论"></a>二、道德情操论</h3><p>我们如何做道德判断，如何分辨是非黑白？</p>
<p>在每个人的体内由两个自我，有一个公正的旁观者</p>
<p>或受到霍尔斯的影响，我们被激情 passion 驱动，同样被<strong>同情</strong> sympathy 左右。在同情他人的时候，我们也是在寻求别人的同情。我们试图讨好别人，渴望好的名声、受人尊敬，我们同情他人，也寻求他人的同情。</p>
<p>书中提到的 看不见的手，并不是指无政府状态的市场，而是指上帝的意愿。</p>
<h3 id="三-国富论"><a href="#三、国富论" class="headerlink" title="三、国富论"></a>三、国富论</h3><h4 id="私利和公利-self-interst-and-the-common-good"><a href="#私利和公利-self-interst-and-the-common-good" class="headerlink" title="私利和公利 self-interst and the common good"></a>私利和公利 self-interst and the common good</h4><ul>
<li><p>不要期望别人一定善行：我期待某人为我做某事，是出于私利而非善心；我们的价值不是出于善心，而是出于别人对它的利用。</p>
<ul>
<li><p>”良好的人际关系都是出于私利的。 “</p>
</li>
<li><blockquote>
<p>It is not from the benevolence of the butcher, the brewer, or the baker, that we can expect our dinner, but from their regard to their own interest.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>寻求私利不仅有利于个人，也有利于社会</p>
<ul>
<li>在获得高报酬的时候，要发挥自己的能力、努力工作，为社会做出巨大的贡献</li>
</ul>
</li>
<li><p>比起行政条例或立法者，<strong>个人利益得失的最好裁决者是个人</strong>，政府干涉越少越好（*）</p>
<ul>
<li>人们应该自己来判断他们需要什么，而政府不应该强加意志于人民</li>
</ul>
</li>
</ul>
<h4 id="劳动价值论-labor-theory-of-value"><a href="#劳动价值论-labor-theory-of-value" class="headerlink" title="劳动价值论 labor theory of value"></a>劳动价值论 labor theory of value</h4><ul>
<li>劳动决定价值</li>
<li>全部生产成果归劳动者所有<ul>
<li>每个人的财产就是他的劳动力，他们所创造的价值来自于此，因此也就属于拥有劳动力的人</li>
<li>这个理论只有在资本累积和土地私有之前才成立</li>
<li>在资本累积和土地私有之前，所有的生产力才属于劳动者（分歧）</li>
</ul>
</li>
<li>资本家如何从中获利？利润和租金从何而来？（马克思：剥削；亚当：提供生产资料的人应得）<ul>
<li>劳动力、租金之间存在分配问题。因为资本家投资是为了把资本转换成劳动力，并承担这一行为的风险，监督劳动过程，因此他们理应从中获取利润。同理，对于土地也是这样。</li>
</ul>
</li>
</ul>
<h4 id="看不见的手"><a href="#看不见的手" class="headerlink" title="看不见的手"></a>看不见的手</h4><ul>
<li>《道德情操论》中指上帝的意愿</li>
<li>《国富论》中指自由市场</li>
<li>手稿《天文学历史》中指朱庇特之手，因为人们总是把不能解释的事件看作朱庇特之手（迷信）</li>
</ul>
<h2 id="john-stuart-mill-功利主义与自由主义"><a href="#John-Stuart-Mill-功利主义与自由主义" class="headerlink" title="John Stuart Mill: 功利主义与自由主义"></a>John Stuart Mill: 功利主义与自由主义</h2><p>功利主义是一个很重要的基础命题，影响了现代经济学理论，以及在理性选择之下的政治和社会理论。理论基础：边沁 Bentham（功利主义之父）</p>
<h3 id="边沁的理论"><a href="#边沁的理论" class="headerlink" title="边沁的理论"></a>边沁的理论</h3><p>《道德与立法原理导论》</p>
<ul>
<li>“我们生而寻乐且回避苦难，因此倘若我们将苦难最小化、欢乐最大化，那么我们就获得了中最大的快乐。”</li>
<li>并且这可以被量化——判断一个行为是否合理，只需要快乐减去痛苦再乘受到影响的人数 &gt;0 即可</li>
<li>“苦和乐是人生的两大主宰”</li>
<li>“功利”定义：功利是一种原则，它支持或反对某种行为，以增大或减少某个利益集团的幸福感。</li>
<li>要衡量幸福很简单，计算多少人幸福、计算多少热你痛苦</li>
</ul>
<h3 id="一-密尔生平"><a href="#一、密尔生平" class="headerlink" title="一、密尔生平"></a>一、密尔生平</h3><p>1822年 创建“功利主义”这以名词，之后精神出现问题……</p>
<p>他开始对功利主义的不折手段感到不满。他认为这是一种冷漠的工具主义。</p>
<p>遇见哈里特·米勒（第一位激进的女权主义者）</p>
<h3 id="二-主要贡献"><a href="#二、主要贡献" class="headerlink" title="二、主要贡献"></a>二、主要贡献</h3><ul>
<li>重新定义了功利主义：他认为之前的功利主义太过冷漠，因此需要加入一些感性思维</li>
<li>更高级的幸福：人类既有低层次的幸福，也有高层次的幸福</li>
<li>“个人的自由是在最终的准绳，而非<strong>权宜</strong>。” 权宜指通过最小的代价获得最大的回报。 ”不能以权宜为名，干预个人的自由。“</li>
<li>推动女权：妇女的法律地位就像奴隶，只比努力稍好一点。</li>
</ul>
<h3 id="utilitarianism-1861-功利主义"><a href="#Utilitarianism-1861-功利主义" class="headerlink" title="Utilitarianism (1861) 功利主义"></a>Utilitarianism (1861) 功利主义</h3><ul>
<li>人类有更高等级的欲望 Higher happiness<ul>
<li>不仅仅追求幸福的数量，也追求幸福的质量（喜好）；对新古典经济学影响很大。不能像边沁一样只是积累欲望，并且假设如果能满足更多欲望，社会就会变得更好</li>
<li>首善即是道德</li>
<li>在确认美的重要性的时候，想象和娱乐的实际重要性——席勒</li>
<li>”做不满足的人比做满足的猪好……做不满足的苏格拉底比做满足的傻瓜好。“</li>
</ul>
</li>
<li>合法性要比公正狭隘，说明了合法性和公正的区别<ul>
<li>合法不一定公正</li>
<li>《平权法案》</li>
</ul>
</li>
<li>公正不能简单地用权宜来解释<ul>
<li>权宜不一定公正，而充分的公正必有其代价</li>
<li>我们能切实地感受到公正和公平有一定的联系，我们偶尔察觉到某种程度的不公平事件也是不公正的，尽管它以合法的手段实现，我们或许认为它不公正。通常，不平等被解释并证明为权宜之计。</li>
</ul>
</li>
<li>公正的五个部分<ol>
<li>剥夺任何人的个人自由和财产都是不公正的</li>
<li>合法权被剥夺，可能是本来就不应该拥有的权力</li>
<li>即使不被法律保护，每个人都应该得到自己应得的东西</li>
<li>不守信是不公正的</li>
<li>公正不能存在偏袒</li>
</ol>
</li>
</ul>
<h3 id="on-liberty1859-论自由"><a href="#On-Liberty-1859-论自由" class="headerlink" title="On Liberty(1859) 论自由"></a>On Liberty(1859) 论自由</h3><ul>
<li>Freedom<ul>
<li>我们不应该接受被赐予的自由。对得到认同的统治者也要小心谨慎，那无法保证自由，因为它会造成多数人的专制现象。应该维护个人的权利和少数群体的权力</li>
<li>少数人有与大多数不一样的喜好，而这些也应当得到尊重</li>
<li>个人的自由应得始终出于短期的功利性考虑之上</li>
<li>言论自由：完全的言论自由太重要了，因为如果一个观点被压制了，我们也许会失去改正错误的机会。即使事实不让人愉快，也应该允许被说出来</li>
<li>我们应该听取双方的意见，这样才能发现错误</li>
<li>多数人的专制现象</li>
</ul>
</li>
<li>Individuality<ul>
<li>必须保卫个人自由，必须抵制强权干涉，无论合法与否。他希望捍卫人们自由生活的权力。</li>
<li>只有当民众的个人自由被侵害的时候，政府才有权出面干预。</li>
</ul>
</li>
</ul>
<h3 id="the-subjection-of-women1869"><a href="#The-Subjection-of-Women-1869" class="headerlink" title="The Subjection of Women(1869)"></a>The Subjection of Women(1869)</h3><ul>
<li>”婚姻是奴隶制度的仅存体现“</li>
<li>女性的屈从便是奴隶制度的一种体现，而它无法通过女人的天性来加以解答</li>
<li>婚姻中的平等</li>
<li>女性在政治和教育方面的平等性</li>
<li>婚姻友谊</li>
</ul>
<h2 id="karl-marx-异化理论"><a href="#Karl-Marx-异化理论" class="headerlink" title="Karl Marx: 异化理论"></a>Karl Marx: 异化理论</h2><h3 id="生平-1818~1883"><a href="#生平-1818-1883" class="headerlink" title="生平 1818~1883"></a>生平 1818~1883</h3><p>1830~1835 中学</p>
<p>1835 波恩大学 学习波兰罗马神话、参加学生政治运动</p>
<p>1836 柏林大学 青年黑格尔派</p>
<p>1841 在耶拿大学获得学位</p>
<h3 id="黑格尔的哲学理论"><a href="#黑格尔的哲学理论" class="headerlink" title="黑格尔的哲学理论"></a>黑格尔的哲学理论</h3><p>异化：主体和客体相互分离</p>
<p>整体性：当主体和客体成为同一体就有了整体性</p>
<h2 id="karl-marx-历史唯物论"><a href="#Karl-Marx-历史唯物论" class="headerlink" title="Karl Marx: 历史唯物论"></a>Karl Marx: 历史唯物论</h2><h2 id="karl-marx-历史理论"><a href="#Karl-Marx-历史理论" class="headerlink" title="Karl Marx: 历史理论"></a>Karl Marx: 历史理论</h2><h2 id="karl-marx-阶级与剥削论"><a href="#Karl-Marx-阶级与剥削论" class="headerlink" title="Karl Marx: 阶级与剥削论"></a>Karl Marx: 阶级与剥削论</h2><h2 id="friedrich-nietzsche-权力-知识与道德"><a href="#Friedrich-Nietzsche-权力、知识与道德" class="headerlink" title="Friedrich Nietzsche: 权力、知识与道德"></a>Friedrich Nietzsche: 权力、知识与道德</h2><p>尼采思想的最重要的议题在于，与人类意识加以批判性审视，但并没有占据批判性的制高点，即不设立善（good）的标准、不设计终极价值和终极理想。他以批判性的审视来批判良好社会和善（good）的基本原则。<strong>我们的 good society and good 从何而来？</strong></p>
<h3 id="一-生平-1844-1900"><a href="#一、生平-1844-1900" class="headerlink" title="一、生平 1844-1900"></a>一、生平 1844-1900</h3><p>神学院学习，成为无神论者</p>
<p>1864， 结交最好的朋友作曲家Richard Wagner，后为仇敌（由于尼采十分厌恶反犹太主义）</p>
<p>1869-1877，巴塞尔大学，教授古典哲学</p>
<p>1873，结交Paul Ree</p>
<p>1888，罹患精神疾病，最后由其妹妹伊丽莎白尼采照顾</p>
<p>伊丽莎白是极端的右翼分子，宣扬纳粹主义，最终成为希特勒的信徒。作为尼采手稿的整理者，试图通过尼采的文章，在尼采的思想之外捏造纳粹思想。因此，长期以来，部分人认为尼采是一个纳粹主义者。尼采与纳粹主义的关系，也是关于尼采哲学的一个重要议题。</p>
<h4 id="lou-paul-friedrich的三角恋关系"><a href="#Lou-Paul-Friedrich的三角恋关系" class="headerlink" title="Lou Paul Friedrich的三角恋关系"></a>Lou Paul Friedrich的三角恋关系</h4><h4 id="richard-wagner对尼采的影响"><a href="#Richard-Wagner对尼采的影响" class="headerlink" title="Richard Wagner对尼采的影响"></a>Richard Wagner对尼采的影响</h4><p>尼采是古希腊文明的推崇者，其人崇拜英雄，向往希腊神话中的诸神般的英雄形象，因此为Wagner所吸引。</p>
<p>Wagner的思想转向反犹太主义，以及其作品中所表现的基督倾向，这使得尼采无法忍受，致使两人关系的决裂。</p>
<h3 id="二-the-birth-of-the-tragedy-out-of-the-spirit-of-music-悲剧的诞生1872"><a href="#二、The-Birth-of-the-Tragedy-out-of-the-Spirit-of-Music-悲剧的诞生-1872" class="headerlink" title="二、The Birth of the Tragedy out of the Spirit of Music 悲剧的诞生(1872)"></a>二、The Birth of the Tragedy out of the Spirit of Music 悲剧的诞生(1872)</h3><p>观点：人类的一切历史都来源于 Dionysian和Apollonian的精神争斗。Dionysian即酒神，象征情绪，直觉、本能操控你的行为。Apollonian即太阳神，象征理性。</p>
<p>尼采的观点与启蒙运动所倡导的理性相悖：启蒙运动即阿波罗精神战胜狄俄尼索斯精神，而尼采对此并不认同（具有后现代倾向之所在）——尼采反对启蒙与都弄及其对理性主义的过分强调。</p>
<h3 id="三-human-all-too-human-人过于成为人了1879"><a href="#三、Human-All-Too-Human-人，过于成为人了-1879" class="headerlink" title="三、Human, All Too Human 人，过于成为人了(1879)"></a>三、Human, All Too Human 人，过于成为人了(1879)</h3><p>摒弃浪漫主义的影响，追随Ree，认为我们所做的是<strong>批判性地审视</strong>基督教中的正邪概念，而不是<strong>接受</strong>所谓善的普遍标准。至此，他开始试着构思《论道德的谱系》</p>
<h3 id="四-thus-spoke-zarathustra-查拉图斯特拉如是说1883-1885"><a href="#四、Thus-Spoke-Zarathustra-查拉图斯特拉如是说-1883-1885" class="headerlink" title="四、Thus Spoke Zarathustra 查拉图斯特拉如是说(1883-1885)"></a>四、Thus Spoke Zarathustra 查拉图斯特拉如是说(1883-1885)</h3><p>集中批判了犹太-基督教(Judeo-Christian)的道德标准，尼采认为这类道德标准是种束缚并且试图抛弃这种束缚。</p>
<p>查拉图斯特拉——“不道德的第一人，人们必须敢于不道德”。</p>
<p>尼采试图在犹太-基督教的道德标准与虚无主义之中找到折中点，而不是否定一切。</p>
<p>这是尼采的超人哲学(Ubermensch)的开端。</p>
<h4 id="ubermensch-超人"><a href="#Ubermensch-超人" class="headerlink" title="Ubermensch 超人"></a>Ubermensch 超人</h4><p>所谓超人，是指<strong>自己掌握自己命运</strong>的人，真实地表达自己而不受文明世界的束缚，自己成为自己的主人，从而逃脱尼采所谓“永恒的轮回”(The eternal return)。超人可以不被那些“物化意识”之类的禁锢所束缚，所有具体化概念都可以被打破，一切规则都不复存在。</p>
<h3 id="五-on-genealogy-of-morality-论道德的谱系1887"><a href="#五、On-Genealogy-of-Morality-论道德的谱系-1887" class="headerlink" title="五、On Genealogy of Morality 论道德的谱系(1887)"></a>五、On Genealogy of Morality 论道德的谱系(1887)</h3><ul>
<li>重建从Ree继承而来的谱系论(Genealogical Method)，并且发现了他所谓的“道德的起源”。所谓谱系论，即把已有的道德标准进行比较，然后通过其中一种视角批判另一种，而不是单纯地站在自己的立场上进行批判和审视。</li>
<li>审视 good/bad good/evil的区别，以及该区别的来源</li>
<li>发展出邪恶(Evil)概念的起源理论，尼采认为这来源于奴隶道德和仇富心理</li>
<li>“金发野兽”(The blond beast)意指思想的起源</li>
<li>超人哲学</li>
<li>惩罚的来源、坏道德</li>
</ul>
<h4 id="重构谱系论"><a href="#重构”谱系论“" class="headerlink" title="重构”谱系论“"></a>重构”谱系论“</h4><blockquote>
<p>We are unknown to ourselves, we knowers, and with good reason. We have never looked at “ourselves”.</p>
<p>我们自己对自己永远是不可知的</p>
</blockquote>
<p>把所有你认为道德的东西进行批判性审视：这些观念从何而来。我们必须要思考好与坏的来源，以及它们是如何被构建的，而不是仅仅考虑哪一种更优。因此，我们所需要的是批判的道德观。所有道德、所有道德观，包括公平公正、人道主义，都是在理想状态下创造出来的。</p>
<blockquote>
<p>The value of these values should be subjected to critical scrutiny itself</p>
<p>这些价值观的价值也应当受到批判式的审视</p>
</blockquote>
<p>尼采认为自己能做的，是提供一种批判式的分析而非说明某种绝对价值。他并不说明什么才是对的，但他<strong>并没有因此成为虚无主义者</strong>，尼采不认为”Anything goes”，相反他认为这世间充满痛苦。</p>
<h4 id="好和坏-善和恶之起源的不同处"><a href="#好和坏、善和恶之起源的不同处" class="headerlink" title="好和坏、善和恶之起源的不同处"></a>好和坏、善和恶之起源的不同处</h4><blockquote>
<p>Well, when we use the word ‘good’, you often see that good has something to do with being not egoistic.</p>
<p>Well, that’s not so. It has nothing to with non-egoistic, in terms of its origin. It was constructed as a non-egoistic later on.</p>
<p>Where does the good coming from? It is coming from a master race; a master race which saw itself as good and defined those who were subjected to its rule, usually dark-skinned, natives, as bad. That is where the notion of good and bad is coming from.</p>
</blockquote>
<h4 id="奴隶的道德"><a href="#奴隶的道德" class="headerlink" title="奴隶的道德"></a>奴隶的道德</h4><p>基督教带来道德的转变</p>
<blockquote>
<p>Only those who suffer are good; only poor, the powerless are good.  The rich and those in power are evil.</p>
</blockquote>
<p>尼采认为，奴隶的道德反抗正是始于犹太人的反抗，这造成了一种悖论——那些没有罪的，背负起人类之罪，正如上帝为了拯救人类，让自己被钉在了十字架上。正是这种仇恨(ressentiment)，开始让人们无法简单判断“敌人就是坏的(bad)”，但由于它是恶的(evil)，它甚至可能打败我，因此无论它bad or not，我一定要击溃它。</p>
<h4 id="the-blond-beast-金发野兽"><a href="#The-blond-beast-金发野兽" class="headerlink" title="The blond beast 金发野兽"></a>The blond beast 金发野兽</h4><blockquote>
<p>所有高贵种族的核心本质，都不外乎是一头猛兽——一头非常漂亮的、伺机追求战利品和胜利的金发猛兽。</p>
<p>许多个世纪以来，欧洲都心怀恐惧，目睹了金发的日耳曼猛兽的震怒……尽管古日耳曼人和我们德意志人之间<strong>几乎不存在概念上的联系</strong>，更不用说血缘上的联系。</p>
<p>如今的欧洲正在成为一块平庸之地。我们无法再看到任何会变得伟大的东西，我们正逐渐消瘦…….我们更聪明、更舒适，也更平庸。</p>
</blockquote>
<p>这并非纳粹思想，而是一种英雄崇拜，一种对在现代世界中无法实现自我的极具煽动性的批判。</p>
<h4 id="作坊理想理想在作坊中被捏造fabricate出来"><a href="#作坊理想——理想在作坊中被捏造-fabricate-出来" class="headerlink" title="作坊理想——理想在作坊中被捏造(fabricate)出来"></a>作坊理想——理想在作坊中被捏造(fabricate)出来</h4><blockquote>
<p>在这些作坊里，谎言把“软弱”称为“成就”，把“懦弱”、有仇不报称为善，尽管是你的无能……屈服于那些你痛恨的人，这就是所谓的顺从。不是因为你承认了他们的优越性，而是因为惧怕。而你自己依此创造出一种“善”的概念。</p>
<p>有人说“爱你的敌人”——尽管说这话时，他们正在辛苦流汗。</p>
<p>作坊理想弥漫着谎言的臭味。</p>
</blockquote>
<h4 id="惩戒的起源-the-origins-of-punishment-the-problem-of-memory"><a href="#惩戒的起源-the-origins-of-punishment-the-problem-of-memory" class="headerlink" title="惩戒的起源 the origins of punishment- the problem of memory"></a>惩戒的起源 the origins of punishment- the problem of memory</h4><blockquote>
<p>Well we have to forget; forget is we have to suppress memories which were bad, and in order to suppress, well there is <strong>mnemo-techniques</strong>. That means that we are actually–pain is the most useful way how we forget what we have to forget–we have to remember.</p>
<p>These Germans, the nation of thinker, made a memory for themselves with dreadful methods, stoning, breaking on wheels, raping apart and trampling to death wild horses.</p>
</blockquote>
<h2 id="sigmund-freud-性行为与文明"><a href="#Sigmund-Freud-性行为与文明" class="headerlink" title="Sigmund Freud: 性行为与文明"></a>Sigmund Freud: 性行为与文明</h2><blockquote>
<p>我们的意识来源于被深埋的压抑面，如果压抑的内在能导致神经官能有所反应，我就能通过这点让你了解，生活中什么压抑着你，从而真正地治疗你。</p>
</blockquote>
<p> 弗洛伊德同尼采一样，揭示了现代文明的压迫性，同时他不想拒绝文明。因此对于如何评价<strong>文明</strong>倍感苦恼。</p>
<h3 id="一-生平"><a href="#一、生平-4" class="headerlink" title="一、生平"></a>一、生平</h3><p>童年，专制的父亲、温和的母亲</p>
<p>1873，维也纳大学，学习法律，之后转为医学</p>
<p>1885，巴黎的短暂研究，对神经学产生浓厚兴趣，即使用催眠法来治疗歇斯底里症，回到维也纳后决定做一名神经病学家</p>
<p>1896，将自己的研究命名为心理分析(Psychoanalysis)</p>
<p>晚年著作颇丰：《梦的解析》、《性学三论》 、超心理学《图腾与禁忌》</p>
<h3 id="二-the-ego-and-id-自我与本我1923"><a href="#二、-The-Ego-and-Id-自我与本我-1923" class="headerlink" title="二、 The Ego and Id 自我与本我(1923)"></a>二、 The Ego and Id 自我与本我(1923)</h3><p>我们的认知系统由三部分组成：自我(ego)、本我(Id)，超我(Superego)</p>
<p>引导人类发展的两个本能阶层</p>
<h2 id="max-weber-新教与资本主义"><a href="#Max-Weber-新教与资本主义" class="headerlink" title="Max Weber: 新教与资本主义"></a>Max Weber: 新教与资本主义</h2><h2 id="emile-durkheim-社会反常理论"><a href="#Emile-Durkheim-社会反常理论" class="headerlink" title="Emile Durkheim: 社会反常理论"></a>Emile Durkheim: 社会反常理论</h2><h2 id="推荐书目"><a href="#推荐书目" class="headerlink" title="推荐书目"></a>推荐书目</h2><p>霍布斯：《利维坦》<br>洛克：《政府论》<br>孟德斯鸠：《论法的精神》<br>卢梭：《爱弥儿》《社会契约论》<br>亚当斯密：《国富论》<br>密尔：《妇女的从属地位》《论自由》《功利主义》<br>马克思：《资本论》<br>尼采：《论道德的谱系》<br>弗洛伊德：《自我与本我》《文明及其不满》<br>韦伯：《经济与社会》《新教伦理李与资本主义精神》<br>埃米尔涂尔干：《社会分工》《社会方法理论》《自杀论》</p>
]]></content>
      <categories>
        <category>社会学</category>
      </categories>
      <tags>
        <tag>sociology</tag>
      </tags>
  </entry>
  <entry>
    <title>竞品分析</title>
    <url>/post/8a63fe9/</url>
    <content><![CDATA[<p>学习内容：<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=1012&amp;sid=20-h5Url-0&amp;lgec_type=website&amp;lgec_sign=86228E00A960E2EB44DCA4027393428B&amp;buyFrom=2&amp;pageId=1pz4#/sale">竞品分析实操手册 (lagou.com)</a></p>
<h1 id="何为竞品分析"><a href="#何为竞品分析" class="headerlink" title="何为竞品分析"></a>何为竞品分析</h1><h2 id="不要漠视对手多抬头看路"><a href="#不要漠视对手，多抬头看路" class="headerlink" title="不要漠视对手，多抬头看路"></a>不要漠视对手，多抬头看路</h2><p>借鉴同行，因为世上本没有路，走的人多了，自然成了一条路。所以在自己的行业，最好的老师就是<strong>竞争对手</strong>，把它找出来，就对手的成功或合格的竞品而言，必然已经踩过许多坑了，那我们就可以看到别人怎么做的，看到别人的数据构建，包括别人是通过什么渠道在操作的，别人通过这些能做起来，通过分析<strong>WHAT HOW WHY</strong>，明确竞品竞店做了哪些我没有做的动作？该从哪些方面去分析我和竞品的差距呢？分析出来原因后，我该做哪些动作呢？</p>
<p>做竞品分析的目的是为了更好地参与市场竞争，为后续更加激烈的竞争做准备工作。</p>
<p>并且不仅在于关注对手动向，更重要的是为自己的判断做一个论证和决策依据，再决定是否朝假设的产品方向发展。</p>
<h2 id="竞品分析的流程"><a href="#竞品分析的流程" class="headerlink" title="竞品分析的流程"></a>竞品分析的流程</h2><p>明确目标（标的）—— 选择竞争对手 —— 确定分析对手的维度 —— 收集整理竞品的信息 —— SWOT分析法</p>
<h2 id="常见痛点"><a href="#常见痛点" class="headerlink" title="常见痛点"></a>常见痛点</h2><ol>
<li><p>如何发现当前场景中真正的需求？</p>
</li>
<li><p>竞品做了哪些我没有做的动作和迭代？</p>
</li>
<li><p>从哪些方面去分析我和竞品的差距呢？</p>
</li>
<li><p>竞品分析之后的落地操作？只是抄吗？</p>
</li>
<li><p>如何定出有竞争力的价格？</p>
</li>
<li><p>现实的竞争环境中竞品思维的运用？</p>
<p>……</p>
</li>
</ol>
<h2 id="课程中出现的分析模型"><a href="#课程中出现的分析模型" class="headerlink" title="课程中出现的分析模型"></a>课程中出现的分析模型</h2><h3 id="1-wwhr模型-whatwhyhowresult"><a href="#1-WWHR模型-What——Why——How——Result" class="headerlink" title="1. WWHR模型 What——Why——How——Result"></a>1. WWHR模型 What——Why——How——Result</h3><p>如果把竞品分析比作买瓜，那流程就是先明确竞品分析的目标（为什么买瓜），选择竞争对手（什么瓜适合），收集竞争对手信息（瓜为什么好），再执行分析手段（怎么选瓜），然后输出报告和结论（麒麟甜还是京欣甜？），最后收集报告的反馈（瓜甜或不甜）</p>
<h3 id="2-mas-模型-meetanalyzesolve"><a href="#2-MAS-模型-meet——analyze——solve" class="headerlink" title="2. MAS 模型 meet——analyze——solve"></a>2. MAS 模型 meet——analyze——solve</h3><p>遇到问题（meet），分解问题（analyze），然后逐一击破分解出来的问题（solve）</p>
<h3 id="3-增长黑客模型"><a href="#3-增长黑客模型" class="headerlink" title="3. 增长黑客模型"></a>3. 增长黑客模型</h3><ul>
<li>how do users find us? 拉客、辨识度</li>
<li>do users have a great first experience? 激活</li>
<li>do users come back? 粘度</li>
<li>how to make money? 变现</li>
<li>do users tell others? 传播</li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image6/M01/4C/0E/Cgp9HWDn1_iAeQ4UAAHhZYR32mM653.png" style="zoom:50%;"></p>
<h3 id="4-stepps-模型"><a href="#4-STEPPS-模型" class="headerlink" title="4. STEPPS 模型"></a>4. STEPPS 模型</h3><p>六个维度分析营销：</p>
<ul>
<li>社交货币</li>
<li>情绪</li>
<li>公共性</li>
<li>诱因</li>
<li>实用价值</li>
<li>故事</li>
</ul>
<ol>
<li>公司提供 <strong>诱因、使用价值、故事</strong></li>
<li>用户感知 <strong>社交货币、情绪、公共性</strong></li>
</ol>
<h3 id="5-福格行为用户决策模型"><a href="#5-福格行为——用户决策模型" class="headerlink" title="5. 福格行为——用户决策模型"></a>5. 福格行为——用户决策模型</h3><p><img src="https://s0.lgstatic.com/i/image6/M00/4F/2F/CioPOWD36UGAJahzAALmmhs4kgE578.png" style="zoom:50%;"></p>
<h3 id="6-漏斗分析法"><a href="#6-漏斗分析法" class="headerlink" title="6. 漏斗分析法"></a>6. 漏斗分析法</h3><p><img src="https://s0.lgstatic.com/i/image6/M00/51/85/CioPOWEHtk6AewPTAAa7hxKLfGk625.png" style="zoom:50%;"></p>
<h1 id="一-竞品分析的目标"><a href="#一、竞品分析的目标" class="headerlink" title="一、竞品分析的目标"></a>一、竞品分析的目标</h1><h2 id="明确定位从哪来"><a href="#明确定位（从哪来）" class="headerlink" title="明确定位（从哪来）"></a>明确定位（从哪来）</h2><p>包括个人定位、业务定位、项目定位、产品定位等等。</p>
<p>以商店为例，定位自身的情况</p>
<ul>
<li>本店最大的核心竞争力是什么？</li>
<li>我为什么要做这项业务？</li>
<li>我看好业务的哪些方面？</li>
<li>有多少人是潜在对手？</li>
</ul>
<p>以公司业务为例，明确业务情况，建立基本出发点</p>
<ul>
<li>从下看（业务本身和团队的情况）：业务是刚刚开始还是进入成熟稳定期？没有收入还是有稳定的现金流？团队成员整体的能力和水平如何？对市场中竞品的动作能快速反应还是坐以待毙？</li>
<li>从上看（上级对你的预期和资源情况）：你的老板，合伙人、股东对你的预期 KPI/OKR 是如何的？给你提供了什么样的资源，你需要怎么配合？你的业务最需要什么（资金、人才、市场）？</li>
</ul>
<h2 id="明确目标到哪去"><a href="#明确目标（到哪去）" class="headerlink" title="明确目标（到哪去）"></a>明确目标（到哪去）</h2><h3 id="目标1明确差距制定相应策略"><a href="#目标1：明确差距，制定相应策略" class="headerlink" title="目标1：明确差距，制定相应策略"></a>目标1：明确差距，制定相应策略</h3><p>差异包括：对手不如我们；对手做得比我们好；对手和我们做得差不多。</p>
<p>针对不同情况，运用WWHR模型分析，以 对手 &gt; 我们 为例：</p>
<ul>
<li>What：到底是什么功能对手有你没有？</li>
<li>Why：为什么对手会有你没有？</li>
<li>How：对手是怎么样有的？</li>
<li>Result：该功能的收益如何？用户使用频率如何？使用结果满意度是如何的？</li>
</ul>
<h3 id="目标2分析风险坚定发展方向"><a href="#目标2：分析风险，坚定发展方向" class="headerlink" title="目标2：分析风险，坚定发展方向"></a>目标2：分析风险，坚定发展方向</h3><p>通过分析竞争对手，快速得出目前市场竞争情况，提示自身业务所处在的竞争环境，对现有业务进行风险告警。<strong>当对手有了新动作，你要及时知晓，结合自身的情况判断是否存在威胁和风险，坚定发展方向。</strong></p>
<p>例如：</p>
<ul>
<li>了解行业动态、竞争格局。对手在一场发布会宣布了接下来的业务方向，重大组织调整等，这些动作对公司业务来说就具有一定的风险，只是风险存在高低划分而已，如果你第一时间知晓，并根据发布会情况提前规划了应对策略，等风险发生，比如对手顺势推出了新业务时，就能够很好地应对。</li>
<li>是不是对手每一个版本，你都要跟进呢？并不是，你要<strong>明确自己业务的发展方向和公司战略意图</strong>，这样才能在参与竞争时有选择地应对，而不是对手做了什么动作，不知道怎么跟进，或者应激式地反应，而这要求你随时保持警觉。</li>
</ul>
<h1 id="二-如何选择竞争对手"><a href="#二、如何选择竞争对手" class="headerlink" title="二、如何选择竞争对手"></a>二、如何选择竞争对手</h1><p>选择竞争对手本质是在选择业务场景、目标用户群体、产品形式等。</p>
<h2 id="竞争对手分类"><a href="#竞争对手分类" class="headerlink" title="竞争对手分类"></a>竞争对手分类</h2><ul>
<li>直接性竞品</li>
<li>潜在性竞品</li>
<li>替代性竞品</li>
</ul>
<p>这三个维度与你的产品越接近，威胁程度也就越高，所以你尤其要关注直接性竞品</p>
<h3 id="直接性竞品"><a href="#直接性竞品" class="headerlink" title="直接性竞品"></a>直接性竞品</h3><p><strong>满足的用户需求相同、目标用户群相同、产品形式接近的产品</strong>就是你的直接竞品。</p>
<p>在做竞争对手分类时，必须考虑一个极其重要的元素，该<strong>元素决定了竞争对手是否够格来参与直接竞争</strong>（比如腾讯 VS 阿里，体量接近），这个元素就是<strong>体量 / 实力</strong>。</p>
<p>初创公司——关注类似业务的初创公司</p>
<p>行业 Top 级别——就应该更多关注第二、第三，通过跟踪它们的动作，给自己一个及时预警的冗余空间（特别是第二和第三合并这类的大动作，作为行业第一要马上做出反应）。</p>
<p>行业中游水平，如第十——关注第二十一或者第十九，而不是行业一百以外，或者行业第一，因为太后面或者太前面的对手从规模上彼此都够不着，多关注自己身边的对手对于制定竞争策略更加实际。</p>
<h3 id="潜在性竞品"><a href="#潜在性竞品" class="headerlink" title="潜在性竞品"></a>潜在性竞品</h3><p><strong>产品满足用户的需求不同，产品形式不同，但目标用户特性类似。</strong></p>
<p>比如格力空调和小米电饭煲，一个是制冷的，一个是做饭，但同样面向家庭用户，而且二者都具有制作对手品类家电的实力</p>
<h3 id="替代性竞品"><a href="#替代性竞品" class="headerlink" title="替代性竞品"></a>替代性竞品</h3><p><strong>满足用户的相同需求、目标用户特性类似、产品形式上差异极大</strong>。甚至在参与竞争的过程中，你并不会太直接地感知到自己的市场份额被吞噬，竞争对手往往利用<strong>科技元素</strong>通过产品形式或者<strong>商业模式的创新</strong>，充分占领用户的时间和极大提高需求满足的效率，采取降维打击。</p>
<p>比如共享单车 和 出租车。又比如抖音和王者荣耀，两个同时满足了年轻用户的<strong>娱乐需求</strong>，但对于一刷抖音就停不下来的用户，玩王者荣耀的时间就少了，反之亦然，所以二者体现的是在用户的使用时间上的相互替代和竞争。</p>
<h2 id="竞争对手排序"><a href="#竞争对手排序" class="headerlink" title="竞争对手排序"></a>竞争对手排序</h2><p>本质是<strong>明确竞争格局</strong>，同时进行<strong>产品优劣分析，细化场景</strong>，多维度进行产品排序。如行业影响力、公司市值、用户规模、综合成绩等。</p>
<h1 id="三-产品视角的分析维度"><a href="#三、产品视角的分析维度" class="headerlink" title="三、产品视角的分析维度"></a>三、产品视角的分析维度</h1><p>产品七要素：功能/需求（Feature）、用户体验（UE/UI）、团队（Team）、技术（Technology）、营销（Marketing）、用户（User）、盈利模式（Profit）</p>
<h2 id="功能功能模块细化功能点流程分析"><a href="#功能：功能模块细化-功能点流程分析" class="headerlink" title="功能：功能模块细化+功能点流程分析"></a>功能：功能模块细化+功能点流程分析</h2><p>充分且深入地体验、分析竞品功能，做出功能对比表格</p>
<ul>
<li>横向是根据 02 讲确定的各个竞品的名称；</li>
<li>纵向是竞品各个功能模块的拆解，有哪个功能就在哪儿打勾，这里我要提醒你，功能分解的颗粒度根据需要，一般分解到 3~4 级的菜单，这样才足够细致。</li>
</ul>
<p>以美团优选、橙心优选和多多买菜为例，社区团购的 App：</p>
<ol>
<li>一级功能侧重展现整体业务模式以及核心功能，比如首页、分类、购物车；</li>
<li>二级功能侧重展现运营更深一级的内容，比如热卖、新人专享等；</li>
<li>三级功能侧重具体的操作落地，比如加入购物车（当然，不同产品都有自己的侧重点，功能分布也会不同，你要灵活运用）。</li>
</ol>
<p>做竞品分析时，你必然要把自己变成用户来使用竞品，区别于打开一个产品直接体验功能，你还可以作为用户，拆解用户使用产品的流程中所对应的功能点，然后再对比涉及的功能点。</p>
<h2 id="用户体验主观体验爽不爽调研打分"><a href="#用户体验：主观体验（爽-不爽），调研打分" class="headerlink" title="用户体验：主观体验（爽/不爽），调研打分"></a>用户体验：主观体验（爽/不爽），调研打分</h2><p>UE/ UI 好坏判断很难量化，因为主观性较强，比如有人讨厌黑色，可能有很多人喜欢，而针对这种主观性较强的事情，最好引入<strong>打分制</strong>。同时打分制要做一定的用户调研，样本一般在 10 个以上就行</p>
<p>此处可以引入更专业的调研打分方式。</p>
<h2 id="团队最能反映对手的战略意图"><a href="#团队：最能反映对手的战略意图" class="headerlink" title="团队：最能反映对手的战略意图"></a>团队：最能反映对手的战略意图</h2><p>团队简单讲是看组织架构、组织架构对应的人员组成，而从竞争层面上看，能看出<strong>竞争对手的战略意图、业务效率、资源分配情况</strong>。</p>
<p>同时分析竞品团队的 <strong>团队的资金/资源优势、投融资的情况、股东信息、技术背景</strong>，看看他们的<strong>专利</strong>等（从企某查、天某查等地方都可以看到这些信息）：</p>
<ul>
<li>通过看人员构成，搜查关键人物的信息，你可以对团队的调性有一个大概的判断，比如对方是个海归带队，可能会有一个了解国内市场的过程，那一直在国内的你可能就有一个时间差的优势。</li>
<li>看对方的股东变更情况，看得出哪些股东加入，哪些股东退出，加入退出的条件是什么，比如是投融资等，而通过投融资就能看出对方的资金实力了。</li>
</ul>
<h2 id="技术采用成熟技术持续观察对手的技术"><a href="#技术：采用成熟技术持续观察对手的技术" class="headerlink" title="技术：采用成熟技术持续观察对手的技术"></a>技术：采用成熟技术持续观察对手的技术</h2><p><strong>创业过程中，只用最成熟的技术</strong>。这也说明，技术对于一个团队业务的影响是根本性的，你有可能遇到技术难题，你的竞品也是有可能遇到的。</p>
<h2 id="营销运营产品全周期管理"><a href="#营销-运营：产品全周期管理" class="headerlink" title="营销/运营：产品全周期管理"></a>营销/运营：产品全周期管理</h2><ol>
<li>市场分析（Market）：关注潜在销量和竞争对手的营销活动信息；</li>
<li>消费者分析（Customer）：关注自己平台上或其他潜在消费者（用户）喜好和购买原由；</li>
<li>产品分析（Product）：关注自己产品的优势和竞品的劣势；</li>
<li>促销方式制定（Promotion）：关注合适的促销手段和渠道。</li>
</ol>
<h2 id="用户用户画像-用户数据-用户看法经验推算"><a href="#用户：用户画像、用户数据、用户看法；经验推算" class="headerlink" title="用户：用户画像、用户数据、用户看法；经验推算"></a>用户：用户画像、用户数据、用户看法；经验推算</h2><ul>
<li><p>用户画像/标签包括：正常的标签（真实手机号，男女，年龄）、地域标签（注册地址，常登录地址-背后是各种 ip 地址的识别）、兴趣标签（动作行为，游戏行为等）、安全标签（虚拟手机号，僵尸号等）</p>
</li>
<li><p>用户数据包含注册数、DAU、AURP 值、留存（次日，3 日，七日）等。</p>
<p>通过行业系新闻网站、路演等获取，并结合自己的数据情况，一般都会有水分，我的经验是打个对折，对手说有 1000 万用户，预计真实情况，可能 500 万不到。</p>
</li>
<li><p>用户看法：偏向主观，引入打分机制、问卷调查方式</p>
</li>
</ul>
<h2 id="盈利模式如何实现变现还能更赚钱吗"><a href="#盈利模式：如何实现变现？还能更赚钱吗？" class="headerlink" title="盈利模式：如何实现变现？还能更赚钱吗？"></a>盈利模式：如何实现变现？还能更赚钱吗？</h2><p>产品的盈利模式决定了产品能够走多远，你要根据产品特性选择盈利模式，</p>
<ul>
<li>例如：互联网行业的盈利模式无非是：广告、增值服务、付费下载、电商、提成佣金。</li>
<li>例如：主件便宜，而附件需要用户定期更换购买，通过附件赚取利润。电动牙刷等。</li>
</ul>
<p>差异化竞争：在具体操作盈利模式时区分应用场景，调整策略（变现选择广告、低成本资源、剪刀差等多种路径）</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><div class="table-container">
<table>
<thead>
<tr>
<th>问题</th>
<th>回答</th>
</tr>
</thead>
<tbody>
<tr>
<td>我是谁？</td>
<td>什么团队、用什么技术</td>
</tr>
<tr>
<td>我是做什么的？</td>
<td>实现何种功能？解决何种需求？用户体验如何（如何快捷解决）？用户数据（我面对的用户是什么样的）？</td>
</tr>
<tr>
<td>我怎么赚钱的？</td>
<td>营销（如何拉客）？盈利模式（如何变现）？如增长黑客模型</td>
</tr>
</tbody>
</table>
</div>
<h1 id="四-用户决策五要素"><a href="#四、用户决策五要素" class="headerlink" title="四、用户决策五要素"></a>四、用户决策五要素</h1><p>好处 benefit、品牌 brand、成本 cost、便捷性 usability、渠道 tunnel</p>
<h2 id="好处用户选择产品能获得什么"><a href="#好处：用户选择产品能获得什么？" class="headerlink" title="好处：用户选择产品能获得什么？"></a>好处：用户选择产品能获得什么？</h2><p>在评价竞品和自己的产品时，要看<strong>产品是否能够给用户带来直接的好处，也就是是否满足了用户的需求，以及是否比竞品有更多的好处/需求</strong>。以社区团购为例，用户最直接的好处是买到东西，这也是平台能够最直接满足的需求，但如果你的价格比竞品便宜，你的种类比竞品多，那你就能给用户更多的好处。</p>
<p>这种需求包括<strong>更低的经济成本、更好的服务体验、更便捷的操作</strong>，也包括<strong>情绪价值、社交价值</strong>等。</p>
<h2 id="品牌抓住用户心智"><a href="#品牌：抓住用户心智" class="headerlink" title="品牌：抓住用户心智"></a>品牌：抓住用户心智</h2><p>天下武功唯快不破，你跟竞品谁会先人一步，将品牌占领用户的心智，谁就能获得市场的先发优势。</p>
<h2 id="成本成本中的经济学"><a href="#成本：成本中的经济学" class="headerlink" title="成本：成本中的经济学"></a>成本：成本中的经济学</h2><p>成本包括直接成本、间接成本</p>
<ul>
<li>直接成本：预算的钱和消耗的实践等</li>
<li>间接成本：蹲点抢购，搜索信息分析手机性能、价格</li>
</ul>
<p>在直接成本上的控制效果会直接影响“购买决策者”的选择，而在间接成本上的控制效果会影响其“军师”的决策效率。如果你在二者上控制得好，会与竞品形成一定的竞争优势。</p>
<h2 id="便捷魔鬼藏在细节中"><a href="#便捷：魔鬼藏在细节中" class="headerlink" title="便捷：魔鬼藏在细节中"></a>便捷：魔鬼藏在细节中</h2><p>用户用你的产品希望<strong>易上手、好操作、超便捷</strong>，而这更能区分你与竞品之间的差距，其中涉及到<strong>人机交互的设计合理性</strong>问题。</p>
<p>比如产品提供符合用户直觉习惯的交互方式（如点击返回就是返回上一页、点击取消就会马上停止当前的动作）；也提供软件速度、耗电量、内存容量等性能指标，这会让用户在使用产品的过程中感受到高度的便捷性。</p>
<p>便捷性<strong>直接关系到用户在使用我们产品时的效率</strong>，也直接关系产品对用户需求的响应速度，你能比竞品快几百毫秒也会在竞争当中取得优势</p>
<h2 id="渠道产品到达用户的最后一环"><a href="#渠道：产品到达用户的最后一环" class="headerlink" title="渠道：产品到达用户的最后一环"></a>渠道：产品到达用户的最后一环</h2><p>渠道选择要根据你的资金和用户群来确定。尽量能以较低的价格抓取到目标用户是做好渠道的原则。</p>
<p>总的来说，竞争的源头还是<strong>自身产品的品质和人的实力竞争</strong>，而终端比拼的是通过渠道触达用户的能力，所以竞争是全链路的事情。</p>
<h1 id="五-产品视角-or-用户视角"><a href="#五、产品视角-or-用户视角" class="headerlink" title="五、产品视角 or 用户视角"></a>五、产品视角 or 用户视角</h1><p>竞品分析不必要面面俱到，也并非只能选择产品视角或者用户视角，而是要根据决定要素灵活运用，这样才能达到你竞品分析的目的。</p>
<h1 id="六-信息收集"><a href="#六、信息收集" class="headerlink" title="六、信息收集"></a>六、信息收集</h1><h2 id="信息收集的问题点"><a href="#信息收集的问题点" class="headerlink" title="信息收集的问题点"></a>信息收集的问题点</h2><ul>
<li>心理素质不过硬：没有主动打电话，把信息收集的主动权掌握在自己手里。</li>
<li>信息多且杂，认为信息多即是好：应该做好信息收集的表格，将问题统一化，然后根据表格中的问题，整理得到的信息。</li>
<li>罗列信息，没有结论：应当尝试作出结论，并提炼出自己的竞争策略。</li>
<li>信息来源的渠道单一：信息来源于客服，较为单一，而我希望看到更全面的信息。</li>
</ul>
<p>因此需要解决的问题在于</p>
<ol>
<li><p>明白并不是想收集什么信息就能收集到什么信息</p>
</li>
<li><p>如何主动打听信息，因为有些信息你能收集得多全，得看你付出多大的努力</p>
</li>
<li><p>如何在信息“不充分”的条件下做竞品分析。尝试用费米问题的逻辑方式进行推演</p>
<blockquote>
<p>这类问题通常涉及对于只给定有限的已知信息，而似乎是算不出来的量，作出合理的猜测。</p>
<p>费米估算将大问题化整为零，分解成若干个相关的次一级、小而易解的问题，再逐个估算，得出近似值。能结合<a href="https://zh.wikipedia.org/w/index.php?title=事前驗屍法&amp;action=edit&amp;redlink=1">事前验尸法</a>，分析假设相反情况的几率，并应用<a href="https://zh.wikipedia.org/wiki/貝氏推論">贝氏推论</a>调整估算值。</p>
</blockquote>
</li>
</ol>
<h2 id="信息收集的原则-可用于反竞品分析"><a href="#信息收集的原则-可用于反竞品分析" class="headerlink" title="信息收集的原则 可用于反竞品分析"></a>信息收集的原则 可用于反竞品分析</h2><h3 id="1-确定目标-竞品和分析维度"><a href="#1-确定目标、竞品和分析维度" class="headerlink" title="1. 确定目标、竞品和分析维度"></a>1. 确定目标、竞品和分析维度</h3><p>另：先把已经确定的“竞品目标、竞品类型、分析维度”以邮件等可以留存的形式发送给你的汇报对象确认，否则你用一个星期做出来的竞品分析报告，可能会因为这三个环节中某一个环节不符合汇报对象的预期，导致返工甚至重做，浪费时间不说，还会给人留下不专业的印象。</p>
<h3 id="2-追本溯源"><a href="#2-追本溯源" class="headerlink" title="2. 追本溯源"></a>2. 追本溯源</h3><p>像遇到同一条信息有不同出处，或者类似“援引自哪里”的情况，我会去寻找出处或援引的地方是否为正规渠道……尽管这么做会耗费一些时间，但可以确定信息的真实性。</p>
<h3 id="3-取其精华"><a href="#3-取其精华" class="headerlink" title="3. 取其精华"></a>3. 取其精华</h3><p>如果说“追本溯源”是从众多重复的信息里，找到最真实的信息，那“取其精华”就是<strong>从一条信息中，找到最有价值一段（也就是跟竞品分析的目标、分析维度最接近的信息）</strong>。</p>
<p>营销合作流程举例：</p>
<blockquote>
<ol>
<li><p>确定合作对象；</p>
<ol>
<li>1 确定的合作对象可以是外部或内部（外部的也许是甲方，也许是乙方，内部的也许是运营部门或者市场部门）；</li>
</ol>
</li>
<li><p>分解合作对象需求；</p>
</li>
<li><p>分析确定合作对象的需求；</p>
</li>
<li><p>确定与合作对象的共赢点；</p>
</li>
<li><p>开始策划/研发营销活动；</p>
<p>5.1 涉及研发或者落地执行，所以一定要尽快提出并明确需求</p>
</li>
<li><p>完善和丰富营销细节；</p>
<p>6.1 细节可以让营销活动出彩，一定要引起重视</p>
</li>
<li><p>选择时机推出。</p>
<p>7.1 合适的营销时机是成功的一半，我们要实时跟进营销效果和数据情况（特别是服务器压力，执行现场的控制等）。</p>
</li>
</ol>
<ul>
<li>危机公关<ul>
<li>确定事实、表明态度、做出措施 </li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4-统揽全局"><a href="#4-统揽全局" class="headerlink" title="4. 统揽全局"></a>4. 统揽全局</h3><p>从宏观的角度看到全局和行业共性</p>
<p>宏观：政策因子、行业预期产值、行业天花板和底线</p>
<h2 id="如何收集信息重视渠道"><a href="#如何收集信息：重视渠道" class="headerlink" title="如何收集信息：重视渠道"></a>如何收集信息：重视渠道</h2><div class="table-container">
<table>
<thead>
<tr>
<th>渠道</th>
<th>包括</th>
</tr>
</thead>
<tbody>
<tr>
<td>官方渠道</td>
<td>官网、微博、公众号；媒体报道，访谈，高管微博；产品wiki、财报、广告、发布会；招聘信息，内部出版物。</td>
</tr>
<tr>
<td>第三方渠道</td>
<td>行业媒体、协会、线下峰会、第三方评测机构、竞品的合作伙伴、供应商、专利机构、搜索引擎。</td>
</tr>
<tr>
<td>自己收集</td>
<td>亲自体验、实地考察、用户访谈、问卷调查、反编译。</td>
</tr>
</tbody>
</table>
</div>
<p>特别注意<strong>招聘信息</strong>：从招聘信息中其实可以看出来<strong>竞争对手的布局和潜在计划</strong>，比如美团的招聘信息中有“熟悉智慧建筑、智能家居、安防监控”，以此，可以初步得出美团可能会进入相关领域的猜想。当然你后续要搜集更多的信息来佐证这个假设</p>
<p><img src="https://s0.lgstatic.com/i/image6/M00/50/CA/Cgp9HWECOfmADxakAAwOo6QxNzI173.png" alt></p>
<p>善用非官方渠道：比如高管的朋友圈、群里打听、饭局上或者打对方客服电话套话、假装合作、挖人……也可用于反竞品分析</p>
<h2 id="如何整理信息汇总-分类-评选"><a href="#如何整理信息：汇总-分类-评选" class="headerlink" title="如何整理信息：汇总-分类-评选"></a>如何整理信息：汇总-分类-评选</h2><h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据来源渠道、竞品名称对信息进行分类，从汇总的信息仓库里把信息粘贴到相应的分类下面，同时做好排重工作，将重复的删除，也要做好校正，针对不同渠道来的信息做一个比对，一定程度上也能验证真实性</p>
<h3 id="评选"><a href="#评选" class="headerlink" title="评选"></a>评选</h3><p>进一步细化处理信息，可以按照与竞品分析目的的接近程度、可靠程度进行</p>
<p>信息的可靠性一般通过：</p>
<ol>
<li>官方渠道优于第三方渠道；</li>
<li>有比精确好，例如数据上有一个量级即可，不需要完全精确；</li>
<li>注明信息来源，一个是可以甩锅，更重要的是可以追溯。</li>
</ol>
]]></content>
      <categories>
        <category>商业</category>
      </categories>
      <tags>
        <tag>business</tag>
      </tags>
  </entry>
  <entry>
    <title>索引优化作业</title>
    <url>/post/f3c7f886/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>辣鸡的我写索引优化作业遇到一个很奇怪的问题。</p>
<p>大概就是，在500w行数据的order表中，找出年龄小于20order列表，看能否使用索引进行查询优化。</p>
<p>创建索引、查询时间、查询计划一套做下来，发现优化器没有用创建的索引。于是开始寻找问题。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>首先很自然地用下面的语句进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from orders where age &lt; 20; </span><br></pre></td></tr></table></figure>
<p>发现在没加索引的时候，查询时间，explain计划如下</p>
<p>加了个单列普通索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table orders add index ageindex(age);</span><br></pre></td></tr></table></figure>
<p>再执行语句发现，查询时间和explain计划没变，说明<strong>优化器没有使用新建的索引</strong>。</p>
<p>强制使用索引，加上<code>force index(ageindex)</code>，获得查询时间和explain结果如下</p>
<p>图中可见，索引确实让过滤数值和row值都优化了，但是时间却大大增加了，而传输时间更是多了太多。</p>
<p>接着做第二题，查找姓王的人，类似的题目。但是不管用普通索引还是全文索引，优化器都不用索引。</p>
<p>后来改换思路，把要查询语句改成只返回主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id from orders where age &lt; 20;</span><br></pre></td></tr></table></figure>
<p>突然峰回路转，索引被使用，查询时间立刻降低</p>
<p>原来<code>select *</code>才是罪魁祸首</p>
<h1 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h1><p><a href="https://www.zhihu.com/topic/19617529">SQL语句为什么使用select * 会降低查询速度?</a></p>
<p>大佬说了，select* 杜绝了覆盖索引的可能性。虽然上面的索引在查询计划里看起来过滤了大量数据，但</p>
<blockquote>
<p>首先通过辅助索引过滤数据，然后通过聚集索引获取所有的列，这就多了一次b+树查询，速度必然会慢很多。首先通过辅助索引过滤数据，然后通过聚集索引获取所有的列，这就多了一次b+树查询，速度必然会慢很多。</p>
</blockquote>
<p>磁盘io导致查询开销陡增，反倒不如全表顺序查询时间少。当索引节约的成本能以抵消、甚至远远低于磁盘io要付出的代价时，优化器自然选择放弃索引。</p>
<p>所以假如要求是select *，在不考虑维护的情况下，不如建立包含全列的多列索引。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>索引是个很重要的优化方法，经过这么多年的发展，网上已经有很多各种经验之谈，不过了解原理还是很重要啊。</p>
<p>《高性能mysql》得好好看一看才行。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title>索引优化注意点——为什么我的索引没有用</title>
    <url>/post/5f43b32a/</url>
    <content><![CDATA[<p>一些网上找到的经验之谈。</p>
<h1 id="建立索引的几大原则"><a href="#建立索引的几大原则" class="headerlink" title="建立索引的几大原则"></a>建立索引的几大原则</h1><h2 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h2><p>最重要的大原则</p>
<p>具体可见<a href="https://www.kancloud.cn/kancloud/theory-of-mysql-index/41857">mysql索引使用策略和优化</a></p>
<p>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul>
<li>尽量选择区分度高的列作为索引，区分度的公式是<strong>count(distinct col)/count(*)</strong>，表示字段不重复的比例，比例越大我们扫描的记录数越少</li>
<li>索引列不能参与计算，<strong>保持列“干净</strong>”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引</li>
<li>尽量的<strong>扩展索引</strong>，不要新建索引。</li>
<li>对于定义为<strong>text</strong>、<strong>image</strong>和<strong>bit</strong>的数据类型的列不要建立索引。</li>
<li>对于经常存取的列避免建立索引</li>
</ul>
<h1 id="索引使用的注意点为什么我的索引没有使用"><a href="#索引使用的注意点——为什么我的索引没有使用" class="headerlink" title="索引使用的注意点——为什么我的索引没有使用"></a>索引使用的注意点——为什么我的索引没有使用</h1><ul>
<li><p>一般说来，索引应建立在那些将用于<strong>JOIN</strong>,<strong>WHERE</strong>判断和<strong>ORDER BY</strong>排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引，例如对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况。</p>
</li>
<li><p>应尽量避免<strong>在 where 子句中对字段进行 null 值判断</strong>，否则将导致引擎放弃使用索引而进行全表扫描；最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.</p>
</li>
<li><p>应尽量避免<strong>在 where 子句中使用 != 或 &lt;&gt; 操作符</strong>，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免<strong>在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引</strong>，将导致引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p><strong>in 和 not in 也要慎用</strong>，否则会导致全表扫描。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id from t where num in(1,2,3)</span><br></pre></td></tr></table></figure>
<p>对于连续的数值，能用 <strong>between</strong> 就不要用 in 了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id from t where num between 1 and 3</span><br></pre></td></tr></table></figure>
<p>很多时候<strong>用 exists 代替 in</strong> 是一个好的选择，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select num from a where num in(select num from b)</span><br></pre></td></tr></table></figure>
<p>可以用下面的语句替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select num from a where exists(select 1 from b where num=a.num) </span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的模糊查询也将导致全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%abc%&#x27;</span></span><br></pre></td></tr></table></figure>
<p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引。</p>
<p>若要提高效率，可以考虑<strong>全文检索</strong>。</p>
<p>既然谈到模糊查询下使用索引，我们就顺便详细地讲讲吧。</p>
<ol>
<li><p><code>like %keyword</code>    <strong>索引失效</strong>，使用全表扫描。但可以通过翻转函数+like前模糊查询+建立翻转函数索引=走翻转函数索引，不走全表扫描。<a href="https://link.jianshu.com?t=http://www.educity.cn/wenda/389292.html">例子</a></p>
</li>
<li><p><code>like keyword%</code>    <strong>索引有效</strong>。</p>
</li>
<li><p><code>like %keyword%</code> <strong>索引失效</strong>，也无法使用反向索引。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//可以拿我给出的数据库试一下嘛。然后用explain测试，就能测出有没有走索引了</span><br><span class="line">select * from table where code like &#x27;王%&#x27;  </span><br><span class="line">select * from table where code like &#x27;%王%&#x27;  </span><br><span class="line">select * from table where code like &#x27;%王&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<strong>在 where 子句中使用参数</strong>，也会导致全表扫描。 </p>
</li>
<li><p>应尽量避免<strong>在where子句中对字段进行函数操作</strong>，这将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>不要<strong>在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算</strong>，否则系统将可能无法正确使用索引。</p>
</li>
<li><p>一个表的索引数最好<strong>不要超过6个</strong>，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
</li>
<li><p>应尽可能的<strong>避免更新 clustered 索引数据列</strong>，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源</p>
</li>
<li><p>MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么<strong>order by中的列是不会使用索引的</strong>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title>索引各类型创建</title>
    <url>/post/95bb5ff7/</url>
    <content><![CDATA[<h1 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1. 普通索引"></a>1. 普通索引</h1><p>基本索引</p>
<p>创建方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#标准语句： </span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list) </span><br><span class="line"></span><br><span class="line">CREATE INDEX index_name ON table_name (column_list); </span><br><span class="line"></span><br><span class="line">#还有建表的时候创建亦</span><br><span class="line">CREATE TABLE table_name ( ID INT NOT NULL, column_listVARCHAR(16) NOT NULL, </span><br><span class="line">                         INDEX [index_name](column_list(length)) );</span><br></pre></td></tr></table></figure>
<ul>
<li>length 表示 length=10，索引字段记录前10个字符</li>
<li>BLOB和text类型，length不能短于实际长度。CHAR和VARCHAR可以</li>
</ul>
<h1 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2. 唯一索引"></a>2. 唯一索引</h1><p>彼此各不相同的值，<strong>必须唯一，可以空值</strong>，关键字<code>UNIQUE</code></p>
<p>保证数据记录的唯一性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD UNIQUE (column_list) </span><br><span class="line">CREATE UNIQUE INDEX index_name ON table_name (column_list) </span><br><span class="line">#还有建表时创建 </span><br><span class="line">CREATE TABLE table_name ( ID INT NOT NULL, column_list VARCHAR(16) NOT NULL, UNIQUE [index_name ] (column_list(length)) );</span><br></pre></td></tr></table></figure>
<h1 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3. 主键索引"></a>3. 主键索引</h1><p>特殊的唯一索引，<strong>不能有空值</strong>，常见于id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name ( </span><br><span class="line">ID INT NOT NULL,</span><br><span class="line"> [column] VARCHAR(16) NOT NULL,</span><br><span class="line"> PRIMARY KEY(ID)  </span><br><span class="line"> );  </span><br></pre></td></tr></table></figure>
<h1 id="4-全文索引"><a href="#4-全文索引" class="headerlink" title="4. 全文索引"></a>4. 全文索引</h1><p><strong>建立索引</strong>，<strong>在索引中搜索定位</strong></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。</p>
<p>不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。插入修改删除表的同时也要针对索引做一系列的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` ( </span><br><span class="line">    `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL , </span><br><span class="line">    `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL , PRIMARY KEY (`id`), </span><br><span class="line">    FULLTEXT (content) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>my5.7有了针对中文的全文索引插件</p>
<h1 id="5聚集索引和非聚集索引"><a href="#5-聚集索引和非聚集索引" class="headerlink" title="5.聚集索引和非聚集索引"></a>5.聚集索引和非聚集索引</h1><p><a href="https://jingyan.baidu.com/article/e73e26c0f1e82d24acb6a75d.html">百度经验给的例子</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create CLUSTERED INDEX 索引名称 ON 表名(字段名) #创建聚集索引</span><br><span class="line">create NONCLUSTERED INDEX 索引名称 ON 表名(字段名) #创建非聚集索引</span><br></pre></td></tr></table></figure>
<h1 id="6单列索引和多列索引"><a href="#6-单列索引和多列索引" class="headerlink" title="6.单列索引和多列索引"></a>6.单列索引和多列索引</h1><p><strong>最左匹配原则</strong>，</p>
<p> <strong>适用场景</strong>：</p>
<ol>
<li>全字段匹配</li>
<li>匹配部分最左前缀</li>
<li>匹配第一列</li>
<li>匹配第一列范围查询(可用用like a%,但不能使用like %b)</li>
<li>精确匹配某一列和和范围匹配另外一列 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#假设只使用单列索引名字 </span><br><span class="line">ALTER TABLE people ADD INDEX name (name); </span><br><span class="line">#使用多列索引： </span><br><span class="line">#相当于创建了(height)单列索引，(height,name)组合索引以及height,name,age)组合索引 </span><br><span class="line">ALTER TABLE people ADD INDEX height_name_age (height,name,age);</span><br><span class="line">#注意： 注：在mysql中执行查询时，只能使用一个索引，如果我们在name,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title>美国现代主义文学</title>
    <url>/post/24c055c0/</url>
    <content><![CDATA[<p>讨论三个作家：<strong>海明威</strong>、<strong>福克纳</strong>、<strong>菲茨杰拉德</strong></p>
<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><h3 id="三个层次的讲解"><a href="#三个层次的讲解" class="headerlink" title="三个层次的讲解"></a>三个层次的讲解</h3><ol>
<li>社会历史批评</li>
<li>文本批评——叙事技巧分析</li>
<li>文本批评——感官描写分析</li>
</ol>
<p>The Great Gatsby 了不起的盖茨比    </p>
<p>To Have and Have Not    </p>
<p>To Whom the Bell Rolls    </p>
<p>The Men and The Sea</p>
<p>A  Farewell to Arms</p>
<p>The Sound and the Fury</p>
<p>narrative experiment 叙事手法上的创新</p>
<p>联想链接叙事</p>
<p>通感</p>
<p>一战、海明威、反讽 irony 的语气在表现战争中很重要——使用不带感情色彩的词语：时间、地点、场景、地理信息</p>
<p>海明威与菲茨杰拉德不谋而合，似乎只要提到战争就感觉在侮辱自己的语言和经历</p>
<p>只有没参加过一战的人，才能用乌托邦式的笔法描写战争</p>
<p>福克纳：内战却在一定程度上促进民族融合，社会内的一种私人的情感连接-》这样过于理想化（注意美式观念）</p>
<p>有些悲剧故事，确有一丝喜剧色彩，其中仍然蕴含这一丝希望；应该要怀抱希望</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>In Our Time</p>
<p>Indian Camp</p>
<p>为什么只有少数人可以冷静对待，而我们大多数人在伤害与暴力面前却显得如此无助</p>
<p>无力面对痛苦——最后一句话“It rained all through the evacuation.”</p>
<p>之前都是人为叙述，而雨是自然的、毫无环境影响，这是趋向一种<strong>人类无力干涉的绝对的自然进程</strong>，people can do nothing with it，只能客观地接受它们的到来。</p>
<p>这句话是文章的<strong>resting point</strong>。同样的，别人的痛苦也是这样一种自然过程，我们只能像接受雨一样客观接受它。这种自然的联想，毫无可以雕琢的痕迹，但是却能暗示读者，并带入这种微妙的氛围。</p>
<p> 这种经历姑且定义为<strong>recipients</strong> 客观接受者——只能站在那里，任由痛苦强加于我们之上。</p>
<p>无论我们多擅长做一件事，人生在世，能做到的限度都是有限的。</p>
<p>The Doctor and the Doctor’s Wife</p>
<p>欧洲移民和美洲原住民的紧张关系。</p>
<p><strong>能避免的冲突</strong></p>
<p>开门、关门——自然暴力的倾向以及维护和平的倾向</p>
<p>正反两面，试验所有有可能性</p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p> Soldier’s Home——the intransitive relation of emotions across time 感情在时间上的不可传递性，强烈的情感在时光中无法长存</p>
<p>Krebs good soldier,but not a very efficient player in civilian life；海伦 basketball play, also a good player in life, is more consequential in life than Krebs ever would be</p>
<p>Krebs, not attended to, not listened to, being completely on the sidelines. 战争中的英勇士兵成为日常的局外人、生命的看客——悲剧色彩</p>
<p>Chapter 9 Mr. and Mrs.Elliot 艾略特夫妇</p>
<p>讨论斗牛场景，典型的海明威风格——悲喜剧结合 19世纪的美国文学，tragedy being energized by comedy and priduce a really interesting kind of experimental genre.</p>
<p>T.S.Eliot 诺贝尔奖获得者 荒原    </p>
<p>海明威代替手法 logic of substitution</p>
<ul>
<li>Gertrude Stein/Alice B. Toklas taking the place of Vivienne and T. S. Eliot</li>
<li>Comedy taking the place of tragedy</li>
<li>Horse taking the place of the picador</li>
<li>Cat taking the place of ? （雨中的猫）</li>
</ul>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title>瑜伽师地论讲义1</title>
    <url>/post/4fba53d6/</url>
    <content><![CDATA[<h2 id="第1~10讲"><a href="#第1-10讲" class="headerlink" title="第1~10讲"></a>第1~10讲</h2><h3 id="第1讲"><a href="#第1讲" class="headerlink" title="第1讲"></a>第1讲</h3><p><strong>《瑜伽师地论》</strong></p>
<p>　　我们从《传记》上看，从玄奘大师的《传记》上看，他到印度去取经，其中主要的就是要请这一部论，要学习这一部论的。</p>
<p>　　到了印度以后，见到戒贤论师的时候，就是在那烂陀寺，曾经说了一个故事。就是戒贤论师他有风病，这个风病一发作了的时候，痛苦的不得了，可能已经很久了，这位大德也就想要自杀，就想要死掉了。动了这样的念头以后，做了一个梦，梦见文殊菩萨、观世音菩萨、弥勒菩萨来了，那么文殊菩萨说：你以前做国王，你虐待老百姓，所以你现在受这种报。你想要死还是不行的，这个罪业没有结束，你死了，你还是要苦的，所以你不能够死。你要发大心弘扬佛法，你的罪渐渐就灭了，这个问题才能解决。现在从支那国（就是我们中国）来一个出家人，你为他讲《瑜伽师地论》，你要等他来，为他讲《瑜伽师地论》。那么这样子这个梦就醒了、醒了。</p>
<p>　　他就问这个玄奘大师：你从你的祖国到这里来，前后多少年了？他说：三年了。（从中国到印度那烂陀寺，走了三年才到那里）。这件事可以看出来，这个玄奘大师到印度去学习《瑜伽师地论》，是有文殊菩萨、观世音菩萨、弥勒菩萨的因缘，请戒贤论师不要自杀，要专为玄奘大师讲《瑜伽师地论》，有这样事情。</p>
<p>　　《瑜伽师地论》可以说是全面的、有次第的介绍佛法。它不是佛法概论，它是一个很详细的、很深刻的开示佛法的。小乘佛法、大乘佛法都在内了。一共是一百卷。一百卷，戒贤论师为玄奘大师一共讲了三遍。玄奘大师跟他学习了三遍，讲了三次。第一次是讲了十五个月，第二次讲了九个月，第三次就没有说时间。</p>
<p>　　（十五个月，假设我们也姑妄言之，用同样的速度来说的话，我们一个学期才有四个月上课，一个学期有四个月的上课，若四个学期就是十六个月；一年有两个学期，那么两年就是四个学期，四四一十六个月。所以我们预计可能要两年才能讲完，要这么长的时间。）</p>
<p>　　若是我们能够认识到《瑜伽师地论》的重要，我们就是用三年的时间也是值得的。三年学习一部《瑜伽师地论》也是值得。因为我们能够对于佛法，尤其是对于修行这件事，能够符合佛的本意，符合佛所说的正知正见，我们能够通达了修行的这条道路，的确不是容易。</p>
<p>　　我们就一般的…我们中国佛教很久以来，大家都是学习这念佛法门。念佛法门也非常殊胜，也的确是很好。能够念阿弥陀佛求生净土，能成功了，也就是全面地成功了，也是好。</p>
<p>　　但是你若想要学习禅，你也许想要学习禅。我们中国有所谓禅宗，你能明白禅怎么样修、怎么样学，还不是容易。如果是用圣教量当一个尺，去量一量禅宗的禅师的语录的话，那还是有点问题的。有些大禅师是可以，有些人说的法语还是有点问题的。</p>
<p>　　而这一部论对于禅是全面的、深入的开示了我们，我们若能认真的学习了，就不会再随着别人的舌头转了，你自己就会有主张，「喔！是应该这样学习禅的」，我们就会明白了。</p>
<p>　　这一部论在我们中国，注解也是很多。玄奘大师回到中国来，翻译《瑜伽师地论》以后，很多人学习这一部论，也有很多著作。</p>
<p>　　但是现在我们能够看到的，在《藏经》里面完整无缺的就是《瑜伽师地论记》，是唐朝释遁伦他编集的，就是别的人的著作，他把它编集在一块儿，来解释这一部论的。</p>
<p>　　另外一种就是窥基大师的《瑜伽师地论略纂》，那只是解释到这个＜本地分五十卷＞，其他就没有解释。</p>
<p>　　另外还有一些人的著作，有的只是一部份还在，都残缺了；另外的完全都不在了，不存在了。</p>
<p>　　印度当然也有这样的《瑜伽师地论》的注解，有一部叫《瑜伽师地论释》，在《瑜伽师地论记》上也提到，有五百卷这么多，但是玄奘大师只是翻出来一卷，其他的没有翻译。</p>
<p>　　另外一部注解就是民国以来这个韩清净，在北京有个三时学会，这个韩清净居士有个《瑜伽师地论科句披寻记汇编》这一部书。</p>
<p>　　这一部书，这个韩清净他是专学唯识的，的确对于唯识是很熟悉。这一部书流传到海外来，可惜其中也不全，也有点缺。就是当初他是打字印出来的，印出来的，校对有问题，其中有多少缺少。</p>
<p>　　我们现在每一位同学都有这部书，我们慢慢会知道里面也有残缺。我们现在能够找到的参考书就是这两部，一个是《遁伦记》，一个是《披寻记》这两种，这两种也是很好了。</p>
<p>　　我们一开始，我想用这个《遁伦记》前面的这个概论，发给各位的</p>
<p><strong><em>《瑜伽论记》卷第一‧释遁伦集撰</em></strong></p>
<p><strong><em>初发论端，六门分别：</em></strong></p>
<p><strong><em>一、叙所为，二、彰所因，三、明宗要，四、显藏摄，五、解题目，六、释本文。</em></strong></p>
<p>　　从他的我们来学习大意。</p>
<p>　　初开始，这个「发」就是开始。初开始，这一部论的起首，这一部论的开始，我们怎么样学习呢？「六门分别」，分六个部分来解释它。</p>
<p>　　第一个是「叙所为」，叙述所为。看这个文呢？就是说这一部论的目的是什么？</p>
<p>　　这一部论的作者，我们中国佛教、玄奘大师说是弥勒菩萨说的，就是天上的这个弥勒菩萨说的；但是西藏的佛教呢？说是无着菩萨造的，这个是就是不一样。</p>
<p>　　那么说这一部论的目的是什么？这叫做「所为」，这个「为」有这样的意思。</p>
<p>　　「二、彰所因」，第二段呢，显示，「彰」者，显也。显示怎么一个因缘，有这一部论。这个和那个所为不一样。</p>
<p>　　「三、明宗要」，这一百卷的《瑜伽师地论》，其中重要的宗旨是什么呢？在这一段里面说出来。</p>
<p>　　第「四显藏摄」，显示大乘的藏和小乘藏，都有经律论的，它是属于那一部分的？叫做「显藏摄」。</p>
<p>　　第五段解释《瑜伽师地论》的题目。</p>
<p>　　第六段嘛，解释本文。</p>
<p><strong><em>第一叙所为者。此论所为有何等耶？如《释论》明，有十番两缘。</em></strong></p>
<p>　　现在第一段「叙所为」，叙述这一部论的…会成就什么样的功德？这样意思。</p>
<p>　　「此论所为有何等耶」，这一部论所希望成就的是什么呢？有什么样的事情是它所成就的呢？「如《释论》明」，就是玄奘大师翻译的《瑜伽师地论释》，只有一卷，薄薄的一本。那一部书上说明。</p>
<p>　　「有十番两缘」，这个「番」也就是次，十次，一次、两次，一番就是一次。一共有十次两个因缘，说出来是此论「所为」。</p>
<p><strong><em>一、为法久住及利有情故。</em></strong></p>
<p>　　第一个所为，就是为了佛法长久地住世在世间，是为了这件事。「及利有情」，这个以佛法来利益一切有情识的众生。这是《瑜伽师地论》的所为，就为这件事而说这样的佛法的。</p>
<p>　　这个我们人世间的事情，我们学习佛法的人，当然常常的会感觉到，人生活在世间，就是小时候凭父母的照顾，然后到学校读书，然后在社会上做事。或者是成功了，或者失败了，或者失败了以后又成功了，成功了以后又失败了，不管怎么样，如果寿命长，就是老病死；如果寿命短，还没有老就死了，人的一生就这样就完了。至于这个生命的以前，怎么一回事？生命以后，怎么一回事？都不知道。就是迷迷糊糊的来了，迷迷糊糊的走了。</p>
<p>　　若是学习了佛法的话呢？就像有开个窗户，开一道门，外面有广大的世界，我们可以不受老病死的苦恼，我们可以做一位清净自在的圣人。这样的事情唯有佛法才能做到。所以我们若想要得到佛法的利益，就是得要学习佛法。学习佛法一定要有佛法住世，佛法若是灭亡了，你到什么地方、你读什么书，才能知道这件事？没有，没有这件事。在学校里面读书，就是学你在社会上生存的本事、本领，至于说是转凡成圣之道是没有的。</p>
<p>　　所以佛菩萨的慈悲，为了法的久住，能利益众生，而演说这部论的。</p>
<p><strong><em>二、为圣教已隐没者重开显；隐没者倍兴盛。及有情界中，有种姓者出生死；无种姓者脱恶趣故。</em></strong></p>
<p>　　前面是第一番的两缘，现在是第二番。</p>
<p>　　「为圣教已隐没者」，就是佛所宣说的法语，叫做「圣教」。</p>
<p>　　「已隐没者」，就是已经失传了、没有了。为什么它会失传呢？会隐没了呢？会灭掉了呢？就是没有人弘扬了。没人弘扬，这个法门就隐没了。</p>
<p>　　我们现在还算好，就是把所有的《藏经》，所有的经编集在一起，完全把它印刷出来，储藏起来。你不弘扬，《藏经》里还是有，那还算好。但是不弘扬，虽然有，和没有差不多。不过也还是好，因为总会有人看上去，欢喜了，弘扬那一个法门，那一个法门还是可以流传的。</p>
<p>　　那么古代的时候，没有印刷，都是听人背诵，同人把这部经背下来，这样子一代一代的传下去的。那么若没有人背诵，也就是没有人弘扬；没有人弘扬，那么这个法门就没有了，是这样子。</p>
<p>　　所以「圣教已隐没者重开显」，为了这件事，再把它重新的开发出来、显示出来，所以要说这一部论。这可见《瑜伽师地论》里面所包含的佛法非常的广，不是一经、一论的事情。</p>
<p>　　「未隐没者倍兴盛」，还在流行的佛法，它没有失掉，没有失没，要加倍的兴盛，所以要说这一部论。</p>
<p>　　从这样说呢？我们每一个人的根性不同，好乐不同，我欢喜这个法门，我就弘扬这个法门，这也是对。那个法门虽然也是好，但是我不欢喜，我就不弘扬，当然是也不能说不对。可是若是从全面的佛法，在全面的一切众生来说呢？每人的根性不同，好乐的佛法不同，就应该有各式各类不同的法师，弘扬各类不同的法门，都应该有，应该是这样子才好。</p>
<p>　　「及有情界中，有种姓者出生死；无种姓者脱恶趣故」，前面是在法的方面说。有隐没的、有不隐没的。这一节呢？是在人的方面说。</p>
<p>　　「有种姓者」，这个「种」是什么？就是种子。种子，譬如说谷，或者是麦，或者各式各样的植物，都有种子。由种子发芽，然后根、梗、枝、叶，开花结果。</p>
<p>　　这里说这个种子呢？就是在人的心里面有这样、有这种功能，有出离生死得涅槃的功能，得圣道的功能，在我们心里面有这种功能，那就叫做「种」。</p>
<p>　　这种种子在佛法里面说呢？分两类，一类是本有的。就是你不须要去学习，在你的心里面就有这种功能，这是本有的种子。第二种呢？是熏习来的，你若不熏习就没有，你要学习你才有。这是另一种习所成性，修来的一种种子。这个种子分这么两类，分这么两类，在唯识的经论里面这样说，在其他学派也有不这样说的。</p>
<p>　　像《涅槃经》说：「一切众生皆有佛姓」，那么一切众生都可以成佛。就不说是有人有佛性；有人没有佛性，不是这样。但是唯识上是这样讲，有人有佛性，有人没有佛性。有的人有阿罗汉的种姓，有辟支佛的种姓，有人没有。有人有佛姓，但是没有辟支佛姓和声闻姓；有人有声闻姓和辟支姓，但是没有佛姓；有人三乘种姓都没有，也有这种情形。</p>
<p>　　现在这里就是这样意思，有种姓的人出生死，没有种姓的脱恶趣。这个「姓」，有的文上，「人之初，性本善」的性，写那个性；这里是姓氏的姓，这意义也是一样。譬如说这个人姓张，他就是姓张；那个人姓李，就是姓李。那么这样说，说这个人有辟支佛姓，他就是辟支佛姓；他没有阿罗汉姓，没有佛姓。这个人有佛姓；没有阿罗汉也没有辟支佛姓，那么他就是……，他只是这个姓，而不是那个姓，也有同样的意思的。</p>
<p>　　有种姓的人呢？「出生死」，他若学习这个《瑜伽师地论》的话呢？他就能够超出有生、有死的苦恼境界，他能从这个生死的苦恼境界超出去，得解脱。因为有种姓的关系，你若学习《瑜伽师地论》，那个种姓就会发动作用，你就能够继续的学习，继续努力的修行，就成功了。没有种姓的人不行。没有种姓，就像那个你没有种下麦的种，无论如何，你怎么样施肥，怎么样浇水，那它也不会发出来麦的芽的，没有种就不行。所以「没有种姓」，没有三乘道果的种姓的人，那他不能出生死。</p>
<p>　　没有出生死，就是在三界里面流转生死了。流转生死，但是你若发心学习《瑜伽师地论》呢？「脱恶趣故」，就可以解脱三恶道的苦恼，不会到地狱去，不会到饿鬼道，不会到畜生的世界去。因为你相信了因果、善恶果报，不敢作恶事，那么没有因就没有果了。没有恶因，就没有恶果，所以就可以解脱三恶道的苦恼。你能够学习五戒十善，那么你就在人天里面享福了。</p>
<p>　　所以学《瑜伽师地论》的人，学习《瑜伽师地论》对于有种姓的人也能得到最好的利益；没有种姓的人也能得到好处。所以为了这件事，弥勒菩萨要说这部论的。</p>
<p><strong><em>三、为舍无见及有见故。</em></strong></p>
<p>　　这又是一番。「舍无见及有见故」，舍掉这个「有见」，弃舍这个「无见」。</p>
<p>　　这个有见、无见这个「见」，就表示不正确的执着。一种错误的思想，你对于它有深刻的执着，才称之为「见」。如果有…思想是错误，但是还在犹豫之中，那不能称之为「见」。</p>
<p>　　这个我们先说「有见」，什么叫做「有见」？我们学习了《摄大乘论》，我们应该明白什么叫做「有见」。《摄大乘论》上说是「唯识无义」，一切法都是心的分别影像。离开了心，没有一切法的体性可得的，没有一切法的体性可得。</p>
<p>　　譬如说我们看见个老虎来了，老虎来了的时候，你若知道这个老虎是心变现的影像。当然老虎也是人，牠的业力使令牠得这样的果报，也就是牠那个业，牠的心受业力的影响，现出来这样的影像。我们是人，我们也是一样，我们也是前生有一点比较好的业力，这个业力推动这个心，现出来这样人的果报的影像，现出个影像来。这个影像就是心，心的分别，心的分别现出来影像，离开了心的分别，这个影像是没有的。它没有自己的体性，没有自己的体性的。</p>
<p>　　我感觉到这样的理论，你在经行的时候你这样思惟；或者是你在静坐的时候这样思惟。思惟久了，你心里面快乐，心里面会快乐。就是一切、一切都是影像，没有本身的体性的，没有本身的体性。这样说就是一切是心，一切是心的影像，一切都是不真实，「凡所有相，皆是虚妄」，都是不真实的。</p>
<p>　　我们现在因为没有学习佛法，或者虽然学习了佛法，我们没有深刻的去思惟，对于这样的理论不明白，我们就执着是「不是影像，是真实的」。现在有老虎来，老虎是真的，不是纸老虎，是真的，这就叫做「有见」，这叫做「有见」。</p>
<p>　　宋朝的朱熹〔口误，应是程颢〕，他说：「云淡风轻近午天，傍花随柳过前川，时人不识余心乐，将谓偷闲学少年」，当然朱子是有学问的人，他也是读佛经，但是不是太信佛。但是这个诗，若用佛法来讲是有点意思。「云淡风轻近午天」，天上这个云很淡淡的，并不是乌云。太阳要到中午的时候，在这个时候我出外面去走一走。「傍花随柳过前川」，在花的旁边、在柳的旁边走过去，从这走走。正在走的时候，别人认为：「你这个人年纪这么大了，和小孩子一样，还出来玩一玩！」来讥笑我。「时人不识余心乐」，你不知道我心里面的快乐。「将谓偷闲学少年」，说我这个人不用功，懈怠，不好好读书用功，跑到这里学习小孩子玩、跑一跑，其实你不知道我心里面的快乐。</p>
<p>　　这若用佛法来讲，在经行的时候，你在寂静处经行的时候，看一朵花也好，看见一棵树也好，都是「唯心所现」，都是毕竟空寂的，觅心了不可得，不是与第一义谛相应了吗？这样子就没有这个「有见」了，没有这个有见了。这个我们没能够这样学习佛法的人，就虽然我们还是信佛的人，但是你是在有见里面活动的，你还在有见里面活动，还没能在正知正见里面，还没能做到这一点。</p>
<p>　　「无见」，无见是什么呢？一切法都是如幻如化的，毕竟寂灭，诸法从本来常是寂灭相的，我们看不到这里，我们就不承认有这件事。说是这个老虎是假的，老虎是真的嘛，老虎扑上来，就把你咬死了，那怎么是假的呢？我们不承认是假的，就是不承认这「依他起相」。不承认有「依他起性」、「圆成实性」，所以叫做「无见」。</p>
<p>　　这一般的说，我不相信因果，那也是无见，也是无见。执着有一个我，是常住不灭的，那也是有见，也可以包括在内的。</p>
<p>　　现在我们学习《瑜伽师地论》的话呢？你若认真地学习，就能弃舍这个无见，也能弃舍那个有见，使令你得正知正见。使令你得正知正见，你就会到了佛的境界了，到圣人的境界了，就没有凡夫这个苦恼的事情了，就没有这个事情了。</p>
<p>　　第一「叙所为」，我学习《瑜伽师地论》干什么？我学习它做什么？学习《瑜伽师地论》能令你舍无见、能令你舍有见，能令你超凡入圣了，有这样事情。</p>
<p><strong><em>四、为成熟菩萨（种）姓人，唯依大教，遍于诸乘文义行果，生巧便智，断障得果，自他俱利。及二乘无姓，亦依大教，各于自乘文义行果生智断伏，得自乘果，离恶趣故。</em></strong></p>
<p>　　这又一个两番。</p>
<p>　　「四、为成熟菩萨姓人」，这个「菩萨姓人」，这个人是姓菩萨的。他是一方面，他内心里面有佛性；一方面，他发无上菩提心了。</p>
<p>　　这样的人「唯依大教」，这是他不依小教，不依小乘佛法，那么依这个大乘佛法，这个大乘的佛教。</p>
<p>　　「遍于诸乘文义行果，生巧便智」，「遍」就是普遍的，不是一部分的。「于诸乘」，小乘、中乘、大乘；就是声闻乘、辟支佛乘、佛乘。这个「乘」字就是车。我们汉人的佛教，对古德翻译经的时候，用这个字。可是现在像法尊法师他们，从藏文的佛法翻成汉文的时候，他直接就写「车」。「大乘」就写个大车，这样我们也可能容易明白一点。这个「乘」就是车，这个车在这里有什么意思呢？车是运…有运转的意思，从甲地运转到乙地去；从一个黑暗的地方，能把你运出来，到光明的地方去；从生死的地方，运你到涅槃的地方去；从苦恼的地方把你运出来，到达安乐的地方去，那叫做「乘」。这个乘有这个意思。</p>
<p>　　这样的意义，只有声闻乘、辟支佛乘、佛乘才有这种作用。我们若依人、天乘法，不行。人乘、天乘，我们一般的只是学习五戒十善的、一般的善法，没有这个作用。我们学习一般的善法，也可以不到三恶道去，跑到人天的境界来。你不做恶事，我们修学善法，就可以得到人间的富贵，和天上的大福报的境界，可以得到。但是不行！因为你得到了以后，你还会迷惑，你到富贵的境界来了的时候，我们读古书：「天子一怒，流血千里」，还会做恶事，问题在这里。说我没有在三恶道，我在人间富贵，人间富贵还会做恶事。这个杀盗婬妄的恶事还会做。还会，你还要回到三恶道去。说我到天上去；到天上，天上也是无常的，也要死；死了以后，又可能到三恶道去了。这样说呢，这个「乘」的义，这个车的运转的义不具足，因为你还没能够解脱苦，又回到三恶道去了。所以我们佛教徒，对于善法是应该修，一般的善法都应该做。但是要知道，修学无漏的戒定慧是很重要的，是很重要，因为那才能究竟的解脱苦。</p>
<p>　　这里面说这个「菩萨姓人，唯依大教，遍于诸乘」，不但是一佛乘，乃至声闻乘、辟支佛乘。</p>
<p>　　「文义行果，生巧便智」，这个「文」就是教，文就是这个…就是你说话也是文，「声名句文」，这个文字是「文」；你说话，话里面有文，也是文，就是教（佛教那个教）。就是能诠义理的文句，义是所诠显的，能诠的文和所诠的义。或者是属于声闻乘的、辟支佛乘的、一佛乘的文义。「行果」，你学习这个文义，你就会得到一种「闻所成慧」，然后「思所成慧」、「修所成慧」，得到闻、思、修这三种智慧，然后你就开始修行。「文义」属于解。解、行，由解而行，这个「行」呢？就是止观了，修学止观，这时候叫「行」。你若有行，这就是有因，有因就会得「果」，小乘就会得初果须陀洹、二果斯陀含……乃至阿罗汉果；大乘那就是得无生法忍了，十地菩萨到无上菩提，就是得果了；辟支佛道，辟支佛乘的文义，当然也是得辟支佛果。是有行就有果，就现前了，叫做「生」。这个诸乘的文义行果，你能够「遍于诸乘文义行果」的学习，普遍地学习。</p>
<p>　　「唯依大教」，是在大乘佛法里面学习一切乘的文义行果，结果你就生出来「巧便智」，善巧方便的智，这个是什么呢？就是你得到了通达的智慧了，你通达了三乘文义的这种智慧。这个智慧是很巧妙的、很锐利，得到了这种智慧，「生巧便智」。「断障得果」，你得到这个智慧，这个智慧是有深浅的不同，闻所成慧、思所成慧、修所成慧。修所成慧有有漏的、有无漏的不同。由有漏而无漏，这个时候呢？「断障得果」，就把这个爱烦恼、见烦恼，是障，它障碍我们学习佛法，障碍我们修学圣道。现在你能够逐渐地增长闻思修的智慧，不断地修学止观，这个智慧增长力量大了，就能断除去这一切的障。或者是烦恼障、业障、报障，都是障。断除这个障碍了，你就得果了，得到圣道的果位了。</p>
<p>　　这个这么多的障碍里面，最重的就是烦恼，烦恼障，烦恼障是很厉害的。你若常常的修学闻思修的智慧，常常修止观呢？就能把烦恼调伏下来，能够降伏下来，使令它不发生作用。就算是偶然的失掉了正念，但是正念一起来，烦恼就停下来，那么你就有一点…有断障的希望了，「断障」。</p>
<p>　　这个另外我们说这个报障，报障就是这个身体，这是报障。譬如说我有了重病，其实也是报障。这个报障，我们凡夫如果没有病痛的时候，这个四大调和的时候还好一点，还是好一点，行住坐卧还都是自由的，自由自在的。若是有了病的时候这个报障就加重了。可是若是你的止观修得好的时候，这个报障也减轻，报障减轻。</p>
<p>　　尤其是你若得到欲界定的时候，欲界定到最后的时候，这个报障也是减轻，就是这个身体不感觉到有这么一大块，感觉到有若无的样子，这个身体，那这个报障就减轻了。</p>
<p>　　所以这个烦恼障也可以调伏；这个报障也可以调伏；还有就是业障。业障呢？这个地方呢不那么明显。但是你若常用功修行你会感觉到，你就会感觉到什么事情呢？譬如说是静坐，静坐的时候就是不相应，想要使令心寂静，它就不寂静，它就是东想西想。想要明静而住，哦！不，它要打昏沉，就昏沉。不是昏沉就是散乱；不是散乱就是昏沉，你想要寂静住、止观相应，很难。</p>
<p>　　但是呢，你多忏悔，你读大乘经论，你多念大悲咒，这个业障若消除的时候，就不是了。你坐的时候，你要「奢摩他」，就奢摩他；你要「毗钵舍那」，就毗钵舍那，它就相应。所以这些、从你日常的修行上，你也会感觉到这个业障消除、没消除，你也会感觉到。</p>
<p>　　我们说这个…头多少年，很多人打笔仗，为这个是「带业往生」、「消业往生」的事情打笔仗。但是你读这个《十六观经》很明显的，就是「带业往生」，是带业往生。那个《十六观经》的下三品里面，说是这个众生，在娑婆世界的时候破斋犯戒，造了很多的恶。但临命终的时候，遇善知识的教导、帮助、加持，你还能够念佛。你正念一生起来，你念阿弥陀佛，阿弥陀佛放光接引，就往生了。那么你造的罪呢？造的罪就带走了，还是没有消。说是消除了很多；消除了很多，还有很多没有消；没有消就带去了。带去了，但是你在下三品上看，观世音菩萨为你说法，为你说诸法实相，来灭你的罪。这就可以知道是带业往生。所以这个业障是不容易完全消除。不容易完全消除，但是经论上佛菩萨大智慧，他也说出一个分寸来。就是这种罪业它能够使令你到三恶道去受苦，这种罪业没有消除，它就是障。到得无生法忍的时候，得初果的时候，这种罪消除了，就是消业。所以从这样的…这个经论上这样讲，只有圣人才能消业往生；凡夫都是带业，只有圣人才是。但是我们虽然说是带业往生，你的信愿行的资粮也要强一点，不然的话，你不能往生，那个罪业还是发生作用，障碍你的。</p>
<p>　　所以现在这上面说「断障得果」，就是我们要修这个戒定慧，修这个止观，你要不断的加强，你才能「断障」，才能「得果」。小乘开始，得须陀洹果；大乘开始，得初欢喜地，得无生法忍了，「断障得果」。</p>
<p>　　「自他俱利」，你若得到圣道以后，你有能力继续修行，来利益自己；也有能力弘扬佛法，广度众生了，所以自己和他人都能得到利益。这句话呢？没得圣道以前，这事靠不住，是不是自利？能利他？都靠不住的。得圣道以后这件事才决定了，决定是能做到这一点，所以「自他俱利」。</p>
<p>　　这是说这个菩萨种姓人，他在大乘佛法里面，普遍地学习一切佛法，最后他得到巧便智，能断障得果、自他俱利。这件事呢？你学习《瑜伽师地论》可以成就。</p>
<p>　　「及二乘无姓」，这个二乘就是有声闻种姓、有辟支佛种姓的人，叫二乘。「无姓」，就是没有三乘种姓的人。「亦依大教，各于自乘文义行果生智断伏，得自乘果，离恶趣故」，他若学习《瑜伽师地论》的话呢，他也能够依据这个大乘佛法。「各于自乘」，声闻乘就依据声闻乘去修行；辟支佛乘依辟支佛乘的法门去修行。各于自乘的「文义行果生智」，能「断」障，能「伏」，「断」之前先是伏，能降伏烦恼障、业障、报障；进一步就能断除一切障。「得自乘果」，你得到你本身那一个法门的果，声闻乘得声闻乘果；辟支佛乘得辟支佛乘果。如果无种姓的人呢？他「离恶趣故」，就可以不堕落三恶道了。</p>
<p><strong><em>五、为执着邪教不信大乘者，及于深经种种意趣，迷乱诽毁者，令生信解故。</em></strong></p>
<p>　　这是第五个，这第五番。「为执着邪教」，这个人他不相信佛法，执着其他的宗教。不相信大乘佛法的人，对于大乘佛教他不相信，这样的人，这是一种人。「及于深经种种意趣」，及于这个佛法的经论，除了人天乘的法门之外，属于出世间的三乘的经论都是「深经」。「种种意趣」，各式各样的道理，它里面的意义。「迷乱诽毁者」，他迷惑，不知道怎么回事，而作诽谤，毁破的人。「令生信解故」，他若肯学习这一部《瑜伽师地论》呢？他会相信大乘佛法，改邪归正。他能对于深经种种意趣而不迷乱，也不诽毁了，能生信心，还能够通达里面的道理。</p>
<p>　　佛法说「生信」，这个信是建立在智慧上面的。由于你通达了佛法，有了智慧，你才相信佛法是怎么回事。不是说：「我的好朋友叫我相信佛法，我就相信」，就算是相信了，不牢固！所以一定要本身生出来智慧以后，你从你自心上生出来智慧，观察世间上一切道理，「哦！佛法是对的，佛法是真理」，你才能有信、有解的。</p>
<p>　　我现在我感觉到「执着邪教」，不相信佛法的人，这些人都很容易度化，我感觉不是很难。当然，各有因缘。因为什么他容易度化？因为他本身没有智慧，本身没有智慧，他相信的那一点很容易就破除去了，所以应该容易相信佛法，应该是容易，不是难。问题就是有障，这个障，障住他。就是那个窗户（现在这个窗户是玻璃窗），过去时代就是铺上一层纸。这一层纸，就是譬喻那个人不信佛法的障，那层纸很容易就可以捅破了，但是你若不捅，它就不破。所以我感觉到…这个《大般若经》上也说到，一切众生不是太难度，不是太难度，都是容易度化的。不过这个话，就是从某一个立场来说的，不是太难度。</p>
<p>　　「为执着邪教不信大乘者，及于深经种种意趣迷乱诽毁者，令生信解故」，说这一部《瑜伽师地论》的。</p>
<p><strong><em>六、为摄益乐略言论，及乐广者故。</em></strong></p>
<p>　　这个第六番。第六番「为摄益」，这个「摄」这个字，就是接引的意思，可以这样讲，接引的意思。这个「益」，就是来饶益他，使令他得到真实的好处，叫「益」。</p>
<p>　　「乐略言论及乐广者故」，这个人的根性是这样，有的人欢喜简略，太广了不欢喜，欢喜简略的言论。「及乐广者」，有的人简略，他不欢喜，欢喜详细一点，广博一点。那么这两种人来学习《瑜伽师地论》也都能合适的。</p>
<p>　　这个《瑜伽师地论》里面，譬如说这一大段文很广，但是最后会有几句把这一大段文的要义，用几句话说出来，这《瑜伽师地论》有这种事情。所以里面有略，也有广；有广也有略。欢喜略的人也合适；欢喜广的人也合适。</p>
<p>所以对这两种人，这个《瑜伽师地论》也能摄益他，能引导他，使令他进一步的在佛法里面有成就的。</p>
<p><strong><em>问：</em></strong>「十番两缘」，「十番」是我们平常在讲，１２３４…，讲到十。「两缘」没有看到上面写？</p>
<p><strong><em>答：</em></strong>你比如说第一番，「一、为法久住」这是一缘。「及利有情故」又是一缘，这是两缘嘛，第一番的两缘。第二番「为圣教已隐没者重开显」，这是一缘；「未隐没者倍兴盛」，那么这也可以说是一缘。但是这个地方呢？又加…这算是一缘。「已隐没」、「未隐没」加起来是一缘。第二缘是「有情界中，有种姓、无种姓」又是一缘。这不是二缘！</p>
<p>　　第一番都是两缘。</p>
<p>　　第三番「为舍无见，及有见」，这又是两缘。</p>
<p>　　「第四、为成熟菩萨（种）姓人，唯依大教，遍于诸乘文义行果，生巧便智，断障得果，自他俱利。」这是一缘。「及二乘无姓，亦依大教，各于自乘文义行果生智断伏，得自乘果，离恶趣故。」这又是一缘。加起来就是两缘。</p>
<p>　　第一条（番）都是两缘。</p>
<p><strong><em>问：</em></strong>第二页第一行提到「生巧便智」，我想我们在修行状况之后，必然一定就是先生起智慧才能降伏烦恼…（不清楚）</p>
<p><strong><em>答：</em></strong>智慧，这个一开始也是有多少智慧，但是智慧薄弱，智慧的力量不大，所以虽然有了智，对于烦恼的调伏还是不足的。还要继续的增长智慧，到了一个程度了，才能调伏烦恼。要继续不断的增长，才能够继续不断的调伏烦恼。有的烦恼容易调伏；有的烦恼不容易。所以智慧若不断增长，力量强大了，才能够显著的知道，「哦，我降伏烦恼了。这也是得到圣人的智慧了，这时候才断烦恼。</p>
<p><strong><em>问：</em></strong>我们上学期的《摄大乘论》「四寻思」是不是伏烦恼？「四如实智」是不是断烦恼？</p>
<p><strong><em>答：</em></strong>都是伏烦恼。「四寻思」、「四如实智」都是伏烦恼。因为由「四寻思」进步到「四如实智」；「四如实智」进步到「见道位」，才断烦恼。到「见道位」才断烦恼。</p>
<p>　　所以那两个位子还是在伏的阶段。</p>
<p><strong><em>问：</em></strong>这个「无种性」的人，他有没有因为学习《瑜伽师地论》的关系而熏习的关系，因为听闻法界等流熏习的关系，而得到这个成佛的种子？</p>
<p><strong><em>答：</em></strong>如果是等在「本有」种性来说，这是不能。他原来没有，就怎么也不能熏习。若是站在「新熏」的立场上说呢？那是可以。</p>
<p>　　所以这个地方，《瑜伽师地论》是「本有」种性的立场，和《摄大乘论》有点差别。《摄大乘论》不说有「本有」种，是「新熏」，是有这一点差别。</p>
<h3 id="第2讲"><a href="#第2讲" class="headerlink" title="第2讲"></a><strong><em>第2讲</em></strong></h3><p><strong><em>七、为立正论，及破邪故。</em></strong></p>
<p>　　我们昨天开始，说到《瑜伽师地论》。学习《瑜伽师地论》会得到什么样的功德？也就是说这个造论的人，他造论的目的是什么？一共有「十翻两缘」，昨天讲过了六翻。现在是第七翻。</p>
<p>　　「为立正论」，为了建立正确的、没有过失的理论，这个教、行、理的这一切的「论」、议论。</p>
<p>　　「及破邪故」，破斥一切有过失的议论。</p>
<p>　　这个「正」、「邪」这里面的意思，应该是说有两种，一种是世间上的愚迷的境界，都算是「邪」，因为它能令人苦恼。这佛法是能令人离苦得乐的，所以叫作「正论」，这是一种「正」、「邪」。</p>
<p>　　第二种是我们学习佛法的人，学习的不对，搞错了，以邪为正，那叫作「邪」。</p>
<p>　　现在要建立正论，破斥邪论，多数还是属于后一种，就是在佛法里面搞错了。这件事，如果我们常常的、时时的学习佛法，就会很容易的会认识到这里。如果我们不是…不学习经论的话，我们不知道这件事。我们只是听人说话，你不去看经论，你很难知道这件事，而这件事对人的伤害是特别大的。不管是佛法来到中国，佛法在印度，都有这种问题。</p>
<p>　　现在这个造论的这个作者是大慈悲心，是看到了这一点，所以「为立正论及破邪故」，而造这一部论的。</p>
<p><strong><em>八、为显三性有无；及世间、道理、证得、胜义四法门故。</em></strong></p>
<p>　　这第八番的两缘，第一缘是「为显三性」的「有无」，「三性」就是三自性，遍计所执性、依他起性、圆成实性这三性。「三性」的「有无」，这个「遍计所执」是毕竟空的，是没有这么回事，所以那是「无」；「依他起」是如幻有；「圆成实」是真实有，那叫作「有」。要显示三性的有无，而造这一部论的，使令人能够觉悟到这里。</p>
<p>　　这三性的有无，我们在学习《摄大乘论》的时候，这第二章（十大章，十种殊胜殊胜语，就是第二种），就是那第二种殊胜殊胜语「所知相」，倒是说得很清楚了。</p>
<p>　　「及世间、道理、证得、胜义四法门故」，这是又一种缘。这个「世间」是什么呢？其实就是「遍计所执」，就是社会上这个士、农、工、商的这一切的事情。譬如说是耕田的、务农的、或者是作生意的、或者是做工艺的、或者是读书的、或者是在政府作事的，这都是属于「世间」。</p>
<p>　　这个「道理」呢？就是超越世间的了。就是释迦牟尼佛出现了世间，为我们开示的佛法，那是有道理的。是说…譬如说五蕴，说十二处、十八界，说这个苦、集、灭、道，这一切的事情。那么这些佛法，这是有道理的。「道理」，这个「道」字就是「道路」，这个道路可以从这里通到另一个地方去，就叫作「道」。如果闭塞了、阻塞了，通不过去了，那就不是道理了。现在这里说「道理」呢？就是按照佛法的戒定慧的道理，能使令你从三界的苦恼的境界得解脱，是能通达无碍，所以叫作「道理」。</p>
<p>　　这个「证得」，「证得」就是按照佛说的这个苦、集、灭、道的道理去修学，有成就了，你得须陀洹果了、得斯陀含果、阿那含果、得阿罗汉果了，那么就叫作「证得」。有成就了，那叫作「证得」。</p>
<p>　　这个「胜义」，就是前面说「证得」还是约人说，这个「胜义」就是所证得的。就是一切阿罗汉、辟支佛、到佛的境界，他们成就的广大无分别的智慧，所证悟的第一义谛，名之为「胜义」，叫作「胜义」了。</p>
<p>　　「四法门故」，这是四种法门。「世间」的是一些凡夫生活的事情；「道理、证得、胜义」这是出世间的圣人的事情，那么加起来就是「四法门故」。在《瑜伽师地论》里面，在本论里面，会说到这些事情。</p>
<p><strong><em>九、为开随转、真实二种理门，令知二藏、三藏法教不违；及开因缘、唯识、无相、真如四理门，令修观行有差别故。</em></strong></p>
<p>　　现在说到第九。「为开随转、真实」，这个「随转」和「真实」怎么讲呢？就是佛说法…是大略的说呢？就是这两种方法，一个是「随转」，一个是「真实」。这个「随转」是什么意思呢？就是随顺学习佛法的人的根性而转。根性里面有利根、有钝根，那么佛就随着根性的不同，宣说出来各式各样不同的佛法。随顺众生的根性而开示佛法的，这是一部份。「真实」是佛自己的智慧，随顺佛自己的智慧宣扬这样的佛法。这个佛法是没有…不是方便的，是真实的，佛法是这样子的。随顺众生的根性，那个佛法就是里面有一些迁就，有一些方便的地方，是这样意思。</p>
<p>　　佛这样子为众生说法就是「开」，这个「开」在这里也可以说是建立的意思。建立了这两种佛法，一个是「随转」，一个是「真实」。建立了这两种佛法，这两种都是入理之门，所以叫作「理门」。这按唯识的态度来说，唯识的法门那就是真实了，其他的当然就是方便了。就是这个「随转」，有个「权」的意思；「真实」就是「实」，「权」、「实」两种法门。</p>
<p>　　「为开随转、真实二种理门」，这两种理门，并没有矛盾。「令知二藏、三藏法教不违」，我们学习了这样的佛法之后，也就是学习这个《瑜伽师地论》。学习这个《瑜伽师地论》呢？你就会知道「二藏、三藏法教不违」，「二藏」就是菩萨藏和声闻藏。或者说菩萨藏就是「真实」；声闻藏就是「随转」了。「三藏」就是经律论。菩萨藏里面也有经律论，声闻藏也有经律论。声闻藏一般说就是小乘佛法了，菩萨藏就是大乘佛法，这两种佛法里面都有经藏、有律藏、有论藏，有这三藏。</p>
<p>　　「法教不违」，这两种佛法里面的内容并没有矛盾，它们是可以互相贯通的，并没有矛盾。由学习小乘佛法，也可以进一步回小向大来学习大乘佛法。学习大乘佛法的人也应该学习小乘佛法，不应该互相障碍，互相诽毁，不应该是那样子。</p>
<p>　　「及开因缘、唯识、无相、真如四理门，令修观行有差别故」，这底下呢？又说出来四种法门。「及开因缘、唯识」，这地方，「因缘」是一种、「唯识」是一种、「无相」是一种、「真如」是一种，四种理门。</p>
<p>　　这个「因缘」呢？就是缘起，佛说世间一切法都是因缘生起的。「此有故彼有，此无故彼无，此生故彼生，此灭故彼灭」，这就是「因缘」。比如说十二缘起嘛，「无明缘行、行缘识、识缘名色、…，乃至生缘老死」，一共是十二种。「此有故彼有」，因为有这一样事，才有那一样事。那一样事的有，一定先有那一种事，后来才有这种事。不然的话，那件事不能有。这个是有「无明」才能有「行」、有「行」才能有「识」、有「识」才能有「名色」、…，乃至到有「生」才有「老死」，所以「此有故彼有」。「此无故彼无」，若「无明」灭掉了，「行」也就灭了。「行」若灭了，「识」也就灭了。</p>
<p>　　这「十二缘起」在《瑜伽师地论》里面说得很详细、很详细的。我们举一个例子，比如说这个…拿这个人来说、拿我们人来说。人死掉了，这个人现在他是个男人，死掉了以后他没到三恶道去、也没到天上去，还作人，但是做了女人了。这个男人死掉了以后，还回到人间作女人了。这个事情，比如说我们这个男人在生存的时候，他的内心自然是知道自己是男人，总是男人的想法去思惟分别一切的色声香味触法的，一定是这样子。可是死掉了以后去做女人的时候，她就不是。她就是用女人的心去分别一切色声香味触法。原来他前一剎那是男人，后一剎那就是女人了，他为什么会这样子呢？这种分别心，「无明缘行、行缘识」，就是这个「识」就是分别心，为什么会这样分别呢？就是「行」，就是这个「行」的关系。「行」就是业力，这个业力使令他这样子。说「此有故彼有」，因为有这样的业力，所以会有那样的识。譬如说在生的时候是女人，死了以后他来生变成男人了，他也是一样，前一剎那是女人，后一剎那就是男人，是男人的想法。为什么会这样呢？就是这个「业力」，业力会使令人这样子，所以「此有故彼有」。「此无故彼无」，佛说…这个、种话就是《阿含经》上说这样的佛法，别的大乘经论也是有。这个道理，我认为非常的坚定，不可破坏的。所以叫作「因缘」，就是说一切法都是因缘有的。</p>
<p>　　当然这样说「因缘」呢？就是还是大概的这样说。在这里我们不妨…说因缘应该包括一切的佛法都在内的，并不只限于一部分的佛法的。可是在这里说，说是一共分四种，那它就单独说。一切世间，加上小乘佛法这个部分，都叫作「因缘」。</p>
<p>　　底下「唯识、无相、真如」那这是大乘佛法了。大乘佛法里面，分成两部分，就是一个唯识、一个无相。如果说把「真如」也算是独立起来，那么就是「如来藏」，这么解释也可以。「唯识」是一个法门；「无相」就是般若的法门，就是【中观】这个学派的法门，「真如」就是如来藏的法门。但是在这个地方，我看这个意思不是这样，不是这样意思。</p>
<p>　　这个「唯识」的法门呢？简要的说，就是《摄大乘论》是最好了，它简要的介绍唯识的法门。就是…它是说把一切法都统摄在心里面，统归于一念心里面，来建立一切法的，唯识是这样子。</p>
<p>　　这个「无相」呢？就是「一切法自性空」，它不这样说。它不说一切法是唯心所现，它不这么讲。就直接说一切法是因缘有、自性空，是这样讲。发无上菩提心可以得无上菩提，这是「无相」的法门。</p>
<p>　　这个「真如」是什么呢？真如就是小乘佛教的学者、大乘佛教的学者所证悟的理性是平等的。这是在我们学习《摄大乘论》的时候，曾经讲到这里。这和中国【天台宗】、【华严宗】说得不一样。我们这个…当然这都有圣言量的根据，也并不是自己随便云云。这个这一段文应该这么讲。</p>
<p>　　「四理门」，这四种理门，就是「因缘、唯识、无相、真如」。</p>
<p>　　「令修观行有差别故」，叫我们知道修学圣道的观行是不一样的。你比如说是这个小乘学者修习止观是一样；唯识学者修习止观是又一样；这个中观的学者他修这个止观，也是不一样，是有差别的，这个修行的方法是不一样的。那么这在《瑜伽师地论》里面，都有详细的解释。</p>
<p><strong><em>十、为示境别，令知诸法体、相、位别；及示行别，令知三乘、方便、根本、果差别故。</em></strong></p>
<p>　　现在这是最后一番，也有两缘。「为示境别」，这个「示」就是开示，也就是说明的意思。说明这个种种境界的差别，譬如三恶道的境界、人间的境界、天上的境界；这个散乱心人的境界，和有禅定人心的境界，乃至到圣人的境界；阿罗汉乃至到佛的境界，都是不一样的。我们人啊…人的境界当然是也不同于三恶道、也不同于天、也不同于佛。但是人，有的地方的人有文化，能读书，智慧开发了多少，就会很武断的：「我没有看见的事情都没有！」就是这样子，就是我看得见的境界是真实的。其实不是这样子。所以在佛的智慧能通达无量无边的境界，能通达自己的境界，也通达一切众生的境界，是「为示境别」。</p>
<p>　　「令知诸法体、相、位别」，「为示境别」这句话是总说的，这底下是别说。叫我们知道一切法的体性、相状。表现于外的是「相」状。它本身的事情叫作「体」。这些体状、体相是不一样的，体状是不相同的。就是刚才说的，由三恶道、乃至到佛都是不一样的。因为人的业力不同，这个分别心也不一样，所以所感到、所得到的境界都是不一样的。</p>
<p>　　「位别」，这个「位」有深浅的不同。这个地位，在人的境界地位有高低。用这高低来解释这个「位」也算是合适了，就是有差别，是不一样的。你就人间的这个富贵、贫贱也都是不一样。所以是「令知诸法体、相、位别」不一样的。</p>
<p>　　你就按我们人，这个墙壁，我们不能从这个墙壁过去，能挡住你；但是鬼就不同，鬼他从这里是无障碍的，从墙壁可以过去；从这个地也可以自由的出入，这境界不一样。有的众生在水里面能生活，若是人就不行，所以这个境界是有差别的。</p>
<p>　　但是这里面主要是说凡、圣的不同。这个凡夫的境界也有种种差别，圣人的境界也有种种差别。但是圣人是大自在、是安乐的；人是很苦恼的。像这个《楞严经》里面说到这些魔鬼的境界。这个魔鬼会有种种神通，自在的，但是他怕刀，就会有些个别的事情。你说他有这种神通，说是我们认为他了不起，不是，他有的时候还是不行。说是我们静坐的时候，若用功修行会有魔鬼来捣乱，但是魔鬼怕什么呢？怕镜子、像我们人用的那个镜子。所以这个修行人，你后面放一个镜子，那个魔鬼他怕你，他怕镜子。若人呢？没有这个问题。所以各式各样的境界都是不一样的。所以「令知诸法体相」，这个高、低，深、浅的不同。</p>
<p>　　「及示行别，令知三乘方便根本果差别故」。前面这一段说「令知诸法体、相、位别」，是说我们已经遭遇到的境界。「及示行别」，这是你要重新创造。这个「行」是我们重新创造的一种活动。</p>
<p>　　当然一般人的境界是为了生活、为了享受，作种种事、作种种事情。但是在佛教徒的立场，这个「行」是感觉到我们对于当前的一切事情都不满意，要重新创造一个生命的时候，那叫作「行」。这个「行」也是有差别的，也是不一样的。不一样的，主要是什么呢？这地方说「令知三乘方便根本果差别故」，前一番「为示境别」这句话是总说的；「令知诸法体、相、位别」是别说的；这一句「及示行别」也是总说的；「令知三乘方便根本果差别故」，这是别说的。</p>
<p>　　这个「行别」是什么呢？主要指三种佛法，三乘，声闻乘、辟支佛乘、佛乘，这三种佛法。三种佛法里面有方便、有根本、有果的不同，每一种佛法都有这三种不同。</p>
<p>　　这个「根本」是什么呢？「根本」是发心，譬如说是这个声闻乘的佛法，要发出离心，这是「根本」。这个发出离心也就是发愿，你有这样的志愿：「我感觉到生死是苦，我想要得解脱」，你有这样的坚定的意愿，然后你才能够有戒定慧的修行，所以这个发愿是个根本。</p>
<p>　　这个「方便」呢？就在凡夫位的时候的修行，叫作「方便」；入了圣位以后叫作「果」。</p>
<p>　　声闻乘也有这三种，辟支佛乘也是有，乃至一佛乘也是有，有这种差别。</p>
<p>　　我们学这个…弥勒菩萨造这部论，就是「为示境别」、「为示行别」，是这样意思。「令知诸法体、相、位别」，「令知三乘方便、根本、果差别故」，是这样意思。我们若学习这部论，也就会得到这样的知识，得到了这样的智慧了。</p>
<p><strong><em>如是等类所为诸缘，处处经论种种异说，当知皆是此论所为。</em></strong></p>
<p>　　这一句话总结前面这「十番两缘」。前面这么多的类，也可以说是十类。「所为诸缘」，这就是本论所希望成就的这么多的因缘。「处处经论种种异说」，这是说到其他的经论里面。佛在…我们的佛陀在各地方所演说的经，乃至佛的弟子所造的论，经里面、论里面有种种不同的说法。说到学习佛法得到什么什么好处，这些事情。「当知皆是此论所为」，我们应该知道都是此《瑜伽师地论》所成就的。</p>
<p>　　这是这个…这「十番两缘」是《瑜伽师地论释》，那个最胜子菩萨造的，《瑜伽师地论释》是谁作的呢？是印度的最胜子所造的。他说《瑜伽师地论》有「十番两缘」的所为，有这样的不同。</p>
<p><strong><em>第二、彰所因者。</em></strong></p>
<p>　　一共有六大段，现在是第二段。「彰所因」，显示这个《瑜伽师地论》是【唯识学】成立的因缘，为什么这个时候有这样的佛法出现？</p>
<p><strong><em>按《释论》等云。</em></strong></p>
<p>　　这句话是这个遁伦法师说的。这「按」就是根据的意思，根据这个《瑜伽师地论释》，还有其他的参考书上说的。</p>
<p><strong><em>佛涅槃后，魔事纷起，部执竞兴，多着有见。</em></strong></p>
<p>　　这个我们的释迦牟尼佛入涅槃以后，据这个印顺老法师，对《印度佛教史》的研究，这个佛涅槃后，到这个公元（今年是一九九六年），从佛涅槃那一年到一九九六年的第一年，中间有多少年？印顺老法师他的研究，三百九十年。佛涅槃那一年计算，一直到一九九六年的前一年。这三百九十年，再加上一九九六，就是佛灭度以后到今天就这么多年。他说得很清楚。他说这个数，这个数是这个…这个数怎么算法的呢？就是佛灭度以后到阿育王登位这个时候，这是一个数。这个数是在我们汉文的《藏经》里面有十八部论，就是小乘部派佛教有分十八部。这部论上说，是佛灭度以后一百一十六年的时候，阿育王登位，说得很清楚，一百一十六。那么阿育王登位到公元前一年是多少年？再加起来，那就是三百九十年。三百九十年，去了一百一十六，那就是那个数，就是阿育王登位到公元前一年。公元其实就是公元，就是耶稣历，再加上一九九六，就是这么多。所以根据这个…这一百一十六年是我们汉文佛教的文献上说的。若根据缅甸佛教他们的说法就是不同了，那就不一样。不过若根据这个说法，这是两千三百八十六年。一九九六加上三百九，就是这么多年，还没到两千五百年。没到两千五百年，两千三百八十六。这样说呢？孔夫子要比释迦佛先多少年。孔夫子在先，孔夫子好像是两千五百年左右。若释迦佛说是有八十岁的话，再加上八十岁，二三八六再加上八十岁，那才两千四百多年；孔夫子两千五百多年，所以孔夫子在前，释迦佛稍微晚几年，晚多少年，这个数应该是这样子。</p>
<p>　　「佛涅槃后」，这个「涅槃」在这里用我们人的语言来说，就是逝世了，就是过世了，应该是这么说。就是佛过世以后，应该是这么说。</p>
<p>　　「魔事纷起」，就是在佛法里面捣乱的这些事情，「纷纷」，很多很多的事就都起来了，兴起来。</p>
<p>　　「部执竞兴」，佛法里面的这些学者，这些修学佛法的人，「部执竞兴」，一部分、一个学派、一个学派的，大家的思想不同，互相彼此都有争论，这个「竞」，彼此都有争论。一个学派、一个学派的兴起来，兴起来一个学派以后，这个学派又分裂了，又出来多少个学派。这个在《佛教史》上看是这样子的。在这个玄奘大师翻的《异部宗轮论》是一共有二十个学派，有这么多。</p>
<p>　　「多着有见」，这么多的学派里面，若是给它一个批评的话，多数都是执着有见，都是执着「有」。这个「见」就是执着。对于「有」的执着很厉害，过去也是有、现在也是有、未来也是有，说【一切有部】就是。其他的学派多数执着「有」，就是少数是不执着「有」的。其中二十个学派里面有个【犊子部】，【犊子部】其实就是锡兰的佛教，这个执着有个不思议的、不可说的「我」，执着有「我」，但是这个「我」是不可说的。当然这里面，也是不是那么一句话就能说明白的。都是执着「有」。这样子呢？对于释迦牟尼佛的佛法就有点偏了，佛法就走偏了。</p>
<p><strong><em>龙猛菩萨证极喜地，采集大乘无相空教造《中论》等，究畅真要，除彼有见。</em></strong></p>
<p>　　这印度的佛教的历史，的确不是容易研究的，而印顺老法师他的看法也未必都能同意，但是他可是研究得很清楚。他说龙树菩萨出现在什么时候呢？出现在公元一百五十年到两百五十年这个时代。一百五十年到两百五十年这个时候，龙树菩萨在这个时候出现的。可是各地方的记载，龙树菩萨寿命很长。寿命很长有多长呢？印顺老法师说一百岁已经很长了，他这么说，所以公元一百五十年到两百五十年这个时候。</p>
<p>　　这个「龙猛菩萨」也就是我们一般说的这个龙树菩萨，造《中观论》的这位大德。这个《藏经》里面有《龙树菩萨传》，有《提婆菩萨传》，有他的《传记》的。</p>
<p>　　「证极喜地」，就是他在佛法里面修学，已经达到「极喜地」的这样的程度了。就是菩萨有十地，就是第一地是极喜地。得了圣道以后心里面特别的欢喜，所以叫作「极喜地」。</p>
<p>　　「采集大乘无相空教造《中论》等」，他「采集」，他在佛陀所宣说的「修多罗」里面，所说的佛法里面「采集」，就是根据佛所说的这部经、那部经，主要是般若经。佛说的「无相」的「空教」，根据佛说的大乘的无相空教，这个「教」指佛说的，佛说的一切法空，无相的道理，来造这个《中论》的这一本书。《中论》、《十二门论》、《大智度论》乃至这个《十地经论》，翻到中国来有《十住毗婆沙论》，也是龙树菩萨造，还有《发菩提心论》也是龙树菩萨造的，这是翻到中国来的。造这部…龙树菩萨根据，「采集」，从这么多的大乘无相空教里面采集来的佛法，也等于是学习，「采集」也等于是学习的意思。学习了大乘无相空教的佛法，他为了弘扬佛法普度众生，他作了一部《中论》，还有其他的一些论的书。</p>
<p>　　「究畅真要」，他能够究竟的通畅、通达了佛法的「真要」，佛法的真义的纲要，他能达到这个程度。</p>
<p>　　「除彼有见」，破除去这个【小乘佛教学者】的这个「部执竞兴、多着有见」的这种过失，破除去这些毛病。</p>
<p>　　这上面是说什么呢？因为着「有见」了，所以龙树菩萨造这个「说一切法空」的这种书、这种论，这是缘起是这样子，所以「此有故彼有」，就是这样意思。</p>
<p><strong><em>圣提婆等诸大论师造《百论》等，弘阐大义。由是众生复着空见。</em></strong></p>
<p>　　这个「圣提婆等」，这个「提婆」，在他的传上看，他是现在的锡兰，斯理兰卡的人，他不是大陆上的人。所以说加个「圣」字，是说这个人不是凡夫，也是圣人。他呢，「提婆等」，不只他一个人。是「诸大论师」，这个「提婆」是龙树菩萨的学生，是他的弟子。龙树菩萨寿命很长，威望很高，当然他的学生也是很多。所以「诸大论师造《百论》等」，这个《百论》，说有一百个颂，所以叫作《百论》，这个也翻成汉文了。玄奘大师又翻造《百论》，这叫《广百论》。「造《百论》等」书，「弘阐大义」，他弘扬阐释佛法的大义。</p>
<p>　　「由是众生复着空见」，由于龙树菩萨、提婆菩萨等「诸大论师」，弘扬大乘无相空教。众生学习这样的佛法，逐渐的也有出了毛病了，「复着空见」，又执着了「空」，对「空」又执着的很厉害，也又偏了，又走偏了。那么又走偏了，这个话的意思，龙树菩萨、提婆菩萨所说的大乘空教是符合佛意的，是没有偏，是正确的、没有过失的。但是后来学习的人搞错了，所以「复着空见」，这话有这样的味道。</p>
<p><strong><em>九百年时，有出家士名阿僧佉，唐云无着。应中印度阿瑜陀国（本生处者北印度犍驮罗国是也），其国王城西五百里，营立禅省，领数百人授以禅法。</em></strong></p>
<p>　　这下面就说到《瑜伽师地论》的出现的因缘了。</p>
<p>　　「九百年」的时候，就是佛灭度以后九百年的时候。但是我看印顺老法师的研究呢？他说这个「九百年时」是什么时候呢？说无着菩萨是公元四零五年圆寂的，他活了七十岁，说无着菩萨活了七十岁。那么向上推，四○五去掉七十，那是多少？三三五？三三六。三三六到四○五，这个无着菩萨是在这个时代。在这个时代，若是这样说，再加上三百九十年，是多少年？那和这个九百年数是不对的，数就是不一样了。</p>
<p>　　在这个时候「有出家士」，就是离开了家，这个「家」这个字怎么讲？我姑妄言之，「家」者烦恼也。离开了烦恼的家的人。</p>
<p>　　所以我也有的时候，有时候听人家彼此谈话的时候，「家师」怎么、怎么的…，这是我们出家人，在家人我们不说。「家师」怎么、怎么的…。再就是我们出家人的戒律上说是「出家非家」，有这种字。所以我们想一想，我称我的师父的时候，「家师」怎么、怎么的…，「家师」。你再想一想，用这个字对不对？再想一想喔！本来这还是…这句话也是很…要读书的人才会说这句话的，但是在佛法上说，再想一想，应该怎么说？</p>
<p>　　「有出家士名阿僧佉」，「阿僧佉」是印度话、梵语，「唐云无着」，翻个无着，有的地方翻个无障碍，没有执着。</p>
<p>　　这个无着菩萨这个人，在他的传上看，这个人的性格是很刚烈的，不得了。好像是传上说，他出家以后他很快的就得到四禅，初禅、二禅、三禅、四禅。得了禅定以后修这个空观，修不来，修不来就要自杀，这个人的性格是这样子。后来说是宾头卢尊者在东胜神州（我看那个意思有可能就是在中国。宾头卢尊者可能是在中国），他看见无着菩萨要自杀，他就来了。来了，向他开示小乘佛法的空观，一开示他，他一修行就成功了。成功了还不满意，不满意乘着神通去见弥勒菩萨，弥勒菩萨为他说大乘空观，他再一修行就成功了，还有这个事情。「唐云无着」。</p>
<p>　　「应中印度阿瑜陀国」，这里说这个「应」应该当「现」字讲（现在的「现」），就是出现。这个无着菩萨，这位菩萨他出现在中印度阿瑜陀国，出现在这里。这个「阿瑜陀国」，我查那个字典上，它是中印度的边上，靠近北印度，是这样。这个「阿瑜陀国」翻到中国话，翻个「不可战」，你不可以侵略它，就是是这个意思。这个国必是很强大，其实不一定这样讲，反正最初立这个名字。比如说我们叫「中国」、这叫「美国」，最初就是立这个名字就是了。</p>
<p>　　「本生处者」，这个阿瑜陀国是它的本生处，在「北印度犍驮罗国是也」，这个地方就说是北印度了，这个「犍驮罗国」翻到中国话，翻一个「香风」，也翻一个「善胜」。「香风」就是这个国里面很多的能发出来香的树和花，所以这个国你到处都是有香风、香气。</p>
<p>　　这个印顺老法师说，这个《大般若经》里面那个〈法涌菩萨品〉，昙无竭菩萨、萨陀波伦菩萨那一品，说那个众香城就是这里。印顺老法师他这么解释，就是这里。</p>
<p>　　「其国王城西」，这个王城的国都的西边有「五百里」。「营立禅省」，这无着菩萨在那个地方造一个禅寺，就是一个禅堂。这个「省」就是宫殿的意思，宫舍的意思，就是一个建筑物的意思。在那里造一个禅堂，一个禅寺，或者这样说。「领数百人授以禅法」，教授他们修禅的法门。</p>
<p><strong><em>无着为人位登初地，证法光定得大神通，事大慈尊请说此论等。</em></strong></p>
<p>　　「无着为人位登初地」，这个龙树菩萨位登初地，他也是「位登初地」。「证法光定」，他成就了法光定。这个「光」就是智慧；这个「法」就是第一义谛了。觉悟第一义谛的大智慧光明，得到这样的禅定，所以这个「定」，不但是定，而里面有智慧的。</p>
<p>　　「得大神通」，他具足了前五种神通，漏尽…也应该有一部份的漏尽通。</p>
<p>　　「事大慈尊」，他承事这个「大慈尊」就是弥勒菩萨，天上的弥勒菩萨。「请说此论等」，这个无着菩萨有神通，能到天上见弥勒菩萨跟他学习，这件事应该是可信的。</p>
<p>　　我看印顺老法师，看他以前写的书、后来写的书，我前后对照着，印老法师的思想有点变化。他以前写的书上，他说这个「无着菩萨事大慈尊」，这个弥勒菩萨是人间的学者，印顺老法师是这么说。可是后来呢，这个话就有点转变，说无着菩萨到天上去跟弥勒菩萨学法，他就不再说是人间的学者了，这句话不说了。就是他有一点转变，相信这弥勒菩萨是天上的，是这样子。他也举出来一些事实的。在印度的佛教里面，常有些法师学习佛法的时候，这一段佛法不懂。不懂，当时有阿罗汉嘛，就去问这阿罗汉，阿罗汉也不懂。阿罗汉不懂，说：「不要紧！我带你到天上去见弥勒菩萨！」有这种事情。向弥勒菩萨去学习、去问一问。那么在印度的佛教这个种事情是很…不说普遍嘛，这件事也是常常有的。那么无着菩萨既然是得了禅定有神通，这件事也应该是有的。</p>
<p>　　另外一个想法呢！就算是得了禅定没有发神通，也可以拜见弥勒菩萨的，怎么呢？一入了定的时候，你心里面想弥勒菩萨，也就和弥勒菩萨能见面，在禅定里面可以见面。若是得了神通，那就又不同，可以乘身…这个身体可以到天上去见弥勒菩萨，可以达到这个程度。所以「事大慈尊，请说此论」，请求弥勒菩萨为我们开示「此论」，此《瑜伽师地论》等，这样子。</p>
<p>　　在这个《婆薮盘豆菩萨传》，就是《世亲菩萨传》上，有提到无着菩萨这件事。说无着菩萨，他到天上去向弥勒菩萨学习佛法，然后回到人间就向我们人间的人去宣说，人间的人不相信，不相信这件事。不相信这件事嘛，这无着菩萨就请求弥勒菩萨来到人间来，那上面是这样说这件。「请说此论等」。</p>
<p><strong><em>慈氏菩萨随无着机，恒于夜分从知足天降于禅省。</em></strong></p>
<p>　　这就说到了。这个慈氏菩萨随顺无着菩萨的「机」，随顺他的诚心的请求，「恒于夜分」，常是在夜间的时候，不是白天。「从知足天降于禅省」，兜率天，「兜率」翻到中国话翻个「知足」，就降到人间这个阿瑜陀国。阿瑜陀国，无着菩萨的这个地方，这个禅寺在这里。</p>
<p><strong><em>为说五论之颂。一、瑜伽论。二、分别观行名分别瑜伽论。三、大庄严论。四、辨中边。五、金刚般若。</em></strong></p>
<p>　　「为说五论之颂」，为无着菩萨、为一切人宣说五种论的颂。那五种论的颂？就是一、「瑜伽论」颂，《瑜伽师地论》里面也有很多颂。</p>
<p>　　二、是「分别观行名分别瑜伽论」这个颂，这个没有翻译过来，但是《解深密经》里面有个〈分别瑜伽品〉，应该和〈分别瑜伽品〉，应该有…有可以相通的地方。</p>
<p>　　「三、大庄严论」，《大庄严论》也翻译成汉文了，我们《藏经》里面有这部书。</p>
<p>　　「四、辨中边」，这个《辨中边论颂》也是弥勒菩萨说的。</p>
<p>　　「五、金刚般若」，《金刚般若论》的颂也是弥勒菩萨说的，这一共是五种。</p>
<p>　　五种就是缺少了一种，没有翻成汉文。</p>
<p><strong><em>于时门人，或见光明，不见相好，不闻教授；或见相好，不闻教法；或见闻者。</em></strong></p>
<p>　　说在当时弥勒菩萨慈悲来到人间说法的时候，当时在禅堂里的人，当然不只无着菩萨一个人，还有很多人。很多人、大家的境界不一样，有人看见弥勒菩萨放光明。「不见相好」，没有看见弥勒菩萨的相好，相好没有看见、只是看见光明。「不闻教授」，听不到弥勒菩萨说法，不知道、听不到，但看见光明。</p>
<p>　　「或见相好，不闻教法」，或者这个人也看见光明了，也看见弥勒菩萨的相好，但是听不到他说法，这个人的境界不一样。「或见闻者」，或者又看见了、又听到了。</p>
<p>　　我现在再多说几句，我说我个人的事情。我初出家时，我在家的时候，我叔叔先出家了，请一位法师，就是我出家的师父，到我们家去讲经。我叔叔就把我们…我们是在农村里住，就是通知那个村庄里的人，大家都很熟，就是来听我师父讲经，讲《佛说阿弥陀经》，讲这部经。我也在那里听，但是心里面都是打妄想，不能专注、一心不乱的听法，我只能听到不超过十句。我师父在那儿讲经，大概也是可以讲到一个钟头吧，我顶多有听到十句，其他都不知道说什么。是这么个境界。等我出家到了寺院去，就是佛学院了，去听经的时候，不打妄想，一个妄想也没有。法师讲课，我一句一句完全能听到的。那个时候，我的记忆力比现在好，我不像你们还有拿笔记，我没有笔记。我没有笔记，当时有一个法师叫通如法师，他是日本早稻田大学毕业的，在满州国的时候作过邮政局长，作官的，他出家了。日本垮台了，他马上出家。出家了，我们同时在那里听课，他年纪大了，他有的时候必是打妄想，这一段没听到，他就叫我重讲，我就立刻，不需要温习，我立刻就是从头讲一遍给他，那等于是回讲了。我那个时候有这种境界。</p>
<p>　　可是学习了多少年的时候，我看至少有三年到四年以后，我的思想有点变化，有什么变化呢？我心里面要要求，我要明白什么是佛法？我心里有这么一个心情。一开始听法师讲经，你讲我听就是了。我还没有说「我发出一个心愿来，我要明白什么是佛法？」没有这个心情。</p>
<p>　　我发出来这个愿的时候，「我要明白什么是佛法？」以后呢，因为和同学有点烦恼，就不高兴在佛学院了，就离开了佛学院。离开了佛学院，但是我自己有这个愿，这个愿没有退，我继续读书，继续的阅读佛书、阅读经论，继续的阅读，不停下来。</p>
<p>　　我到了台湾去打禅七，有人小参的时候，有一个年纪很大的居士：「你十年寒窗苦啊！」，他说我这么一句话。我自己算的确也是十年。从开始读书，开始到佛学院，读了十年以后，开始有人请我讲经，的确也有十年。</p>
<p>　　我说这话什么意思呢？《瑜伽师地论》一百卷，不算短了。在我们的程度来说，这一百卷是很长了。很长、不是短时间，我们昨天说，大概要两年才能学完，要有点耐心。有的地方，我们可能有欢喜心，有的地方不见得。有的地方就感觉到：「说这个有什么用呢？」可能会有点厌烦心。但是若是你本身；「我要学习佛法，我要明白什么是佛法」，你若有这个愿呢！你的恒心就有了，就会有恒心，就能把这一部论，从头到底的学习完了。</p>
<p>　　当然，「我不要听你妙境在那里胡说，我自己也可以读」，那也可以，自己读也是可以，也不是说不可以。有参考书也好嘛！也是可以读。自己读也要有恒心的，你没有恒心也是不行。但是我在想，你拿出点精神，你在这里听讲也可以，你自己读也可以。你能完全的用点心把它完全的读完了，你会生大欢喜心，你会生欢喜心。</p>
<p>　　然后你再去听别人讲经，你的感觉不同。听别人讲经，感觉不同了。所以我们有的时候说；某一个人赞叹一个人，说他讲得「不好」。有人说那人讲得「好」。我们听见这句话，怎么讲？心情怎么想法？</p>
<p>　　我有的时候就会想：「你的程度怎么样呢？」你批评别人，你的程度怎么样？你的程度够，你批评人可能有一点…有一点多少真实性。如果你程度不够，你批评未必是对的，你未必是对的。但是要有这个程度，你非要广学佛法不可，不然你不知道，你不知道究竟是怎么回事啊？不知道的。所以「观于海者难为水，游于圣人之门者难与言」，这话说得是对的。</p>
<p>　　我希望各位能够发出来一种学习佛法的愿，我不是劝你们要出家，不是这个意思。就是发出这个愿；「我要明白什么是佛法？究竟是怎么回事情？」印度的佛教或者我们不说，就是佛教来到中国，有这么多的大智慧人来到佛教里面来。</p>
<p>　　头几年我看见一本书，是中国大陆出版吧？不是很久，就是共产党执政以后，可能是文化大革命以后出版的书，就是印这个古书、中国的古书。那个前面有个序，好像一个姓张的这个人，他可能是个大学教授。他说：大概是南北朝以后，周、秦、汉，汉末三国以后就是南北朝，还是南北朝以后，中国的文化的这些学者里面，再没有有份量的哲学的书出来，再没有。因为什么呢？那个作者说了，他说：「这些大智慧的人都跑到佛教里面去了。」哎呀！这个人敢说这种话。在共产党里敢说这种话。</p>
<p>　　所以我们现在学习佛法，你想一想喔！这么多的大智慧人跑到佛教里面来，因为什么？佛教有什么力量能够摄受这么多有智慧的人？我们从这里想一想，我们学习佛法的愿可能会强一点，强一点就会有恒心了，有恒心你就会有成就。我就说到这里。</p>
<p><strong><em>问：</em></strong>刚才您讲到无着宾头卢尊者为他讲小乘佛法的空观。又听，弥勒菩萨为他说大乘空观。这个小乘佛法的空观和大乘的空观有什么比较大的差别？</p>
<p><strong><em>答：</em></strong>小乘的空观就是我空，观我空，观察色受想行识都是无常，我不可得。常恒住、不变易的我、实体性的我没有。这是小乘的空观。或者说修小乘的…修这无常观，色受想行识都是无常，剎那、剎那生灭变化的。比如说「无明灭则行灭，行灭则识灭，识灭则名色灭，名色灭则六入灭，六入灭则触灭，触灭则受灭，受灭则爱灭，爱灭则取灭，取灭则有灭，有灭则生灭，生灭则老死灭」，所以是无常，从这里能入到毕竟空里面去。这空观。</p>
<p>　　若大乘空观，比如若是说这个…就《摄大乘论》说的「唯识无义」，这是空观。那就和小乘空观有点不同，是不一样的。</p>
<p><strong><em>问：</em></strong>二乘、无性？</p>
<p><strong><em>答：</em></strong>就是声闻和辟支佛。辟支佛是印度话，缘觉是中国话，它们是一回事。不过也点地方说个独觉（辟支佛翻成中国话叫做「独觉」），就是不须要老师的教导，他自己就可以觉悟，叫做独觉。</p>
<p><strong><em>问：</em></strong>今天讲到那个「开因缘、唯识、无相、真如四理门」，这个真如门的话，不太清楚？师父讲的和「如来藏」有关系？</p>
<p><strong><em>答：</em></strong>如果这么讲，如果是按大乘佛法里面有三个学派，那么唯识是一个学派、中观是个学派、那真如就是「如来藏」，可以这样解释。</p>
<p>　　但是看这个文上，不感觉有这样的意思。那么这个真如是怎么呢？真如就是「因缘、唯识」、中观所悟入的理性，那叫做「真如」。</p>
<p><strong><em>问：</em></strong>请问在《瑜伽师地论》里面是不是包括佛法的三大系都有在里面，是不是？</p>
<p><strong><em>答：</em></strong>也有，也是有。也有，但是它还是唯识学者的立场</p>
<p><strong><em>问：</em></strong>所以它偏重在唯识的立场。</p>
<p><strong><em>答：</em></strong>对，你比如说这个般若是观一切法空，但是它用唯识的立场来解释这个空，那就和中观学者所解释的不一样，是这样。</p>
<p>　　我刚才说那个中国大陆出版的那个书，前面那个序的文。你们这里也有在大陆读书，你们看见这个序没有？</p>
<p>　　这个书我现在在图书室里有，是一个姓张写的，我认为这个人是有一点智慧。</p>
<p><strong><em>问：</em></strong>昨天的「有见、无见」和「六十二见」是怎么样的关系呢？</p>
<p>　　是从「有见、无见」开出来「六十二」呢？还是「有见、无见」合在一起，详细分可以开「六十二」见？</p>
<p><strong><em>答：</em></strong>「六十二见」说法很多。「六十二见」说法很多、很多的，不是一种。一种多数都是可以说是「有见」，都是执着色受想行识是我、我所，那么这多属于「有见」。另外有一种说法那是很多、很多的说法。</p>
<p>　　不过通常说执着有我是常住不变，那么就是「常见」，拨无因果就是「断见」，就是「无见」了，这样解释。</p>
<p>　　但是在唯识上，又多出来一个说法，就是你不见「如幻有」的，拨无「依他起」、「圆成实」，那就是「无见」了；执着我们所见闻觉知的一切法，是离开了心，有它独立的体性的，那么就是「有见」了。就是「遍计执」了。「遍计执」就是「有见」。但是「遍计执」又不限于「有见」。「遍计执」在凡夫的时候也可能会有「断见」，「断见」也是属于「遍计执」。</p>
<p><strong><em>问：</em></strong>请问「无见」，拨无「依他起」是不是也就是「拨无因果」呢？</p>
<p><strong><em>答：</em></strong>也就是拨无因果。但是拨无因果是「无见」，若执着有因果，那么就是「有见」，那究竟怎么样才是对？怎么样才是正见呢？（叫人答）</p>
<p><strong><em>人答：</em></strong>（因果确实是「有见」，可是它是没有自性的，所以还是算是不着「有、无」，虽然一切法是自性空，因缘所生，但是它的因果是景然分明，它毕竟不违反这个因果。所以不在有边、不在无边，但是在现象来讲、在因果还是如幻如化，但是当体是「唯心所现」。</p>
<p><strong><em>答：</em></strong>你解释还很好。</p>
<p>　　因为若说是没有因果，说空了就是没有因果，那么不是「无见」了吗？</p>
<p>　　你什么解释，假设我这样问，因也是无自性，在无自性上看就是没有因了，我也是无自性，那么无自性不是果也就是空了，没有因果了，那么是不是「无见」呢？我这样问你，你怎么解释？人答：对于这个因果的这个幻象还是有它的作用，可以影响从有到无之间的修行。…）</p>
<p><strong><em>答：</em></strong>可以，讲的还可以。</p>
<p>　　这意思说因果是空也是对；因果不空也是对，但是这个道理要解释一下。解释一下，刚才你说是对，因和果都是因缘生法。因缘生法就是无自性。在无自性那一方面看呢？就是没有的。因也不可得、果也不可得；众生也不可得，乃至佛都是不可得。但是无自性空同时因缘还是宛然有的。这个如幻如化的因缘生法还是有，只是因缘生法里面没有自性就是了，因缘生法还是有的，所以还是有因有果。</p>
<p>　　说这个光明是自性空，你说自性空的时候，这光明还是有的。并没有说是什么都是没有。但是说没有，是在自性空那的面说是没有。</p>
<p>　　比如说现在有声音，声音在自性空那一方面说，声音是没有的。</p>
<p><strong><em>问：</em></strong>可以用「缘起性空」式来解释。</p>
<p><strong><em>答：</em></strong>是的。所以说因果是空，而同时因果是有，应该是这样意思。如果说因果决定是不空，那就是「有见了」。</p>
<p>　　就是这个中观上所说的空、所说的有，和我们一般人说的空又不一样，是不共的。</p>
<p>　　在唯识上说呢？唯心所现的因果还是有，离开了心，另外因果是没有的。那么也是有「空」、有「有」的意思。和中观论说法是不一样。</p>
<h3 id="第3讲"><a href="#第3讲" class="headerlink" title="第3讲"></a><strong><em>第3讲</em></strong></h3><p><strong><em>然世代玄远，名既湮灭，唯有无着，天人共知，感慈氏化，[冰-水+食]（餐）受诸教。</em></strong></p>
<p>　　这是第二大段「彰所因」。这一大段似乎是从【佛教历史】、从【印度佛教史】，来说明《瑜伽师地论》的发起，说明造《瑜伽师地论》的因缘。和前面「叙所为」有一点不同。</p>
<p>　　「然世代玄远」，这里是说无着菩萨请弥勒菩萨来到人间说法这件事，不只是无着菩萨一个人听法，同时也有很多人的。那些人多是谁呢？「然世代玄远」，然而因为这个时代过去了，到了后来，已经很久远了。「名既湮灭」，多是谁，没有纪录下来，所以那些名字也都不见了。</p>
<p>　　「唯有无着，天人共知」，唯独无着菩萨，人间的人知道，天上的人也知道。他是请弥勒菩萨来人间说法。「感慈氏化」，就是他的程度高，特别的身清净、口清净、心清净，有特别的诚心，所以感动了弥勒菩萨来到人间教化，说这一部《瑜伽师地论》的。</p>
<p>　　「餐受诸教」，这无着菩萨他是跟弥勒菩萨学习这么多的佛法。这个「餐」是吃饭，这个学习佛法就像吃饭似的，放在口里面要嚼，然后到胃里面消化，然后到肠里面，十二指肠、小肠，这样的消化，得到了营养，把这些营养普遍到全身，然后这个人才得到它的好处。那么学习佛法也应该是这样子，从闻思修得无生法忍的。这个「诸教」就是前面《瑜伽论》、「分别观行」名《分别瑜伽论》、《大庄严论》、《辨中边》、《金刚般若》，指这么多说的。</p>
<p><strong><em>今此论中，理无不穷、事无不尽、文无不释、义无不诠、疑无不遣、执无不破、行无不备、果无不证。</em></strong></p>
<p>　　「今此论中，理无不穷」，这底下呢，这以下单独说《瑜伽师地论》。「今此」，《瑜伽师地论》中。</p>
<p>　　「理无不穷」，佛所说的真理，在这一部论里面没有不说明的。「穷」就是没有余剩的，没有剩余的，只讲了一部分，还有一部分没有说，那就是「不穷」了。现在全部的都说明了。佛说的真理，全部的都有说明，所以叫做「穷」。</p>
<p>　　「事无不尽」，这个「事」，这个因缘生法的事。六道众生是染污的缘起的事；四种圣人是清净的缘起，也是「事」，这些因果都是事。这些事，在这一部论里面也完全的为我们说明了，没有遗余的了，所以叫做「尽」。</p>
<p>　　「文无不释、义无不诠」，前面「理、事」是一双，这下面是说「文、义」又是一双。</p>
<p>　　这个「文」是能诠显的，就是能表达的；「义」是所表达的。能表达的「文」，这个「无不释」就是…这一部论的文，对于若理、若事没有不解释的。</p>
<p>　　「义无不诠」，这个「义」就包括理、也包括事，也没有不诠显出来的。</p>
<p>　　「疑无不遣、执无不破」。有「理、事」，有「文、义」，这样子说明了有什么好处呢？「疑无不遣」，你是信佛的，你是不信佛的，你对于佛法所有的疑问，如果你学习这部论的话，都能够排遣出去，叫你没有疑，叫你对于佛法能生起坚定的信心。</p>
<p>　　「执无不破」，有信是有信，但是这个执着心还是在的，那就要加一番修行才可以。所以这个我执、法执没有不破除去的，那么你就转凡成圣了。你相信佛法，想要得无上菩提的愿力，就成功了，「执无不破」。</p>
<p>　　「行无不备、果无不证」，前面这个「疑」和「执」是破恶；这底下「行」和「果」是生善，破恶生善，这又是一双。</p>
<p>　　「行无不备」，就是要破疑、破执，不是空口说话就可以成功的，是须要修行的，你要修这个四寻思、四如实智，这样用功修行。这种修行的法门呢？在《瑜伽师地论》里面，完全的都具足了，没有缺少，没有说还有一样修行法门没有讲，不是的，「行无不备」。</p>
<p>　　「果无不证」，不管是【小乘佛法】里面的四果、四向；是【大乘佛法】的十地，那么多的圣道的果、所得到的果，也都能证得的。你若是按照《瑜伽师地论》去修行去，都能成就的，「果无不证」。</p>
<p>　　这可见这一部论非常的圆满，也就是非常的重要了。</p>
<p><strong><em>自非玄鉴高士，孰能唱和于此者哉？</em></strong></p>
<p>　　「自非玄鉴高士，孰能唱和于此者哉？」说是这一部论…若想要学习这一部论，这里面说是包括…这句话是赞叹。赞叹说论的人、赞叹学习论的人，这个「唱和」，「唱」就是造论的这个人，就是指弥勒菩萨说的；「和」就是学习这部论的人，一唱一和。这部论这么样圆满、高深，如果不是「玄鉴高士」，谁能够及格呢？「谁能唱和于此者哉」呢？这个「玄鉴」，这是要圣人的智慧叫做「玄鉴」，有微妙的智慧。这个「鉴」就是无漏的智慧的照见，「照见五蕴皆空」这个「照」就是叫做「鉴」，就是微妙的智慧。若没有、若不是具足微妙的智慧，那么高尚的人士啊，这一定…这是的确也是不简单。「孰能唱和于此者哉？」那个人能对此论能唱、能和呢？那个人能「唱和」于此论呢？就是你想学习也不容易，何况造论的人啊！是这样意思。</p>
<p><strong><em>奘法师以超世之量，悼还源之梗流，故能出玉门而遐征，戾金沙而殉道。乃到中印度‧摩揭陀国‧那烂陀寺。</em></strong></p>
<p>　　那么这底下呢，前面这个「自非玄鉴高士，孰能唱和于此者哉？」是结束前面这一段文，同时也发起下面一段文了。前面是赞叹弥勒菩萨、赞叹无着菩萨，但是这里面也有赞叹下面玄奘法师的意味在里面喔。</p>
<p>　　「奘法师」，玄奘法师。「以超世之量」，这个玄奘法师，他是超越世间的那种大智慧的心量，大慈悲心的心量。看看《玄奘法师传》，的确不是平常人，不得了，这个人！</p>
<p>　　「悼还源之梗流」，这个「悼」有个悲恸的意思，悲伤的意思。那么悲伤，什么事情令他悲伤了呢？「还源之梗流」，「还源」（这个「源」，就是第一义谛了），就是由凡夫在虚妄分别中受诸苦恼的这种境界，回到第一义谛去。「之梗流」，中间有障碍。中间什么障碍呢？这就是…这里面是说印度的佛教经过梵僧，加上中国人本身各位大德的努力，传到中国来翻成汉文，就是这些佛法。这些佛法是「还源」的法门，但是「梗」，梗是阻碍的意思，有阻碍。譬如说这个流，这个坐船在水里面走，走到中间有阻碍。这个法流，初果须陀洹叫做预流，预流也就是预圣流，也就是法流。圣流，现在说佛说的这一切法，都是流入圣道的一种法门。现在在这里面有阻碍，有「梗」，有阻碍。那么是有什么阻碍呢？</p>
<p>　　我从《玄奘法师传》上引来这么三页。这三页，你们拿这三页来看。这三页，其实引这个三页似乎是说得太多了，但是我的想法是：一方面明白这句话，「悼还源之梗流，故能出玉门而遐征」，为了解释这句话，要引；另外我们要知道，究竟玄奘大师为什么要到印度去？到印度去干什么？我们一般说他到那儿去取经去，但是从《玄奘法师传》上，说的就明白了。</p>
<p><strong><em>《大唐慈恩寺三藏法师传》卷一第八页：</em></strong></p>
<p><strong><em>法师既遍谒众师，备餐其说。详考其义，各擅宗涂。验之圣典，亦隐显有异，莫知适从。乃誓游西方，以问所惑。并取《十七地论》以释众疑。即今之《瑜伽师地论》也。又言昔法显、智严，亦一时之士，皆能求法导利群生。岂使高迹无追、清风绝后？大丈夫会当继之！</em></strong></p>
<p>　　这个第一页，「法师既遍谒众师，备餐其说。详考其义，各擅宗涂。验之圣典，亦隐显有异，莫知适从。乃誓游西方。」这一段是在《大唐慈恩寺三藏法师传》的＜卷一‧第八页＞上说的。</p>
<p>　　「法师既遍谒众师」，就是玄奘法师，他「遍谒众师」，普遍的去拜见很多的大德。「备餐其说」，就是全面的、普遍的、具足的学习了他们的智慧，学习了他们所说的佛法。</p>
<p>　　从《玄奘法师传》上看，他一开始听人讲经是学的（《涅槃经》）《大般涅槃经》，学习《涅槃经》的。又学习了《摄大乘论》、《俱舍论》、《成实论》，又学习这么多的佛法。可是看那个文上，似乎是没有和【天台宗】的人接触，没有，没有和【天台宗】的人接触，我只有这个感觉喔！当然那个传也未必说的那么详细。</p>
<p>　　「详考其义」，这个「备餐其说」，这是听闻当时的学习；「详考其义」是后来的思惟，思惟各位大德的法门，各位大德所宣扬的佛法。</p>
<p>　　「各擅宗涂」，每一位大德都有他的专长。他所宗的法门、他所学习的法门，他对于那一个法门有深刻的学习、研究，他在这一方面他是有心得的。</p>
<p>　　「验之圣典，亦隐显有异」，但是他们说的法门，在经论上去考查一下，他们说的对不对呢？「亦隐显有异」，就是说的…这个「显」就是明显的；这个「隐」就是不明显。他说得对，或者他说得不对，都有这两面，有这两面的事情。这表面上是对，但是又好像有一点不大对，这个「隐」，这样子。或者是明显的是不对了，但是又不能完全说，又好像有一点是对的。</p>
<p>　　「莫知适从」，那么各位大德说的佛法是这样的情形，究竟说得是对、是不对呢？不能决定，我不知道谁是对的。适当的就是对的，对的我可以随顺，我不知道随顺那一个人说的才是对，我不能决定，就是有疑问了。</p>
<p>　　「乃誓游西方以问所惑」。这才决定，「誓」是决定的意思，决定要到印度去，「以问所惑」，向印度的大德请问我所疑惑的、所不明白的佛法。</p>
<p>　　「并取《十七地论》以释众疑」，我「问所惑」，「问所惑」这是一个目的；「取《十七地论》」，去请这一部论，「以释众疑」，来解释我心里面的众多的疑问、疑惑。这个《十七地论》是什么呢，「即今之《瑜伽师地论》也」。那么从这句话来说呢？到印度去请《瑜伽师地论》是他一个重要的目的。他为什么到印度去？这目的是在这里。</p>
<p>　　「又言昔法显、智严，亦一时之士」，这个玄奘大师他又说，这个传是别的人写的，是他的学生叫慧立法师写的。又说「昔法显、智严」，这个法显法师，他这是名称普闻，大家都知道，另外同时还有个智严法师。这个智严法师和法显法师似乎是同一个时代的人。</p>
<p>　　这个智严法师也和玄奘大师去印度这条路是一样，从新疆然后转到印度，也是这一条路去的。去到了罽宾国，就是北印度，到了罽宾国，到那边去。那个传上说这个人静坐特别有成就。他在那里遇见了这个佛驮跋陀罗。佛驮跋陀罗就是翻译六十卷《华严经》那一位（晋译《华严》六十卷），就是那位佛驮跋陀罗，他遇见他。这个佛驮跋陀罗想要到中国来，那么就是劝这个智严法师为伴，所以智严法师就回来了，就同他一同就回到…就是到了长安。那个时候呢？鸠摩罗什法师正在长安，是同一时代的人。到了长安的时候，佛驮跋陀罗和这个鸠摩罗什法师的弟子之间，我们看传上，大家有点事情，大家有点不和。不和，就有人在大众僧里宣布他不对劲，宣布这个佛驮跋陀罗有犯戒的事情，怎么、怎么地…，当然不是严重的戒喔。那么呢，这样一不和了的时候，佛驮跋陀罗就离开了长安，到卢山去了；可是智严法师没有随他去，还是在长安一个地方住下来用功修行的。从这一段记载，就知道智严法师和这个鸠摩罗什法师、佛驮跋陀罗在同一个时代，知道这件事。</p>
<p>　　但是这个智严法师后来又有事情，又有什么事情呢？他在没有出家的时候受过五戒，他犯了戒，这犯那一条戒？怎么情形？没有详细说，就说犯了戒。犯了戒然后若是再去出家受比丘戒，是不是得戒了呢？心里面疑惑。心里疑惑，也必是也可能会请问大德，但是疑问还没有决断。没有决断，他又去印度。那时候去是从水路去的，坐船，坐船去了印度。到了印度各地方去拜谒，遇见了一个阿罗汉。遇见阿罗汉，向阿罗汉说这件事，阿罗汉说，「我不知道。我不知道你究竟得戒、没得戒？但是我可以到弥勒菩萨那里去给你问一问」。所以这阿罗汉就入定，一入定在禅定中就到弥勒菩萨那儿去了，就请问弥勒菩萨。弥勒菩萨说是得戒了。这一下子这个智严法师大生欢喜，生大欢喜。然后他又到罽宾国去，又到了罽宾国。到了罽宾国，他就在那里圆寂了。</p>
<p>　　圆寂的时候还有点事情，就是那个地方这个比丘过世了的时候，如果是凡夫，在一个地方火化；如果是圣人，在另外一个地方火化。那么就把他送到凡夫那里火化，这个你抬不动他的身体，就是动不了；说是把他送到圣人那儿，一抬就去了。那么这位智严法师有弟子陪他的，那么又回到中国来，传说这件事。那么就知道这智严法师是圣人了，得了圣道了。这是智严法师的事情。</p>
<p>　　法显法师他是从水路去的，到印度。那上面说的也很殊胜，他看…拜这个…到灵鹫山去，看见一个九十多岁的老翁。后来，当时也感觉这个老翁不是平常人，可是没有特别的请问什么。等到老翁不见了，离开了的时候，问另外一个少年，少年说这是大迦叶尊者！哎呀，他就后悔没有多多请问他，也有这种事。法显法师后来回来也是很难的，回到好像是山东半岛，可能从青岛这个地方过来，到牢山这个地方。后来回到建业（建业就是现在的南京），就是遇见这个佛驮跋陀罗。</p>
<p>　　那么这可见这个法显法师和智严法师、佛驮跋陀罗、鸠摩罗什法师都是那个同一个时代的。不过这个时候已经是东晋的末年了。</p>
<p>　　「亦一时之士」，这个法显法师、智严法师也是那一个时期的一个豪杰之士，不是平常人。</p>
<p>　　「皆能求法导利群生」，他们都能够到印度去求取佛法，来利益、来教导一切众生的。这是赞叹他们两个人。</p>
<p>　　「岂使高迹无追、清风绝后，大丈夫会当继之」。这个有文学的人说这个话来就是好听，这个话说得好。「岂使高迹无追」，所以像法显法师、智严法师这种高尚的事迹，「无追」，这后来的人都没能够向他学习，「岂使高迹无追」。岂使「清风绝后」呢？这种清高的风范，后来就没有了呢！「岂使高迹无追」，「岂使清风绝后」呢？说是「大丈夫会当继之」，这个玄奘法师这个时候，这个心情很激动！是「大丈夫」，这个有作为的人。因缘，这个「会」就是因缘具足的时候，一定也要这样做，我要继续这种高风，继续这个「清风」、「高迹」的！</p>
<p>　　这是在这个…看上面那个小字，「贞观元年法师二十六岁，誓游西方取《十七地论》」。这个《玄奘法师传》，金陵刻经处是欧阳竟无、这个吕秋逸他们刻的。而他说「贞观元年法师二十六岁」这句话，这和这个印顺老法师的考证是一致的，印顺老法师也同意这个说法。同意这个说法，但是后面就有点不同。</p>
<p>　　那么这一段文是玄奘大师临去印度之前，他内心里面的一个愿望、一个动机，为什么要去印度？是这样意思。</p>
<p>　　去印度啊，这个印顺老法师的考证，他就是贞观元年的八月间去印度的，而不是贞观三年（很多的地方都是说贞观三年）。因为梁启超他考证了一下，不是贞观三年，是贞观元年。所以这件事的确是要多读书，才能知道这件事，不多读书是不行的。</p>
<p>　　说是这个，从什么地方知道呢？是因为叶护可汗。这个叶护可汗这个人，玄奘法师若是贞观三年去的话，是见到了叶护可汗的，但是贞观三年叶护可汗已经死了，所以若是贞观三年去，到那里见叶护可汗这件事，是不可能的。若是贞观元年去，那就见到叶护可汗了。所以从这个地方看，贞观元年是对的。不过这件事你要读《唐书》、多读中国的历史，你才能知道；只是读佛书还是不行。</p>
<p>　　那么这一段文说明他到印度去，是要去求、请这个《瑜伽师地论》而去印度的。这是一段喔。</p>
<p>　　我们…这一段「悼还源之梗流」，我们若学习佛法的时候，你对于佛法有疑问，这个事是不行的，你要修行的时候修行不来。你心里面有疑问，你的止观是修不成的。你念佛，你对净土法门有疑问，你念佛也念不来。不管修行什么法门，都是要有信心才可以。所以是「梗流」，就是「悼还源之梗流」。这是这一段。</p>
<p><strong><em>《大唐慈恩寺三藏法师传》卷一第十三页：</em></strong></p>
<p><strong><em>法师对曰：奘桑梓洛阳，少而慕道。两京知法之匠、吴蜀一艺之僧，无不负笈从之，穷其所解。对扬谈说，亦忝为时宗。欲养己修名，岂劣檀越敦煌耶？然恨佛化经有不周、义有所阙。故无贪性命，不惮艰危，誓往西方，遵求遗法。</em></strong></p>
<p>　　底下，「法师对曰：奘桑梓洛阳，少而慕道。两京知法之匠，吴蜀一艺之僧，无不负笈从之，穷其所解」。这一段，是在《玄奘法师传》的＜卷一‧第十三页＞上说的。＜第十三页＞这个地方啊，是怎么回事情呢？他已经过了玉门关（玉门关在敦煌的西面），过了玉门关以外，有五个峰，五个峰每一峰，一峰、一峰的距离都是一百里那么远。这是在第一峰的时候，玄奘法师到了第一峰的时候，第一峰那个地方的首将王祥，就是唐朝的政府派在那里的一个将军，叫王祥。这个王祥这个人似乎是信佛的。他遇见了玄奘法师，他就劝他不要去印度：「那个这个道路非常的艰难，你很难到印度去，不如回到敦煌去，敦煌那里有个法师是很有道德的，你到那里，一定他会欢迎你的」。王祥这样劝他。这样劝他的时候，「法师对曰」，玄奘法师就回答他说。「奘」，是玄奘。「桑梓洛阳」，我的家乡就是在洛阳，在洛阳那里。「少而慕道」，我年纪很小的时候，我就仰慕佛法，就出家了。这个印顺老法师的考证，他是十一岁出家，他那么年小，那么年轻，十一岁就出家了。出家以后，十三、四岁以后，逐渐地就是学习佛法。他哥哥先出家喔，这样子。</p>
<p>　　「两京知法之匠」，「两京」就是皇帝的住所在地，国家的首都。有两个首都：一个就是长安、一个就是洛阳。「知法之将」，对于佛法有研究的这些大德，在这两个地方的这些佛法中的大德。「吴蜀一艺之僧」，「吴蜀」，蜀就是四川、成都、重庆这一带的地方；「吴」呢？就是金陵、建业、荆州这些地方；或者这个汉阳、武汉这些地方。「一艺之僧」，不要说是通达很多的经论，他就通达一经一论也好。</p>
<p>　　「无不负笈从之」，我没有一位法师，我不去背着这个书袋子、书包、书箱子，我就随着他去学习佛法。</p>
<p>　　「穷其所解」，他所解悟的佛法，我完全要学习。的确也是不容易，的确是不容易。这可见这好乐佛法的心特别的诚恳、勇猛，所以他才能够这样子。</p>
<p>　　「对扬谈说」，他学习了这个…跟随这么多的大德学习佛法，所以他也是有了成就的。「对扬」，就是有人问，问我佛法、请我讲法，我宣扬佛法、谈说佛法的时候。「亦忝为时宗」，也能为当时人所尊重的。这个「忝」是一个谦虚的意思，谦虚的，就好像我是不及格，是这么意思。</p>
<p>　　「欲养己修名，岂劣檀越敦煌耶？」我学习了佛法也是有多少成就的，但是我不满意，所以我要到印度去。如果说是我不想到印度，为了「养己」，我就在一个地方，吃点有营养的东西、穿得暖暖的、住得舒舒服服的，享受、享受，我如果愿意这样子。或者说「修名」，我再做一点沽名钓誉的事情，这样子，那当然是可以的，那我就可以。「岂劣檀越敦煌耶」，那我还会轻视你吗？如果你王祥给我做檀越，我一定是很欢喜啊！说是你劝我到敦煌去，到那儿亲近有张皎法师，到那儿去，当然也是可以。我没有什么远大的志愿，我就是不要那么辛苦嘛，何必那么远去求法呢？我就舒舒服服住下去，过这一生就好了嘛！当然是可以这样子的。然而我的心不是在这里，我不想这样。</p>
<p>　　「然恨佛化经有不周、义有所阙，故无贪性命，不惮艰危，誓往西方，遵求遗法」。然而我最遗憾的事情，就是佛陀教化众生所说的经典，在我们汉地来说还「不周」，不是完全的，不具足的。「义有所阙」，这个「经」指文说，文不足，所诠的义也就不足了。</p>
<p>　　「故无贪性命」，所以我不爱我的生命，「不惮艰危」，你说到印度去这条路太难走了，我不怕，我不怕艰危！「誓往西方，遵求遗法」，我决定要到印度去，「遵求遗法」，随顺我的本愿，我一定要去求法，求佛陀所遗的教法。我不欢喜「我要享受享受就好了」，我不，我不这样子。</p>
<p>　　那么这上面看出来，就是「恨佛化经有不周、义有所阙」，这样的原因要到印度。这个就是有点…这个宽了一点喔。</p>
<p><strong><em>《大唐慈恩寺三藏法师传》卷一第十九页：</em></strong></p>
<p><strong><em>去圣时遥，义类差舛。遂使双林一味之旨，分成当现二常。大乘不二之宗，析为南北两道。纷纭诤论凡数百年，率土怀疑，莫有匠决。玄奘宿因有庆早预缁门，负笈从师年将二纪。名贤胜友备悉咨询，大小乘宗略得披览。未尝不执卷踌躇捧经侘傺，望给园而翘足，想鹫岭而载怀，愿一拜临启申宿惑。</em></strong></p>
<p>　　「去圣时遥，义类差舛，遂使双林一味之旨，分成当现二常。大乘不二之宗，析为南北两道。纷纭诤论凡数百年，率土怀疑，莫有匠决」。这是在＜第一卷‧第十九页＞上说的。这一段文是怎么意思呢？就是他到了高昌这个地方，这个时候已经是…这后面这个地方，「悼还源之梗流，故能出玉门而遐征，戾金沙而殉道」，已经过了这地方了。到了这个高昌王曲文泰，曲文泰这个人和玄奘大师特别的有缘，就是要不准他到印度去，一定要留在他那里住。后来玄奘大师就绝食，我不吃饭了。后来曲文泰才改变了意旨，就又请他住了两个月吧，在那儿讲经，非常的恭敬尊重。然后给他准备了很多的到印度去，在路途上所须要的这些资粮，送了多少黄金白银，又是给他收了四个徒弟，四个沙弥，送了很多的马。就是帮助他，很多、很多、很优厚的这些事情。于是玄奘大师很感动，就是写一封谢信，所以叫做「表」，表谢高昌王，就是写一封感谢他的信。</p>
<p>　　在这一封信上这么说：「去圣时遥」，就是那个时候是距离佛在世的时代，已经很久了，很遥远了。玄奘大师是在公元的第七世纪，六百年左右。（那时候还不到一千年，不满一千年<em>那个时候已超过一千年了（注一：</em>此依师父指示修改过。注二：印老考：佛灭度于公元前390年；玄奘法师生于公元~600年。而玄奘大师26岁西行，故说此文时应已距佛在世过千年了）。</p>
<p>　　「义类差舛」，佛所说的法，一个法门、一个法门的，流传了这么久的时候，就有些走样了，就有些偏失了，这句话是总说。这底下说有什么地方令你发…引起了问题呢？</p>
<p>　　「遂使双林一味之旨，分成当、现二常」，因为流传的时间久了，就使「双林一味之旨」，佛在双树林那里入涅槃，这句话表示佛在说《涅槃经》，佛说的《涅槃经》。涅槃是「一味」，就是一个滋味，不是有差别的。但是流传到现在呢？「分成当、现二常」，在《涅槃经》说到「当、现二常」。这个「常」是指什么说？就是佛性。「一切众生皆有佛性」，佛性是常住的，但是分成两个常，一个「当常」、一个「现常」。</p>
<p>　　这个「现常」怎么讲呢？就在凡夫的时候，是现在，「现」在我们是凡夫，我们的心里面就有常住的佛性，现在就有，这叫做「现常」。这个讲法呢？我们通常在佛学院里头，佛学院里学法的人，多数能听见这句话：「一切众生皆有佛性」。一般讲经也容易提到这里，「一切众生皆有佛性」。</p>
<p>　　这个「当常」是什么呢？一切众生没有佛性。你现在没有佛性，将来你才有佛性，将来才能得阿耨多罗三藐三菩提，这「当常」。这样说，你现在没有佛性，将来才有佛性，叫「当常」。</p>
<p>　　那么究竟是「当常」？究竟是「现常」呢？就这个就是个疑问，这也是个疑问。这个《涅槃经》上说一个譬喻，说是这个人家里面有乳、有酪，那么人家就问：「你有酥否？有没有酥？」他的家里是没有酥，只有乳和酪，但是他回答说：「我有酥。」因为…没有酥，为什么说有酥呢？「定当得故」，因为你有奶酪，决定可以制造出来酥的，所以我就说有酥。那么这个意思就是说…《涅槃经》下面说「一切众生都有心，凡有心者皆当作佛」。这个「心」就是譬喻是「奶酪」；「皆当作佛」譬喻是「酥」。你有心就能成佛，你就能成佛。那么你现在是没有阿耨多罗三藐三菩提的，现在是没有佛性的，可是将来你一定决定成佛，所以就说「一切众生皆有佛性」。这是「分成当现二常」，这就是在这个地方就有疑问，就是有点疑问的，这么一个。</p>
<p>　　「大乘不二之宗，析为南北两道」，这个是什么呢？就是这个菩提流支，菩提流支在南北朝的时候在北魏。北魏的时候，这个北魏的皇帝皇后，这些人信佛信得很诚恳，造了一个永明寺，你看那个《高僧传》有提到这个永明寺，不得了！那真是，那里面七宝庄严，非常的高大。后来被火烧了，你看这个可惜、不可惜！。这个菩提流支就在那里住，翻译经典，和勒那摩提都是印度来的梵僧。这两个梵僧，把这个《十地经论》翻译好了以后，大家都是讲这《十地经论》，弘扬佛法。而这个菩提流支是属于北道，这个勒那摩提是南道，（道德的道），南北两道。这两道是指地点说的，但是他们宣扬的佛法也不一样。</p>
<p>　　宣扬的佛法是说这个，勒那摩提是南道，他主张一切染净诸法以「法性」为依持，染污的缘起和清净的缘起以「法性」为依持。而菩提流支说呢？以「阿赖耶识」为依持。那么就像这个《摄大乘论》说，以阿赖耶识为依持。阿赖耶识是在《摄大乘论》上，在所知依这一章看，阿赖耶识是个杂染的、是生灭变化的。若是「法性」为依止，「法性」是常住不变的、无生灭的。那么这就是不一样了。</p>
<p>　　【天台】智者大师在《摩诃止观》上就引来这一段文。引来这一段文，这个我又看了慧远大师，慧远大师是【地论宗】的一位大德，他有《十地经论》的注解的。不过慧远大师这个人是非常的「博」，博学的人，他也提到这两件事。那么智者大师是说：「以「法性」为依持，就是以「心」为依持；以「阿赖耶识」为依持，就是以「无明」为依持」（无明烦恼的无明，以无明为依持）。那么这个说法就不一样了。</p>
<p>　　不一样了，所以这个时候玄奘大师就说，「大乘不二之宗」，大乘佛法是「不二」的，没有差别相。但是「析为南北两道」，就是分开成为两个部分，大家说法的不一样。不一样，我挑你的毛病，你挑我的毛病，都互相有诤论。「纷纭诤论」，这个「纷纭」就是很多的，很杂乱的。</p>
<p>　　「凡数百年」，从这个北魏‧菩提流支、勒那摩提有了南北二道以后，一直到了唐朝贞观十九年。玄奘大师贞观十九年、二十六岁，就是去印度，就是到这个时候他才走。那么就是有多少百年了，这个诤论。</p>
<p>　　「率土怀疑，莫有匠决」，说这个《涅槃经》上说这个「当、现二常」，和这个《十地经论》的这些学者，分为南北两道，究竟是怎么回事情呢？全面的中国的佛教徒都在怀疑。「莫有匠决」，也没有一个大善知识能决断这个疑问的，没有。</p>
<p>　　「玄奘宿因有庆，早预缁门」，我过去栽培过多少善根，就是特别的吉祥，所以很早我就来到佛教、来到寺院里出家了。「负笈从师，年将二纪」，背着书包，我到处去参学，到现在差不多有「二纪」，有二十年了。十一岁出家，到二十六岁、二十七岁这一年，到这个时候，有十七年之久。始、末算算，有十七年之久。那么就是「年将二纪」，还没有到，可也差不多少了。</p>
<p>　　「名贤胜友，备悉咨询」，这个有名望的这些贤者，和有殊胜功德的好友、善知识。「备悉咨询」，我完全都到那儿去请教，请教我的疑问。</p>
<p>　　「大小乘宗略得披览」，我都学习过、都读过。这个「略」就是也是谦虚的意思，我没能详细的去研究。</p>
<p>　　「未尝不执卷踌躇，捧经侘傺」，我未尝「不执卷」，一拿到…手里捧这个经卷的时候，心里面就犹豫，究竟是「现常」呢？是「当常」？究竟是「法性」为依持？是「阿赖耶识」为依持呢？就是犹豫。捧着经书的时候「侘傺」，「侘傺」是失志貌，失掉了意志的相貌；失志貌，也就是心情不快乐。</p>
<p>　　「望给园而翘足，想鹫岭而载怀」，我就是盼望、我要远远的去看那个祇树给孤独园，我看不见。看不见，我「翘足」，把足翘起来看，看那里的大德能不能给我解释、解释，这个意思哦，这表示他的诚心。「想鹫岭而载怀」，我心里想，灵鹫山那里一定有大德啊！那里有大德的，「而载怀」，这个「载」者，满也，能满我所愿啊，能给我除疑啊。</p>
<p>　　「愿一拜临，启申宿惑」，我希望我一下子能到那里去，去拜见他们。「启申宿惑」，这个「启」，就是说出来我的疑惑。说出我的疑惑，请他们能给我解释。能够陈述我的疑惑，让他们来解释。请他们来解释，我在汉地、在中国学习佛法的疑惑，能解、能断除我的疑问。</p>
<p>　　这一段文，说得比前面具体了一点，你究竟你对佛法有什么疑惑呢？就是这两点。一个是《涅槃经》上「当、现二常」；一个是《十地经论》这两位这个…分个两学派「南北两道」，究竟怎么回事情？不大明白，就因此而到印度去的。</p>
<p>　　（现在几点了？还有一点时间，我们下面再把它念完好不好。）</p>
<p><strong><em>《大唐慈恩寺三藏法师传》卷二第二页：</em></strong></p>
<p><strong><em>明日，王请过宫备陈供养。而食有三净，法师不受，王深怪之。法师报此惭教所开，而玄奘所学者，大乘不尔也，受余别食。食讫，过城西北阿奢理儿寺（唐言奇特也）。是木叉鞠多所住寺也。鞠多理识闲敏，彼所宗归。游学印度二十余载，虽涉众经而声明最善。王及国人咸所尊重，号称独步。见法师至徒以客礼待之，未以知法为许。谓法师曰：此土《杂心》、《俱舍》、《毘婆沙》等一切皆有，学之足得，不烦西涉受艰辛也。法师报曰：此有《瑜伽论》不？鞠多曰：何用问是邪见书乎？真佛弟子者不学是也！法师初深敬之，及闻此言，视之犹土。报曰：婆沙、俱舍本国已有。恨其理[疏-（梳-木）+束]（疏）言浅非究竟说。所以故来欲学大乘《瑜伽论》耳。又《瑜伽》者，是后身菩萨弥勒所说。今谓邪书，岂不惧无底枉坑乎！</em></strong></p>
<p>　　「明日，王请过宫」，这一段是＜第二卷‧第二页＞。第二页，是他到了龟兹国，鸠摩罗什法师是龟兹国的人，从龟兹国到我们汉地来的。到那里去，鸠摩罗什法师到了那里去，遇见了一位木叉鞠多法师。和他的对话，这一段文表示这个意思喔。那么玄奘法师到那里第二天，「明日」，第二天。这个龟兹国王「请过宫备陈供养」。请他，他是在庙里面住，请他到皇宫里面去，要供养他。</p>
<p>　　「而食有三净」，就是三净肉，不见杀、不闻杀、不为我杀。「法师不受」，玄奘法师不接受。「王深怪之」，那个龟兹国王有点…就是很怪，怎么会不受呢？「法师报此渐教所开」，这就是小乘教，小乘佛法是准许的、所开许的，可以吃三净肉。「而玄奘所学者」是大乘佛法，是「不尔也」。「受余别食」，就是受这个素食了。</p>
<p>　　「食讫」，「过城」的「西北」，在这个王城的西北，有「阿奢理儿寺（唐言奇特也）」，奇特寺。「是木叉鞠多所住寺也。鞠多理识闲敏，彼所宗归」。这个有学问的人会赞叹人，就是说这么四个字，「理识闲敏」，哎呀这四个字我至少费了五分钟思惟它的意思。</p>
<p>　　「理识」应该说这样说，可以有几个意思。就是他修学止观、修学四念处，「理」者，治也（治理国家的治），就是来调整他的心，来清净其心。修学四念处清净其心，叫「理识」。或者就说他学习佛法的真理，来熏习他自己的识，这样讲是「解」。修学四念处就是「行」了。</p>
<p>　　「闲敏」，这个人表示于外的态度，很闲静，很安闲自在的，但是内心是非常灵敏、敏捷的，这样赞叹他。</p>
<p>　　「彼所宗归」，说这个人，这个木叉鞠多法师，是那个地区的佛教徒所尊重的、所皈仰的、所皈依的。他为什么会有这个成就呢？「游学印度二十余载」，这么多年。</p>
<p>　　「虽涉众经，而声明最善」，虽然他也学习了很多的经论，但是属于「声明」这一方面，是他最擅长的。「声明」，就是文学特别好；或者音韵的这些，会唱念这些事情。</p>
<p>　　「王及国人咸所尊重，号称独步」，很多人都尊重他，在那个地区他是最殊胜的了，没有人能赶得上他的，「称独步」。</p>
<p>　　「见法师至」，他看见玄奘法师到来了。「徒以客礼待之」，他是客人，自然应该是礼敬他的。「未以知法为许」，他还不同意你就是明白佛法的。</p>
<p>　　「谓法师曰」，就对这个玄奘法师说。「此土《杂心》、《俱舍》、《毘婆沙》等，一切皆有，学之足得」，说我们这个地方（就是龟兹国），这个《杂心论》、《俱舍论》、《毘婆沙论》等，这一切的论都有。「学之足得」，都可以好了，可以成就了。</p>
<p>　　「不烦西涉受艰辛也。法师报曰：此有《瑜伽论》不？」玄奘法师对他说，说是你说有《杂心》、《俱舍》、《毘婆沙》等，你这里有没有《瑜伽师地论》呢？</p>
<p>　　「鞠多曰：『何用问是邪见书乎？真佛弟子者不学是也！』」啊，你看这个，这个木叉鞠多是这么一个人。</p>
<p>　　「法师初深敬之」，玄奘法师初开始见面对他很恭敬。「及闻此言，视之犹土」，这可见大家的思想相差太多了。</p>
<p>　　「报曰」，玄奘法师就回答他说：「《婆沙》、《俱舍》，本国已有」，我们汉地也是有的。「恨其理疏言浅」，那个里面的道理，说得都是很…说的粗疏；那个语言也是很浅薄的。「非究竟说」，非究竟的佛法。</p>
<p>　　「所以故来欲学大乘《瑜伽论》耳」，我所以向西来求法，就是要学习大乘《瑜伽师地论》的。</p>
<p>　　「又瑜伽者，是后身菩萨弥勒所说。今谓邪书，岂不惧无底枉坑乎」你谤毁【大乘佛法】，你不害怕到无间地狱去啊？这个「枉」，就是困在那里，你不可以跑出来的，这个意思。</p>
<p>　　这可见鸠摩罗什法师他在龟兹国的时候也学习【大乘佛法】，可是到了这个时候，似乎就是【小乘佛法】了，【大乘佛法】不在了。这【小乘佛法】的力量很大，使令【大乘佛法】不在了。这锡兰的地方也有【大乘佛教】，但是【大乘佛教】不在了，只是【小乘】。</p>
<p>　　从《玄奘法师传》上看呢？玄奘法师到印度去的目的何在？去看就比较清楚了。也会明白这句话，「悼还源之梗流」，这句话也明白了，明白这句话的意思。好，就讲到这里。</p>
<p><img src="file:///C:\Users\m1885\AppData\Local\Temp\ksohtml36792\wps1.png" alt="img"></p>
<p><strong><em>问：</em></strong>这里有一个人提出一个疑问，提出一个问题。这个问题提得很好，我也是看过《瑜伽师地论》的论释，我也看见这段文，也看见了喔。在《瑜伽师地论释》中有一段文如下：「复有二缘，故说此论：一、为显了遍计所执情有理无，依他起性、圆成实性理有情无，令舍增益损减执故；二、为显了世间道理，证得胜义法门差别」，你在这里划个圈不对，不要在那儿划圈。「令修二谛无倒解故」。这是《瑜伽师地论释》上的文，这底下提出问题。请问：「情有理无」、「理有情无」如何解释？</p>
<p><strong><em>答：</em></strong>这个「情有」<strong><em>这句</em></strong>话，就是我们的执着心上是有这件事，这遍计所执是我们的执着，我们有这种事的；「理无」，但是在道理上，就是没有我们所执着的，没有所执着的这件事。就是在佛菩萨的清净智慧上，是没有遍计所执这件事的。譬如说，一切法是唯心所现的影像，离开了我们的心，这个影像是没有自体的。在我们心的虚妄分别现出来影像的时候，影像本身还是空无所有的，这是在「理无」上说。但是在我们凡夫，就不同意这个说法，明明这里有个房子嘛，明明这里有老虎嘛，怎么能说没有呢？所以「情有」，但是在理性上是没有的。就是蛇、绳子的那个譬喻，光线不好的时候，那里有一个绳子在那里盘着，我们看是条蛇。这个蛇是没有的，绳子是有，就是「情有理无」。遍计所执，这个蛇是「情有理无」的，是这样意思。</p>
<p>　　「理有情无」，就是依他起和圆成实，那是佛菩萨的大智慧上才有这件事。一切法是如幻如化的、是毕竟空寂的，能够理会到这件事，能契证这件事，能证悟一切法是如幻如化的、如梦中境、如水中月的、是毕竟空寂的。但是我们凡夫不行，凡夫不知道一切法是如幻如化，更不知道第一义谛，所以是「理有情无」。</p>
<p><strong><em>问：</em></strong>请问：「二谛无倒解」，指的是那二谛？</p>
<p><strong><em>答：</em></strong>那还是简简单单地说好一点，就是一般说的世俗谛和第一义谛，就这么简单说好了。如果说四重二谛，慢慢地再说，就这样好了。而这件事，这个《遁伦记》上，他也没有说，他没有讲那个。没有讲那个，但是这里面也有这个义，也是有的，也还是有这个义的，义并没有失掉，还是具足的。那么可以知道它是在那里吧？是不是，「三、为舍无见及有见故」，这就可以包括那件事，包括了那个在内的。「第八、为显三性有无，及世间道理证得胜义四法门故」，其实这也就是你说的那段文，它比较略了一点。「为显三性有无」，就是「情有理无」、「情无理有」，就是这个意思，也就包括在内了。</p>
<p>　　你们还有什么疑问，还有什么问题？</p>
<p><strong><em>问：</em></strong>这里有一个人提出一个疑问，提出一个问题，这个问题提的很好。我也是看过《瑜伽师地论》这个《论释》，我也看见这段文，也看见了喔。在《瑜伽师地论释》中有一段文如下：</p>
<p>　　「复有二缘，故说此论：一、为显了遍计所执情有理无；依他起性、圆成实性理有情无，令舍增益损减执故。二、为显了世间、道理、证得、胜义法门差别」。（你在这里划个圈不对，不要在那儿划圈。）「令修二谛无倒解故」。</p>
<p>　　这是《瑜伽师地论释》上的文，这底下提出问题。</p>
<p>　　请问：「情有理无」、「理有情无」如何解释？</p>
<p><strong><em>答：</em></strong>这个「情有」这句话，就是我们的执着心上是有这件事。这「遍计所执」是我们的执着，是我们有这件事的。</p>
<p>　　「理无」，但是在道理上，就是没有我们所执着的，没有所执着的这件事。就是在佛菩萨的清净智慧上是没有「遍计所执」这件事的。</p>
<p>　　比如说，一切法是唯心所现的影像，离开了我们的心，这个影像没有自体的。在我们心的虚妄分别现出来影像的时候，影像本身还是空无所有的，这是在「理无」上说。但是在我们凡夫呢？就不同意这个说法。明明这里有个房子嘛，明明这里有老虎嘛，怎么能说没有呢？所以「情有」。但是在「理」性上是没有的。</p>
<p>　　就是《摄大乘论》那个譬喻，这光线不好的时候，那里有一个绳子在那里盘着，我们看见是条蛇。这个蛇是没有的，绳子是有，就是「情有理无」。这个「遍计所执」，这个蛇是「情有理无」的，是这样意思。</p>
<p>　　「理有情无」，就是「依他起」和「圆成实」呢？那是佛菩萨的大智慧上才有这件事。一切法是如幻如化的、是毕竟空寂的，是与这样的事情，能够理会到这件事，能契证这件事。能证悟一切法是如幻如化的、如梦中境、如水中月的、是毕竟空寂的。但是我们凡夫不行，凡夫不知道。不知道一切法是如幻如化，更不知道第一义谛的，所以是「理有情无」，这么意思。　　</p>
<p><strong><em>问：</em></strong>请问：「二谛无倒解」，指的是那「二谛」？　　</p>
<p><strong><em>答：</em></strong>那还是简简单单的说好一点。就是一般说的这个「世俗谛」和「第一义谛」，就这么简单说好了。如果说四种二谛，慢慢的再说，就这样好了。</p>
<p>　　而这件事，这个《遁伦记》上它也是「十番两缘」，它也没有说，他没有讲那个。没有讲那个，但是这里面也有这个义，也是有的，也还是有这个义的，义并没有失掉，还是具足的。</p>
<p>　　你们可以知道它是在那里吧？是不是，「三、为舍无见及有见故」，这就可以包括那件事，包括了那个在内的。「「第八、为显三性有无，及世间道理证得胜义四法门故」，其实这也就是，这就是你说的那段文，它比较略了一点。「为显三性有无」，就是「情有理无」、「理有情无」，就是这个意思，也就包括在内了。　　</p>
<p>　　你们还有什么疑问，还有什么问题？我们刚才讲的这一大段，就是从《玄奘法师传》引来的这个，可以写一篇文章。你可以写出个科目来，将来我们有杂志出版，你就可以写一篇文章。就是他为什么到印度去？</p>
<p><strong><em>问：</em></strong>有一个小小的疑惑在第三页「慈氏菩萨随无着机，恒于夜分从知足天」来说法，他为什么弥勒菩萨他会选择在晚上来到世间为大众说法。</p>
<p><strong><em>答：</em></strong>大概白天大家去这工作忙，一般都是这样子嘛。有可能是这样子。晚间有时间。（有人说：印度的天气也比较热，晚上比较凉快）也是的，可能是。</p>
<p><strong><em>问：</em></strong>请问昨天您讲那个「因缘空」或者「不空」的问题，如果用因缘法来说，因缘法的话，师父您说「此灭故彼灭」。那如果就因缘上来说，如果这个心清净的话，那我们常听说「心灭罪亦亡」，是不是这样说，就是你的心的话，那这个等于在因上就…因缘上说就灭了。那这个用唯识来说，遍计执是毕竟空寂，依他起是如幻有。因为是如幻有，所以这个心清净的话，就不起这个遍计执。因为不起遍计执，就把这个杂染的阿赖耶识统统都改成清净的，都是变成圆成实了。但是有个问题就是圆成实的自性也是空。那这样就可以把这三个套在一块来说了，就是因缘自性空和唯识依他起、圆成实这三性加在一块说，可以吗？</p>
<p><strong><em>答：</em></strong>可以。也可以。</p>
<p>　　这个「罪从生起将心，心若灭时罪亦亡」，这句话的确是很好，但是你若是去讲的话，你还是要想、思惟一下。怎么叫做「心若灭时罪亦亡」？你们谁愿意解释这句话？</p>
<p><strong><em>有人答：</em></strong>是不是把所有阿赖耶识种子从杂染现起清净，那时候就是，一切法不受。</p>
<p><strong><em>答：</em></strong>那么也是的，是的。但是明白点说呢？就是执着心灭了。心还是在，心不能够…。比如说佛…有个离垢识，他还是有识，心还是没有灭。阿罗汉他也有分别心，他这个明了心的识还是在。那么怎么叫做「心若灭」了呢？就是应该是执着心灭了。执着心若灭，「心若灭时罪亦亡」。</p>
<p>　　所以「心若灭时罪亦亡」，应该分两个意思说。第一个意思呢？我们一切法是如幻如化、如幻有不真实，是毕竟空。你若证悟了这样的真理的时候，你就和真理统一了，能和真理统一。不是用嘴子说、嘴巴说的「这是我所说的真理」。我的心能说出这句话，表达这个真理，不是这个意思。这样子是不能灭罪的。是说你和那个真理统一了，就是变成一体的了，不是彼此对立的了。你若没有执着心，就是要有无分别智现前。无分别智成就了，这个执着心没有了。执着心没有了，我刚才说老虎来了，老虎来了，你不认为有个真实的老虎，是如幻如化的，是毕竟空的。你就不执着了。是来一个人也是，这一个人也是如幻如化，如镜中像、如水中月，有而不真实，是毕竟空的。你能契会了这个真理的时候，这个执着心就没有了。执着心没有了的时候，就「罪亦亡」，罪就没有了。</p>
<p>　　罪没有了这个话是…用凡夫心的分别是没有罪了，把罪灭了，当然这样讲也是可以，但是这个地方也可以不这么讲。就是有罪的时候就是没有罪，叫做「罪亦亡」。比如说这个人有罪，这个人是…假设的这个得了严重的痛苦的病痛，受这个罪的果报。但是这个人若是圣人的话，他没有执着心的时候，有病就是没有病，叫「罪亦亡」，也可以、可以这样解释。有病、有苦就是没有苦。因为他同第一义谛相应的时候，就和没有苦一样，无差别相。圣人这个忍力大，原来就是这么回事。我们凡夫这个执着心，就把自己留在那个苦恼里面，被苦恼所困，你要受这个果报。若是你得无生法忍了的时候，与第一义谛相应的时候，虽然那个苦恼还在，但是他没有苦。这叫做「罪亦亡」，这第一个解释。</p>
<p>　　第二个解释呢？就是我们刚才而的，没有了。你能常修如是观，就是「唯识无义」，唯识是无义，「无义」也就没有识了，也没有分别心了、也没有执着心了。这个时候你常作如是观，你的罪业就剎那、剎那的消灭，就灭了。在阿赖耶识里面的这些罪垢，它逐渐的、逐渐的就消灭了，消灭，就灭了，说「罪亦亡」。</p>
<p>　　所以得到圣道的人，三恶道的罪决定是消灭，不会到三恶道受苦了。就是他修这个四念处的力量，把那个罪都消灭了。</p>
<p>　　我们没有得无生法忍，你这种止观不相应的人，你修不来，这样的止观你修不来。唯识是无义；无义是唯识，这四寻思观、四如实智修不来。我修不来，我不修。我就光是念念经，我就是这样子。这好，只好这样子嘛！只好一天读经，我一天拜佛嗑头，也能灭罪，也可以灭罪。说初开始忏悔要多磕头，我拜梁皇忏也好，拜大悲忏也好，千佛忏、万佛忏也好，多磕头。多磕头，你诚心，你也以灭罪。因为你长期的拜，长期的礼拜，你这个清净心的时间长，清净的力量也逐渐的增长，这个染污逐渐的减少、逐渐的减少。说是这样子你也能灭罪。当然还是修止观灭罪的力量大。等你常常磕头，磕到十万大头以后，你要修止观容易相应，容易相应了，应该是这样做。</p>
<h3 id="第4讲"><a href="#第4讲" class="headerlink" title="第4讲"></a><strong><em>第4讲</em></strong></h3><p><strong><em>奘法师以超世之量，悼还源之梗流，故能出玉门而遐征，戾金沙而殉道。</em></strong></p>
<p>　　这个「悼还源之梗流」，这句话呢？昨天解释过了。</p>
<p>　　「故能出玉门而遐征，戾金沙而殉道」，这是玄奘法师在我们中国的汉地学习佛法有疑问。有疑问，而对于学习佛法的诚心，是因为特别的强，所以有疑问决定要除疑，「故能出玉门而遐征」，所以不怕辛苦，这么遥远的地方，他也不怕，他是到了敦煌。这个「玉门关」在敦煌的西面。出了玉门关之外，又到了远远的地方去，目的当然是到印度。出了玉门关之外，有五个峰。五个峰之外，有八百里的沙漠。这个「戾金沙而殉道」，这个「金沙」是指那个沙漠，那个八百里的沙漠那个地方说的，也叫做沙河。但是这里用一个「金」字、「金沙」。「戾金沙」，「戾」也是所到的地方，就是所经过的地方，有八百里那么长远，那么长、那么远的地方，难走，经过的地方，他也是…也过去了。</p>
<p>　　在《玄奘法师传》上看，走到那里是特别辛苦了。就是他带的水，一下子一失手就都流走了。走了多少天？走了五天？多少天？一点水没有饮下去。所以实在是不能走路了，就是卧在那个沙地里面。那个马也不能走了，他人也没有精神了。躺在那个沙地里面，经了五天、过了五天以后，他一方面躺着卧在那里，也就念观世音菩萨。过了五天之后，夜间的时候，忽然间有凉风吹来，身体感觉到舒服有精神了，马也精神了，这才是…才可以走。但好像还是不想走。不想走这时候…这个凉风一吹来，精神好一点才能睡觉，睡了一会儿觉。睡了一会儿觉，还是不…就作个梦，梦见一个很高大的一个人，叫：「还不起来！还不起来走！」喔，他就醒了，这时候骑着马才走。走到一个地方，忽然间这个马不听招呼，就是到另一个地方去，走了不远，那个地方有青草、也有水，这样子他才解决了这个困难。</p>
<p>　　「戾金沙而殉道」，这个「殉」是顺的意思，随顺的意思（注：似应为：为求法而不惜身命之意，如下句说），就是重道轻生，重视佛法的戒定慧的圣道，而轻视生命上的辛苦。这个生命上受到什么辛苦，不介意。我一定要到印度去求道、去求法，所以叫做「殉道」。</p>
<p>　　这个义净三藏，唐朝那个义净三藏。义净三藏是玄奘法师已经回来了以后，他才去印度去。他有一个叫「取经诗」，取经的诗。</p>
<p><strong><em>「晋宋齐梁唐代间，高僧求法离长安。去人成百归无十，后者焉知前者难。</em></strong></p>
<p>　<strong><em>远路碧天唯冷结，沙河遮日力疲殚，后学如未谙斯旨，往往将经容易看」</em></strong></p>
<p>　　「晋宋齐梁唐代间，高僧求法离长安」，这个容易知道喔。「晋宋齐梁唐代间，高僧求法离长安」</p>
<p>　　「去人成百归无十」，到印度求法的人有一百个人，回来的人可能连十个人都没有。这个为什么那么少呢？就在中途的时候，那种苦受不了就死掉了的有；也有少数的呢？到了印度就留下来了，不回来了，所以「去人成百归无十」。</p>
<p>　　「后者焉知前者难」，后来的人，你知道古代的人求法的困难！你不知道啊，「后者焉知前者难」</p>
<p>　　「远路碧天唯冷结」，那个路途的长远，特别的地远，那个时候没有飞机、也没有汽车，顶多是骑马，或者是徒步走，很辛苦啊。「碧天」，看这天是蓝色的，可是非常的冷，过这个雪山的时候那个冷风啊，就是…就在那里就冻死了，不得了啊！「远路碧天唯冷结」，就是冷啊。「结」是结果的结，「远路碧天唯冷结」，这个「结」在这里或者是个障碍的意思也可以。这个冷不得了，障碍你，可能把人冻死了，「远路碧天唯冷结」。</p>
<p>　　「沙河遮日力疲殚」，这个沙，这个沙漠之地就像河似的。最初我看见这里怎么讲法呢？沙怎么能是河呢？看到那个《玄奘法师传》上讲，你从那里走的时候，这个大风一来，这个沙，沙是很微细那个沙子，吹得满天都是沙，像云雾似的。是把天都遮起来了，这种境界。「沙河遮日力疲殚」，没有力量就死掉了，你受不了你就死掉了，「沙河遮日力疲殚」。（「殚」是一个好歹的「歹」，加个单双的「单」）「沙河遮日」，把太阳都遮住了，满天都是沙。「力疲殚」，没力量了，就死掉了，「力疲殚」。</p>
<p>　　「后学如未谙斯旨，往往将经容易看」，后来的人学习佛法，我在读一部经的时候，「如未谙斯旨」，如果你还不知道这件事的话。「往往将经容易看」，常常经请来我就看一看嘛，不感觉到有什么事情，其实那里面有多少辛苦，已经有多少人的命都死掉了。「后学如未谙斯旨，往往将经容易看」。这里这几句话有这个意思，「戾金沙而殉道」，是不容易啊！</p>
<p><strong><em>乃到中印度摩揭陀国那烂陀寺，遇大三藏尸罗跋陀罗。始闻此论，文义领会，意若泻瓶。虽复所迳诸国备通群章之妙，而研究法相特思于兹文。既而旋轫上京，奉诏于弘福寺，以贞观二十一年五月十五日肇译此论，至二十二年五月十五日绝笔解座。此论梵本有四万颂，颂三十二言，译为一百卷。</em></strong></p>
<p>　　「乃到中印度摩揭陀国那烂陀寺」，经过这么多的辛苦，才到了中印度的摩揭陀国。「摩揭陀」翻个「持甘露」（受持的持，甘露）。这个「印度」也不是中国话，翻成中国话翻个「月」（月亮的月，太阳月亮，翻个月）。这在《大唐西域记》上给他一个注解，说是印度这个地方，常常有圣人、有佛出现世间。这些佛菩萨来教导众生，就像有月亮照明似的，能破除黑暗，能令你清凉、没有热恼，所以叫做「印度」，其实这是佛教徒给它的一个解释了。</p>
<p>　　「摩揭陀」翻个持甘露，也翻个「无恼害」，没有恼害。</p>
<p>　　「那烂陀寺」，那烂陀就是菩提道场那个地方的一个庙的名字，翻到中国话翻个「施无厌」，说是那个大庙的旁面有一个水池，池里面有个龙，龙的名字叫做「施无厌」，所以这个庙也就用这个名字做名字。也有说是释迦佛往昔的时候，行菩萨道的时候的名字叫做「施无厌」。</p>
<p>　　「遇大三藏尸罗跋陀罗」，遇一位很有道德的三藏法师，叫尸罗跋陀罗，就是戒贤论师。</p>
<p>　　在这个印顺老法师的《佛教史》的上看见一件事，说是那个恶国王毁灭佛教的这些事情，戒贤论师被恶国王埋在土里头了，然后有佛教徒的在家居士又把他给救出来，他受过这种苦的，「戒贤论师」。</p>
<p>　　「始闻此论」，这个时候才开始听戒贤论师讲这一部论。</p>
<p>　　「文义领会，意若泻瓶」，戒贤论师为玄奘法师讲这部论，同时有几千人听这部论，有那么多人听。</p>
<p>　　在那烂陀寺有几万人的出家人，法师在那里住，若是几千人听这当然也是可能的。但那是候没有扩音机，有几千人…那也可能听到喔。</p>
<p>　　「文义领会，意若泻瓶」，这是说玄奘法师对于戒贤论师讲的文、讲的义的领会。「意若泻瓶」，就像一个瓶子里面装的水，把它泻到另一个器里面的时候那样子，就是他能够全面的领会了。不像我们打妄想，就听不到了，「意若泻瓶」。</p>
<p>　　「虽复所迳诸国备通群章之妙」，玄奘法师到印度去，也是亲近过很多的善知识的。虽然是又在很多的地方，经过了很多的地区、国家，亲近了很多的善知识。「备通群章之妙」，就是通达了、学习了很多的经论的微妙。</p>
<p>　　「而研究法相特思于兹文」，但是玄奘法师他内心里面学习佛法，「法相」就是学习佛法的性相的道理。其中的真义，要以「兹文」，以「兹」就指《瑜伽师地论》，依《瑜伽师地论》为一个重要的观察的根据，叫做特「思」、叫「思」。这个「思」就是思惟。说这个地方、那个地方有不同的讲法，究竟以谁讲的为准呢？「特思于兹文」，特别的要以《瑜伽师地论》的讲法为准，是这样意思。这个话的意思就是对于《瑜伽师地论》特别的尊重的意思。</p>
<p>　　「既而旋轫上京，奉诏于弘福寺，以贞观二十一年五月十五日肇译此论」，在印度一共十七年。十七年，那个时候玄奘法师心里面想要回来了，在那个传上看啊，还有文殊菩萨的警觉，告诉他「你应该回去了，应该回到中国去了」。但是他还找一个尼干子去算一算。算一算是在这里好、还是回到中国去好。那尼干子说你回去也是好、在这里也是好。那么这时候，结果他是回来了。「旋轫」，这个「轫」就是车轮。这个车是按照这个方向走，但是旋转一下，改变方向，那么就是回到中国来，就是表示这个意思。回到中国来，这个「上京」就是指中国说，或者是指长安说（当时中国的首都是在长安）。「既而旋轫上京」，就是过了一个时期，就回到中国来了，那个时候正赶上…贞观元年去印度，贞观十九年回到中国来，正赶上唐太宗到辽东去伐这个高丽，就是那个时候。就在那个时候，这个唐太宗在洛阳，他叫房玄龄在长安，正在掉动军队的时候，那正是紧张的时候。但是玄奘法师同他见面的时候，唐太宗把所有的事情都停下来，就是和他谈话，一谈，谈到太阳落了还没谈完。所以人若是有缘，那个事情就是妙。</p>
<p>　　「奉诏于弘福寺」，唐太宗曾经劝…见面的时候，就劝这个玄奘法师还俗，在政府里作官帮助他治理国家。依前后看那传，前后劝他两次，他都没同意。没同意，玄奘法师他说出个理由来，这个理由我认为说得好。玄奘法师说，譬如鱼是在水里生活的，你让牠到陆地来生活，不可以啊。我从小就出家学的佛法，我学了佛法，我就在佛教里面生活，我到印度取经、回来翻译经，我能做这件事；世间上的这些政治的事情、军事的事情，我没有学过，你叫我做这个事情，我做不来啊！他这个理由说得好，所以唐太宗也不再勉强他。但是又劝他随着他到辽东去，还这样子。玄奘法师说我不能去，有这个事情。然后唐太宗下一个诏告诉房玄龄，安排他翻译经的事情。那么玄奘法师就由洛阳就回到长安，由房玄龄的安排，好像召集了全国的有名望的大德，来帮着他翻译，「奉诏于弘福寺」。</p>
<p>　　「以贞观二十一年」，一开始翻译不是翻译《瑜伽师地论》，翻译了其他的经。到二十一年的「五月十五」这一天，「肇译此论」，开始翻译这一部论。「至二十二年五月十五日绝笔」，二十一年五月十五到二十二年五月十五正好是一年，「绝笔」，就把笔停下来。「解座」，当时的这个法座，大家都坐在那里翻译，这时候「解座」了，可能是休息几天，也可能是，这样子。</p>
<p>　　看这个翻译《瑜伽师地论》的情形，其他的事情不看见有详细的所…纪录，其中有一件事，我们看出来，就是要有人执笔。玄奘法师翻译，把梵文翻成汉文让人写，给这些法师写了五、六卷以后，就要换人。写了五、六卷以后就换人。其中有一位法师特别的，就是辨机法师。辨机法师写了三十几卷才换，就是有这样事情。</p>
<p>　　这可见辨机法师这个人有点特别，但是你们知道辨机法师后来怎么情形，你们知道？我们先不要讲喔。</p>
<p>　　「此论梵本有四万颂」，不过也有…这个他们研究《瑜伽师地论》的人说，这个前后同一个名词、同一样…含义一样的这句话，用的名词不同，用的名词不一样。这也可能是执笔的人有关系，也可能是玄奘法师有意这样子。同一样的意义，用不同的名字来表达，也可能是有意这样子的。「此论梵本有四万颂」，有这多。　　「颂三十二言」，颂有三十二个字，有四万个三十二个字。「译为一百卷」，翻成这么多。</p>
<p><strong><em>自佛法东流，年载修远。虽闻《十七地论》之名，而不知十七者何也。《地持》、《善戒》但是菩萨一地。《决定藏论》是决择分初。自余汉土皆未之有（善戒经是求那跋摩译，地持论是昙无谶译。传闻梁武帝时，真谛太清四年岁次庚午十月，往富春令陆元哲宅，为择琼等二十名德翻十七地论，始得五卷）。今始部分具足，文义圆明。荡荡乎明大明于重冥、鍠鍠焉声希声于宇内，斯可谓整蹄驾于玄途、辟幽关乎虚室者也。</em></strong></p>
<p>　　「自佛法东流，年载修远」，这前面把《瑜伽师地论》出现的因缘说过了。这又说到《瑜伽师地论》能来到中国来，这个因缘也说过了。来到中国来，的确是不容易。「年载修远」，佛法传到中国来，这个年代很久了，到玄奘大师那个时候，可能还不够一千年。</p>
<p>　　「虽闻《十七地论》之名」，在玄奘大师离开中国去印度这个时候，这个时候…当然玄奘大师他听过这个《十七地论》的名字了。这个《十七地论》我们知道就是《瑜伽师地论》。《瑜伽师地论》没有到中国来，可是中国的佛教界就听到这个名字了，那这是谁说的呢？就是来到中国来，弘扬【唯识学】的这些人。在中国的北方的，就是菩提流支这些人，菩提流支是弘扬【唯识】的人，有《法华经论》、《金刚波若论》都是菩提流支翻译的。再就是真谛三藏这些人，翻译《摄大乘论》这些人。这都是弘扬【唯识】的这些梵僧他们讲的。所以我们中国佛教界，虽也闻到《十七地论》的名字了，虽然是听到了，「而不知十七者何也」，这「十七地」究竟是什么？什么叫做十七地？不知道。</p>
<p>　　「《地持》、《善戒》但是菩萨一地」，这个《地持经》，也有的地方说《地持经》，也有说《地持论》，是昙无谶翻译的。这个《善戒经》是求那跋摩翻译的。这两部书就是《瑜伽师地论》里面的书、里面的一部分。是《瑜伽师地论》的那一部分呢？是＜菩萨地＞。这个《瑜伽师地论》里面有个＜菩萨地＞，十七地里面有个就是＜菩萨地＞。这个《地持论》和《善戒经》就是《瑜伽师地论》里面的那个〈菩萨地〉，只是〈菩萨地〉一地，一共十七地，里面的一地。</p>
<p>　　「《决定藏论》是＜决择分＞初」，这个《决定藏论》是真谛三藏翻译的，它也是《瑜伽师地论》里面的一部分，是那一部分呢？是＜决择分＞里面最初的那一部分。</p>
<p>　　「自余汉土皆未之有」，除了这几种之外，剩下的那《瑜伽师地论》，我们汉土都没有，都没有翻译过来。</p>
<p>　　这底下这个小字：「《善戒经》是求那跋摩译；《地持论》是昙无谶译」，昙无谶就是翻译《涅槃经》那一位。昙无谶比鸠摩罗什法师稍晚几年来到中国来。</p>
<p>　　「传闻梁武帝时，真谛」三藏在「太清四年」的时候，「岁次庚午十月」，他「往富春令」，就是到了富春令，大概是个县官，在「陆元哲宅」，在他的家里面，「为择琼等二十名德，翻《十七地论》，始得五卷」，这是传说的话。</p>
<p>　　「今始部分具足」，现在这个《瑜伽师地论》一部分、一部分的十七地，一共是五分。这个「部」字我疑惑是个「五」（一二三四五的五）。《瑜伽师地论》一共是五分，是具足了，完全都有了。</p>
<p>　　「文义圆明」，文也圆满了、义也圆明了。</p>
<p>　　「荡荡乎，明大明于重冥」，这个「荡荡」是广大深远的意思。这个广大深远的《瑜伽师地论》来到我们中国了，我们中国才有光明啊，是这个意思。「明」就是光明。而这个光明不是小，是大光明。「于重冥」，在我们这个黑暗的地方放大光明了。这个「重冥」，冥而又冥，「重冥」。或者说是见烦恼是个「冥」，是黑暗；爱烦恼又是一个「冥」，所以叫做「重冥」。</p>
<p>　　「鍠鍠焉，声希声于宇内」，这个「鍠鍠」，「鍠鍠」是怎么呢？是钟的声音，来形容钟的声音，叫「鍠鍠焉」。「声希声于宇内」，这个「声」就是法音，表达佛法的音声，叫「声」。「希声」呢？就是希有的声音，少有的声音。这是出于《老子》。《老子》上面说：「听而不闻」，叫做希声。听则听，但是没听到，叫做「希声」。在佛法讲呢？就是「其说法者无说无示」，那叫做「希声」。</p>
<p>　　嘉祥大师解释：「言满大千实无所说」，佛说法的法音遍满了三千大千世界，但是佛没有说话，那叫做「希声」。这就是一个微妙的法音，就是这样子。「于宇内」，于这个世界之内，于这个三界之内。</p>
<p>　　这句话是说声音，就是能诠的法音是这样子。那个「明大明于重冥」，那应该是什么呢？应该是这个法音所诠表的道理。能诠的名句文和所诠的义理，能诠的音声就是教，所诠的义理就是义，教义。「明大明」，佛法的这个法的真义是大光明境界，所以「明大明于重冥，鍠鍠焉，声希声于宇内」。</p>
<p>　　「斯可谓整蹄驾于玄途、辟幽关乎虚室者也」，这可以说是「整蹄驾于玄途」。</p>
<p>　　这个「整」就是调理、调整的意思。说这个道路不平坦，把它修一修，叫它平坦容易走，叫做「整」。</p>
<p>　　「蹄」这个字是兽的足，或者马、或者牛的足叫「蹄」。</p>
<p>　　这个「驾」就应该说是所驾的车。</p>
<p>　　「蹄驾」，就是兽拉车，或者是这样意思。但是我认为啊，可能这个「蹄」也是个错字，可能是个错字喔。</p>
<p>　　在这个《十二门论》，这个三论的《十二门论》里面，有僧叡法师作的序：「整归驾于道场，毕趣心于佛地」。「整归驾于道场」，那么这是「整归驾」，它那是「整归驾」，这个「蹄」我看不如是用「归」字比较好，所以有可能就是个「归」，后来的人把它展转的写差了。</p>
<p>　　「整归驾」就是坐这个车回去，回家去，叫「归驾」（归去来的归），「整归驾」。那么这里是什么意思呢？就是到涅槃那里去，叫做「归驾」。到涅槃那里去，就是修行的意思，你修行六波罗密，你修止观，叫「归驾」。</p>
<p>　　「于玄途」，「于玄途」那就是…在这个《摄大乘论》上也提到，在《佛地经论》也有提到，这个佛的受用土「以大止妙观为游路」，「为游路」就是「玄途」了。就是微妙的圣道，名之为「玄途」。就是你修学这个妙止、妙观，回到无上菩提那里，回到涅槃，到涅槃那里去。</p>
<p>　　但是这条道路，在我们中国的时候，当然这就是玄奘大师的意思，有很多的地方令你有疑问而不得解决，就是这条路不顺，现在把《瑜伽师地论》翻译成功了以后，这条路顺了，所以叫做「整归驾于玄途」，就是这样意思，「可谓整蹄驾于玄途」。</p>
<p>　　「辟幽关乎虚室者也」，这个「辟」是开，把它开。「关」就是门。这个门关起来了，现在「辟」，把它开、把这个门开开。但是这个门是不容易开的，因为是「幽」，非常的深远，不可思议。但是难开的门现在开了。</p>
<p>　　这个「幽关」是什么呢？假设用前面的…，譬如说是…若是在我们凡夫的境界来说呢？佛法的真义，不能无所凭借的就表达出来，不能。譬如说是「鸟鸣花笑」，这个鸟叫了一声，看那花开了的时候，喔，你就开悟了。这个「鸟鸣花笑」就是你的门，入理之门，就是你的门。你观察万物无常，从这里得了圣道了，那么这就是门。说从文字上去表达佛法的真义，文字就是门。我们从经论上学习佛法，开悟了，这个经论的文字就是你的门。说文字上的佛法，我学习了以后，还没有开悟。我常常修止观，忽然有一天，那个鸟在树上叫一声，喔，开悟了，那鸟的叫，「鸟鸣」就是门，那就叫做「辟幽关」。</p>
<p>　　但是现在这里说呢？前面「鍠鍠焉，声希声于宇内」，这是指「教」说的。所以这个「辟幽关」不应该再说教了，那这个地方就应该指「烦恼」说的，指烦恼。</p>
<p>　　我们在修止观的时候，把这个烦恼破除去了，这第一义谛的真理显现出来了，就是「虚室」。</p>
<p>　　「虚室」是什么呢？我以前说过，就是拜大悲忏，《大悲心陀罗尼经》说：「愿我速会无为舍」，那就是「虚室」，无为舍就是「虚室」。《维摩诘经》说：「毕竟空寂舍」，维摩诘居士他也在房子里面住，他也有一个家，住在一个房子里头。那么我们平常的凡夫住在一个四面有墙有窗户，住在这个房子里头；但是圣人不是，圣人住的房子是毕竟空寂舍，住在毕竟空寂里面，当然那是成功了的人的境界。</p>
<p>　　所以这个地方，这个「虚室」就指无上菩提说的了，就是涅槃说的了。</p>
<p>　　「整归驾于玄途」是因，「辟幽关乎虚室」是果，由因而得果。就是你这样修行以后，你就破除了烦恼的关，就证悟了第一义谛了，这么意思。</p>
<p>　　所以，「明大明于重冥」是义，「鍠鍠焉，声希声于宇内」是教，这个教义是一双。「斯可谓整归驾于玄途，辟幽关乎虚室」，是因果一双。一个教、义；一个因、果一双。这是赞叹《瑜伽师地论》来到中国来的这个话。来到中国来，中国人可以有这个希望了，这样意思。所以这个人有文学同时他还是有智慧，用这么四句话来赞叹一下。</p>
<p>　　前面这说过了两大段，就是第一是「叙所为」，第二是「彰所因」，这两段说完了。</p>
<p><strong><em>第三、明宗要者。《释论》下云：又十七地具摄一切，文义略尽。后之四分，皆为解释十七地中诸要文义。故亦不离瑜伽师地，由是此论用十七地以为宗要。</em></strong></p>
<p>　　「第三、明宗要者」，就是说明一百卷的《瑜伽师地论》它里面究竟是说的什么道理呢？解释「宗要」，它的宗旨，它的精要的地方是什么？</p>
<p>　　「《释论》下云」，这个《瑜伽师地论释》在下面的文上说。</p>
<p>　　「又十七地具摄一切，文义略尽」，这个十七地只是《瑜伽师地论》里面的一分，就是＜本地分＞。这个＜本地分＞十七地已经具足的收摄了、包括了一切文义。「略尽」，一切文义的要义尽了，就是全部的重要的义都包括在这里面了。</p>
<p>　　「后之四分，皆为解释十七地中诸要文义」，后面还有四分，就是＜摄决择分＞、＜摄释分＞、＜摄异门分＞、＜摄事分＞，这四分。这四分里面说的什么事情呢？「皆为解释十七地中诸要文义」，都是解释前面这个＜本地分＞十七地中的「诸要文义」，特别重要的地方，再加以解释的。</p>
<p>　　「故亦不离瑜伽师地」，所以那个后面那四分，也没有离开那十七地的，有它特别的意义，也不是单独有什么意义的。也都…它里面说的义，也都包括在＜本地分＞了。</p>
<p>　　「由是此论用十七地以为宗要」，就是因为这样的理由，所以此《瑜伽师地论》就用十七地以为「宗要」，是它这个重要的道理，就在这里。这个「宗要」这个地方就这样解释了。</p>
<p>　　当然这个「十七地」，一共有十七个地，它每一地有名字，从名字上就知道它在说什么。我们在这里也不要再重覆了。</p>
<p><strong><em>第四、显藏摄者。《释论》下云：虽复通明诸乘境等，然说者问答决择诸法性相，意为菩萨令一切皆得善巧，修成佛果，利乐无穷。是故此论属菩萨藏阿毘达磨，欲令菩萨得胜智故。</em></strong></p>
<p>　　「第四显藏摄者」，这个第四条，显示这个《瑜伽师地论》它在这个经律论三藏里面，【小乘】的三藏，就是声闻藏；【大乘】的三藏，叫做菩萨藏，当然这是菩萨藏。菩萨藏里面它是属于那一部分呢？</p>
<p>　　「《释论下》云：虽复通明诸乘境等，然说者问答决择诸法性相，意为菩萨令一切皆得善巧，修成佛果，利乐无穷。」说是这个《瑜伽师地论》虽然是「虽复通明」，一卷、又一卷、一分、又一分、一地、又一地，这叫做「复」。</p>
<p>　　「通明」不是只说明一部分，是通于很多的「诸乘」，通于诸乘。「通明」就是普遍的说明「诸乘」，当然也包括人天、和出世间的三乘，里面的境行果，这些事情。</p>
<p>　　「然说者问答决择」，然里面这个说者，或者「说者」其实就是弥勒菩萨（《瑜伽师地论》是弥勒菩萨说的），里面的「问答决择诸法性相」，决断、简择诸法的体性，诸法的表现于外的相用。</p>
<p>　　这样的开示，「意为菩萨」，它的用意，它内心的目的、意趣，目的是为了菩萨、为了饶益发无上菩提心的菩萨。</p>
<p>　　「令一切皆得善巧」，使令这一切的菩萨，都能够得到善巧的智慧。</p>
<p>　　「修成佛果」，通达了境行果的道理，然后去修行去。修行的时候，将来能得到无上菩提。</p>
<p>　　「利乐无穷」，不管是自己也好，普度一切众生也好，都能得到无穷无尽的利乐。</p>
<p>　　「是故此论属菩萨藏阿毘达磨」，所以可以知道这一部论是属于菩萨藏，而不是属于声闻藏的。但是这个菩萨藏也包括了声闻藏在内的，所以在十七地里面有个声闻地。说是【小乘】里面，不是明显地包括【大乘】三藏，但是【大乘】里面包括了【小乘】三藏的。「是故此论」是属于菩萨藏。「菩萨藏」里面有经律论，它是属于那一部分呢？属于「阿毘达磨论」，就是属于论，就是叫做对法论。「阿毘达磨」是翻个对法。</p>
<p>　　这个大体上说，这个经、律都是佛说的，是佛说的法。「阿毘达磨」是佛弟子，或者是阿罗汉说、或者是菩萨说。解释佛的经、律的，是这样意思。</p>
<p>　　这个对法是什么意思呢？（这个「对」就是对答的对，彼此相对的对；佛法的法，法律的法，对法。）这个「对」在这里有两个意思，一个是面向的意思、趣向的意思。所以对向涅槃。对者，向也。就是向涅槃那里去，叫做「对」；那个「法」就指涅槃说了。这样说呢？是指学习佛法的人的愿望说的，你学习这样的佛法以后，你会发愿到涅槃那里去，这是第一个意思。说是这部论，它里面的意愿，就是要到涅槃那里去；不是在人天里面流转生死的。它能令你得大涅槃的，是这样意思，所以叫做「对法」。</p>
<p>　　第二个意思，「对」者，观也（观察的观）。就是你的智慧，去观察苦集灭道、或者观察「唯识无义」、观察第一义谛、观察三自性，那么这个「法」就指「三自性」说，「对法」。这样子，这样呢？就是行。前面说对向涅槃是愿；这里说呢？是对观就是因；对向涅槃，若是已经到涅槃那就是果了。</p>
<p>　　所以这里面也应该包括教行理果，都应该包括在内，是名为「阿毘达磨」也。</p>
<p>　　这个经里面道理的情况呢？多数是随顺众生的根性，而有它的次第。经里面道理的次第，是随顺众生的根性，来排那个次第的，「随机」论次第。这个论呢？多数是随义论次第，随这个道理，随道理来论次第。大概的这么说，是有这样的差别。</p>
<p>　　那个经是随机散说，随听法的人，听法的人是各式各样的人都有。那么佛会随着不同的根性，说出来各式各样的佛法，这一会的说法就是这样情形，这是随机的。而这个论是「随义」的，就是有次第的由浅而深、或者是由略而广，把这个…随作者的意愿，他把佛法这样的表达出来。当然这是论与论也各式各样的论，也是不完全一样的，「是故此论属菩萨藏」的论藏。</p>
<p>　　「欲令菩萨得胜智故」，它目的是什么呢？就是希望学习佛法的菩萨，他能成就殊胜的智慧。这殊胜的智慧当然包括闻思修，乃至于得无生法忍的这些智慧。这样子你才能在佛法里面起作用。单单有闻慧是不行的，这一段是「显藏摄」。</p>
<p><strong><em>问：</em></strong>讲一讲辩机法师的故事。</p>
<p><strong><em>答：</em></strong>辩机法师的故事也是可以说的。辩机法师当时好像在大总持寺的住持，那里的上座。但是你看那《大唐西域记》，当然是玄奘法师口述，是辩机法师写出来的，看他那文学不得了、这个人。他有什么事情呢？这件事我认为唐太宗不公平。什么事情啊？就是唐太宗有一个女儿，是嫁给了房玄龄的第二个儿子，但是不知道什么原因，他这个…唐太宗的女儿，就见到了这个辩机法师，见到他呢？可能他们就在一起了。一起了，这个你们看见这个谁？北京师范大学的校长叫陈元，他有出了一本书。出了一本书，他说：（这个公主叫什么名字？不叫太平公主，不是）她是同她先生说好了，另外找两个女孩子给他先生，她就和辩机法师在一起，就是有这种事情。这个陈元（他是信基督教的），他说：可能在一起有十几年这么久，这么久后来这个道教的道师的什么人知道了。知道了就是…就揭发这件事。好像皇宫里面有一样什么叫做玉枕，当然这种东西可能不是一般人有的，就是在大总持寺这里面拿到。拿到了，就是假借这件事是报告了政府，政府当然是调查这件事，就把这件事就揭发出来。揭发出来，唐太宗下令就是把辩机法师腰斩东市，是这样，就把他杀了。但是他的女儿呢？对他女儿就是怒目而视就完了。就是有这么一件事。</p>
<p>　　若我看我批评这件事，我认为…啊，这回还有下面一句，等到唐太宗死的时候，他这个女儿哭而不哀，有这种、特别的形容了一句，有这话。</p>
<p>　　我在想，这个时候，我也没有时间去特别去查。不知道这个时候房玄龄在不在。因为房玄龄和唐太宗的关系太深了，太深，如果房玄龄在，可能是唐太宗受了房玄龄的…房玄龄也可能不支声，揭发了以后，房玄龄也可能不说什么。唐太宗可能会愤怒，可能会受房玄龄的影响，就这样处理。如果是房玄龄若是已经死掉了，唐太宗不应该这样处理。因为这件事我在想，因为她的女儿若是…一定是她女儿主动嘛，因为这是皇帝的女儿，那是谁敢轻视她啊！那么这样子做的话，唐太宗也应该明白这件事。那么辩机法师就是倒霉了，什么都不对，我在想这件事。如果你不顺着她，也是要死掉；你顺着她，这件事也就是这样结果了。但是在这个《玄奘法师传》上，一个字不提它这件事，但是这历史上有。而这个欧阳修有这个《新唐史》、《旧唐史》，这一段我记不清楚，欧阳修关系这个历史这个地方，他把很多佛教里面光彩的事情删掉了很多，但是这件事不删掉，这件事写得清清楚楚，「腰斩东市」，这个欧阳修这个人。有这件事。</p>
<p>　　可是在《大唐西域记》上还是写《辩机法师传》。这个陈元这位老先生，他也提到道宣律师，因为道宣律师，当时翻译的时候，道宣律师也在场，所以这些位大德知道这件事的。可是道宣律师在《高僧传》里面没有提他，没有给他立传。可是在其他的地方，似乎是有提到他的名字。这个陈元就是推测道宣律师那个意思，道宣律师也很同情他，但是重视律的人，也是同情辩机法师。</p>
<p><strong><em>问：</em></strong>请问「叙所为」里面十番的第二番的第二缘「有情界中，有种姓者出生死；无种姓者脱恶趣故」和第四番一个是「菩萨（种）姓人」跟「及二乘无姓」，这两个有什么不同？因为看起来是有一点重复，还是它一个略、一个是广说。</p>
<p><strong><em>答：</em></strong>那个第四番「及二乘无姓，亦依大教，各于自乘文义行果生智断伏，得自乘果，离恶趣故。」是说得详细一点。前面的说的略。有广略的不同。</p>
<p>　　说是这个我们学习佛法，学习了十几年，然后对人家说：「佛法和其他的宗教是一样，都是劝人为善」这个说话。我们从这里可以会出来，学习佛法可以出生死，一般的做善事只是脱恶趣而已，出离生死还是不能。所以佛教和其他的宗教是不一样。</p>
<p><strong><em>问：</em></strong>里面都讲「三乘」，有菩萨乘，为什么没有特别提「佛乘」？</p>
<p><strong><em>答：</em></strong>这个「菩萨乘」就是「佛乘」，菩萨是因、佛是果。所以说或者「菩萨乘」，或者说「佛乘」，是一样的。</p>
<p>　　这个我们在《玄奘法师传》上，看出来《瑜伽师地论》的确是很重要，但是它来到中国来，只是当时或者唐朝有很多人学习。我看到宋朝以后、元明清以后，越来没有人学习，学习的人越来越少。到元明清以后，越来大家就欢喜研究这个《起信论》和《楞严经》。</p>
<p>　　《起信论》和《楞严经》也是好，但是对于【法相】、【大、小乘】、这个修行的法门来说，还是要《大智度论》和《瑜伽师地论》才好。</p>
<p>　　我感觉这个《楞严经》的「耳根圆通」、「二十五圆通」选「圆通」选个「耳根圆通」，选「耳根圆通」，「耳根圆通」说那个道理还就是「止」的成分多，「观」不明显。而事实上呢，谁修「耳根圆通」了？「耳根圆通」是第一，结果是「念佛」法门、大势至菩萨「念佛」法门反倒是第一，应该是第一才对。念佛法门很多人欢喜念佛，「耳根圆通」反倒是没有人。文殊菩萨选了「耳根圆通」第一，它是第一吗？结果是念佛法门是第一，事实上是这样子嘛！</p>
<p>　　但是若真是修止观呢？那我看还是要《瑜伽师地论》和《大智度论》好。可是从佛法的历史上看，尤其是从【禅宗】的历史上看，都是逐渐地、逐渐地转到后来，都是「止」而没有「观」，没有「观」。</p>
<p>　　这个事…一方面是因为人懒，不愿意修「观」，就是第六意根懒、第六意识懒。第二个就是不欢喜读经论，所以这「观」修不来，只好去修「止」。修「止」呢？是钝根；修「观」是利根人。</p>
<h3 id="第5讲"><a href="#第5讲" class="headerlink" title="第5讲"></a><strong><em>第5讲</em></strong></h3><p>　《瑜伽师地论》，我们在开讲的时候，分六大段。第一是「叙所为，第二、彰所因，第三、明宗要，第四、显藏摄」，这四大段都讲过了。现在是第五段「解题目」。</p>
<p><strong><em>韩清净＜分别瑜伽品＞</em></strong></p>
<p><strong><em>梵音瑜伽，此云相应。然此瑜伽依瑜伽释，两释不同。一云：通说三乘境行果等所有诸法，皆名瑜伽。一切并有方便善巧相应义故。</em></strong></p>
<p>　　这《瑜伽师地论》是这一部的总名。「梵音瑜伽，此云相应」，这个《瑜伽师地论记》里面有解题目的，但是那个文太广、太多了。</p>
<p>　　现在这里面是这个…现在我们影印这一部分是韩清净〈分别瑜伽品〉里面解释的，他解释的比《瑜伽师地论记》少一点。</p>
<p>　　这个「瑜伽」这个词不是中国话，是印度的梵文，翻成中国话嘛叫做「相应」。这「相应」怎么样解释呢？「然此瑜伽，依《瑜伽释》，两释不同」，这个「相应」这句话，也就是这个「瑜伽」，若根据《瑜伽师地论释》有两种解释，不一样。</p>
<p>　　第一种呢？「通说三乘境行果等所有诸法，皆名瑜伽」，这是第一个解释；第二个解释是「正取三乘观行，说明瑜伽」，这二种解释。第二个解释是别；第一个解释是通。就是通于三乘（声闻乘、辟支佛乘、一佛乘），都有瑜伽的道理。这个三种佛法里面都有境、行、果、理这么多的事情，都是有的。这个「境行果理」，或者「境理行果等所有诸法」，皆可以名之为瑜伽的。什么原因呢？</p>
<p>　　「一切并有方便善巧相应义故」，因为「境理行果等」，它们都具有方便善巧的道理。都有这种道理与之相应的，所以都可以名之为瑜伽。</p>
<p>　　这个「方便」这个字，就是智慧，「方便」就是「善巧」。「善巧」是赞叹智慧的一个词。方便就是善巧，善巧就是智慧。一切法它相应、不相应就是智慧的问题，有智慧就是相应，你没有智慧就是不相应。就是我们遇见一切境界的时候，你有智慧的时候，一切境界都是佛法，都是清净无染的；没有智慧的时候，就不是佛法了。这个大意就是这样子。</p>
<p>　　这下面就是解释「并有方便善巧相应义」，解释这个道理。</p>
<p><strong><em>境瑜伽者：谓一切境，无颠倒性、不相违性、相随顺性、趣究竟性，与正理教行果相应，故云瑜伽。</em></strong></p>
<p>　　「境瑜伽者：谓一切境，无颠倒性」，说是境行果等都有相应义，那么境怎么叫做相应、怎么叫做瑜伽呢？「谓一切境」，这是说这个「境瑜伽」这个「境」，就是所有的一切的境界，一切的色声香味触法、眼耳鼻舌身意、眼识乃至意识，这十八界，不管是佛的境界，乃至到地狱里的一切的境界，都没有颠倒性，这就叫做「相应」。</p>
<p>　　这个「没有颠倒性」怎么讲呢？就是我们没有得圣道的人，我们的这个识，就这一念灵明的心，接触一切境界的时候，都是颠倒的，就是贪瞋痴。这个识和一切境界接触的时候，自然的这个贪瞋痴就出来活动，所以都是颠倒的境界。现在在佛教徒呢？这个识若与一切境界接触的时候，没有这一切的颠倒，就是他能通达一切境界都是虚妄的、都是不真实的。它本身没有真实的体性，它是内心分别所现的一切的影像而已。如果内心里无分别的时候，一切境界都是没有的，这虚妄境界也不现了，这心也不可得了。你能这样子通达呢？叫做「境瑜伽」，就是「相应」了。「谓一切境无颠倒性」，没有颠倒的性。</p>
<p>　　所以若是我们学习佛法，这经律论在我们的内心里面来说，也是一种境界，我们经本子一打开，里面有字，白纸黑字，这是一种境界。若是我们在这里不能够「无颠倒性」，那也就不是瑜伽了。不要说一般的尘劳境界，就是经律论也是这样子。说是「谓一切境无颠倒性」。</p>
<p>　　所以这个天台智者大师解释这个「经」这个字的时候，《妙法莲华经》这个「经」这个字的时候，不是说是白纸黑字的这个《妙法莲华经》是经，所有的一切色声香味触法都是经，那就是因为「无颠倒性」的关系。你能通达这个无颠倒性，一切都是经、都是正法。</p>
<p>　　「不相违性」，前面是说这个境，它也有方便善巧义，这可见这个境也称之为瑜伽，就是因为有方便善巧的智慧，「向道上会」。向道上会，向道上去理会，所以叫做「境瑜伽」。</p>
<p>　　这个「不相违性」怎么讲呢？这个不相违性指「教」说的。就是佛说出来的随顺众生的根性，所宣扬出来的正法，语言文字的佛法。这语言文字的佛法，在佛说的时候就是个声音，是个语言、声音，把它纪录出来就是文字了。这样的文字的教法「不相违性」，与那个「一切境无颠倒性」，其实就是真理，与真理不相违背，是符合诸法的真理的。佛说的那个教与真理是相随顺的、是相契合的、没有矛盾的，它恰到好处的形容诸法的真实相，所以是不相违、没有冲突的。所以也是相应、也是瑜伽，教也是瑜伽。</p>
<p>　　「相随顺性」，这个「相随顺性」是什么意思呢？佛说与理相应的这个教，你能够这样去学习、去修行的时候，它就与第一义谛相随顺，而不是相冲突的。说我坐船想要到彼岸去，这个船是在水上走，这里不是彼岸。船也不是彼岸、水也不彼岸，但是是向彼岸去了。如果你这个方向不对了呢？与彼岸就是愈来愈远了，愈走愈远了，那就不是相随顺。说我们发心修行的时候，我们一开始是要凭借佛说的语言文字的佛法，是凭借这个。凭籍这个，它不是那个第一义谛，但是与第一义谛相随顺，它相随顺的，它不冲突，所以也是「相应」，所以也是「瑜伽」，就是「不相违性，相随顺性」。</p>
<p>　　「趣究竟性」，这个是果。佛说的这个教，我们随顺佛的教去修行，能向…这个「趣」就是进趣，向前进，到无上菩提那里去了、到大般涅槃那里去了、到第一义谛那里去了，所以与果也是相应的、与果也是没有冲突的。也有这个方便善巧相应之义，所以也叫做「瑜伽」，果也叫做瑜伽。</p>
<p>　　这样说呢，一个是境，「一切境无颠倒性」，一个是境。这里面有理，还有教、有行、有果。</p>
<p>　　「与正理教行果相应」，这是结束前面这几句话。这样说呢，这个「境」，它与正理、与佛的教法、与佛教徒的修行、所希望成就的果，都是相应的、都是相合的。「相应」也就是相合的意思。</p>
<p>　　「故云瑜伽」，所以境、理、教、行、果都名之为「瑜伽」。</p>
<p><strong><em>此境瑜伽，虽通一切，然诸经论，就相随机，种种异说。或说观待等四种道理，如是乃至说蕴界处缘起谛等，皆名瑜伽。总具四性，顺四法故。</em></strong></p>
<p>　　「此境瑜伽」，前面说这个境瑜伽，「虽通一切」，按照道理来说，是通于一切的境界的，没有不包括在内的。</p>
<p>　　「然诸经论」，可是在很多的修多罗里面，在很多的阿毘达磨论里面，它也会很明白的说出来，什么叫做「境」？什么叫做「境瑜伽」？它也会说出来的。</p>
<p>　　「就相随机」，这个「就相」，「相」就是法相。这个法相是什么呢？就是佛为我们说的这些语言文字的一切的佛法，叫做「法相」。因为文字一说出来的时候，在我们的心里面去思惟的时候，这都是「相」了。我们…其实一切法都是相，我们这些染污的事情也都是相。我们心里面有了贪心了，那贪也是相；起了瞋心，瞋心也是相；愚痴也是相，一切一切皆是相。现在说佛说的一切的正法，在我们心里，我们听见了、我们阅读了以后，在心里面也是相。那么这就是…就法来说，叫做「相」。</p>
<p>　　「随机」，这个「机」是众生的程度，众生的程度叫做「机」。这个「机」这个字是怎么讲呢？好像是在《易经》上说：「动之微，吉之先现」，叫做「机」，动摇，这个动力，一开始的时候是小小的动，叫做「微」，微小的动叫做「机」。「吉之先现」，就是一切如意的事情，最初开始的那个动力，就叫做「机」。</p>
<p>　　现在这里是说什么呢？就是我们众生开始发心的时候，这个内心的那一点诚意叫做「机」。最初学习佛法的时候，那一点点的诚心，叫做「机」。或者我们受苦了，哎呀，很苦啊，佛慈悲啊，消除我的苦恼。你这一念向佛有所求的那一点诚心，就叫做「机」。这「机」有利、有钝的不同，就是各式各样的差别。</p>
<p>　　那么就「相」来说，就是按照佛法来说，应该什么是「境瑜伽」？若按照众生的「机」来说，什么是「境瑜伽」？这句话是这样意思喔。</p>
<p>　　所以「种种异说」，若按照佛法来说，这个境瑜伽应该是什么、什么…；若按照众生的根性来说，是什么、什么、什么…，种种的不同的说法。这底下就指出来，究竟什么说法呢？</p>
<p>　　「或说观待等四种道理」，有观待的道理、作用道理、证成道理、法尔道理这四种道理。这四种道理就是境瑜伽。</p>
<p>　　这个四种道理，是在《瑜伽师地论》的＜第二十五卷‧第九页＞。我把它影印出来。我们也在这里就…我们把它念一遍喔。这四种道理就是境瑜伽，这样讲。</p>
<p><strong><em>《瑜伽师地论》第二十五卷‧第九页：</em></strong></p>
<p><strong><em>云何以称量行相，依正道理思惟诸蕴相应言教？谓依四道理无倒观察。何等为四？一、观待道理；二、作用道理；三、证成道理；四、法尔道理。</em></strong></p>
<p>　　「云何以称量行相，依正道理思惟诸蕴相应言教？」这是先问，先问一句，怎么叫做「以称量行相，依正道理思惟诸蕴相应言教」呢？</p>
<p>　　其实这个「称量行相」就是权衡轻重叫做「称量」，其实也就是思惟的意思。对于这件事究竟是什么一种情形呢？心里面想一想，认识它，究竟是怎么回事？那就叫做「称量」。</p>
<p>　　这个「行相」，这个「行」是什么呢？「行」就是我们内心的活动，叫做「行」。心里面在活动，叫做「行」。也就是「称量」，「称量」就是内心在活动嘛。这样的相貌叫做「称量行相」。</p>
<p>　　怎么叫做「称量行相」？「依正道理」，就根据佛所说的道理，叫「依正道理」。去思惟观察色受想行识诸蕴，思惟这个诸蕴是怎么一回事。</p>
<p>　　「相应言教」，与诸蕴相应的言教。就是佛说这个色蕴、受想行识蕴是无常的、是苦的、是空的、是无我的，这样的佛说的正法，叫做「言教」。「诸蕴相应言教」，就是佛说的诸蕴相应言教。我现在听到了、我从经本上看见了，我就去思惟去，叫做「思惟诸蕴相应言教」。或者是思惟色声香味触法相应言教、思惟眼耳鼻舌身意相应言教、思惟十八界，各式各样的相应言教。现在这里说，「云何以称量行相，依正道理思惟诸蕴相应言教」。</p>
<p>　　「谓依四道理无倒观察」，这回答这个问题，就是依据这四种道理，没有错误的观察，那就叫做「以称量行相，依正道理思惟诸蕴相应言教」。</p>
<p>　　「何等为四？一、观待道理；二、作用道理；三、证成道理；四、法尔道理」，就是这四种道理。</p>
<p><strong><em>云何名为观待道理？谓略说有二种观待：一、生起观待；二、施设观待。生起观待者：谓由诸因诸缘势力生起诸蕴。此蕴生起要当观待诸因诸缘。施设观待者：谓由名身句身文身施设诸蕴。此蕴施设要当观待名句文身。是名于蕴生起观待、施设观待。即此生起观待、施设观待，生起诸蕴、施设诸蕴，说名道理瑜伽方便。是故说为观待道理。</em></strong></p>
<p>　　「云何名为观待道理？」怎么叫做「观待道理」？这「观待道理」怎么解释呢？「谓略说有二种观待」。简略的说有两种观待，那两种？</p>
<p>　　「一、生起观待」，第一个是生起观待。就是一切法都是因缘所生，此一法生起的时候，就有观待的道理。</p>
<p>　　这个「观」，是相对的意思。就是这个「相对」…这里是因果相对，因与果是相对的。或者是心与境相对，我们的心与境界相对。相对的时候，就是心去观察的意思。我们内心在观察这件事的时候，就是心与所观境相对、相面对的时候，去观察。当然你不观察，也不知道这件事，这叫做观。</p>
<p>　　这个「待」是凭借的意思，就是假藉的意思。你若没有这个因缘，这件事不成功。你一定要依赖它，那就叫做「待」，这个待有这样意思。</p>
<p>　　「二、施设观待」，头一个是「生起观待」，第二是「施设观待」。这个「生起观待」怎么讲呢？「生起观待者：谓由诸因诸缘势力生起诸蕴。此蕴生起要当观待诸因诸缘」。「谓由诸因诸缘」，这个蕴的生起，它一定要假藉诸因，很多的因、很多的缘的势力。或者是因的力量，叫「势」；缘的力量，叫「力」。或者也不必这样分别，就是诸因诸缘的势力。这个因和缘啊，主要的力量是因，次要的力量是缘，或者这样分别。</p>
<p>　　譬如说是我们种的这个谷，这个谷的种子种在地下了。这个种子是因，其它的土、水、或者是肥料、或者是阳光、或者也有风，这些都是缘，就这样说喔。</p>
<p>　　现在这里是说「诸蕴」，就是我们的这个生命体的果报。这个果报的因缘呢？种子，也是种子是因，业力是缘。业力帮助这个名言种子成熟了，因缘和合了，这个色受想行识现起了，一剎那间色受想行识现起来，这叫「诸因诸缘」的「势力生起诸蕴」，生起了色受想行识的蕴。</p>
<p>　　「此蕴生起要当观待诸因诸缘」，这个色受想行识的蕴，它能够现起来，它一定要凭借诸因诸缘才可以。没有因缘的时候，色受想行识它不能现起。</p>
<p>　　譬如说是我们人，一剎那间我们投胎了。投胎了，这个色受想行识现出来了。为什么没有现出来天的色受想行识呢？没有因缘。没有那个因缘，所以不现起。也没有三恶道的色受想行识现起，就是没有那个因缘。也就是…或者你已经有，但是不发生作用。为什么人的因缘、这个蕴现起了？因为人的这个因缘发生作用了，所以叫做「要当观待诸因诸缘」。这个蕴的现起，这个蕴一定要观待诸因诸缘才能现起，这就叫做「生起观待」，不然它不能现出来。</p>
<p>　　从这里看出来呢？诸因诸缘是自性空，它本身没有体性。要现起，要凭借因缘才可以，凭借因缘才能现起。所以这样…你这样一观察呢？很多的佛法的智慧，从这里出来了。</p>
<p>　　这个怎么叫做「以称量行相，依正道理思惟诸蕴相应言教」？就是这样思惟，第一个要思惟这个观待的道理，一切法都是具有观待的道理的。</p>
<p>　　说我们这个臂，这个臂为什么能屈伸呢？因为这里有个节。有个节，所以可以、能屈伸。所以屈伸要观待这个节。说我们为什么会走路？因为你有足；若没有足这件事不可以，你不能走路。所以一切法都是要观待因缘的。</p>
<p>　　「施设观待者」，这个生起的观待这样讲，这个施设的观待怎么讲呢？「谓由名身、句身、文身施设诸蕴」。</p>
<p>　　「施设」实在就是安立的意思。没有这件事，我们把它安立出来。这里没有房子，没有房子把这个房子造出来，那么这叫做「施设」、叫做「安立」。说我们没有这个书桌，没有书桌我们摆上一个书桌子，这叫「施设」。那这指什么说的呢？</p>
<p>　　「谓由名身、句身、文身施设诸蕴」，这个诸蕴有生起观待，也须要有施设观待，就要有名、要有名句文身才可以。</p>
<p>　　这个「文身」啊，「身」就是体的意思。这个「文」是什么？文就是字，一个字、一个字，我们汉文这个一块、一块这个字。这个文就是字。</p>
<p>　　这个「名」是什么呢？就是这个字，用多少个字组织起来成为名。说「房」，这就是一个字，也就是一个名，也就是各式各样…或者「灯」、「光」，就是这些名。因字而有名，因名而有句，多少个名组织起来，称之为一句。多少句呢？就是成为一段了。很多、很多的段落，就是一篇文章了，或者一部书了。这叫做「施设」。</p>
<p>　　现在这个生起观待，生起了一件事，这件事叫什么名字呢？叫做「蕴」，名之为蕴。就是施设，用这个蕴来表示这件事。如果没有这个蕴的施设，你没有办法观。没有这个施设的观待，你没有办法去观察，你心不能动。因为没有名字的时候心不能动，心不能动就不能观察。所以有生起观待，还要有施设观待。所以这个观待有两种，生起观待、施设观待。</p>
<p>　　此蕴的施设，此蕴的安立，蕴的这个名字的安立，「要当观待名句文身」，要凭借名句文身。「是名于蕴生起观待、施设观待」，这是把前面这一段总结起来。</p>
<p>　　「即此生起观待、施设观待，生起诸蕴、施设诸蕴，说名道理」，这个生起观待、施设观待也就是表达了生起诸蕴、施设诸蕴的事情，这就叫做道理，就叫做观待道理。</p>
<p>　　这个【唯识】这个法门，不管是《摄大乘论》也好、《瑜伽师地论》也好、《成唯识论》、《显扬圣教论》、《辩中边论》这些论，它说的法门，你若和其他的法门对比起来，它说得微细，它说得很微细的。你心一动就开始了，就从那里给你…就观察了、就开始了，和别的法门不同。加上玄奘法师是汉人，他的汉文好，他再懂得梵文，由梵文翻成汉文，我们和其他的这些翻译的法师对比起来，都感觉到玄奘法师翻得微细；稍微有一点曲折的地方，他能翻出来。你别的法师，你对照起来，就没有，看不见了。就是他一个有的时候有意的把它略去了，有的时候也因为对汉文的学习要再努力，这地方有点关系的。所以我认为玄奘法师他翻的这些经论，不管你是那一个学派，你不要有门户之见，你就是学习、学习，你会增长很多智慧。</p>
<p>　　「说名道理瑜伽方便，是故说为观待道理」，这是结束这段文。这个说明这个观待的道理，这是修瑜伽的方便。你想要修止观，你想要修行，这个「生起观待」是你修行的一个方便。你知道这件事了，你修行的时候会很顺的就相应了，你若明白这件事的话，「是故说为观待道理」。这观待道理这么样解释，但在《瑜伽师地论》里面另一个地方，还有很多解释的。</p>
<p><strong><em>云何名为作用道理？谓诸蕴生已，由自缘故，有自作用，各各差别。谓眼能见色、耳能闻声、鼻能嗅香、舌能尝味、身能觉触、意能了法。色为眼境、为眼所行，乃至法为意境、为意所行。或复所余如是等类，于彼彼法别别作用，当知亦尔。即此诸法各别作用，所有道理瑜伽方便，皆说名为作用道理。</em></strong></p>
<p>　　「云何名为作用道理？谓诸蕴生已，由自缘故，有自作用，各各差别。」这底下解释什么叫做作用道理呢？</p>
<p>　　「谓诸蕴生已」，谓我们这个色受想行识这个蕴，它已经因缘和合现起来了，由无而有了。</p>
<p>　　「由自缘故，有自作用」，由它本身的因缘。比如说色有色的因缘，受想行识有受想行识的因缘。这个色呢？包括眼耳鼻舌身，前五根都是色、都是色蕴。那么眼有眼的因缘，耳有耳的因缘，乃至身有身的因缘，都有它本身的作用。</p>
<p>　　「各各差别」，互相是不一样的，各有各的因缘是不一样的。这底下就详细说出来。</p>
<p>　　「谓眼能见色、耳能闻声」，这眼它的作用，它能见色。这个地方呢？见闻包括根和识，这个眼根它能够见这个色，见这一切青黄赤白、长短方圆的这些形相，它的功能能把这个形相现出来，当然还要假藉光明现出来。但是能了别，了别这个色相，那是识的作用。但是若没有眼根，眼识也不行，所以这个眼能见色，有根、有识的合在一起的，都包括在内了。「耳能闻声」，这个耳有这样的作用，有闻声的作用。「鼻能嗅香、舌能尝味、身能觉触、意能了法」，鼻有能够嗅这个香味的作用，或者是好香、或者是恶香。舌能够尝味。身能够感觉到触，或者是涩滑、或者是冷热。意能够了法，能了别各式各样的事情。</p>
<p>　　这个色声香味触也是法，是法里面的一部分。「意能了法」这个「法」字，包括了色声香味触，还有它没有包括的其他的一切法，所以这个法是通名，这范围很广大了，「意能了法」。这就是六根、六识有取境的作用。</p>
<p>　　「色为眼境、为眼所行」，那么色声香味触法有什么作用呢？色为眼的所缘境，那么这也是它的作用之一。「为眼所行」，为眼根所活动的境界。若没有色了，这个眼根所活动的地方没有了，「为眼所行」。</p>
<p>　　「乃至法为意境、为意所行」，有了声、声音是耳所活动的地方，乃至到第六这个法，过去、现在、未来；世间法、出世间法，这是意的所缘境，是「意所行」，所活动的地方，那么这也就是它的作用。</p>
<p>　　「或复所余如是等类，于彼彼法别别作用」，这个「所余」，所剩余的。前面这是说十二处，内六根、外六境，十二处。如果把六识也放在内，就是十八界了。那么十二处、十八界，或者是把第七识、第八识也加在内，各有各的境界，各有各的作用，所以叫做「所余」，所剩余的。</p>
<p>　　「如是等类」，就是一类一类的，眼识一类、耳识一类。眼只能在色的境界上活动，而不能在声音那上活动。耳识、耳根只能在声音那里活动，而不能在色上活动，所以是一类、一类的，一个范围、一个范围的。</p>
<p>　　「于彼彼法别别作用」，于这一法、这一法都是各别、各别的发生作用。所以眼有眼的作用、耳有耳的作用，乃至身有身的作用、意有意的作用。「当知亦尔」，你要知道也是这样子，每一法都有它的作用。</p>
<p>　　「即此诸法各别作用，所有道理瑜伽方便，皆说名为作用道理」，就是前面说这一切法，十二处、十八界这一切法，都有各别的作用，这样的道理也是你修瑜伽的方便，你也须要明白这件事的，皆说名为作用道理，这样意思。</p>
<p><strong><em>云何名为证成道理？谓一切蕴皆是无常，众缘所生，苦空无我。由三量故如实观察，谓由至教量故、由现量故、由比量故，由此三量证验道理。</em></strong></p>
<p>　　「云何名为证成道理？谓一切蕴皆是无常，众缘所生，苦空无我。由三量故如实观察：谓由至教量故、由现量故、由比量故，由此三量证验道理」。这底下说这个「证成道理」，证明这件事成立了，是的，是有这样道理，那叫「证成道理」。</p>
<p>　　「谓一切蕴皆是无常」，什么道理须要证成呢？「谓一切蕴皆是无常」，色受想行识都是有变化的，它不是不变的。不变名之为常，有变就是无常了。</p>
<p>　　因为什么它会变呢？「众缘所生」，因为它是很多的因缘才成就这件事。成就这件事，它本身就不真实了，所以它会变。这个众缘所生，这个缘本身也要变，所以众缘所生也非变不可。一变了的时候就苦了，人就会感觉到痛苦。</p>
<p>　　比如说这个快乐的事情，人不感觉苦。但是快乐的事情要变，若变的时候就苦了，所以称之为坏苦。这个原来是没有苦的，但是这个因缘一变就有苦了，所以一变就是无常，无常就是苦。因为苦的关系，就可以知道是空的，不是真实的，它不是真实的。原因啊，我们人的…就是因为执着有我，我要这样子就这样子，我要那样子就那样子。你说有苦，我可以把它消灭了它，叫它不要有。当然我欢喜这件事，我可以把它拿过来；不欢喜的，把它消灭了它。所以这个人有我的时候，会这样子安排这件事。但事实上做不到。做不到，就可以知道是没有我的，所以叫做空。</p>
<p>　　这个「执着我」有两种，就是「即蕴是我」、一个「离蕴」有一个我。即色受想行识是我，这是「即我」；第二个是离开了色受想行识，另外有一个我，这个执着有我，分这么两类。</p>
<p>　　这个空呢？「即蕴无我」，叫做「空」；「离蕴无我」叫做「无我」，是这样意思喔。离蕴无我，那叫做「我空」；即蕴无我，叫做「法空」，因为观察色受想行识都是因缘有的、都是毕竟空的。色受想行识自性空，也是无我；「离开了色受想行识另外有我」这个我也没有，叫做无我。这样…可以这样分别。</p>
<p>　　这是说，为什么一切蕴是无常的呢？因为是众缘所生，所以是无常。无常的时候我们就会感觉到苦。因为苦，所以感觉到作不得主。苦若来的时候你不受还不行，此是苦逼迫性，你不能排斥的，你排不出去的，那么就可以知道是无我。无我就是空无我，就是空。</p>
<p>　　这样的事情，在我们不相信佛教的人来说，也能知道世间上是无常。无常的道理能明白多少，但是对于苦的道理不太明白，对于苦的事情不是太明白。世间上为什么苦？我们一般人不知道，有智慧的人都未必知道，也未必知道是苦。</p>
<p>　　譬如说是我们举出一个道理，在《阿含经》里面说出个道理来。这《阿含经》应该学。我们学这个大乘经应该学，《阿含经》也应该学。《阿含经》说出个什么道理呢？佛有一天问诸比丘，说是远远的那个树林子里面，这个木生所出来那个枝叶，这个叶落下来了，有外边的人来了把这树叶子偷走了，把这树叶子偷走了，你心里面感觉什么？问诸比丘，你心里头感觉怎么样儿？说，我没有什么感觉。它偷走就偷走嘛，与我有什么关系，我好像照常的，一点影响也没有。佛说，是。如果你的衣服，你的衣、你的钵，或者你住的房子被人家破坏了，你的房子、玻璃窗户被人破坏了，把你的衣、钵都偷走了，你心里头…说这时候不舒服，我心里面会不舒服。说为什么呢？为什么你的衣钵、你的衣食住被人偷、被人盗取了、破坏了，你就会感觉到不舒服。那个树叶子被偷走了，你为什么就不感觉什么呢？说：这个我不懂，我不知道。佛说：就是因为你对树叶子，遥远的那些事情，你没有执着，你不执着，不执着是我我所，所以他偷走了我无所谓。你自己的生命有关系的事情，你执着是我、是我所了，所以他若把你的衣偷走了，你就不行。执我、我所换一句话就叫做爱，说我也是有爱，我所也是有爱，就是有爱的关系。所以这样说，这个不舒服的感觉就是苦的感觉，这痛苦的感觉从那儿来呢？从爱来的。这个佛…你看佛就是…说世间是苦，无常是苦，从你本身的生活上来开示这件事。</p>
<p>　　这件事在《阿含经》你看到这里，你想一想的确是这么回事。我的哥哥、我的弟弟若死了，我心里会痛。我的姊姊、我的妹妹死了，也心里会痛。别人的哥哥、别人的弟弟死了，我心里不感觉什么。因为什么呢？没有我、我所，你对他没有爱的关系。自己的哥哥、弟弟、姊姊、妹妹死了，有爱。有爱就有苦。没有爱就没有苦。</p>
<p>　　所以是无常啊，我们人世间的人，思想稍微细腻一点的人，也能知道无常的道理，知道多少。但是这苦不一定知道，不一定明白。</p>
<p>　　原来是在佛的开示里面知道，因为什么是苦？也就是因为是爱。爱为什么是苦？爱无常了，所以是苦。但是我们人呢，还非要爱不可，所以就是非苦不可了。所以是苦。「众缘所生，苦、空、无我」。这件事啊，因为无常知道多少啊，可是从无常若变了的时候会生苦，我们还不大明白。所以严格的说，无常也不明白，也不明白什么叫做无常，也还是不明白。</p>
<p>　　我现在心里头想到梁武帝，梁武帝的确我也认为很了不起，很了不起，能讲《大般涅槃经》、能讲《摩诃般若波罗密经》，有着作，你看有这么大的智慧，在佛法里面，他也是用过功了的人。但是若是作了一个梦，我好像说过，有人把这个土送给他，作梦醒了。醒了向他的大臣讲，大臣说：这表示你能统一中国。因为他还是半璧天下，只在金陵做皇帝，北魏这一大片土地还不属于他，这表示你要统一中国。啊，他的贪心就来了，派他的大儿子萧明（注：昭明太子萧统？）要统一中国。大儿子领了四十万军，一下子变成俘虏了，都叫北魏俘虏了，还有这种事情。你看学习佛法学到这么程度，结果是还有这一念贪心。这一念贪心，他从此就开始倒霉了，就是还是不知道苦啊！对这个「苦」字还是不太明白。这个我，要扩大我所，我、我所还要扩大这件事。</p>
<p>　　这个佛法的道理不是容易明白，所以要「证成」。为什么是无常、是苦、是空、是无我呢？要证成，要假藉因缘来证成一下，喔，是苦、是无常。问题在这里喔。</p>
<p>　　「由三量故，如实观察」，这个证成，怎么样证成法呢？有三种量，如实的观察，这就叫做「证成道理」。</p>
<p>　　这个「三量」，怎么叫做「三量」呢？「谓由至教量故、由现量故、由比量故」，这个「至教量」怎么讲呢？「至」就是极，至者，极也。到了极点了，不能够再向前进了，到了极点了，叫做「至」。指什么说的呢？就是这个教法，所说的道理。这个「教」，表示一种道理，达到极圆满的程度了，叫做「至教」。这个「量」字怎么讲呢？量是「正知」的意思（中正的正，知识的知），正确的知识，可以以之为准的。你合乎它，那就是正确的；你与它不合，不合，那就是不正确的。正确的知识，叫做「量」。这个至教量，当然我们佛教徒，我们尊敬佛，以佛说的教法，名之为「至教量」。佛是极圆满了的人，大圣人，我们对他是有信心的，可以相信的，他说的道理我们相信，所以叫做「至教量」。那么这个至教量，佛说了，「一切蕴皆是无常，众缘所生，苦空无我」，所以我相信。符合至教量，所以这就叫做证量道理（注：应是证成道理。）。由佛说了，所以可以证明这件事，别人说的，别人说的那不一定，佛说的可以，我们可以信赖。所以「由至教量故」，所以相信这个道理，那么这就叫做「至教量」。</p>
<p>　　我们通常说这个「三法印」，就是佛说的这些经，修多罗，佛在世的时候佛说法，佛的弟子都听到，亲在佛前听佛说法，那么这些人又是成为圣人了，或者得无生法忍的这些大菩萨，得了阿罗汉的这些圣人，他们本身证悟了真理，又是听佛说法，所以他会知道这部经是「佛说」的、是「不是佛说」的，他知道。佛灭度以后的佛弟子，我们也没有看见佛，也没有听佛说法，我们怎么知道这一部经是佛说的、不是佛说的？我们凭什么可以知道？佛告诉我们，要符合三法印、符合一实相印，那么就可以相信，这么样讲。这也就是有至教量，所以我们可以相信，是这样意思。佛不是说一定像我们一般的，说那一年、那一月、那一天，有什么东西证明说这一部是佛说的经，是佛说的，佛不这么说。佛说那一部书里面和佛说的道理是相契合的，那就是佛说的。佛这么讲，佛这样讲。所以这叫做「至教量」，这样意思。</p>
<p>　　「由现量故、由比量故」，这个就是另一个说法了，这个「现量」怎么讲呢？这个「现」就是现前、出现，出现在眼前，出现在我们心识之前。如果说是，我们现在这个窗户是玻璃窗，如果是用纸糊的或是一道墙隔住了，墙外面有什么事情，不现前，我没看见，就是不现前。那么中间有障碍，那就是不现前。那不现前的事情，不叫做「现量」。要现前，出现在我们的眼耳鼻舌身意之前、眼耳鼻舌身前五根之前，我们能得到正确的知识，我们从这里得到正确的知识，那就叫做「现量」。这「现量」的意思就是你没有…中间当然没有障碍，你没有迷乱，没有分别。</p>
<p>　　这个「迷乱」怎么讲呢？这个《因明入正理论》上讲，它说出个例子来，譬如在夜间，夜间的时候，有人把像我们在佛前烧的那个香，那香点着了，你在那拿着它，在那儿转一下，我们旁边看的人就是有一圈，一圈明，一圈的光明，叫做香…叫做「火轮」，一圈。其实只是一点点的火嘛，并不是一圈，这叫做「迷乱」。我们这个肉眼迟钝，所以就是看见是一圈。你若认为是一圈，那就是错了，所以叫做「迷乱」，要把这件不算数，这是一个简别。</p>
<p>　　第二件事呢？要无分别。就是你譬如说我们的眼识看见光的时候，看见光的时候，我们是心里面说「喔，这是光」，已经不是眼识了。这「光」就是有名字了，这是第六意识才有名字，眼识没有名字。眼识看见光，只是一个明…眼识在那里明了一下，但是它没有说话，眼识是不会说话的。它没有名字，所以不会说话，这个时候眼识所见的这个光是对的；若第六意识说出来的话，也可能是对、也可能错，就靠不住了，所以那就不叫做现量。所以「现量」的条件，就是不要分别，不要加以分别，而也没有一切迷乱的境界，它能够得到正确的知识，这时候叫做「现量」。</p>
<p>　　这个《因明》上说这个「现量」这个事情，用这个「现量」、「比量」，「宗因喻」，用这个同人辩论，辩论道理，也是一种方法。大家讨论道理的一个规则，不可以犯错误，也是可以喔。但是若是从佛法的观点来看，那我认为还不能说那就是正确的知识，还不能那么说。</p>
<p>　　我说出个道理你听喔，刚才说这个「观待道理」，一切法是因缘所生，都是虚妄不真实。你这种…知道一切法是因缘所生，不真实的这种智慧，要听佛说法，还要经过一番修行，你才能成就这种智慧。</p>
<p>　　譬如说我们这个眼识或者乃至到第六意识，不加分别的时候，你能看见诸法实相吗？我认为不能！因为你没成就佛这种无分别智、后得智，你都没有成就，你那里面还隐藏着执着的。虽然它没有说话，没有分别，没有分别也不行，那个执着心还在那里。</p>
<p>　　说那个小孩子天真无邪，啊，说他「哎呀，这个天真无邪很清净」，其实很多的垃圾都隐藏在那里。小孩子天真可爱，其实不是、不能那么解释。他的那一分…那个清净心里面很多的污浊都在那里头。等他的眼耳鼻舌…，成熟了，很多的东西都出来了，那怎么能算清净呢？他的知识是正确的？不能这么说！</p>
<p>　　所以这个《因明》上说这个道理，就是姑妄言之，我认为是姑妄言之。当然这个陈那菩萨也是大智慧人，他对这件事很有研究。当然那个时代，佛法在印度，这个外道很兴盛，常是同佛教徒辩论，所以须要立出个规则来，这也是对，也不能说不对。</p>
<p><strong><em>问：</em></strong>师父刚刚您最后一段话，我有？了几个问题，就是你从那个「现量」里面，那个「现」现前，也这个同样是「无分别」，你说我们「触」的时候要没有名字，如果一有了想的作用就已经是分别，那么由这个呢，会产生为第一个问题，如果有了名字、有想就没有分别，那么它是不是有「作意」的作用、有「触」的作用、有「受」的作用呢？那这第一个问题就有第二个问题，你讲到说在《因明》还是世间法，那么如果说这还是世间法，那么「作意」「触」和「受」还是世间法。那必须要从智慧相应的「明触」，才是真的是无分别。</p>
<p><strong><em>答：</em></strong>对，我的意思是这样子，一定有「明」相应触，就是有无分别的般若的智慧，这个时候与识相应的时候，才得到正知、正见、正确的知识。若没有般若的智慧，说我无分别，你「无分别」也没有得到正知。我的意思是…</p>
<p><strong><em>问：</em></strong>那第二问题，那如果正知，和智慧相应的时候，如果有名字，应该也是「现量」？</p>
<p><strong><em>答：</em></strong>有名字的时候叫做「比量」。</p>
<p><strong><em>问：</em></strong>我的意思说如果与智慧相应以后，再有「想」的作用，应该也可以算是「现量」。</p>
<p><strong><em>答：</em></strong>说是「现量」，它可以那样，因为它在那个《因明》的书上说呢？「无分别」，「现量」是无分别，「比量」是有分别。由「有分别」而得到的正知，叫做「比量」；由「无分别」而得到正知，叫做「现量」。若是我们说是圣人得到「无分别智」，得「无分别智」，那么从《因明》上的规则上看，那应该是「现量」，可以用「现量」。若…</p>
<p><strong><em>问：</em></strong>如果我们不依照这个《因明》来讲，我们说佛他是从他的正知里面流出来的教量，那是从他的「现量」里面出来的「教量」，那其实他的「教量」也是和他「现量」是应该相应的？也可以说是「现量」。</p>
<p><strong><em>答：</em></strong>是、是。它这个…所以这个《因明论》上，就把这个「至教量」取消了，就只是一个「现量」和「比量」。那么他就把「至教量」、这个「圣言量」放在「比量」里头，它这样放。</p>
<p>　　当然是你说也是对的。因为到佛的境界，「有分别」、「无分别」是统一了的。我们平常的人、或者没有到佛境界的人、或者是到「第五现前地」之前（初地、二地、三地、四地），「无分别智」现前的时候，这个「有分别的智慧」就不现前，就是「后得智」不现前；「后得智」现前的时候，「无分别智」就不现前，就是不可以同时的，是这样解释。</p>
<p>　　但是宗喀巴大师他在这个《入中论善显密意疏》上，他解释又不同。他的意思到佛…唯有到佛的时候才能这样子，其余的人不能。</p>
<p><strong><em>问：</em></strong>那接着就第四个问题，也是接着就是您最后那个「结语」那里，因为当初有这么多的那个哲学思想，所以他为了辩论要有《因明》，那么这句话就引出我的问题，就是如果我是为了「自修」，而且为了适应现代的那个社会的话，我们未必一定要学的这么「细微」，对不对？而且现在的细微应该是适应现代社会的细微了。</p>
<p><strong><em>答：</em></strong>这个事是那样哦，如果你想行「菩萨道」，你想要行菩萨道。一般的社会上的人呢？我看也不须要「宗因喻」、这个什么「至教量」、什么「现量、比量、非量」，也不须要这样。但是有些社会上，有些学问的人，特别有学问的人，或者他也是懂得《因明》的人，他可能会按照这个这种规则、这个辩论的规则同你讲话，也可能这样子。那你要行菩萨道的人，也应该具足这种知识，也是应该、也是应该的。</p>
<p>　　不过这种人，我看还是少数，若是我们在…没有到第八地的菩萨，就算我们是菩萨了，或者是没有到第八地，我们还是选择我们自己重要的事情来做。这个事我们不用学也是可以，就不学这个《因明》也是可以。</p>
<p>　　如果你是…不过通常说，这个「资粮位」的菩萨，把资粮准备了非常的圆满的大菩萨，他的眼耳鼻舌身意和一般人不一样，这个能力特别强。你就是我们讲这个玄奘大师，到印度很多人…连那个法显法师哦，很多人到了雪山，过那个山的时候都冻死了，但是他们不…他们还是照样过去了，他那个身体和别人不同。他这个生理和别人不同，那个心理都是特别的，那样的人学《因明》这件事，不算一回事，他是很容易就懂了，也不算一回事情。记忆力也特别强，而那个智慧也特别高，他就是一看就会懂了，也不算难。那个大福德人就是不同了。</p>
<p><strong><em>问：</em></strong>请问那个好像在《法华经》，还是里面有说：「眼根有八百功德，耳根一千二百功德」，这是相当于这个「证成道理」呢？还是作用道理？还是观待道理？</p>
<p><strong><em>答：</em></strong>这个都有，它都具足这个道理。具足这个「证成道理」、具足这个「观待道理」、「作用道理」，它都具足的，「法尔道理」也是具足的。</p>
<p>　　我们的这个眼睛，你就是…你若不摇头的时候，后面你就是看不见，所以它不具足一千二百功德。这个耳不是，你前后左右所有的声音都能听见。耳听声音的功能，周围都是无障碍，眼就不行。所以这耳的功德是一千二百，眼的功德只是八百，它缺了四百，这是「现量」上就是这样子。</p>
<h3 id="第6讲"><a href="#第6讲" class="headerlink" title="第6讲"></a><strong><em>第6讲</em></strong></h3><p><strong><em>云何名为证成道理？谓一切蕴皆是无常，众缘所生，苦空无我。由三量故如实观察：谓由至教量故、由现量故、由比量故，由此三量证验道理。</em></strong></p>
<p>　　我们昨天讲过四种道理，其中的「观待道理」是排在第一项，第二项是「作用道理」。</p>
<p>　　这个「观待道理」也就是我们平常…我们常常所说的因缘生法。这个你若在静坐的时候…这个「瑜伽」其实就是静坐。在静坐的时候，你在思惟观待道理的时候，你会想到这一切观待的事情都是无常的、是空的、是假的，会想到这里。</p>
<p>　　但是想到第二条道理的时候，「作用道理」，那么是假的、是空的，但是有作用。这个微妙就是在这里，它有作用，但是是假的、是空的。你可以来回的观察，是这样意思。</p>
<p>　　这第三项是「证成道理」，这个思惟「观待道理」的时候，知道是无常的，因缘生法是无常的，无常所以是苦、是空、是无我的。可是没有经过思惟、观察的人，他还是不同意这样的结论，不同意无常是苦、因缘生法是空的、是无我的。你要为他去说明的、去解释的，所以又说到这个「证成道理」。就是用至教量、用现量、比量来证明这件事，是苦的、是空的、是无我的，这样这个道理才能够成立，这样意思。</p>
<p>　　这个昨天讲过了这个「现量」，也讲到「比量」。这个「比量」是推、推论，经过推论而得知的，其中也一定有多少「现量」。不然的话，这个「比量」还是不能成立的。</p>
<p>　　在《因明入正理论》的书上，举一个例子，举个例子说我看远远的地方看到冒烟，看到冒烟就知道那个地方起火了。我看见墙那边露出个角来，那么可能那下面有牛。就是这个烟，你看见烟、看见角，这是「现量」。由「现量」而推论，才知道是有火、才知道是有牛，是这样子。知道是无常的，这个原因就是你以前，由你的现量上得知道。这个起火的地方，这火有烟，火和烟是不分离的，你以前的现量的经验得知道这件事；后来看见烟，喔有烟就是有火。所以这个「比量」由推比而得之，是因为有现量的关系，不过不是全部的，是一部分，是这样意思。</p>
<p>　　「由比量故」，由于推比得到的正确的知识，这也可以证验这件事是对的，这是一个得到正确知识的一个方法。</p>
<p>　　「谓由至教量故、由现量故、由比量故，由此三量证验道理」，证实你所经验的这个道理是对的。这个「验」是自己接触到的事情，我不是听人说，自己接触到的事情，是对的，得到的结论是对的，「证验道理」。</p>
<p><strong><em>诸有智者，心正执受，安置成立，谓一切蕴皆无常性、众缘生性、苦性、空性，及无我性，如是等名证成道理。</em></strong></p>
<p>　　这个「执受」、「诸有智者，心正执受」，这个有智慧的人，他听你所说的至教量、所说的现量、比量，从这三条道路得到的知识是对的，个智慧的人就会明白了这件事。「心正执受」，他内心里面就是得到智慧了，生起了一种智慧，就是信受了…坚定的信受了这样的道理。坚定的信受了这样的道理，而不会动摇的。就是有反对者说出来种种的不同意的意见，你不动摇，所以叫「执受」。</p>
<p>　　「安置成立」，这个「安置成立」呢？或者就说是把这种道理，安置于心，「成立」，建立起来了，或者是这样说。或者说呢？你成就了正知正见了，你能够在内心里面栽培善根，按照这样的道理去栽培善根去，叫做「安置成立」，或者这样说也是可以。</p>
<p>　　「谓一切蕴皆无常性」，这底下就是说，「心正执受，安置成立」什么呢？「谓一切蕴皆无常性」，就是我们这个生命…我们的生命体，我们的色受想行识，这个「蕴」，蕴者，聚也，积聚的聚。色是一大聚、受也是一聚，想、行、识都是一聚，就是一大堆。这一切的色受想行识的蕴「皆无常性」，它们都没有不变的体性，都是有变化的，随着因缘变化的。这个「众缘生性」，它是众多的因缘生起的体性，它的体性是众缘所生。是「苦性」、是「空性」、是「无我性」，这个我们昨天讲过了。</p>
<p>　　「如是等名证成道理」。这个说到「无常」，我们最低限度可以有两个想法。一个是我们现在的生命体，非老病死不可，这是一个想法；第二个呢？第二个想法，我看每一个人都是对于自己的生命不满意，每一个人都会这样，都感觉到还是不是那么好。不那么好，说它是无常呢？很好！它结束了，我重新创造一个嘛，我重新创造一个生命，不是很好吗？如果这个生命是固定的了，你不可以变动，不满意只好忍受着。</p>
<p>　　所以说「无常」，这里面啊，这佛法说什么都是无常的，好像是很消极，其实这话说得不对，无常里面有积极性。所以佛教里面说「无常」，所以佛法里面重视你自己要常常思惟观察，不要只是用耳朵听、用眼睛看，不可以。你还要用心多思惟，你才能够有很多的妙出来。</p>
<p>　　「如是等名证成道理」，其实就是证成这个「观待道理」、证成这个「作用道理」。</p>
<p><strong><em>云何名为法尔道理？谓何因缘故，即彼诸蕴，如是种类？诸器世间，如是安布？</em></strong></p>
<p>　　我们若不相信佛法的话，也有可能有这种思想，就是无论什么事情都是自然的，自然是这样子，那个法就是那样子叫做「法尔」。不认为有什么因缘造成的，不那么想，就是自然是这样子，叫做「法尔」。若是我们常常思惟，用第六意识多思惟这种种的因缘，这个「观待道理、作用道理、证成道理」，常常思惟，思惟就从…就会思惟出来种种的事情出来。知道这是因缘有的，各式各样的事情都思惟出来。但是有的时候，思惟久了也会另外会出来问题，另外还会引出来问题的。引出来问题，这个佛菩萨的智慧说出来「法尔道理」，来解决你因思惟而引起的这些问题。看这底下解释。</p>
<p>　　「谓何因缘故，即彼诸蕴」，什么理由，即彼色受想行识诸蕴「如是种类」？而是这样的种类？这是人的一类，人里面又有很多的类；天这一类，天也有很多的类别；乃至地狱饿鬼畜生，都有各式各样的色受想行识的蕴。说是…像人…我们的色受想行识这个身体是这样子，那个蛇是又一样，蛇又是一样；海里的鱼又是一样。人是在陆地上生活，鱼在水里面生活，这个色受想行识这个蕴各式各样的差别。人是一类，类，这个大类里面又有很多种类，各式各样的情形。什么因缘，即彼诸蕴如是种类呢？为什么这样子呢？你会这样想，会思惟。</p>
<p>　　「诸器世间，如是安布」，这个「器」，譬如说有这个苹果、橙子，放在一个器里面盛载着；我们人在这个世界上生存，也是器，这个世界是我们生存的一个器。当然我们人在这个器里面生存，我们对这个器的彼此间的关系还是很密切的，很密切的。我们说靠天吃饭，其实也靠这个大地…也很厉害的，关系很重要的。那么这个器，这个器世间，它这样安布，是这样子现出来各式各样的形相，有高山、有平地、还有大海，还有太阳、还有月亮，有白天、有黑天，有的地方物产丰富、有的地方很贫瘠的，各式各样的情形。何因缘故「诸器世间，如是安布」呢？这样的陈列呢？</p>
<p><strong><em>何因缘故，地坚为相、水湿为相、火煖为相、风用轻动以为其相？</em></strong></p>
<p>　　「何因缘故」，地是「坚为相」，地是坚固的。「水湿为相」、火是「煖为相」，为它的体相。「风用轻动以为其相」，为它的体、为它的相状，什么原因是这样子呢？你也会想，会思惟这件事。</p>
<p><strong><em>何因缘故，诸蕴无常、诸法无我、涅槃寂静？</em></strong></p>
<p>　　这是圣人的境界了。一切法是无我，什么因缘是无我的呢？什么因缘啊，佛菩萨得的涅槃里面的境界是寂静的？一切有为法都是生灭变化、是无常的，无常即是动，是动的意思。生灭变化，也可以名之为动。这个无为法、涅槃的境界是无为的，就是没有这个因缘生法那个动相了，所以对动而说静，说涅槃是寂静。</p>
<p>　　这个圣人他见到第一义谛以后，他的色受想行识还是在的，这个生命体还是在，但是他这个无分别智出现的时候，和第一义谛相应的时候，就是入于无为的境界去了，那个时候呢？是寂静的，就没有这个有为法这个动荡的这些事情，所以涅槃是寂静。</p>
<p>　　可是我们若常常思惟就会想，为什么涅槃是寂静的？又会这么样想。由有我而无我，到了无我的时候又会想，为什么是无我？又会这样想。</p>
<p>　　我们观察一切有为法是因缘所生，所以会变化，不是常，而是无常。可是承认了无常以后又会想，为什么是无常呢？它是常不可以吗？就会各式各样的想法。</p>
<p><strong><em>何因缘故，色变坏相、受领纳相、想等了相、行造作相、识了别相？</em></strong></p>
<p>　　「何因缘故，色变坏相」，我们年轻人的时候，假设没有相信佛法、没有学习佛法，这个壮年人，社会上这个活动力在强的时候，好像前面有很多、很多的如意的事情等着我，那个冲劲很强的时候，从来不想世间上都是变化无常的，不想这件事，不想。但是若是学习了佛法以后呢？那就，喔，是无常的，又会…就是改变了这种想法。可是承认了无常以后，又会想为什么它会变坏呢？不变坏不可以吗？也会这样想啊，「何因缘故，色」是「变坏相」。</p>
<p>　　「受领纳相」，受是领纳相。这个心、我们这个分别心与一切境界接触的时候，心里面就会接受，是一种感觉，去接受它。我们平常的人，我们的日常生活里面，我们如意的事情我们接受，满我意的事情我接受；不满意的事情，我拒绝，不接受。我们平常是…我们的心情是这样的态度，但事实上，我们不是这样。就是如意的接受，不如意的也是接受的，也是接受。怎么知道不如意的事情你也接受呢？你常想一想就会知道。</p>
<p>　　譬如说是我们不高兴的事情，或者是自己的行为、思想引发出来的；或者是自己还不知道，由第三者、或者第四者展转的传过来，啊，有什么、什么事情，某某人怎么、怎么打主意，怎么、怎么的、怎么对你有伤害呢，你一听见了的时候，你就忿怒了。啊，你就想出来怎么、怎么样报复，于是乎很多的苦恼的事情都出现了。从这一段经验上看，人就是不如意的事情也接受，也是接受。</p>
<p>　　那么呢，我也不愿意接受这个事情，怎么能说我接受了呢？我们平常的人可能心粗一点，我不知道这件事我就接受了；但是有些人思想是很细、很周密的，他会想很久、很久，事情怎么、怎么安排，但是这种人他也一样是接受这种事情。因为你接受了一次可能自己还不觉悟，接受了两次或者还不觉悟，接受第三次应该觉悟了，但是人还是不觉悟。怎么知道呢？你接受了这种事情的时候，就会出现很多很多的苦恼的事情。假设你若说是不接受的时候，我知道是很苦恼，但是我不知道怎么样不接受！怎么样才能不接受呢？我们学习了《摄大乘论》以后，就应该知道这件事，就是不分别就不接受。你不要分别这个事情，就没有事。</p>
<p>　　这是很明显的一件事，譬如说现在这屋子里面有大的白莲花，或者红莲花，或者青黄赤白各式各样的莲花；或者是一个高山，高山、流水、大莲花，很多的各式各样的好看的花。你遇见这种境界的时候，你心里面平静、欢喜、喜悦，自然是这样子。若是遇见那个毒蛇、恶兽、老虎这些东西，你心里面是什么样子？心里不平静。但是若是没有…这个老虎已经过去了，这些不如意的境界过去了，你心里面不分别的时候，心里就平静。从这样的经验上看，所有的不如意的事情，你发觉了，你赶快停下来不要想，不要分别。啊，我对这个人非常的好，但是他一点良心没有，对我种种的伤害，你愈想就愈苦恼，那就叫做接受。不如意的事情你也接受；你若不想，不想，什么事情没有，没有这个苦恼。</p>
<p>　　所以这个受是领纳相，如意的事情你接受，苦恼的事情你也是接受，你不能够「一切法不受，得阿罗汉」，你不能。但是我们不是阿罗汉，没有那样道力，你也可以调一调，调转一下，不分别这件事。不分别这件事就没有事，所以也可以不受。</p>
<p>　　但是另外有一个原因，你不受你也得受，什么？是自己的业力，你前生造了罪，造了罪，你现在要得果报，得果报，就叫做「受」。这果报来了，你不受也得受，你不能不受。说是别人传来的话，说怎么、怎么的…，我可以不想，但是你身体上有病了，你不受，你不受也得受。</p>
<p>　　可是若是修学圣道成功了的人，也能不受。我这身体里有病，他也能不受，因为什么呢？因为他时常修止观，观一切法空，观一切法是无常、是无我的，观一切法空，那个心住在毕竟空那里了。这个色受想行识上的问题，他就不感觉，不感觉这件事，他就不苦，就没有苦受，就能不受。所以修学圣道的人，能有这样的好处。就是没有入无余涅槃之前，你得到涅槃了，就是有这种好处，就能不受。但是表面上你得那个病还是在的，那个老、病还是在的。但是在他内心里面的修行，他是不受这件事的苦恼的，他能不受。可是你没有这个修行，那不行，你不受也得受。</p>
<p>　　所以，色是变坏相，受是领纳相。「何因缘故」，色是变坏相、受是领纳相？我们有的时候你多思惟有好处，但是有的时候也会出现一个问题，就是从无始以来，人就是这样，为什么不从无始以来人不这样子呢？就会要这样想，这样想你没有办法回答，你怎么回答这个问题？所以这个地方给你回答了。</p>
<p>　　「想等了相」，这个色、受、想，这个「想」这个蕴，是「等了相」，这个「等」是普遍的意思，普遍的去明了、去思惟观察，所以就叫做「想」是「等了相」。普遍的去观察、去认识它是怎么一回事，是什么道理，叫做「等了相」。</p>
<p>　　「行造作相」，这个色受想行这个「行」，是造作的意思，就是有了行动。这个「造作相」，当然我们会想到身体表现出来的行动、或者口发出来语言，这就叫做「行」。但是主要是心行，是内心里面的动，叫做「行」。</p>
<p>　　这个我们发出来语言、发出来行动，是心发出来的，不然的话身不会动、口也不会说话的，是由心发出来的，所以这个行是你的心的，你内心的动。「不是风动、不是旛动，仁者心动」，这句话是对的，是「仁者心动」。这个心动，在这里说这个「行」是造作相的意思，是有目的的发出来的动，那叫做「行」。</p>
<p>　　人好像是习惯了，不是有固定的目的也会动，也会动，那个不是属于行蕴的，不属于行蕴喔。可以包括在行蕴里面，但是那个义不够…不具足。</p>
<p>　　「识了别相」，这个「识」，眼识乃至意识，他是「了别相」，就是对于一切法有个明了性，叫「了别相」。</p>
<p>　　而其实这个受、想、行都是由心发出来的作用，由心发出来作用，不是离开了心有受想行的。心接触一切法的时候，有受的作用、有想的作用、有行的作用，是这样意思，是这样分别。它是王，那个受、想、行是臣，王和臣的不同，就是这样说喔。</p>
<p><strong><em>由彼诸法本性应尔、自性应尔、法性应尔，即此法尔说名道理，瑜伽方便。</em></strong></p>
<p>　　「由彼诸法本性应尔、自性应尔、法性应尔」，前面都是问。「何因缘故，地水火风是坚湿暖动？何因缘故，诸蕴是无常、诸法无我、涅槃寂静？何因缘故，色是变坏相、受是领纳相、想是等了相、行是造作相、识是了别相？」这是问，这底下回答了。「由彼诸法本性应尔」，就是由于这一切法，它本性就是这样子，它本来就是这样子，从无始以来就是这样子。这个「本」就是根本，根本就是过去。过去，就是从无始以来就是这样子。就是地是坚相、水是湿相、火是暖相、风是动相，从本以来就是这样子。这「本性」是说过去；「自性应尔」是说现在，从本以来就是这样子，现在它的体性还是这样子。「法性应尔」，就是未来的，将来的地水火风也还是这样子，也还是这样子啊。将来也还是诸蕴无常、诸法无我、涅槃寂静，将来也还是色变坏相、受领纳相、乃至识是了别相，「法性」就是这样子。</p>
<p>　　「即此法尔说名道理」，这就是道理，就是这样子喔。</p>
<p>　　「瑜伽方便」，也是你学习瑜伽的一个方便，也就是这样意思。</p>
<p><strong><em>或即如是、或异如是、或非如是，一切皆以法尔为依，一切皆归法尔道理，令心安住、令心晓了。如是名为法尔道理。</em></strong></p>
<p>　　「或即如是、或异如是、或非如是，一切皆以法尔为依」。「或即如是」，就是前面，前面说的这些事情，是这样子，或者是不同意，另外有个样子，叫「异如是」，另外的样子。「或非如是」，「即如是」、「异如是」都没有，或者是这样子。「一切皆以法尔为依」，就是这样子，都是以法尔为依止的，就是都是法尔。</p>
<p>　　这里面啊，譬如说我们人，头上没有角，但是有的地方有的人头上有个角，就是和我们不同，「或即如是、或异如是」，是这种情形，不同的，各式各样的，各式各样的情形。</p>
<p>　　现在今天的世界，看那个蛇是这样子，看那个鸟是这样子，看那个人是这样子，但是若是另外的不同的世界，又有不同的情形，所以「或即如是、或异如是、或非如是」，是这样子。</p>
<p>　　譬如说我们这个世界上的人，在太阳下有影；但是阿弥陀佛国的人不是，你在光明下没有影，就是各式各样的差别境界，不是一样的。</p>
<p>　　说是我们人在地面上走，徒步走，人的生活是这样子；那天上的人，和我们不同，天上的人他会天空里走，有各式各样的情形。「或即如是、或异如是、或非如是」，总而言之，「一切皆以法尔为依」，自然是这样子。</p>
<p>　　这个经论上、佛经上常说，这个诸天来见佛，听佛说法。听佛说法，这个法会一结束了，诸天就走了，但是走不远，忽然间就不见了，那是什么原因呢？走得太快，他那种速度特别的快，所以就是我们的肉眼迟钝，一下子不见了；若是天眼那还是不同了。所以各式各样不同的情形，这「一切皆以法尔为依」。「一切皆归法尔道理」，这些事情就是自然是这样子。</p>
<p>　　「令心安住、令心晓了，如是名为法尔道理」。所以我们佛法里面，是重视闻思修，重视这个思惟，重视思惟，但是到有些地方，你不可以思惟的。你就到此为止，你不能思惟的，你就这样安住下来好了。因为你思惟、思惟啊，到思惟不过去，可能令你发狂了，都可能的，所以「令心安住、令心晓了」，佛菩萨开示我们这个法尔道理，教你明白这件事，你就是不要再思惟这件事，「如是名为法尔道理」。「法尔」再换一句话就是「自然」的意思，自然是这样子。</p>
<p><strong><em>如是名为依四道理，观察诸蕴相应言教。</em></strong></p>
<p>　　这是前面这一大段，这个是…这个修瑜伽的人、修止观的人，你要根据这四种道理去观察色受想行识诸蕴，相应的言教，就是佛说的观察诸蕴的相应的言教，你要这样子去思惟去。</p>
<p>　　（这个小一点字的这上面，我们从第四行开始）</p>
<p><strong><em>此境瑜伽，虽通一切，然诸经论就相随机，种种异说，或说观待等四种道理，</em></strong></p>
<p>　　这叫做「境瑜伽」。「境瑜伽」就是…这看出来呢，主要还是以色受想行识为所缘境去观察。所以初开始修止观的人，你要尊重佛的智慧，佛怎么说你就怎么观察，你不要自己另外想出个方法来，你不要这样。你成功了以后，你可以无穷无尽的变化，但是它能够…还是能符合佛的本意的。我们若初开始，你不尊重佛的这个相应言教，你自己去独出心裁，那这是不对的。所以「或说观待等四种道理」，为境瑜伽，叫做「境瑜伽」。</p>
<p><strong><em>如是乃至说蕴界处缘起谛等，皆名瑜伽。总具四性，顺四法故。</em></strong></p>
<p>　　「如是乃至说蕴界处缘起谛等，皆名瑜伽」，像这种四种道理，「如是」就指四种道理，如是四种道理可以作为「境瑜伽」，乃至到说这个「蕴界处」，乃至又说到五蕴、说到十八界、说十二处、说十二缘起、说这个四谛（苦集灭道四谛）、乃至六波罗密、乃至一切法。「皆名瑜伽」，都可以称之为这个瑜伽的、称之为相应的。因为你用佛法的智慧去观察的时候，它都是相应的，没有冲突矛盾的。这个「相应」的意思，就是不冲突，能够随顺，没有矛盾，叫做「相应」。</p>
<p>　　「总具四性，顺四法故」，因为这一切法都具足这四种体性，都具足这四种道理，也都是随顺这四种法。谓一切境无颠倒性，无颠倒性是一法、不相违性、相随顺性、趣究竟性，都具足这四法，所以都是「相应」的。</p>
<p>　　这前面主要就是说这个境瑜伽，这底下说「行瑜伽者」</p>
<p><strong><em>行瑜伽者：谓一切行，更相顺故、称正理故、顺正教故、趣正果故，说名瑜伽。</em></strong></p>
<p>　　「谓一切行，更相顺故」，这个「行」就是走路，一步一步的向前走，叫做「行」。我们佛教徒在佛法里面，随顺佛的教导去修行去，也就像走路一样，一步一步的向无上菩提那里去，向大般涅槃那里去，所以叫做「行」。若是你不修行了，就停下来了，就不向前进了。这个行啊，「谓一切行，更相顺故」，念更ㄍㄥ，「更相顺故、称正理故、顺正教故、趣正果故，说名瑜伽」，现在是说这个行叫做瑜伽，行怎么叫做瑜伽呢？</p>
<p>　　「谓一切行」，佛法里面所说的一切的修行法门，都包括在内，「更相顺故」，此法门、彼法门、彼彼法门，互相都是随顺的。</p>
<p>　　譬如我们坐禅，坐禅和念佛法门，是互相随顺的，没有冲突。因为你常常静坐，你心就是寂静，不颠倒。不颠倒啊，一个寂静就不颠倒，一个修止观，修观啊，令你有智慧，也是不颠倒。那么心不颠倒，你临命终的时候，就是信、愿、行现起，你念阿弥陀佛，那么阿弥陀佛放光接引，就是往生阿弥陀国了嘛！所以坐禅，禅和净土法门不相违背，不相违背的，也是互相随顺的。说我读经、我去拜佛，我没有静坐，但是读经、拜佛，与静坐、与念佛法门，一切都是随顺的，没有冲突。</p>
<p>　　一切的法门都是「更相顺故」，我也随顺你，你也随顺我，没有冲突的。说我不念佛，我念咒，念咒与念佛也是一致的、与坐禅也是一致的，也没有冲突，也是一样的。所以一切的法门，「更相顺故」，所以叫做「瑜伽」。</p>
<p>　　「称正理故」，所有的修行的法门，都和那个第一义谛是相称的，没有冲突。因为佛说这么多的法门，目的就是念佛法门也好，你是禅也好、你念佛名也好，你念经也好、拜佛也好，佛说这么多法门，都是向于第一义谛，不是停留在惑业苦那里。这个和凡夫境界不同，凡夫境界互相障碍，这些种种的事情，也可能有不障碍的，但是啊总是有问题；佛说的法门不是，这是无障碍境界，「更相顺故、称正理故」。</p>
<p>　　「顺正教故」，你种种的修行都是随顺佛教，都是佛所教导的，所以与佛的教也是相随顺而没有冲突的。</p>
<p>　　「趣正果故」，所有的修行都是向无上菩提那里、向大般涅槃那里进趣，进趣到大般涅槃那里去，叫做「趣正果故」，与果也是相应的。那么，所以行就是瑜伽，行是相应的，「说明瑜伽」。</p>
<p><strong><em>此行瑜伽，虽通诸行，然诸经论就相随机，种种异说，或说正修诸行，说名瑜伽；或说三十七菩提分法，说名瑜伽；或说奢摩他、毗钵舍那平等运道，说名瑜伽。</em></strong></p>
<p>　　这底下再指出来究竟这「行瑜伽」指什么说的呢？这底下说「此行瑜伽」虽然是通于一切的修行法门，可是在一切的经论里面，或者佛说的经、或者佛弟子造的论。「就相随机」，这个经里面、论里面，就法、就法相来说、就众生的根性来说，所以会说出来种种不同的修行法门，「种种异说」。其中说得什么呢？「或说正修诸行」就叫做「瑜伽」，这还是通说。</p>
<p>　　底下，「或说三十七菩提分法，说名瑜伽」，四念处、四正勤、四如意足（三、四，一十二）、五根、五力、七觉支、八正道，合起来三十七菩提分法。这个「分」者，因也，「菩提」是果，这三十七种法门是三乘菩提的因。这个「菩提」通于声闻乘、辟支佛乘、一佛乘，都叫做「菩提」。说三十七菩提分法，说明叫做瑜伽。三十七菩提分法，或者简单说就是四念处。修这四念处，就叫做行瑜伽。</p>
<p>　　「或说奢摩他、毗钵舍那平等运道，说名瑜伽」，「奢摩他」翻个止，「毗钵舍那」翻个观。这个止观「平等运道」。</p>
<p>　　「平等运道」呢，这可要有修行的人才能平等运道。我们初开始学习的人不能「平等」。就是我们修止的时候，就不能修观。止有的时候修得好、有的时候修得不好，就是不稳定；修观也是，有的时候观得也是很好，有时候不能观，总是不合适。等到止修成功了，观还没成功；或者观修得不错，这止还没好，修得不好。</p>
<p>　　譬如说这个初果圣人、这个二果圣人，他们已经不是凡夫了，是圣人了，已经断惑证真了，但是这止还没成功，止还没修成功。他就是得到了欲界定、未到地定，还没有得到禅，色界四禅还没成就；或者是已经得到未到地定了；或者未到地定没得到，只得到了欲界定。所以他的止还没有成功，还不圆满。所以这个初一段的修行人，只是观修得还不错，止还没成功。有的人止成功了，他虽然是凡夫，得到四禅八定了，那他止修得不错，但是没有观，没有修四念处观，就是不平等。</p>
<p>　　现在说是要「平等运道」，止也修成功了、观也修成功了，就是止里面也有观、观里面也有止，因为止而得到轻安乐、因观而得到轻安乐，这时候止观双运，止观能够双运，这个时候叫做「平等运道」。就是他在修观的时候，他还是止，心里面还有止的功夫，那么就是止观双运。我们止观没成就的人，你修止假设能相应一点，等到修观的时候这个止的功夫就退，退下来，就不行；若止成功的人不是，他不退。</p>
<p>　　这个地方有什么分别呢？譬如说你得到欲界定、得到未到地定，本来也是不错了，但是你的耳识还在动，有什么声音会听见，你还在动。但是他有了定的时候，听见是听见了，他还是在未到地定里面。</p>
<p>　　若是得了初禅（应该是二禅）以后不是了，你有声音他听不见，听不见，你拿引磬去开静，不可以，就无效了，你拿引磬不可以开…令他出定的，他若自己要出定，可以出定；他若不出定，你就打雷他也不出定，这是不可以的。</p>
<p>　　所以那个时候，得到禅以后，在禅里面修观呢？这时候这个禅不失掉，你心里面去思惟一切法毕竟空、唯心所现，这个禅还在，所以止观双运。若是这个未到地定以下的定，你若思惟诸法皆空，思惟…不管是【唯识观】、是【性空观】、是【一心三观】，是怎么观…，你心一动，这个定就退失，不能说止观双运。所以现在这里面说「奢摩他毗钵舍那平等运道」，叫做「瑜伽」，这境界就高了，这程度很高了。</p>
<p><strong><em>如是乃至复说菩萨所有殊胜慧悲，平等双转，名为瑜伽。具上所说四种义故。</em></strong></p>
<p>　　「如是乃至复说菩萨所有殊胜慧悲，平等双转，名为瑜伽」，前面说三十七菩提分法叫做瑜伽、止观双运叫做瑜伽。乃至到菩萨所有的殊胜的智慧、殊胜的慈悲心，那叫做平等运道，那个时候就是要到第八地菩萨，第八地菩萨。</p>
<p>　　不过若照这个我们汉文的佛教来说，要到第五地，不一定到第八地，第五地。第五地是难胜地，初欢喜地、二离垢地、三发光地、四焰慧地、五难胜地。到难胜地以后，那个殊胜慧悲才能够平等双运。就是他那无漏的无分别的智慧和大悲心。这个大悲心去广度众生，是后得智；那个殊胜的智慧是无分别智。无分别智和有分别智平等双运，要到第五难胜地以上才能做到。</p>
<p>　　不过我那一天说过，若宗喀巴大师的意思，要佛才可以，其他的人还做不到，这是说法有点不同喔。「说明瑜伽」…「平等双运，名为瑜伽」。</p>
<p>　　这样说法呢，以三十七菩提分法说明瑜伽，这应该是初发心的时候。初发心的时候，以四念处为瑜伽，修学止观。到止观双运那就是进了一大步了，程度很高了的境界。那么，到最后，菩萨的殊胜慧悲，平等双运，是更高一层的境界。</p>
<p>　　「具上所说四种义故」，因为什么三十七道品和止观双运、菩萨的殊胜慧悲，名之为「瑜伽」呢？因为具足前面说的那四种义故，都是…彼此都是相应的，「谓一切行，更相顺故、称正理故、顺正教故、趣正果故」，，所以名之为瑜伽，这样意思。</p>
<p><strong><em>果瑜伽者：谓一切果更相顺故、合正理故、顺正教故、称正因故，说名瑜伽。</em></strong></p>
<p>　　「果瑜伽者」，前面说这个「境瑜伽」，说这个行瑜伽，现在说这个果瑜伽。「谓一切果更相顺故、合正理故、顺正教故、称正因故，说名瑜伽」，这个「果瑜伽」，就是修学圣道的人有成就了，得到了果，得到了一个结果了，那叫做「果瑜伽」。【小乘】当然就是初果、二果、三果、四果，或者三明六通的这些事情。【大乘】佛法就是十地菩萨他所得的圣道，乃至到佛的境界，十力、四无所畏、十八不共，无量无边的这些功德，都名之为果。</p>
<p>　　这些果法呢，「更相顺故」，彼此也都是相随顺的，而不是相冲突的。说是我念阿弥陀佛求生阿弥陀佛国去，但是我念阿弥陀佛念得不相应，我念药师佛。你若念药师佛，《药师经》上说，你念药师佛的时候，你愿生阿弥陀佛国也是可以，临命终的时候，药师佛派八大菩萨送你到阿弥陀佛国去。这可见这果是相应，也是彼此相应，没有矛盾的，是这样子。所以叫做，果彼此是相应的，「更相顺故」。果当然是合正理，你得到无分别智，和第一义谛是相应的。也是随顺佛的正教的。</p>
<p>　　「称正因故」，你得到的果，和你当初修的因也是相应的，也是相合的。如果不相合，这个因不能得果了，不能得果，那是白辛苦了嘛，「说明瑜伽」。</p>
<p><strong><em>此果瑜伽，虽通诸果，然诸经论就相随机，种种异说：或有处说力无畏等不共佛法，说名瑜伽。</em></strong></p>
<p>　　佛的智力，这个「力」是佛的智慧力量，一共有十种，有十种智力。这个「无畏」有四种，四种无所畏。「等」，还有「不共佛法」，有十八种不共佛法，不共于声闻、缘觉二乘人的佛法，也是佛的功德。这是佛的果，佛所成就的果。这些果也名之为瑜伽。</p>
<p><strong><em>如是乃至或说有为、无为功德，皆名瑜伽。具上义故。</em></strong></p>
<p>　　前面说佛的力无畏等十八不共法，这都是属于有为，乃至到或说有为的功德，和无为的功德。「无为的功德」，你断诸烦恼的戏论，与第一义谛相应，那叫做无为的功德，都叫做瑜伽。因为都具足前面的四种义，所以名之为「瑜伽」了。</p>
<p><strong><em>问：</em></strong>昨天的谈到，这个你提到「即蕴无我」，是「空」；「离蕴无我」是「无我」，是一个（人空）「我空」、一个「法空」，还有它的原因何在，请师父详细的再阐释一下。</p>
<p><strong><em>答：</em></strong>「离蕴无我」，是「人空」；「即蕴无我」，是「法空」。</p>
<p>　　这个「离蕴无我」这是约对治方面说的，在所对治那方面就是我们的…执着心认为色受想行识这五个法、五个蕴之外，另外有一个…有一种「理性」，是常恒住不变易、有主宰的、有主宰性，这个是「我」。就是…所以这个五蕴这边加上一个，就是「色受想行识、我」是六个。我们如果这样执着的话呢？就是在蕴以外有一个我的体性。「色」是这样的体性、「受」是这样的体性、「想、行、识」是这样的体性，另外一个还有一个有体性的我，还有一个我。这样子就是呢，蕴以外有一个我，我们若这样执着的话呢？佛就说蕴以外没有我。如果有一个我呢？佛就说「色受想行识、我」，应该这样说才符合事实。佛没有这样说，就是表示蕴外没有我。这个蕴外这个我啊，这个我在什么地方？也还是在这蕴这里，在这蕴内的。</p>
<p>　　所以这个如果说是你执着这个「我」若是大，这个蕴就在我的体性里面。若执着这个蕴是很大，「我」是很小，这个我是在蕴里面，但是它自己在它自己的体性的。不管说是蕴大或者是我大，都是蕴以外另外有一个我。那么修「无我观」的时候，就是观察只是色受想行识，另外没有我，另外没有我的。</p>
<p>　　这个《瑜伽师地论》后面有讲、《大智度论》里面也有讲。如果这个「我」是在身体里面，「我」是常恒住不变易，有主宰性的，那这样子讲呢？这个「我」在身体里面的话，这个身体苦恼的时候，这个「我」苦不苦？「我」苦不苦？说「我」也苦，苦就是变了。你若感觉苦，这个「我」就是受变化了。「我」原来是不苦的，现在有苦恼的事情来了，「我」苦了，「我」就受到…就是有变化。那就和原来的常恒住不变易有冲突，那个「我」就是无常的了。若说是这个「我」在身体里面住，「我」是不受影响的，这个身体苦了，「我」是不苦，那你感觉一下，你苦不苦。所以这样子呢？就是表示这个「我」是不存在的，「我」是不存在的。</p>
<p>　　这说这个「离蕴无我」，其实这两种空观、两种「无我观」都应该修。说另外没有「我」，只是这个身体就是「我」，色受想行识就是我。</p>
<p>　　不过执着色是我，这种执着的人，可能是一般的粗心。因为这个身体有时候胖、有时候瘦了，但是在「我」上呢？好像没有这种感觉。这个我胖了，没有这种感觉。所以说色受想行识，多数执着这个「识」是「我」，「色受想行」是「我」的住所。这个色是「我」的住所，而不是「我」，像这个房子是我的住处，房子并不是我。</p>
<p>　　说这个色、这个身体是「我」的住处，是这样执着。这个「受」呢？是我和一切法的时候接触的感觉，这样子。这个「想」呢？就是我接触一切法的时候，我要认识一切法、认识一切法是怎么回事情？我可以说话，这都属于想。我采取了行动，是这样子，它们是我发起的…色受想行识发起的作用。另外有一个我的体性，是识，这么执着。</p>
<p>　　这么执着呢？但是观察没有「我」，只是识而已啊，这个识又名之为「我」而已。而不是离开了识，有「我」的体性，应该是这样子，那就是无我了，只是色受想行识，另外没有我。所有的作用，就是色受想行识，另外没有我。这是破离开了色受想行识，另外有我的执着。</p>
<p>　　如果说，好！「我」另外没有「我」，只是色受想行识就是「我」，识就是「我」。识就是我，是观察色受想行识五蕴都是因缘有的，都是毕竟空的，毕竟空那有我可得，色受想行识都不可得了，所以我也不可得。</p>
<p>　　说「即蕴无我」是「法空」；「离蕴无我」是「我空」。「离蕴无我」，就是「人无我」；「即蕴无我」就是「法无我」。</p>
<p><strong><em>问：</em></strong>这个「离蕴是我」和我们佛教里头的【真常唯心派】他们的（师父笑…）等于是印度教是我们佛教给他们…</p>
<p><strong><em>答：</em></strong>这个这样子，若是用这样子，这个刚才说这个「无我」，这是在【般若】、【中观】这一部分的说法，是这样讲。若说是【真常唯心论】，那就是不同了。这【真常唯心论】修无我观是很困难的、是很困难，是不容易，不能那么修。只是修空观可以，修无我观是很困难的。因为这样子，修【真常唯心论】呢？一切色受想行识的有为法都是空的，空而不空是【真常】、【真常唯心】。所以这个…【真常唯心】因为色受想行识这个识，在有为法里面如果空了，那么这个人是木头了。所以《起信论》上非要加上一句，就是这个【真常唯心】这个「真如上有大智慧光明义」。在这个真如的体性上，有大智慧光明。所以把这有为法空了的时候，那个真常的真如上，有寂而常照的大智慧，这样子就是圆满了。但是和这【中观】、【般若】这个体系就是不合，就不一样了。但是我们中国传统的佛教呢？是这样子的思想，是【真常唯心】，是这样子。所以修无我观很困难，修空观可以。</p>
<p><strong><em>问：</em></strong>这个假设【真常】有「我」，似乎是唱高调（？），因为不能够拒绝这是经论的时候，大家是没有资格去谈这个…</p>
<p><strong><em>答：</em></strong>阿弥陀佛，这话是那样，佛教传到中国来呢，最盛的时候是南北朝，那个时候《楞伽经》…《般若经》鸠摩罗什法师翻译的，还是很盛行，《楞伽经》以后是宋，《般若经》是晋朝的时候就来了、晋前就来，汉朝的时候好像就来了。【净土法门】和在中国佛教史是最早，等到这【真常唯心】，它是后来，后来来到中国来，来到中国来。《楞伽经》是更晚，《楞伽经》是唐中宗，神宗元年来，就是这样记载了，这时候来。《起信论》稍早一点，说是真谛三藏翻译，也有人说是不是的，中国人造的哦。在南北朝的时代呢？【般若】法门很盛行、《般若》、《中观》很盛行。这时候还没有《楞严经》，但是《起信论》来了，来了似乎是学习《起信论》的人也是有，就是【地论宗】的人，也是有。</p>
<p>　　等到了唐朝、隋…晋宋齐梁、陈隋之间，这时候【天台宗】起来了，【天台宗】智者大师我看也是【真常唯心论】，也是这样子。就是这么多的法门里面，天台智者大师是选了这个法门了，因为智者大师对《涅槃经》特别的有心得，有心得的。那么中国佛教，智者大师出现以前呢？中国佛教似乎这个思想还不稳定，一会那样子，一会子那样子。智者大师判教以后，中国佛教就是稳下来，思想就是这样子。</p>
<p>　　【华严宗】起来呢？在我来看，其根本的思想还是和【天台宗】一样，小小的有一点分别，实在也没有大的分别。</p>
<p>　　到了唐朝以后，唐朝初年，这个《中观》、《般若》的，还是有力量的，还是有。等到后来唐玄奘三藏回来，【唯识宗】起来，其它的学派都是…【天台宗】也好、这个【三论宗】也好，都是低下了一点。【天台宗】就是局限在江浙一带，那其他的地方都是【唯识宗】的天下和【华严宗】的天下。【禅宗】，后来的人说【禅宗】是兴盛，若我来看，都是因为教兴盛，所以禅兴盛；教若是衰微了，禅就完了，我的看法是这样子。</p>
<p>　　那么后，就是这样子，一直是【真常唯心论】是中国佛教的主要的…主流，所谓叫做主流。就是近代、民国初年，杨仁山居士从日本取回来《中观论疏》、取回来《成唯识论述记》这些参考，那么这个【中观学派】、【唯识学派】，又逐渐、逐渐的起来。等到近二、三十年来，印顺老法师真是中国佛教，真是一个大的…就是平流中忽然间有大浪起来了，就是提倡《中观》，提倡《阿含经》。我认为还要继续的兴盛起来。其他的【真常唯心论】受到了印顺老法师这个思想的冲击，会渐渐的会低下来，你从现在看啊，是凡老一派这个【真常唯心论】这一派思想的人，我认为…已经出现的、没出现不知道，已经出现的这些人，没有发言权，我们用现在的话来说，没有发言权，没有。属于这一派思想的人，小小的有一点思想，你不敢同印顺老法师比，你不敢、不敢，是这样子。所以这样子下去，刚才也可能有大福德、大智慧人出来，那就不知道。</p>
<p>　　但是我看将来中国的佛教，锡兰的佛教，我们中国派到锡兰去学习佛法的人、派到日本学习佛法的人，加上【南传佛教】到了台湾，把【南传】的藏经翻成汉文。这样子蕴酿起来的时候，我看【南传佛教】到中国来的人，也对中国的【真常唯心论】有威胁，也有威胁。这个印顺老法师【中观】的思想也直接的在冲击，所以【真常唯心】能起来，在今天来看还没有看见有一个人有这种大智慧，还没看到。这是佛教的这个…从佛教史和现在佛教的情况来说这件事。</p>
<p>　　另外一个想法呢？【真常唯心论】也有些功德的地方，有它的优点，有些功德地方，但是也有一点…我等于说它不对，它有些…它有一些不足的地方，什么不足的地方？我们若是学习「无我观」的话，你学习《中观》的思想、学习《阿含经》、学习…我们还是说这两部分的佛法，学习《阿含经》的佛法、学习《中观》这一部分的佛法，你若这样能修「无我观」，人与人之间容易合，不嫉妒障碍。你有大成就，我发欢喜心，随喜功德，不嫉妒障碍。因为他修「无我观」的时候，他的心一切的事情没有冲突，没有我可得。每一个都是无我，彼此之间都是和合无我的，彼此都是合的，没有冲突。如果你修【真常唯心论】，修「无我观」修不来。</p>
<p>　　你说是没有资格谈这个【真常】是无我的，没有这个资格，但是事实上你在…你用功修行的时候，【真常】修…这个【真常唯心论】的学者只好念佛，只好念阿弥陀佛求生净士，修无我观修不来，因为思想上有冲突。有、没有资格去谈论这个问题？我们先放在那里，就从事实上修行上看，只好我念一念《金刚经》、我念一念《法华经》，然后我念阿弥陀佛求生净士，这就是修行了，修「无我观」修不来。修「无我观」修不来呢，结果呢？这个我执还在那里，我执、法执都在那里，不能破，降伏都不…都有困难。你我执在那里的时候，人与人之间的关系会怎么样？</p>
<p>　　人与人之间的关系，如果是地位高了的人，不过这是按今天来说，我看修养都不是太好，随时就会说出一句话攻击别人，会攻击别人。用贪瞋痴攻击别人。那么人就会不合。人不合，佛法就衰微了、就衰微。你若修这个「无我观」能成功的话，他不会，他这个嫉妒障碍这个的心就会停下来，随喜别人的功德，那么佛法就是容易兴盛。</p>
<p>　　不要说大的佛教、大的佛殿（？），就是一个寺院里面，一个师父收几个徒弟，假设你不修无我观，一样的嫉妒障碍。一样的，没有什么分别，他就不合。一个老法师在的时候，有可能还算是大家在一起，有可能都不一定。等到老法师死了，就是四分五裂，就是不能合，就是各自发展了，不能合，都是这样子，就是因为这个我执还在，我执还在。假设你能无我的话，不要紧，我的师弟有道德，有种种优越的条件，他可以担当重任，好，我支持我的师弟，我不是打倒你，敲你的墙脚，破坏你，不、不…，不做这种事，他自然是合的，自然是这样子，这是不同。</p>
<p>　　就是你，你们初来佛教的人当然可能还不知道这件事，但是你若是学习佛法久了，不用说，自然会知道，知道这件事，这样子。在家的在社会上，社会上的人做生意，好像「商场如战场」，我倒是没有这种经验。但是你告诉我「商场」，「商场如战场」，我就明白了。什么原因呢？就是我执，就是这样子。</p>
<p>　　你看中国历史，什么叫做父母兄弟？没有这回事情，那有谁是我父亲，没有这回事情。我若有机会，打倒一切人我做皇帝。我父亲一样的，也是把他搞死他，不要说哥哥、弟弟。你看那个隋炀帝、看看历史上，就是这样子。佛教呢？学习了佛法，能够用功修行，能够把这些粗烦恼降伏一下，稍好一点。如果不能修无我观，就完全都暴露出来，若我看，从事实上看就知道。</p>
<p>　　所以说这个【真常唯心论】有它的优点，是有优点，有什么优点呢？就是没有、不容易有【断灭论】。就是把五蕴，「照见五蕴皆空」，还有一个【真常唯心】存在，没有【断灭】，这是它的优点，就是这么回事。</p>
<p><strong><em>问：</em></strong>它是用佛的常乐我净的说明比较好吗？佛的常乐我净理论比较容易接引来说明好呢？</p>
<p><strong><em>答：</em></strong>也可以这么说，但是其他的学派的佛法也一样可以说「佛常乐我净」，也可以。你就说我们生死凡夫嘛，譬如身体变动一些，天的身体死掉了，换成人的身体，一直的相续下去啊。这个有漏的惑业苦，虽然苦恼的境界，它也不断的，一直的相续下去。那你修无漏的大悲心、那个无漏的六波罗蜜的功德，当然也可以常乐我净，但是那大自在的境界。一样可以说明的，也是没有困难。</p>
<p>　　不过这个事还是这样子说好了，就是每一个人随自己的欢喜。你欢喜就【真常】，欢喜【唯识】、欢喜【三论】、你欢喜《阿含》，随你自己的欢喜好了。这天台智者大师这个意思。</p>
<p>　　但是在最…我们刚才说这一段佛法，说了【瑜伽】，一切佛法都是互相随顺相应不违的，不冲突。冲突的是人的分别心，不是法，法本身没有冲突，人的分别心有问题。人的分别心有问题呢？也还是在凡夫，圣人还没有这个问题。所以这个我们说到了这学期写出来一个佛学院，我们发表了一个简介，教义里面我原来都没有这种想法，等到写这个东西的时候，当然我以前也看见过，等到写这个东西的时候呢？就把以前的想法也加进去，发觉一件事，什么事情呢？小乘佛教徒攻击大乘佛教，说「大乘非佛说」，原来是凡夫的小乘佛教徒。凡夫的小乘佛教徒会说出这种话，若是入圣位的人，他是相信大乘的，从经论上有这样的说法。《法华经》也有这个说法，《般若经》也有这种说法。已经入圣位的这个小乘佛教学者是相信大乘的，他不会去破坏大乘。</p>
<p>　　破坏大乘的是凡夫里面的小乘佛学的一部分，也不是全面的。但是这句话说得是很厉害，说「大乘非佛说」。「非佛说」那是谁说的？那么就是魔说的，所以这句话是很厉害。这句话是很厉害，而我们中国的【真常唯心论】的学者没有话好说，就是闭口，你不能解释这句话是错的。但是你说出来那几句话没有力量，那么谁能说出、能解释这句话说的不对呢？只有印顺老法师。他有着作，他能解释这句话，把这句话反驳，他保护了大乘佛教。</p>
<p>　　当然我们中国传统的佛教学者，对印老是不满意，对他是不满意的。不过现在到今天来看，这些老法师还走了，还有谁在啊？我看【华严宗】的老法师也不在了，【天台宗】的老法师也不在，中国大陆听说这个四川．重庆，啊，不是，成都的文殊院的这个老法师，就这些人，我八九年去的时候想要看看他，他说有病，我也没打扰他。另外【天台宗】那里还有谁？【天台宗】的老法师也不在，【华严宗】的老法师也不在，【禅宗】的老法师我看也都走了，都走了。传统佛教的人先走了，那些老法师的弟子有多少？</p>
<p>　　所以这个【真常唯心论】，我的想法呢？除非有大福德、大智慧人出来领导还有可以。所以谁也不要说这个佛法好、那个佛法不好，谁也不能说这种话。无论那一个学派的佛法，若有一个大人出来弘扬，那就是最好的佛法，人都是这样子，人都是这样子。你的智慧不够，那你就不要谈，这个事情不要谈。你说什么都没有用，人家不听你的。如果大福德、大智慧你说错了也是好，这是事实是这样子，人是这样子。初发心的人自己没有眼睛，都是看着，就是这样子。等到你本身修学地位高了，你才自己才有眼睛，但是谁能到那个程度？那个程度的人很少，很少的。</p>
<p>　　所以这个学派之间，每一个人都可以站在自己的立场去分析，去发挥，去说明这个，所以这个机会是平等的。但是人家接受、不接受又一回事情。又是一回事情。</p>
<h3 id="第7讲"><a href="#第7讲" class="headerlink" title="第7讲"></a><strong><em>第7讲</em></strong></h3><p><strong><em>如是圣教，亦名瑜伽，称正理故、顺正行故、引正果故。</em></strong></p>
<p>　　这是解释《瑜伽师地论》这个题目。在题目里面先解释「瑜伽」。「瑜伽」里面，分「境瑜伽」、「教瑜伽」、「行瑜伽」、「果瑜伽」。这个「境」就包括了「理」在里面。这三种境、行、果，都已经讲过了。这以下解释这个「教瑜伽」。</p>
<p>　　「如是圣教，亦名瑜伽」，这样的圣教，就是佛所开示的一切的法门，这语言文字的佛法，它也可以名之为「瑜伽」的。</p>
<p>　　这个「瑜伽」前面讲过是，中国话是相应的意思。这个「教」称之为相应，怎么样解释呢？「称正理故」，它和佛所说的这个第一义谛的真理是相称合的，是相称的、是相合的。</p>
<p>　　就是「法界等流」，我们学习《摄大乘论》的时候，佛说的这个教是「法界等流」，就是佛觉悟了这个法性的真理，由于大悲心的推动，就是流出来这个清净的、显示真理的语言。这个语言表达佛所觉悟的真理是正合适，恰到好处，所以叫做「等」，「等流」，就是「等」，和那个真理是相合的。所以这上面以这个「称正理故」就是那个「等流」的意思。如果是它和这个佛所觉悟的真理、佛所证语的真理，佛在菩提树下所觉悟的这个缘起、法性的真理，若是不相合的话，那我们学习佛法就是白学了，就是没有用了，那你不能因此而证悟真理的。现在佛告诉我们是「等流」，是「称正理故」，所以我们可以放心了。</p>
<p>　　「顺正行故」，它能随顺我们的修行。我们依据佛的教法去修行去，它也是相合的，它也相合喔。这个相合这个意思呢？就是契机，有契机的意思。「称正理」是契理；「顺正行」是有契机的意思。说是它是「称正理」，但是与我们的根性、程度不合，这也是会有困难，也会有困难。它能契机，这个契机这句话呢？那我们从经论上的学习，可以知道这个修行的事情就是止观，也就是所谓禅。禅是什么？就是四念处。修四念处啊，其中这个修止的这件事，有多少和人的这个分别心有一点距离。因为我们的分别心，习惯了散乱的境界，东想西想这样子，自由的活动。这个止不是，叫它不要动，这是有一点不合。但这个观是合的，观怎么是合的呢？观就是思想，就是按照佛的教去思惟去。这和打妄想是一样的，只是内容不同。和打妄想一样，所以就是能契机了。这个语言文字啊，佛说法的时候，就用我们习惯使用的这种语言文字。所以我们就是按原来的情况嘛，原来的这种语言文字，来表达真理，所以我们心里面去思惟去，也是合适的。所以叫做「称正理故、顺正行故」，是随顺的，并不是有什么困难的。</p>
<p>　　「引正果故」，这个教，这个「教瑜伽」，你依这个教去这样修行，就能使令你引发出来圣道，能引发出来圣道，就是证果。这是一种没有过失，而有广大的利益的一种成就，所以叫做证果，所以这个「教」也叫做「瑜伽」。如果这种教不符合真理、也不顺于正行、也不能引正果，那就不是佛教了，那就有问题了。</p>
<p>　　若是我们学习佛法啊…我们从印度佛教史来看、从中国佛教史来看，的确是有问题。就是你不常学习、你不常读诵经论，你的修行的法门逐渐的就会偏了，就会有偏差，就会有这个问题。所以用功修行的人，你不能够只是坐在那里修止观，一定你还要读经，你一定还是要这样子，它才能够使令你心安。就是有的时候读经，有的时候你都会想，我这样修对不对呢？都会有这种想法，所以一定要读经的啊！若是把这个经论啊，不立文字，把这个经放在藏经楼上去喂虫子、给虫子咬，说我这样子可以开悟了，从《佛教史》上看，是不可能的事情，是不可能的。就是你读经，说是我有一点境界是不是和经论相合，都可能还是不一定的，都还不一定，何况你再不读经呢！所以这个地方呢？是这个「教瑜伽」可见也非常重要，非常的重要的。</p>
<p>　　这样说就是，境瑜伽、行瑜伽、果瑜伽、教瑜伽合起来名之为「瑜伽」。这前面是「通说三乘境、行、果等所有诸法，皆名瑜伽，一切并有方便善巧相应义故」。</p>
<p><strong><em>一云：正取三乘观行，说名瑜伽。数数进修、合理、顺行、得胜果故。</em></strong></p>
<p>　　这是第二个解释，就在《瑜伽师地论释》这部书上有两种解释，现在是第二个。</p>
<p>　　第二个说法呢，是「正取三乘」，就是主要的，这个「正」在这里应该说是主要的。前面说通于三乘境、行、果等，现在不那样说。主要的是取这个三种佛法里面，声闻乘、辟支弗乘、佛乘，这三种乘里面都有境、教、行、果（教、理、行、果）。</p>
<p>　　现在单独的取这个观行来说，就是修行的这一方面来说，就是修止观。修止观里面呢？本来是有止、也有观，但是这个止字、止略去了，就单独说观，这可见观的特别重要。因为你单修止而不修观，就是成功了，当然也是不错，可是还是凡夫啊，一定要用观才能得圣道的。</p>
<p>　　「说明瑜伽」，就是这个止观、三乘学者所修的止观，叫做「瑜伽」。因为什么呢？「数数进修」，这个「数数」就是一次、又一次、不间断的，不断的重覆就是了。修止也是、修观也是，不断的重覆这么进修。这个「进」就是向前进，不停下来。你能够这样去不怕辛苦，也不怕腿疼，去修止观。这样子去用功修行，它是要「合理」，要符合佛说的教理，就是「境瑜伽」。</p>
<p>　　「顺行」，也是随顺佛所说的这个法门而修行。「得胜果故」，这样子你就会得到一个殊胜的圣道，叫做「得胜果」。</p>
<p>　　这个以止观的修行为瑜伽，这是符合正义。这个瑜伽师，就是修…就是在我们中国佛教习惯的说法，就是禅师。瑜伽师就是禅师，就是这个意思。</p>
<p>　　这个说「合理、顺行、得胜果故」，这个合理，也就表示你修止观的时候，常常要读经，也有这个意思。</p>
<p><strong><em>境、果、圣教，瑜伽境故、瑜伽果故、诠瑜伽故，亦名瑜伽，非正瑜伽。</em></strong></p>
<p>　　这前面说行是瑜伽，止观的修行是瑜伽，其他的这几个不是瑜伽吗？可也不离开瑜伽的。这个境、和果、和圣教这三个，是瑜伽的所缘境。这个禅师啊、这个修止观的人是…这个境、果、和圣教这三个，是所缘境，这个禅师所学习的境界。你不能够单独修止观的，你还要读这个圣教，圣教里面也说到圣道所成就的果、所缘的境界，也包括这几个的，是瑜伽的境。</p>
<p>　　这个「瑜伽果故」，境是这个瑜伽师、这个禅师的所缘境；果，是修瑜伽的人所成就的果；这个教是「诠瑜伽故」，是显示这个瑜伽应该怎么修行的、应该怎么样修行。你时常要阅读它的，你才能够保证你修行得没有错误。不只是坐在那里修止观，你还要读这个圣教，里面也包含这个圣果和一切的所缘境都包括在内、在里面的，所以它们也是瑜伽。</p>
<p>　　「非正瑜伽」，但是不是主要的，主要是说修行这方面说、修止观这方面说的。这（讲义）底下这「今」字不要喔。</p>
<p>　　这样子，就是，前面一个解释是通说的，这第二个解释是别说的。一个通、一个别，但是主要是别，别也没有弃舍通。这个瑜伽的解释就是这样子。</p>
<p>　　这个题目的「瑜伽」这个词解释完了，现在就解释这个「师」。</p>
<p><strong><em>梵言阿遮罗，此云师。有调化之功，匠物适机，群徒所放之美称也。</em></strong></p>
<p>　　「梵言阿遮罗，此云师」，这个梵文是这个「师」这个字叫做「阿遮罗」，我们汉人、中国人叫做「师」。</p>
<p>　　「有调化之功，匠物适机，群徒所放之美称也」，「有调化之功」，这个「师」是指这个人说的，指教导我们的人说的。他有一个调转、调和、调理、转化我们的这个功能。我们这个身口意，不符合圣道，与圣道有点距离，他能调、渐渐地调和、转化，他就与道相应了，就可以得圣道了，「有调化之功」。「化」是变化，变化气质，有人说是变化气质，实在主要就是这一念心。调身口意其实就是调这一念心。我们这一念心若是调伏了，身口自然也调伏。这个心它有烦恼推动它，叫它去种种的活动，都是染污的。现在调伏它，用智慧、用佛法里面的般若的智慧、随顺般若的智慧去行动、去说话、去思惟，叫它与圣道相合，这叫「调化」。</p>
<p>　　「匠物适机」，这个「匠」，就是巧妙的意思，木匠、铁匠、泥水匠，他有这巧便的智慧，能够…也还是「调化」，这就是教导…这「物」就是众生，教导众生。「适机」，他教化的，能适合那个人的根性、能契合那个人的根机。其实「机」是什么？「机」就是心，就是我们这一念心。这一念心它是一切法的开始，一切法都是因…由心而有的。你若没有分别心的时候，一切法都没有了。所以这个「适机」就是契合众生的心而已。就是调伏这一念心这件事，他调和得很适当，没有过犹不及的这些事情。</p>
<p>　　「群徒所放之美称也」，在这应该唸倣ㄈㄤˇ喔。就是众多的学者，众多的弟子所倣效的一个「美称」，向他学习而一定有成效的一个美好的称呼，就叫做「师」。这个「师」这个字这样解释。</p>
<p><strong><em>释论解云：三乘行者由闻思等次第习行，如是瑜伽随分满足，展转调化诸有情故，名瑜伽师。</em></strong></p>
<p>　　「释论解云：三乘行者由闻思等次第习行，如是瑜伽随分满足」，这个又引…这是遁伦法师…这是《瑜伽师地论记》，这是唐朝的遁伦法师他编辑的，前面那几句话是遁伦法师讲的，这底下他引《瑜伽师地论释》上的解释。说三乘的修行人，他由「闻思」修等的次第的「习行」，不断的学习。「行」ㄒㄧㄥˊ这个字这个字当动词讲，就是向前进，一步、一步走向前进。如果当名词讲，就唸行ㄏㄥˋ。「行」ㄏㄥˋ就是你修行的成就、德行。修行有了成绩了，叫行ㄏㄥˋ；你在修行的时候应该唸行ㄒㄧㄥˊ。我查了字典，查了多少次，当然多少次，人、很多人都唸行ㄏㄥˋ，大行ㄏㄥˋ普贤菩萨，这唸行ㄏㄥˋ是对，他是有德行的人，有成就了的人。「次第习行」，按照闻思修的次第，不断的这样子修行的人。</p>
<p>　　「如是瑜伽随分满足」，这时候应该念行ㄏㄥˋ了。你从闻思修上的次第的学习，时间久了你就会有成就，什么成就呢？「如是瑜伽随分满足」，随着你的修行，一分一分的成就。你这时候闻所成慧你这时候有点成就，进一步又成就了思所成慧，进一步有修所成慧，修所成慧也通于有漏、也通于无漏。随着你自己的精进或者懈怠，或者不完全懈怠，也还是用功，那么你就会有成就。或者到了六十分，或者七十分，或者是一百分，或者两百分，逐渐的这么成就，就是叫做「满足」，一部分、一部分的满足。</p>
<p>　　「展转调化诸有情故」，如是「由闻思等次第习行，如是瑜伽随分满足」，是这个人自己用功的事情。「展转调化」，是这个人他本身有一点成就了，他就去展转的去饶益同梵行者，所以叫做「展转调化」。你给我做老师来教化我、教导我。教导我，我若继续用功修行，我有点成就了，我也可以去教化别人，所以展转的调化诸有情故，这样子，这就叫做「瑜伽师」，这瑜伽师就是这么回事。</p>
<p><strong><em>或诸如来证瑜伽满，随其所应，持此瑜伽，调化一切圣弟子等，令其次第修正行，故名瑜伽师。</em></strong></p>
<p>　　「或诸如来证瑜伽满，随其所应，持此瑜伽，调化一切圣弟子等」，前面这个解释通于一般的加行地。这个我们按照法的规定来说，这个做瑜伽师最低限度要到加行地的程度。在资粮位、在外凡位给人家做老师，是勉强了一点。到煖顶忍世第一的时候、到煖顶忍的时候，你为人做老师，还好一点；说没有到煖顶忍就给人做老师是勉强一点的。但是这里来说也应该通于圣位，到初果、二果、三果、四果，乃至得无生法忍，初地、二地、三地、四地，乃至到第八地，都包括在内了，「或诸如来」这是最后了，这个瑜伽师到最后圆满就是佛的境界。</p>
<p>　　「证瑜伽满」，一切功德究竟圆满了。「随其所应，持此瑜伽」，随他所适合的，「应以佛身得度者，即现佛身而为说法」、「应以何身得度者，即现何身而为说法」，就是随其所应，这个境界是不可思议了。</p>
<p>　　「持此瑜伽，调化一切圣弟子等」，他的内心里面有无量无边的法门，所以叫「持」。他用这样的瑜伽来调化一切圣弟子等，那佛的究竟的境界，那是非常广大的，教化一切圣弟子等，凡夫的弟子乃至圣位的弟子，都包括在内的。</p>
<p>　　「令其次第修正行，故名」叫做「瑜伽师」，「令其次第修正行」，这个「次第修正行」真是不容易。</p>
<p>　　这个在…你若看这个天台智者大师的摩诃止观，他说得很微细的，这个次第还真是不是容易。若读《优波鞠多尊者传》也会明白这件事，那真是圣人啊。若遇见佛、遇见大菩萨，拜他做师父，那真是…真得要有善根啊！他能够随时随地有次第的、恰到好处的教化你，「故名瑜伽师」，这叫瑜伽师。</p>
<p><strong><em>梵云步弥，此云地者，生成住持义也。始自五识终暨无余，凡圣因果统无不备，皆具能生成住持，有类于地，故云也。</em></strong></p>
<p>　　「梵云步弥，此云地者」，前面这「瑜伽师」讲完了，这底下讲这个「地」字。</p>
<p>　　「生成住持义也」，这个「地」是什么意思？就是大地，这个大地它能生长万物。这个「成」，就是生长到最后圆满了，叫做「成」。成了以后还能「住持」，不失掉，这个大地能够这样子。现在这里是说，不是说大地，是说我们修行人的这个地。看底下解释喔。</p>
<p>　　「始自五识终暨无余，凡圣因果统无不备，皆具能生成住持，有类于地，故云也」，这是正面的解释这个「地」。</p>
<p>　　「始自五识」，就是《瑜伽师地论》从开始，开始从这个＜五识相应地＞就是＜本地分＞，五识相应地、意地、有寻有伺地、无寻唯伺地、无寻无伺地，乃至三摩哂多地、非三摩哂多地、有心地、无心地、还有闻所成地、思所成地、修所成地，乃至声闻地、独觉地、菩萨地、有余依地、无余依地，一共有十七地。「终暨无余」，到最后到这个「无余依地」，一共十七地。</p>
<p>　　「凡圣因果统无不备」，这十七地里面，凡夫的因果、圣人的因果。凡夫的因果，当然说到造恶就要到三恶道去，修善就到三善道。其中说到修禅定，说得非常的详细，就是从欲界定、未到地定，乃至初禅、二禅、三禅、四禅，乃至到无色界的四空定、灭尽定，很多、很多的事情。这样子…若是灭尽定那就是圣人的境界，如果只是说到四禅八定是通于凡夫的。圣人的因果，修这个四念处、三十七道品，乃至到得初果、二果、三果、四果，乃至得十地菩萨，这一切因果，「统无不备」，完全都包括在内，没有不具足的了。</p>
<p>　　「皆具能生成住持」，这个一共十七地，我们若是学习它的时候，它有这种功能，能令你裁培善根，使令善根得生长、得成就，成就了以后而不失掉，能够住持不失坏。这个不失坏这个住持的意思，安住而不失坏，只有圣道才可以。你修学出世间的法门，你若有成就了，就是永久的成就而不失坏。世间的这个善恶因果都是不能住持的，都是有时间性的，到时候就没有了。你就是这个人造恶，造了很重的恶，到地狱去，到地狱还是有时间的；就是不管是多长，只要有时间，总是一天一天到时候没有了，就结束了，不是永久在地狱里头、永久在三恶道里，不是。你修的善法，你到了非非想定，八万大劫，到时候这个定也就完了，也结束了，都是失坏的，能生成而不能住持。但是若是佛教的功德、出世间的圣道可不是，「生成住持」，常乐我净，而不失坏的。</p>
<p>　　这样子说呢，这个＜本地分＞十七地，「有类于地」，就像这个大地似的，能生成住持万物似的，「有类于地」。「故云也」，所以叫做「地」，它是瑜伽师的地。这十七地，这十七个部分的佛法能为瑜伽师的地，能令你「生成住持」三乘的圣道，所以叫做「地」，这样的意思。这个地就是这样的解释，这叫做地，这底下又再解释。</p>
<p><strong><em>释论解云：地谓境界，所依、所行、或所摄义，是瑜伽师所行境界，故名为地。</em></strong></p>
<p>　　这底下说哦，这个《瑜伽师地论释》上解释的就更详细了，前面说个大意，前面是总说，这里等于是别说。这个「地」这个字是境界的意思。怎么叫做境界呢？「所依、所行、或所摄义，是瑜伽师所行境界，故名为地」。</p>
<p>　　这个「所依」，是我们学习佛法的一个对象、的依止处。这个依止处实在就是你居住的地方。说你现在在什么地方住？我在旧金山住，就是旧金山是你的依止处。说你在什么地方住？我在法云寺佛学院住，就是那个地方就是你的依止处，这个「依」是这样意思。</p>
<p>　　「所行」，就是你活动的地方。也就是你学习佛法…就是这一念心。我们佛教说的…很多的地方…这个经律论里面说到这个「行」、说这个「依」。这个能依和能行是谁？就是一念心，就是我们的分别心。我们的心在这里住、在这里活动，这样意思。这个「依」是所住之处，这个「行」就是所活动的地方，其实就是一个地方。一个地方啊，可是有点分别，这个「依」和「行」有点分别。</p>
<p>　　比如说我们现在学习这个《瑜伽师地论》，这个《瑜伽师地论》是我们的心、我们的思想的依止处。这个「行」呢，还是这里，但是和这可有点不同了，就是更详细的在这里活动，叫做「行」。这个「依」就是你开始限制自己的心的范围，我这个心就不超越这个范围，就在这里。那么在这里面不断的行，就是不断的学习、不断的闻思修。这个「行」和「依」是同一个地方，但是有一点不同。所依之处、所行之处是一样的，但是依和行有一点差别。差别呢？就是「依」指范围说；「行」是说在这个范围内的更不断的深入的学习，叫做行。这么讲。</p>
<p>　　「或所摄义」，或者是说，是凡你所学习的、所接触的、所包含的一切的境界，都可以名之为境界，都可以名之为境界的。「是瑜伽师所行境界，故名为地」，是这样讲。</p>
<p><strong><em>如龙马地，唯此中行，不出外故。</em></strong></p>
<p>　　这底下说出个譬喻，譬如龙马的地方，这个「龙马地」这句话，在《阿含经》里面说，这个龙的形相，就有马的形相，这个龙有马的形相，所以叫「龙马」，也可以这样讲。龙，有蛇相的龙，像一条蛇似的，有的像一条鱼似的、像虾蟆似的，龙有四种形相的（注：《大方等大集经》卷58：此处多有象龙马龙蛇龙鱼龙虾蟆龙）。那么这个说龙里面有的像马的形相的是叫「龙马」，或者这个马是另一种动物，不是龙，也可以。「如龙马地」，这「龙马地」怎么讲呢？就是龙马所行之地。</p>
<p>　　「唯此中行不出外故」，他们只是、唯独是在这个范围内活动，不超过这个范围之外的。说我们这个瑜伽师地这个地，也有这样意思，就是在这个范围内，不超越这个范围，在这里活动。它是我们的所依、所行，所以叫做瑜伽师地，这样解释喔。</p>
<p><strong><em>或瑜伽师依此处所，增长自法，故名为地，如稼穑地。</em></strong></p>
<p>　　「或瑜伽师依此处所增长白法」，我们的心就依止在这个地方，就是依止这个四念处，心依止这个四念处住，在四念处这个范围内，一直的观身不净、观受是苦、观心无常、观法无我，你在这个处所上依止、在这个处所上修行，「增长自法」。这个「自」这个字，我疑惑是「白」。增长「白」法，就是增长清净的功德。增长「自」法，也可以，就是一切功德法是自法；一切罪过的法是他。我们增长自法，不要增长他法，那么讲也可以。「依此处所增长自法，故名为地」，这就有生长的意思、有生成住持的意思了。这个「地」这么讲，「依此处所增长自法，故名为地」。</p>
<p>　　「如稼穑地」，「稼穑地」，就是种田。这个「稼」就是种田，这个种子种下去，要耕耘它、要除草、要施肥，做这些事。等到成熟了，「穑」就是收回来，叫「穑」。那么这个土地里面种上了种子，你不断的做这件事呢，最后有了成就了。现在我们这《瑜伽师地论》也是，你不断的学习、闻思修，也可以有成就的。所以「依此处所增长自法，故名为地」，这是这样子解释。</p>
<p><strong><em>或瑜伽师地所摄智，依此现行、依此增长，故名为地，如珍宝地。</em></strong></p>
<p>　　这底下又再有一个解释。「或瑜伽师地所摄智」，或者是这个禅师他不断的修行，他想要摄取一种清净的智慧，就是圣道了。前面的那个「稼穑地」似乎是在圣道之前，在资粮位、加行位的时候如稼穑地；现在「如珍宝地」，这就是得无生法忍以后了。你从这一念心里面成就圣道了，所以「所摄智」。</p>
<p>　　「依此现行、依此增长」，你要依据此《瑜伽师地论》这十七地，你不断的这样用功修行，也可以说现行；或者是不断的修行，就有清净的智慧现行了，得到无漏的圣道了。太阳出来没有？太阳出来了，叫「依此现行」。</p>
<p>　　「依此增长」，而这个智慧，不能一下子就得无上菩提了，你还要继续努力修行，使令这个清净无漏的智慧增长、无漏的戒定慧继续的增长。「故名为地」，所以这十七地、这十七个部分的佛法，就名之为地。像「珍宝地」，那块地里面有珍宝，不是一般的五谷，这是特别殊胜的境界了，这样子解释啊，譬如说我们不断的修四念处：观身不净、观受是苦、观心无常、观法无我，这个身、受、心、法就是地。我们不断的这样观察呢？就出来智慧了，就出来圣道了。</p>
<p>　　但是你在初开始用功的时候，也是身、受、心、法，等到有成就了以后，还是身、受、心、法，和以前有点不同了，有一点不同了，所以叫做「珍宝地」。以前的「稼穑」的时候是大…是土地，是地水火风一般的土地，现在变成珍宝地了，不同了。</p>
<p><strong><em>或瑜伽师行在此中，受用自法，故名为地，如牛王地。</em></strong></p>
<p>　　「或瑜伽师行在此中」，就是他的这个清净的戒定慧、清净的智慧，在这个境界里面活动，活动有了成就以后，「受用自法」，你有了受用了。不像你像得了欲界定的时候，虽然是定，但是没有轻安乐，可也有一点舒服了，也是很轻快，但是啊，若和这个未到地定、和这个四禅来说，是微不足道了。现在若得了禅了的时候，有殊胜的轻安乐，有这样的享受了，所以叫做「受用」。现在说你在凡夫的时候用功修行，也是很难得了，但是还没有什么成就啊。</p>
<p>　　所以修行这件事，在凡夫开始修行的时候，只是努力的辛苦地修行，没有什么成就，心里面不快乐。等到得了圣道以后，得到大自在的境界了，心里面叫做欢喜，叫做欢喜地，有了受用了。所以这个啊，我们出家人…我们佛教徒这么说喔，我们佛教徒修学佛法，把世间的五欲弃舍了，在佛法里面还没有成就，这个时候是很难的，是很难。</p>
<p>　　所以现在得了圣道的时候，「瑜伽师行在此中，受用自法」，你对于你所成就的圣道，有了享受了，你也会有作用了。不像凡夫的时候，人家看，哎呀，你很有修行，你给我加持」加持吧。其实那能加持呢，没有什么作用啊。但是得了圣道可是不同了，「行在此中，受用自法，故名为地」。</p>
<p>　　「如牛王地」，这又说个譬喻，「如牛王地」，就是牛群里面有个王，这个牛王在牛群里面很自在的，很大自在的境界。这个牛王能保护牛群，这个众多的牛也是拥护牠，牠有威力能保护这个牛。就像佛是一切众生的大导师，他能保护一切众生的，所以一切众生向他学习，得大自在的境界。就是修行人有了成就的时候，心情自在了，心安了一点。不是凡夫啊，有一点风吹草动，心就不安。若是得了圣道，心就安了。所以这个「王」是自在的意思，就是心安了。</p>
<p><strong><em>或诸如来名瑜伽师，平等智等行在一切无戏论界、无住涅槃瑜伽中故，是彼所摄，故名为地。</em></strong></p>
<p>　　这最后，前面「如珍宝地」、「如牛王地」，这是譬喻得无生法忍以后的这些圣人，称之为瑜伽师地；最后「或诸如来名瑜伽师」，那又更高了、更圆满了。</p>
<p>　　「平等智等」，他成就了这个平等的智慧。如理智就是「平等智」、如量智就是差别智；或者说是妙观察智、平等性智、大圆镜智、成所作智。这些大智慧，当然「行在一切无戏论界」，就是第一义谛。</p>
<p>　　这「戏论」是什么呢？一切的语言、名字都是戏论。你说「如来有所说法不？不也，世尊，如来无所说」，就是佛的境界是无戏论的境界，但是凡夫很难契合到这里，所以非要戏论不可，非要立出个种种的名字去分别观察，这样这个凡夫才能从凡夫的地逐渐的进步。可是到成功了以后，就是无分别的境界，离一切名言相了，所以叫「一切无戏论界」。那么这种无戏论界，你要成就平等的智慧，就是无分别的智慧。成就了无分别的智慧，你才能「行在一切无戏论界」，也就是不行，也就是于一切法不行一切法，就能行在一切无戏论界的，那「一切无戏论界」是什么呢？就是「无住涅槃」。虽然得了涅槃，而于涅槃无所住，也不住生死、也不住涅槃。</p>
<p>　　「瑜伽中故」，这样的瑜伽就是果瑜伽了。佛的境界呢？成就了那么多的无量的功德，但是其中最主要的就是智慧，所以别的功德没有提。这个智慧在大般涅槃、无住的果瑜伽中，「是彼所摄，故名为地」，这样的无戏论界，是那个无分别智所相应的地方，所以那个地方叫做地，「瑜伽师地」，这样讲呢？这是第一义谛名为瑜伽师地了。</p>
<p>　　前面这么几种的解释，实在是有深浅的意味在里面的。</p>
<p><strong><em>或十七地摄属一切瑜伽师故，如国王地。是故说名瑜伽师地。</em></strong></p>
<p>　　「或十七地摄属一切瑜伽师故，如国王地」，这个或这十七地，前面一从一开始的＜五识相应地＞到最后的＜无余依地＞，这十七地，「摄属一切瑜伽师故」，它是摄属这一切的瑜伽师。「瑜伽师」就是从凡位开始，一直到佛的境界，都包括在内了，都包括在这十七地里面。它是属于一切，能够一切瑜伽师地都包括在十七地里面了，所以这十七地是一切的瑜伽师的地。也可以十七地是属于一切瑜伽师，一切瑜伽师也属于十七地，可以这么解释。就是随你这一位瑜伽师的修行的深浅，这十七地就不同，就是不一样的，所以可以互相摄属。</p>
<p>　　「如国王地」，像国王的地方，「国王地」就是属于国王的。在这一切、在这他所…他的权力所属的境界，都是自在的，如国王地，「是故说明瑜伽师地」，这个瑜伽师地这个「地」字这么讲。</p>
<p><strong><em>解云：其境及所摄，各唯一解；依行二种，各有二解，合六番释也。</em></strong></p>
<p>　　这是把前面这一大段总起来结束。这个「解云」这句话，应该就是这个遁伦法师说这句话了。他说「其境及所摄，各唯一解」，第一个解释，「释论解云：地谓境界，所依、所行、或所摄义，是瑜伽师所行境界，故名为地」这叫做「境」，「其境」指这个说的。</p>
<p>　　「及所摄」就是最后这个，是「或十七地摄属一切瑜伽师故」，这是摄属。</p>
<p>　　这是两个解释，境，一个解释；所摄，一个解释，这是两个解释。</p>
<p>　　「依行二种，各有二解」，那就是这个有第二个，「唯此中行，不出外故，或瑜伽师依此处所，增长自法，故名为地，如稼穑地」，这个这就是…这个「如龙马地」是往前上段的话，这底下「或瑜伽师依此处所，增长自法」，从这里开始，这是「依」。这个依叫「如稼穑地」。「或瑜伽师地所摄智，依此现行」这个行。一个「依」、一个「行」。这是「依」一个解、「行」一个解。</p>
<p>　　这底下，「如珍宝地」或…是前面一段「或瑜伽师行在此中，受用自法，故名为地，如牛王地」，这个「行」又有一个解，这个「行」就是两个解释了。「如珍宝地」、「如牛王地」这都是「行」。</p>
<p>　　「或诸如来名瑜伽师，平等智等行在一切无戏论界、无住涅槃」，这个也可以说是「依」，可以说是「依」啊。就是前面啊…「或瑜伽师依此处所，增长白法」，这又是一个依。说两个「依」、两个「行」。「或瑜伽师依此处所，增长白法」，这是个依；「或诸如来名瑜伽师，平等智等行在一切无戏论界、无住涅槃瑜伽中故，是彼所摄，故名为地」，这个也是「行」、这也是「行」。</p>
<p>　　*这是把前面这一大段总起来结束。这个「解云」这句话，应该就是遁伦法师说这句话了。他说，「其境及所摄，各唯一解」：这个，「释论解云：地谓境界，所依、所行、或所摄义，是瑜伽师所行境界，故名为地」，「如龙马地，唯此中行，不出外故。这第一个解释，叫做「境」，境是指这个说的。「及所摄」就是最后这个，「或十七地摄属一切瑜伽师故，如国王地」，这是摄属。这是两个解释：境，一个解释；所摄，一个解释，这是两个解释。</p>
<p>　　<em>「依行二种，各有二解」：那就是这个第二个，「或瑜伽师依此处所，增长自法，故名为地，如稼穑地」，这是「依」。「或瑜伽师地所摄智，依此现行、依此增长，故名为地，如珍宝地」，这又是一个「依」。这个依就是两个解释了，「如稼穑地」、「如珍宝地」，这都是依。这底下，「或瑜伽师行在此中，受用自法，故名为地，如牛王地」，这个是「行」。「或诸如来名瑜伽师，平等智等行在一切无戏论界无住涅槃瑜伽中故，是彼所摄，故名为地」，这又是一个「行」。这个行也是两个解释了。所以两个依、两个行。（注：以</em>标出这上两大段，已依 师父指示修改过。）</p>
<p>　　这前后两个是境，一个所摄。最后一个解释是「摄」、最初一个是「境」，中间四个是两个依、两个行，依、行两种各有两个解释，合起来就是「六番解释」，这样意思。</p>
<p><strong><em>梵云舍萨怛罗，此云论。释论云：问答决择诸法性相，故名为论。《俱舍论》云：教诫学徒，故称为论。然则师有瑜伽，瑜伽之师，依主释也。瑜伽师之地，亦依主释。瑜伽即地，二体无别；地是所诠，能诠即论，瑜伽师地之论，亦依主释。合为瑜伽师地论。有三释。</em></strong></p>
<p>　　「梵云舍萨怛罗，此云论」，中国话叫做论。「释论云：问答决择诸法性相，故名为论」：这个《释论》上的解释，有人有问、有回答，用问答的形式来决择诸法性相。这个「决择」，「决」是决定，「择」是简择，就是观察分别，这个是坏的、这个是好的；就是这样分别，这个是正确的、这是错误的，那么，这样去观察分别，而有一个决定的结论，这叫做决择。对诸法的性相，这样子问答决择的学习，这叫做「论」。「《俱舍论》云：教诫学徒，故称为论」，这么讲，教诫他的学生，那就叫做论。这是两个解释。</p>
<p>　　「然则师有瑜伽，瑜伽之师，依主释也」。这个「论」解释完了，这底下统起来说。「然则师有瑜伽」：现在统起来解释这个题目，「师有瑜伽」，这是什么意思呢？就是，这个师啊，他有瑜伽的功德。「瑜伽之师」：是有瑜伽的一位师长。是「依主释也」：这样子呢，师是主，瑜伽是属于师的功德，所以叫做「依主释」。在唯识的经论里面，有六离合释，这是用那六离合释来分别这件事。</p>
<p>　　「瑜伽师之地，亦依主释」，这个，瑜伽和师这样子解，或者是师有瑜伽、瑜伽之师，这么解释。这个「地」，是瑜伽师的地，瑜伽师所闻思修的地，「亦依主释」，这样这个地是属于瑜伽师的。</p>
<p>　　「瑜伽即地，二体无别；地是所诠，能诠即论」：瑜伽即地，这个相应，譬如说境瑜伽、教瑜伽、行瑜伽、果瑜伽，那么瑜伽就是地，这都是相应，瑜伽就是地。瑜伽和地，他们两个法的体性是无差别的，那么叫做瑜伽即地，那这等于是持业释，这样解释。「地是所诠，能诠即论」：这个论和地要怎么样解释呢？这个地是所显示的，能显示的就是论，就是用语言文字来显示这个十七地的义，他们的关系是这样子。那么若总起来说，「瑜伽师地之论，亦依主释」，瑜伽师地的论，瑜伽师地是主，那个论是属于它的。</p>
<p>　　「合为瑜伽师地论」：合起来叫做瑜伽师地论。「有三释」：这前面一共有三个解释。「师有瑜伽，瑜伽之师，依主释也」，这是一个解释。「瑜伽师之地，亦依主释」，「瑜伽即地，二体无别；地是所诠，能诠即论，瑜伽师地之论，亦依主释」，这又一个解释。合起来叫做瑜伽师地论，这一共有三个解释。</p>
<p>　　这是把题目解释完了，我们下一次就入到正文了。我心里面倒很着急啊，题目不要说太多，解释正文要紧，到现在就算是解释完了。</p>
<p><strong><em>问：</em></strong>请问院长，玄奘法师后来如何决断「当常」、「现常」这个问题？</p>
<p><strong><em>答：</em></strong>我也在想。你最初有这个疑问所以到印度去，但是你学了，完了以后怎么解释这个问题呢？但是没有看到有交代，没有看见。</p>
<p>　　佛法学多了，以前的疑问，在他心里面不那么明显了。就算是没有说，但是不明显。因为初开始学习佛法的时候，遇见这个问题不懂，心里面认为这件事很重要。等到去天天的学习、天天的思惟，学多了，对于一个…站在【唯识】的立场去通达全面的佛法以后，以前的疑问，在他心里面不介意了，再不说什么了。不说什么，但是这个问题是这样子。</p>
<p>　　如果是…从…现在我开始说的话，是我妙境心里面的分别，是无稽之谈，或者说有根据也可以。</p>
<p>　　这个【唯识宗】的经论里面，它说一切众生有的有「佛性」、有的没有「佛性」，不是都有「佛性」的。所以不是一切众生都能成佛的，有人成佛、有的人不能，有的人能得阿罗汉，有的人不能，他永久的都是个生死凡夫，【唯识】的经论有这种味道，有这种意思。这种意思，我们现在把这个声闻、缘觉这件事放在那里不说，单独说「佛性」。</p>
<p>　　这个窥基大师他就…也是大智慧人，所以他就解释这个《涅槃经》上说，《涅槃经》说「一切众生皆有佛性，凡有心者皆得做佛」，这个《涅槃经》上有这种话。《涅槃经》有这个话。</p>
<p>　　《涅槃经》前十卷「一切众生皆有佛性」，那意思是「现常」，你现在的虚妄的分别心里面就有「佛性」，是这样子。等到后来、后一大段的《涅槃经》里面说的是「当常」，就是说你现在没有「佛性」，你现在你没有「阿耨多罗三藐三菩提」，你没有。但是你现在心里面有虚妄分别心呢？你这分别心遇见佛法了，由闻思修这么修行，逐渐地、逐渐地就得「阿耨多罗三藐三菩提」了。是「将来」你会有一个常住的佛，是「当常」，是这么讲。这么讲那么统合起来说呢？佛说「一切众生皆有佛性」，这样解释。</p>
<p>　　这样解释，这个谁？我们的印顺老法师，也是大智慧人（我现在想起来什么说什么哦），他说这个《涅槃经》上说「一切众生皆有佛性」，就有一点共于【外道】的理论，有这种情形。有这种…或者说的谦让一点来说，有这种倾向啊。</p>
<p>　　那么【三论】的学者把他重新加一个新的解释，新的解释怎么意思呢？「一切众生皆有佛性」，他将…他现在有虚妄分别心去起惑造业、流转生死，也就是这一念心，遇见佛法之后呢？从闻思修逐渐、逐渐，将才就成佛了，这就叫做「佛性」、这就叫做「一切众生皆有佛性」。就是调和一下，调和一下，使令他附和佛法的真义，不共于外道。我看印老法师好像有这个味道，有这样解释。</p>
<p>　　那么这个窥基大师怎么解释呢？窥基大师他不这么解释。他说「一切众生皆有佛性」，是在你现在的色受想行识里面有这个「诸法如义」。「如来者，诸法如义」，都是「诸法寂灭相」，都是「空」的、都是「毕竟空寂」的、离一切相的「圆成实性」，一切众生都是有的，这叫「理性佛性」。说是「当常」就是我们遇见了佛法的时候，发无上菩提心了。感觉到众生是苦，佛法是宝，能够是众生的这个常夜的明灯，是非常的重要，我应该发心把这个灯来破一切众生的无明的黑暗啊，我要做大菩萨。你发了无上菩提心，你修行六波罗蜜，就在你的阿赖耶识里面就栽培了无漏的善根了，这个是「佛性」，这个就是「佛性」。这个「佛性」逐渐的增长、逐渐的成就，就得无上菩提了，就成佛了。这样说呢？「一切众生皆有佛性」，有那个「诸法如」的「佛性」，那并不保证你就能成佛的。你若有这个发无上菩提心、修六波罗蜜，这样的「佛性」，这叫做「行性佛性」，是有为，你有这个「佛性」你才能成佛的。</p>
<p>　　所以这个【唯识】的经论上说啊，是有的人有「佛性」、有的人没有「佛性」，约「行性」说的，约「行性」的「佛性」说的。这个《成佛之道》论也提到，这是窥基大师这么样来…用《涅槃经》上的「当常」和「现常」，把它名之为「理性佛性」、「行性佛性」，来融通解释「一切众生皆有佛性」这个道理，使令它没有矛盾，这样解释。这样说这个「当常、现常」就是这样解释了。那么也是「当常」、也是「现常」，是无障碍的、是无障碍。</p>
<p>　　说是一切众生皆有诸法如的「佛性」，这个不管是【三论宗】也好、【法相宗】也好、【天台宗】也好，乃至【华严宗】、【禅宗】，一切佛法都是统一承认的，都是承认这一点。那么这个「行性佛性」这样解释，谁能反对呢？我看也要承认，也要承认这一点。那么这样解释，就应该是把这个「当常」、「现常」的问题，究竟是「当常」？是「现常」？这问题应该是解答了。解答的结论呢？就是也是「当常」、也是「现常」，而没有矛盾。应该是这样说。</p>
<p>　　我以前也说过一个问题，就是【禅宗】里面有一位禅师，两位禅师在一起走路的时候，一位禅师说是「人若是没有…心里面若没有佛，就不能流转生死」，说这个问题。有一位禅师说「若有佛的话，就不迷于生死」，不迷于生死应该没有生死。这两个禅师互相争论，后来去见那个法常禅师（法常禅师是马祖的弟子），马祖印证什么、什么子熟也？印证他就是开悟了，就是这样意思，那么印证的时候。那么法常禅师说「你们…」好像那有一位禅师说（是夹山禅师），一个定山禅师、夹山禅师。夹山禅师问他，两个人提出这问题了，说是我们这两个人的看法，谁亲？谁疏？用这亲、疏两个字来形容这两个问题。一个是亲，亲者近也；疏者远也。我们两个问题谁是能接近真理？一个谁是能与真理相远？用亲、疏两个字来形容。那么法常禅师说「且去，明天再来」。那么明天来了，那么就是夹山禅师他去问的，那么法常禅师说「亲者不问，问者不亲」。这样子就等于是否认了夹山禅师这个问题，等于是这样子。</p>
<p>　　但是我看这个解释还是不能够令人心服，心还是不服。不过我另外有一个在《高僧传》上看出来一件事。好像一个人在禅定里面就看见佛了，看见佛。佛开示他的道理，他就从中提出来一个问题，说是一切法究竟是有为呢？是无为呢？这样问佛。佛说「都是戏论」，这句话说得好，这句话说得好。说是「有佛…心里面是有佛？是没有佛？」「都是戏论」，应该这么解释也是对的。</p>
<p>　　我们没有成佛的人，就是佛菩萨开导我们的时候，一定要把这个「缘起」的道理要说清楚，我们才能够心里面没有疑问，才能心能安下来，去修「四念处」，不然的话心里老是不安。所以就会说「是有佛呢？」、「是无佛？」因为这都是经论上的话。</p>
<p>　　《楞伽经》上说「如来藏」，「如来藏」是「涅槃因」、也是生死之因。因为有「如来藏」你才能流转生死、你才能得涅槃。「如来藏」是什么？「如来藏」就是「诸法如」、就是「佛性」。就是「佛性」，有「佛性」才能流转生死、有「佛性」才能得涅槃。</p>
<p>　　但是夹山禅师说「若有佛性，就不应该迷于生死」，也有道理。尤其是这个《大乘起信论》上说是「如来藏有大…」「真如有大智慧光明义」，有「大智慧光明」，为什么流转生死呢？你解释、解释我听听。我看很难解释这个问题，很难解释。</p>
<p>　　但是这个…这个【三论宗】也承认「诸法如」是「佛性」，一切众生都是「诸法如」，都有「佛性」，但是没有说「如上有大智慧光明义」，没有说这句话。没有说这句话呢？就没有这个问题。</p>
<p>　　若是照《阿含经》上这么解释呢？不说这件事。就是一切众生迷惑颠倒，起惑造业流转生死。你现在修四念处，破除颠倒就得涅槃。你没有借口生出种种疑惑，没有这个借口。</p>
<p>　　但是人呢？你常常用功修行就会发现一件事，你就按照《阿含经》这个四念处修行，也会发现到「诸法如义」，也会发现这件事。你不能说是「大乘非佛说」，这句话不能说，你真实用功修行。你只是在文字上这样分别，有的时候有这样想法，有那样想法，但是你自己修止观的时候，你就会踫到这个「诸法如」。你踫到的时候，啊！这句话不可以这么说。你自己会踫到！</p>
<h3 id="第8讲"><a href="#第8讲" class="headerlink" title="第8讲"></a><strong><em>第8讲</em></strong></h3><p>《瑜伽师地论》卷第一</p>
<p>弥勒菩萨说　唐三藏沙门玄奘奉诏译</p>
<p>本地分</p>
<p><strong><em>云何瑜伽师地？谓十七地。何等十七？嗢柁南曰：五识相应意，有寻伺等三；三摩地俱非，有心无心地。闻思修所立，如是具三乘；有依及无依，是名十七地。</em></strong></p>
<p>　　《瑜伽师地论》一共是分五分，一共有五分。第一分就是〈本地分〉，第二分〈摄决择分〉、〈摄释分〉、〈摄异门分〉、〈摄事分〉。一共是这五分。</p>
<p>　　第一分叫做〈本地分〉，就是根本的瑜伽师地，所以叫〈本地分〉。其余的四分都是属于〈本地分〉，是解释〈本地分〉。以这第一分为根本，所以称之为〈本地分〉。而《瑜伽师地》，也以〈本地分〉来立名，是这样意思。〈本地分〉，它是根本的瑜伽师地，这里面说了十七地，都是属于瑜伽师地的，瑜伽师的境界。</p>
<p>　　第二分叫〈摄决择分〉，是解释瑜伽师地的深隐要义。你们有带这个〈披寻记〉，这个〈披寻记〉上都是根据《瑜伽师地论释》，这样解释的。第二分叫〈摄决择分〉，就是解释〈本地分〉，不容易明白的精要之义，那么这是第二分大意。</p>
<p>　　第三分叫做〈摄释分〉，是解释的释。〈摄释分〉是说什么？是说《阿含经》里面的内容。《阿含经》，《四阿含经》里面究竟说的什么呢？它把它分成多少类，统一起来，叫做〈摄释分〉。解释《阿含经》的内容，通说一切《阿含经》的内容，那叫做〈摄释分〉。这是第三分〈摄释分〉。</p>
<p>　　第四分，就是〈摄异门分〉。〈摄异门分〉是什么意思呢？就是《阿含经》里面用不同的名，表达相同的内容的解说，那叫做〈摄异门分〉。最后一分叫做〈摄事分〉，事物的事，〈摄事分〉。〈摄事分〉里面说的什么呢？就是解释《杂阿含经》，解释《杂阿含经》的修多罗。这一部份印顺老法师把它和这个《瑜伽师地论》的文，和《杂阿含经》的文会合起来了，所以叫做《杂阿含经会编》。这一本书是支那内学院的吕征他也做过。这个书我是看过，但是没有详细去阅读。印顺老法师他说：「听说有这本书，但是没有看过」。那印老就是把它会合了，这件事不是容易做的。</p>
<p>　　这个〈摄事分〉，其中一大部分是这样的，就是解释《杂阿含经》的；一少部分，是说这个律，毗奈耶的事情，一少部分说到律。那么这里面也有论的意思；所以这个〈摄事分〉，这个《瑜伽师地论》实上说，是解释三藏的要义，说到三藏包括这个论典在内。这个〈本地分〉，一共是五十卷；〈摄决择分〉三十卷，这是八十卷。这个〈摄释分〉才二卷；〈摄异门分〉也是二卷，这是四卷。到最后一分是十六卷，那么加起来就是一百卷。〈本地分〉是最多，五十卷。</p>
<p>甲一、本地分（分二科）　乙一、略辨地名（分二科）　丙一、征</p>
<p><strong><em>云何瑜伽师地？</em></strong></p>
<p>　　这底下就是解释这个〈本地分〉。这个《瑜伽师地论‧遁伦记》，他也有科，他也分科了。我们现在每人都有的这个《披寻记》也有科，他的科微细了一点，比《遁伦记》的科微细一点，我们就用这个《披寻记》的科好了。</p>
<p>　　这个〈本地分〉，这一分里面分二科。第一科是「略辨地名」，就是简略的说明这十七地的名称。第二科是「别广地摄」。现在是「略辨地名」这一科。这一科里面又分成两科。第一科，就是「征」。「征」，就是问的意思。</p>
<p>　　「云何瑜伽师地」，这句话就是问，就是征。怎样叫做「瑜伽师地」呢？问这个话的意思，假设是学者，学习的人向弥勒菩萨问，他可能在别的经论上看见过这个「瑜伽师地」这个名字，现在提出来请问。或者说是作者自己，自己假设这么一个问，提出这个问题。</p>
<p>丙二、辨（分三科）　丁一、标</p>
<p><strong><em>谓十七地。</em></strong></p>
<p>　　这底下第二科就是「辨」。「辨」，就是说明的意思，也就是回答的意思。回答这底下分成三科。第一是「标」，就是「谓十七地」。怎么叫做「瑜伽师地」？就是十七个地，就是瑜伽师地。就是这样回答！这是「标」。</p>
<p>丁二、征</p>
<p><strong><em>何等十七？</em></strong></p>
<p>　　这是第二科，又是问，又是「征」。那一些叫做十七地呢？这又是问。</p>
<p>丁三、列（分二科）　戊一、嗢柁南</p>
<p><strong><em>嗢柁南曰：五识相应地，有寻伺等三；三摩地俱非，有心无心地；闻思修所立，如是具三乘；有依及无依，是名十七地。</em></strong></p>
<p>　　「嗢柁南曰」：这个「嗢柁南」，这底下就是列，把这十七地给列出来。这一科又分成二科。第一科，是「嗢柁南」。这个〈披寻记〉里面有解释，《遁伦记》也有解释。都是相同的，这解释的很好。我们在学习《摄大乘论》的时候，也有提到这个。他说是：「以少略言集合多法，施诸学者，令易受持，就叫做集施」，利用很少的几个字，能够表达出来很多的佛法，用这样的句子布施给学习的人，使令他容易受持、容易记得住，那么就是叫做「嗢柁南」。这分二科，第一科是「嗢柁南」。第二科，就是「长行」。这个「嗢柁南」这个颂里面，一共是二个颂，颂这个十七地的名字。</p>
<p>　　「五识相应地，有寻伺等三，三摩地俱非，有心无心地，闻思修所立，如是具三乘，有依及无依，是名十七地」：这就叫做「十七地」。这个第一个地，就是「五识相应地」。第二地，就是「意地」。「有寻伺等三」呢？这里面有三个地：「有寻有伺地、无寻唯伺地、无寻无伺地」这三个。</p>
<p>　　「三摩地俱非」，这个地方有点事情，后面的长行不叫「三摩地」，不叫这个。叫做「三摩呬多地、非三摩呬多地」。而这个颂上说，这个「嗢柁南」上说是「三摩地俱非」，这地方有点事情。这个「三摩地」的这句话，翻到中国话是等持，这个等持也是讲过的。就是等，是平等；持，是摄持，它有力量能把它把握得住，叫做持。这个平等怎么讲法，你们谁愿意讲一讲，这个等字。等，就指我们心说的，我们的心，不是散乱、就是惛沈；不是惛沈、就是散乱，所以叫做不平等。现在学习奢摩他的止，使令我们的心也不惛沉、也不散乱；也不散乱、也不惛沉，这叫做等，是这样意思。</p>
<p>　　说是我们怎么能够不惛沈、也不散乱呢？持，因为你常常修，就能创造出来一个力量，能把你这个心，摄持住，就能不散乱、也不惛沈，明静而住，所以叫做等持。这个等持这个名词，这个名，它所包含的义，很广。譬如说我们修这个欲界定，也可以名之为等持。欲界定，就是九心住，九心住最后一住，就叫做等持。所以这个是通于欲界定的。那么未到地定，到了初禅、二禅、三禅、四禅以上，都可以名之为「三摩地」。</p>
<p>　　可是这个得「三摩地」这句话，在《瑜伽师地论》里面，有详细的解释。所以我愿意学习《瑜伽师地论》，就是他每一样法门，他说的很详细、很微细，他不是说一个大概，说一个大概就完了，他不是。他说的很清楚的。他这个分三个部份，「得三摩地」是一个意思。第二意思是「三摩地圆满」。第三是「三摩地自在」，分三个部份说。「得三摩地」怎么讲呢？譬如说是我们由欲界定再进一步到了未至定，就是未到地，这个时候就名之为「得三摩地」了，就是得到了。</p>
<p>　　「三摩地圆满」怎么讲呢？就是由未至定，也叫近分定。由未至定再进一大步，得了初禅、二禅、三禅、四禅了，这叫「三摩地圆满」。这「三摩地圆满」和得三摩地不同，这三摩地的境界圆满了。</p>
<p>　　「三摩地自在」怎么讲呢？看这说的也好。得三摩地的这种人，三摩地圆满了的人，他还有烦恼。他还有什么烦恼呢？他有高慢心。有高慢的心，我得三摩地了，你们都不如我。这个愈有成就的人，他当然还没到最高的成度的时候，这个高慢心是更高，比我们一般人的高慢心还要高。我们一般人没有什么成就，还有高慢心；若是有了成就，那是高慢心还小，这是人都是这样子，有高慢心这是第一。</p>
<p>　　第二有爱心，有爱着心。就是他所成就的境界他爱着，爱着自己所成就的境界。就得了禅定了，初禅、二禅、三禅有三昧乐，他爱着这个乐，爱着。到第四禅，更不得了，那境界是更高了，那是爱着心更厉害了，有慢、有爱、还有见。见，就是我见。还有这爱、见、慢、也有疑，疑惑心还是有；有这些烦恼的人，虽然是三摩地园满了，他这个入定出定的事情还是不自在的，还是不自在的，还不能称之为「三摩地自在」，没有达到这个境界。所以还需要学习佛法，观察所得的这个禅是无常、苦、空、无我，还是这样观，要这样观察，破除去这爱着心，破除爱、慢、见、疑，破除这些烦恼，使令这些烦恼不活动了；但是种子还没有破，可是心是清净了。现行的心，清净、显白，离诸暇秽，没有这些烦恼的活动，这叫做「三摩地自在」。</p>
<p>　　现在说这个「三摩地」呢？「俱」，就是这些功德都成就了，都有了。这样子就和这个「三摩呬多」，「三摩呬多」（唸ㄒㄧ），我查了字典，这个字唸ㄒㄧ。其实我多少年来，常常查这个字，这一回应该是记清楚了，唸ㄒㄧ。这个「三摩呬多地」翻个等引，它是不通于欲界定、未到地定的。一定初禅以上，才可以名之为等引。这个等，就是平等，刚才说由以平等才引导你达到那个定的境界，所以叫做等引；或者是你用功，你不断的用功修行，不怕辛苦，就能够引导你到定的境界，到等的境界，所以叫做等引。等引这个名字，比三摩地高一点，三摩地是通于欲界定；这是不通于欲界定的。但是若要加一个「俱」字呢？「三摩地俱」，就和等引，和「三摩呬多」是平等了，就是它的含义就一样了，就是这样意思，这个地方有这么多差别。</p>
<p>　　「三摩地俱非」，就是非三摩地俱，那就是散乱的境界了。「有心无心地；闻思修所立，如是具三乘」：这个地方「闻所成地、思所成地、修所成地」。「所立」，所成立的，所建立的这些功德，殊胜的功德，是以「闻思修」为方便才能成就的，才能够成就，所以叫做「闻思修所立」。这个〈披寻记〉的解释呢？说所成立的胜解相，这个声闻乘、辟支佛乘、一佛乘，都是以「闻思修」为方便，为正方便，才能成立它所应得的义，所应得的功德，就这么解释，「如是具三乘」，这样子具足这三种佛法。</p>
<p>　　我们说这个「闻思修」，不知道说多少遍了，说了很多遍，我也是讲过《楞严经》的，《楞严经》：『从闻思修入三摩地』就那么说。但我现在不这么说，闻思修得无生法忍，这么说。因为这个修，就是三摩地，就是三摩地，它通于有漏的、通于无漏的。通常有人问，提出个问题来问我们：「说我相信佛法，我也欢喜佛法，但是我不知道学习佛法的次第，应该怎么学」？就是闻思修，就是修学佛法的次第。我们若常常读经，就很容易知道这个问题，就是从闻思修是一个学习佛法的次第，就是这样学。但是你若不多读经论就不知道，不知道怎么讲。我们可能说，会说一些其他的事情来。</p>
<p>　　「有依及无依，是名十七地」：这个颂，这个「嗢柁南」，就是把这个名字标出来，其中多少有些是需要解释，其他的不要解释。底下这个是第二科是长行，这个行是长一点，比那个颂长，颂是短的。</p>
<p>戊一、长行</p>
<p><strong><em>一者、五识身相应地。二者、意地。三者、有寻有伺地。四者、无寻唯伺地。五者、无寻无伺地。六者、三摩呬多地。七者、非三摩呬多地。八者、有心地。九者、无心地。十者、闻所成地。十一者、思所成地。十二者、修所成地。十三者、声闻地。十四者、独觉地。十五者、菩萨地。十六者、有余依地。十七者、无余地。如是略说十七，名为瑜伽师地。</em></strong></p>
<p>　　「一者、五识身相应地。二者、意地。三者、有寻有伺地。四者、无寻唯伺地。五者、无寻无伺地。六者、三摩呬多地」：这个「有寻有伺地」，这个「寻伺」，「有寻有伺地、无寻唯伺地、无寻唯伺地」，这个「寻伺」，「有寻伺、无寻伺」，我们在《摄大乘论》上也有讲过，我不知道你们有没有这种感觉，我感觉这个「有寻伺、无寻伺」这个地方，是要用心才能明白的，是要一点用心的，不然你很难讲明白它。</p>
<p>　　「六者、三摩呬多地。七者、非三摩呬多地。八者、有心地。九者、无心地。十者、闻所成地。十一者、思所成地。十二者、修所成地。十三者、声闻地。十四者、独觉地。十五者、菩萨地。十六者、有余依地。十七者、无余地。如是略说十七，名为瑜伽师地」：这个地，这「十七地」，我们也可以这样说，就是从凡夫一直到佛的境界，完全说到了。这个天台宗常好说十法界，这就是把十法界的事情统统都说了。这个说的非常的微细，非常的微细的。</p>
<p>　　那么这是「略辨地名」这一科到此为止。这现在第二科叫「别广地摄」。而《瑜伽师地论》〈遁伦记〉上的名字叫「随别解释」。你们若是带着那个〈披寻记〉，你们的眼睛好，能把那个字给看的很清楚，「别广地摄」。要有没有带，这个「别广地摄」应该在黑板上应该写出来。这个〈遁伦记〉的科的名字叫「随别解释」，就是随顺一地一地的去解释，这样子这个科名我们容易明白。但是这个〈披寻记〉叫做「别广地摄」。「别广地摄」就比那个「随别解释」难解一点；或者这样解释，「别」，就是一地一地的叫做「别」，广博的详细的去解释每一地里所含摄的大意，或者这么解释，叫做「别广地摄」。这一大科里面分成十四科，本来「十七地」应该是十七科。但是它分成十四科，其中有合在一起的。第一科就是「五识身相应地」，「本地分中五识身相应地第一」指第一科。</p>
<p>本地分中五识身相应地第一</p>
<p>乙二、别广地摄（分十四科）　丙一、五识身相应地（分二科）　丁一、征</p>
<p><strong><em>云何五识身相应地。</em></strong></p>
<p>　　这个「五识身相应地」，其实这里面下面有解释，什么叫做「五识身」、怎么叫做「相应」都有解释。第一，这个「十七地」里面它列在最前面，所以是第一。这一科里面分两科。第一科是「征」。「云何五识身相应地」，怎么叫做「五识身相应地」呢？这是问。</p>
<p>丁二、释（分二科）　戊一、略辨（分二科）　己一、名相应地</p>
<p><strong><em>谓五识身自性、彼所依、彼所缘、彼助伴、彼作业，如是总名五识身相应地。</em></strong></p>
<p>　　这底下就是解释，解释的时候又分两科。第一科是「略辨」，就是简略的说一说。这个《瑜伽师地论》，我们从这里面，从这个文相上看，这个文相分科了的时候，我们就容易明白它的相貌，都是先略说，而后广说。若是我们写文章也可以这样子，先略说而后广说，也是可以这样写。那么这个先「略辨」，「略辨」又分成两科。第一科叫做「名相应地」。第二科「名五识身」。「五识身相应地」，分成两段来说明，第一段先说明什么叫做「相应地」？第二段再说「五识身」。这是第一段叫做「相应地」。</p>
<p>　　「谓五识身自性、彼所依、彼所缘、彼助伴、彼作业，如是总名五识身相应地」：这个地方是解释「相应地」。「五识身自性」，就是这「五识身」它本身的体性，叫做「自性」。和别的法不同的，所以叫做「自性」它自己的体性，叫「五识身自性」。这「五识身」的「自性」是什么？下面有解释。</p>
<p>　　「彼所依」又是什么？「五识身」的「所依」是什么？「彼所缘」的是什么？「彼助伴」是什么？「彼作业」是什么？这一共是分五段，「自性、所依、所缘、助伴、作业」分五个。这五项，五种事情彼此之间不冲突，他们互相和合、互相随顺，互相和合没有冲突，在一起工作，大家做这一件事，和合起来做这一件事叫做「相应」，这「相应」就是这么讲。「如是总名五识身相应地」。我随顺你，你也随顺我，我也不向你捣乱，你也不向我捣乱，大家和合起来做，这叫做「相应」。那么有多少样事情互相的和合呢？就是这五样事，就是一个「自性、所依、所缘、助伴、作业」这五法。「如是总名五识身相应地」这是第一段。</p>
<p>己二、名五识身</p>
<p><strong><em>何等名为五识耶？所谓眼识、耳识、鼻识、舌识、身识。</em></strong></p>
<p>　　第二「何等名为五识身耶？所谓眼识、耳识、鼻识、舌识、身识」，就这五识。每一个识都是有它的体相的，所以叫做「身」，这个「身」是一个体的意思。但是别的地方也有说是有阻碍，有碍，有障碍的那个碍，有碍的意思，所以叫做「身」还有这么解释的。但这个「识」是心法，它为什么有什么碍呢？因为它所依，它所依的根是有碍的是色法，所以它叫做「身」有这么解释的。但这样的解释只限于此法这样解释。</p>
<p>　　也有说六识身，六识身那么第六意识，它所依的根不是色法了，所以这个解释是一种特别的意思。这是「略辨」，「略辨五识身相应地」简单地说。下边就是「广显」，第二科是「广显」，就是详细的显示出来「五识身相应地」的相貌，这一段里面分两科。第一科是「别辨五相」，第一科是「别辨五相」。「别辨五相」是辨什么呢？辨这个眼识、耳识、鼻识、舌识、身识五识的相貌。「别辨五相」里面分五科。第一科就是「眼识摄」，属于眼识这一方面这是第一科。这一科又分成五段，第一科是说「自性」。</p>
<p>戊二、广显（分二科）　己一、别辨五相（分五科）　庚一、眼识摄（分五科）　辛一、自性</p>
<p><strong><em>云何眼识自性？谓依眼了别色。</em></strong></p>
<p>　　「云何眼识自性」，先问怎么叫做「眼识」的体性呢？「眼识」的体性是什么样子呢？这个「自性」这个「自」，实在也是别的意思，总别的别，别的意思，单独它是这样子，所以叫做「自」，所以也就是别。若是通就不是了，就是大家共同的都是这样子，那叫共相。现在是别。</p>
<p>　　「谓依眼了别色」，那么这就是「眼识」的「自性」。这个眼识的相貌，眼识的体性是很难说的，难说也要说！那怎么说法呢？就说这个「依眼」，这个眼识它是以眼为所依，这个眼就是眼根，以眼根为所依，所以它叫做「眼识」。「了别色」，以「色」为它了别的境界，所以叫做「识」。那么就是这个明了性叫做「眼识」的「自性」这样解释，这个解释也是很好，这是「眼识」的「自性」。</p>
<p>辛二、所依（分二科）　壬一、别举三依（分三科）　癸一、俱有依</p>
<p><strong><em>彼所依者：俱有依，谓眼。</em></strong></p>
<p>　　「彼所依者」，现在就是把这个眼识的自性，就这样解释完了。当然这里面还有其他的意思，你慢慢的不要着急，一样一样说。第二段是「所依」，眼识的「所依」。</p>
<p>　　「彼所依者：俱有依，谓眼」：前面说「谓依眼」，这里又要解释这个眼。「彼所依者」， 就是这个眼识它不能够独自的存在，它不能够独自的存在发生作用的。它要有一个凭借，它要有一个住处，或者是怎么讲也可以，它要有个住处。它的住处是谁呢？这个地方说是「俱有依」。「俱有依」这是怎么讲法呢？就和它同时的存在活动，同时的活动，同时的存在，叫做「俱有依」。它活动的时候一定它所依靠的这个东西和它同时存在的，不然的话它不能活动。这个眼识有的时候生起作用，有的时候它不起作用；但是眼根是常在的，眼根是一直相续不断地存在的。</p>
<p>　　这个「俱有依」是指什么说的呢？「谓眼」，就是我们这个眼根，这是它的「俱所依」。下面还有在解释这个眼根的事情。</p>
<p>癸二、等无间依</p>
<p><strong><em>等无间依，谓意。</em></strong></p>
<p>　　「等无间依」，不只这一个依，这个一共有三个依。第一个是「俱有依」，「俱有依」是叫做增上缘。在四缘里面是增上缘，一个有强大力量的，就是眼根，眼根对它是帮助的力量很大；如果眼根若坏了，眼识就没有办法生起了，所以这个眼根是太重要了。还有个「等无间依」这是第二个依，「等无间依」怎么讲法呢？这个我们在学习《摄大乘论》的时候也提到，这个「等无间依」，就是眼识的前一剎那灭了，后一剎那的眼识才能生起。前一剎那、后一剎那中间没有间隔，这个没有间隔这句话怎么讲呢？譬如说是你前一剎那眼识灭了，但是后一剎那眼识没生起。</p>
<p>　　假设你入定了，你入定了，你入定七天，入定七天眼识是不动的，不生了的，中间有七天，七昼夜的距离，但是没有第三者在中间阻碍，没有，还是无间的，还是没有间隔的；时间上可能是有间隔，但是没有第三者在中间的阻碍。那过了七天以后，一剎那一出定了，那么眼识才生起。那么虽然有七天的间隔，但是没有第三者在里边，所以还是无间。那么前一剎那的眼识灭了，后一剎那的眼识才能生起，如果他不灭，后一剎那眼识不能生起，所以后一剎那的眼识的生起，依前一剎那的眼识的灭做依止，这个依也是很重要，没有这个依也不行。这唯有心法才有这一回事，这叫「等无间依」。这样说这耳识是耳识的「等无间依」，眼、耳、鼻、舌、身各有各的「等无间依」，也是不混乱，这是「等无间依」。</p>
<p>　　这个「等无间依」名字叫做意。这个意，不是第六意识的意，不是。这个意是什么意思呢？当依止讲，意是依止的意思。前一剎那的识灭了，做后一剎那识的生起的依止，这就叫做意，意是依止的意思。意有二个解释：一个是依止义，一个是思量义。现在是指依止义，叫做意。</p>
<p>　　这个「俱有依」，其实不只是眼根，「俱有依」是同时的；「等无间依」是前后的。「等无间依」不可以是同时的，说它是无间的，它又不是同时的，所以叫做「等无间依」。这个眼根对眼识来说是同时的，但是这个「俱有依」不只是眼根，譬如说这个第六识、第七识、第八识也是它的「俱有依」。第六识就是分别依，如果第六识不在的话，它特别注意一件事的时候，眼识也没有办法生起，眼识也是不能生起，就是『心不在焉，视而不见，听而不闻，食而不知其味』所以这个孔夫子也知道这件事，他也知道这件事。这个第六识是分别依，第七识是染净依，第八识是根本依，但这里边没有提，不提了。</p>
<p>癸三、种子依</p>
<p><strong><em>种子依：谓即此一切种子，执受所依，异熟所摄阿赖耶识。</em></strong></p>
<p>　　这个眼识的生起，要有「俱有依」，要有「等无间依」，还要有「种子依」。这个等无间缘，「俱有依」是增上缘，增上缘、等无间缘，「种子依」就是因缘。这个「种子」也是眼识生起的一个重要的一个条件，就是眼识的生起要有眼识的「种子」现行，眼识才能活动。那么眼识的生起要有「种子」来现行，「种子」是剎那剎那的，所以眼识也是剎那剎那的，那么眼、耳、鼻、舌、身、意、识都是这样的，都是剎那剎那的。那么从这里头，我们读这个永嘉大师的〈证道歌〉，好像这么说的『分别名相不知休，入海算沙徒自困』。这个不学教的人，就会拿这句话来喝斥这个学教的人；或者是一般没有学教的人，喝斥人，实在是不及格，他不应该喝斥我们，我们是学教的人。他们没有学教，不愿到佛学院去，他来喝斥我们他不应该。</p>
<p>　　但是这禅师他要喝斥我们，就是说『分别名相不知休，入海算沙徒自困』这个喝斥对不对呢？也有一点道理。我今天因为第一段文，很琐碎，有的时候那一个字要查字典，要把它唸准了。还有这个名相呢？有的时候要查查大辞典，查了好多的大辞典。然后今天早上本来是要静坐的，静坐的时间都被占去了，只坐了一刻锺，坐了20分钟，我心里就想起来这句话，这〈证道歌〉这句话，这个『分别名相不知休，入海算沙徒自困』。但是我又想出一个自圆其说的道理来，就是这句话「种子依，谓即此一切种子，执受所依，异熟所摄阿赖耶识」就这句话。若是不学习经论的话，尤其是你若不学习唯识的话，你很容易一静坐的时候，我欢喜坐禅，禅是最重要的，学教、分别名相那是自找苦恼。但是你很容易走差路，很容易走差路，什么呢？坐那里因为没有得定的人，当然是心里妄想很多；得了定以后，明静而住、念念相续、无散乱转，这个明静而住，一坐坐七天，或者坐一百天，坐这八万大劫，那很容易你就意会到这一念心就是常住真心、性静明体，没有生灭的，这就是佛性，我就是佛！很容易就会想到这里。</p>
<p>　　但你若是想学习过唯识的话，「种子依」这个识是由「种子」现行生出来的，而「种子」是一剎那一剎那的，识也是剎那剎那的，都是无常的。那里是常住真心？这就是一个问题，这是个问题，你又不知道；你若不学习，很难知道这件事情。他说的不对，那么你敢说是《瑜伽师地论》是弥勒菩萨说的，弥勒菩萨是未来佛，其实现在就是佛，你说他说错了吗？你敢说这句话吗？你『不惧无底深坑苦，视之如粪土』。不过这件事，所以我们学习佛法，说是玄奘大师那时学习了多少佛法，学习了《涅槃经》，我们看《玄奘法师传》，他第一，最初开始学习的佛法就是《涅槃经》，学习了《涅槃经》，他学习了《摄大乘论》、《俱舍论》是后来。他那个时候才有这个疑问，说是究竟是南道对？是北道对？当场是现场有疑问。我们现在学习也是一样，因为你不可能一下子把所有的经论，一下子就毕业了，就是你学过有时候还是弄不清楚。</p>
<p>　　所以这个地方，有的时候说是常住真心，有的时候说剎那生灭，你怎么决定？你心里面怎么样，有什么感觉？这是个问题。所以「种子依：谓即此一切种子，执受所依，异熟所摄阿赖耶识」。这个眼识的生起要依赖眼识的种子，种子一剎那现，就是一剎那的眼识；这一剎就那就灭了，所以眼识也灭了，要一剎那、一剎那的这样生起。那么从这里说『分别名相不知休』，「分别名相」里面也有好处，也是有好处的。另外我想到一件事，这个船子和尚，这个船子禅师，他是摆船的，他对他的同参说：「我的贪心不大，你去对那个学教的，学习佛法的、讲经的法师，你注意，找那个伶俐的一个叫他来，我收他做徒弟」。 这个《禅师语录》有这件事。</p>
<p>　　那么这个禅师他就叫做夹山禅师，就是他。这个人的确是很利，他这个后来那位叫什么名号，叫道果禅师，他就去听听，各处去听经，听一个法师讲经「法身是无相的」他这么一讲，他感觉那位法师有点智慧，当然还是不同意他的说法，那么他就介绍这个法师去亲近那个船子和尚，他的问答，那当然也是有智慧的人，这位法师就变成禅师了，就是开悟了。那么从这件事上看，看出什么消息，很多的大禅师是学教的，然后经过那个开悟的禅师指点指点就进了一大步，就是这么一回事，这样子比较合乎道理。说是完全也没有读过书，就是认识几个字，也没有学过教，说是给你一拳就开悟了，我很难相信这件事，我不相信这件事。</p>
<p>　　你学过教，学过佛说的圣言量，他懂得多少佛法，然后这个祖师开悟了的大智慧，再去警策他一下，这是有可能的，这是合道理的，合乎道理。这样说『分别名相不知休，入海算沙徒自困』这句话不对，还是应该学习佛法的，还是应该学习佛法的。我以前也说过，这个临济禅师，我看他的语禄，这个人非常的利，但是看他自己说的法，我就不满意了，我就不感觉满意。但是看他的传上，我到日本去，那是一个寺庙上，不是大宗祠寺，一个庙上，给我一本《临济禅师语录》，它那上面说，临济禅师是学过教的，他在一个大法师那里听过经的，这句话很宝贵。在我们汉文佛教的这个《禅师语禄》，你看《临济禅师语录》好像很难找到这句话，很难找到说临济禅师是学过教的，很难找到这句话，也可能有我没看见；但是不容易看见，就算有也容易看见，为什么会这样子？</p>
<p>　　所以我认为这个执笔的人要忠实才对，要诚实，他是怎么的就怎么写才是对的，有些地方隐藏起来不说，不说，那意思就是不重视文字的，你学教这件事不需要，不需要这件事，就表示这个意思，我认为这件事是不对，是不合道理的。你能说是你这样讲释迦牟佛出世是错了，不应该说话，这完全是搞错了。所以还是要学习，但是最遗憾的事情，就是现在没有佛。我们说谁是菩萨再来，这个话，说一说也是好听啦。所以说没有佛，也没有菩萨，也没有阿罗汉，没有过来人，我们不能拜他做师父，就得靠什么呢？就得靠经论了，要依法，这是问题就在这里。这要依法，就得要多学，你才能通达无碍，多学就是个问题，多学就是个问题。</p>
<p>　　「谓即此一切种子，执受所依」：「即此一切种子」，这个「种子依」，以种子为所依，这个种子是什么呢？「谓即此一切种子，执受所依」。「一切种子」，我们内心里面有各式各样的分别，都是由种子变现的，都是因为种子变现的，若是没有种子了，你不会有那样的心理作用。譬如说阿罗汉，他把爱烦恼、见烦恼除掉了、灭掉了。这阿罗汉他心里清净，他就不会再有这个欲的，欲的这种分别心，他没有。贪、瞋、痴无余断，贪无余断、瞋无余断、愚痴无余断，没有剩余的，完全的消灭了。这个消灭不是指现行说的，是指种子说的。所以没有那个种子了，他就没有这个贪、瞋、痴的烦恼不现行，不能活动了。我们有这样的烦恼现行，就是因为有种子，内心里面有这样的种子，所以种子是无量无边的，所以「一切种子」。</p>
<p>　　「执受所依」，这个「执受所依」，我们学《摄大乘论》上面解释过，就是阿赖耶识「执受所依」，这个「所依」，就是身体，这个眼、耳、鼻、舌、身是为阿赖耶识所执受，所以他是一个活活的生命体，他若不执受就变成死尸了。他执受他，所以他能够有觉受，这个「受」，就是有感觉，就是因为阿赖耶识执受的关系。这个「执」呢？就是阿赖耶识与这个身体同在，有执持他的力量。</p>
<p>　　「执受所依」，这个「执受所依」是谁呢？就是「异熟所摄」的「阿赖耶识」。「异熟」，我们《摄大乘论》应该没有白学，就是变异而熟。这个阿赖耶识的现起，是由这个善、恶的业力，在我们凡夫来说就有善业、有恶业，你就是一个蚂蚁它也有「阿赖耶识」，一个老虎也有「阿赖耶识」，乃至天他也有「阿赖耶识」。但是这个「阿赖耶识」的现起，有善业现起的、有恶业现起的；善业、恶业是因，阿赖耶识是果。在因是善、恶；在果上是无记，所以叫做「异」，执持不同，不同的。因中有善、恶，到结果的时候只是无记，所以叫做「异」这是一个意思。</p>
<p>　　第二个是异时而熟，这个善、恶是在前一生，现在这一生，不是在和前一生的以后，所以是异时而熟，不同的时间才成熟的，叫异时而熟，也是变异而熟，逐渐的变异才成熟的。这样成熟了的「所摄」，属于这样一类的意义是谁呢？就是「阿赖耶识」，这个「阿赖耶识」就是「一切种子」识，这「一切种子」在那里呢？就在「阿赖耶识」里面，这「阿赖耶识」里面有无量无边的种子，其中这个眼识的种子，生起现行的时候，就是眼识，是这样子。这里边是说这个眼识，它是要以种子为依，它才能现行的，才能活动，这也是一个条件。</p>
<p><strong><em>问：</em></strong>如何区别自然外道与佛法中，所谓的法尔如是之间的不同。</p>
<p><strong><em>答：</em></strong>我看到这里的时候，我也有这种想法，外道有所谓的自然外道，佛法也说法尔，法尔也是自然的意思，那有什么不同呢？佛法说法尔如是，但是先要学习观待道理。先要学习观待道理、作用道理、证成道理。观待道理就是诸法因缘生的意思。先这样观察，先在观察的时候，诸法因缘生，所以是无常、苦、空、无我这样观察。我不知道你们会怎样，你要常常的，这个闻、思、修，这个思惟，常常思惟，就会出来一个问题，就是什么问题呢？因缘所生是无常的，因缘所生是常的不可以吗？就会出来，你初开始分别思惟，依据圣言量的思惟，他就是这样的，但是久了，就会出来一个反动的力量，会有这种事情。为什么他是白的，很多什么事情都是一样！为什么水是这样？火是那样子？这个最后说这个法尔，就是这样子。这样说呢？和外道就不同了，和外道是不一样了。</p>
<p>　　外道他也不明白，或者说是不承认，不承认是因缘有，说自然有，这就是没有办法能改造自己，能改善自己；反正自然是这样子，你无可奈何。说这个人他是很穷苦的，是自然这样子，那你没办法改变。那么说是上帝造的，那么你也没有办法改变，因为这权力在上帝那里。若是说因缘有，因缘有，那么这个因缘是这样子，那么我现在我不做这个因缘，那么就会改变了。不是这个因缘，就没有这个因缘所生法，你有不同的因缘，有不同的因缘所生法，我可以从中选择，我就能改变自己。所以佛法说到法尔，还是和外道不一样。</p>
<p><strong><em>问：</em></strong>佛法说空、无常、无我，又说法尔如是，这该如何解释？</p>
<p><strong><em>答：</em></strong>你还是照正常的思惟因缘有的，是空、无常、无我这么说，等到内心里边有反动的分别的时候，你再用法尔道理来对治，我认为是因缘生的。这样子去应用，这样子。</p>
<p><strong><em>问：</em></strong>真常论者只能修空观，修的是什么空观？</p>
<p><strong><em>答：</em></strong>当然也一样，也可以修唯心（识）观的空观，修自性空的空观。他的空观就可以把一切有为法都可以空掉，一切烦恼空掉。但是那个真常的理性是不可以空的；可以修这个空观。假设这样思想的人，去学习了《瑜伽师地论》，《瑜伽师地论》里边破这个我，还一大段的，破我执还一大段。或者《瑜伽师地论》也是，破我的地方也是，也说的很扎实的，说了多少段，不只一段的。那么他会怎么想呢？为什么，这个我和真常的理性有什么分别？就会要想这个问题。如果读这个《楞伽经》的话，也会想到这个问题，问题是在什么地方呢？</p>
<p>　　欢喜坐禅的人，他懒得看经，不大愿意看经。看经费眼力，坐那里多舒服呢！这是很正常的事情。你若读了《楞伽经》，然后再去读这个《起信论》的话；或者先读《起信论》，再读《楞伽经》的话，思想上就会有问题，会有冲突的。你读了《楞伽经》，把这个《楞伽经》藏经里面有三种翻译，都可以读。然后读《楞伽经》，读《起信论》，读读《涅槃经》，再读《大智度论》，再读《瑜伽师地论》，我认为这个人，他的思想自己在作战。他一定是这样子。</p>
<p>　　所以这个修空观，修的是什么空观？什么空观都可以修，但是这个我，这个真常不可以空，它就是会有这个问题。会有这个问题，如果他也容易就会知道这个是我。很容易执着这个我见。这样说，这个我，最后的这个我不能断，最后的我若不能断，这个人是什么样的人呢？我以前说过，天台智者大师的《释禅波罗密》，你们各位有没有读过？他解释非非想定的时候，这个非想非非想究竟是什么东西呢？智者大师说，就是那个修行的人，是『真神不灭』。『真神不灭』的这个「神」是什么？「神」在《智度论》上常就指我说的，就是神我，神即是我也，『真神不灭』，是真我不灭是这么意思。这个我是不灭，其余的一切法都空了，我是不空的，是这样意思。那么这个非非想定，连初果都不如，连初果都不如，还是个凡夫。</p>
<p>　　若读这个《中观论》的这个〈观法品〉，〈观法品〉那上面说修止观，先要修我空观。那龙树菩萨的想法是这样，先要修我空观。修了《阿含经》也是这意思，你修了法空观而不修我空观，不可以，一定要修我空观。你修我空观不修法空观也是可以；你修法空观，不修我空观，不可以。这《阿含经》有这意思。那么《中观论》〈观法品〉就是要修我空观，要这样修。这样子从《阿含经》上看，从《瑜伽师地论》上看，从《大智度论》上看，你我空，就是圣人。要用这样的圣言量来比量一下，这真常论者，他若不修我空观，那他是怎什么样？</p>
<p>　　所以印顺老法师、我又提到印顺老法师，在这个《中观论颂讲记》说，『识是不能了生死的』！阿弥陀佛！其实这句话，这个嘉祥大师也是这样讲，你看他的《中观论疏》也是这样说。不过是这个印顺老法师说这句的话的时候，就好像这个刺激性大一点。『唯识是不能了生死的』！那么用这句话说真常论者只能修空观，修的是什么空观？</p>
<p>　　若以真常唯心的观念与方法，能修空观不必修无我，可以达到何种程度？你想一想。当然这个真常论者本身来说，那他就是佛，我就是佛，自然是这样子，自然就想到这里。那你说他是和初果也不如，这是不可以的，不能这么说。所以这样子说法，我们学习佛法的，怎么样来决定这件事。</p>
<p><strong><em>问：</em></strong>既然是一切法门更相随顺，那么要依真常的方式修行，而停留在真常、真心常住的阶段，此时再学般若破除它，是否可能更上层楼？</p>
<p><strong><em>答：</em></strong>这在般若的立场来说，当然是更上一层楼，可以更上。这种人如果他的禅定工夫够，他若修般若空观，一下子得无生法忍，他会比一般人快。所以佛在世的时候有些外道，佛最后临入涅槃的时候，度的那个须跋陀罗，他一下子就得阿罗汉，那么这是特别的，可以更上一层楼；但是真常论者，他就不这么想。这还是思想的问题，每一个人都是站在自己的立场来说话的。你说你的，我说我的，不必说是，你不能勉强的把它统一起来，这事是办不到。</p>
<p><strong><em>问：</em></strong>《十二门论疏》卷上，叡师序云：『整归驾于道场毕趣心于佛地』。</p>
<p><strong><em>答：</em></strong>当然我是读过《十二门论疏》的序，但是我若向各位说，我又去查了一遍。我又去重新读一遍，这样子。你们应该比我勤快一点，也去查一查，这个是在藏经上有，所以一查就知道了嘛。「毕趣心于佛地」，那个僧叡的僧是佛法僧的僧。这位僧叡法师在我们中国佛教史上是很有名的大法师，鸠摩罗什法师翻译的一个很好的助手。是僧肇法师他们都是同学，僧叡法师比僧肇法师年岁大，他寿命长一点。僧肇法师三十几岁就过世了。「请院长开示是僧叡法师作的序」。这是当然你们可是出家的时间没有我这么多，你还是读的少啊。</p>
<p><strong><em>问：</em></strong>辩机法师。</p>
<p><strong><em>答：</em></strong>辩机法师、这辩不是这个辩，辩字是辩论的辩，这个辩。机是机感的机。你也可以查一，我说这个《大唐西域记》是他写的。玄奘说，他把它写成文字，一查就知道了。</p>
<p><strong><em>问：</em></strong>静坐的时候，突然有一股莫名的瞋心生起。并不是粗猛的，只是微微的对某事、某件事务的不满，当瞋心在抖动时，很清楚的看到它。无形无相。</p>
<p><strong><em>答：</em></strong>说无形无相这句话，不是不太合适。当然地、水、火、风，有青、黄、赤、白，长、短、方、圆的形相，这个心法没有这色法的形相，但是他有瞋就是个相，瞋就是个相，愤怒。那么贪和瞋是不同的，就是有不同的相，还是有相，不应该说是无形无相。但是看出这个，我不知道这是那位同学，这位同学的文章还是不错的，把这个字用的很好，这句子很柔软。</p>
<p><strong><em>问：</em></strong>也找不到他的源头。</p>
<p><strong><em>答：</em></strong>也找不到它的源头，这句话也说错了，你对某事的不满，这就是个源头吗！这就是源头，但是它就是在那儿抖动。再多的观照，瞋心就消失无影无踪了，这个也是事实如此。</p>
<p><strong><em>问：</em></strong>请问这无由来的瞋心，就是业力吗？以前造的业在静坐浮现出来，在静坐中浮现出来。</p>
<p><strong><em>答：</em></strong>这个业，业者动也。不过我们通常在佛法里面用业的时候，就是比较粗重的叫做业。譬如前生造了什么业，今生现出来。譬如说这个人，他也没有佛法学习很多，也不明白什么是佛法，佛法僧出家，但是就欢喜出家，这就是所谓业。他前生在佛法里熏习过，作过出家人，今生他遇见了出家的这些这个大环境，他就欢喜，这属于业，这是业的事情，可以这样解释。</p>
<p>　　至于说是心这个瞋心动了、瞋心动了，对某一件事情的不满，把你静坐的时候，有一个不如理作意，把那个瞋心引出来了，就是这么回事，这是很微细的事情。我们这不如理作意，自已不大感觉，等到这个心所出现了，现形了才知道，你才感觉，现在动了慎心了，是这么回事。</p>
<p><strong><em>问：</em></strong>现在静坐中观照它，它自然消失了，这是否表示以前所造这个的业已消除了？观罪性本空是否如此的观法？</p>
<p><strong><em>答：</em></strong>不是的，这个瞋心动了，譬如刚才静坐之前和某一个人，和某一件事心里不满意，静坐的时候就出现了；或者我是静坐之前一个小时、二个小时，和谁说什么话、说什么话，静坐的时候，这话又现出来，自已又说一遍，这时时有的事情。不一定说是和前生的业力有关系，不必这么解释。</p>
<p>　　但是你就这样观照它，伳这一个瞋心就消失了，这可见很好。你没有随着瞋心去虚妄分别，只是观照，它就慢慢消失了，这也是个方法，但这不是观罪性空，观罪性空是观察这个瞋心是因缘有的，因缘有的，他自性空，这样子叫做观罪性本空。观罪性本空这样观要深刻一点，比你这样观照，更深刻一点，可以能得圣道。若只是这样像你这样观照的话，逐渐消失能得定，得圣道还有一段距离，还有点距离。</p>
<h3 id="第9讲"><a href="#第9讲" class="headerlink" title="第9讲"></a><strong><em>第9讲</em></strong></h3><p>辛二、所依（分二科）　壬一、别举三依（分三科）　癸一、俱有依</p>
<p><strong><em>彼所依者：俱有依；谓眼。</em></strong></p>
<p>癸二、等无间依</p>
<p><strong><em>等无间依；谓意。</em></strong></p>
<p>癸三、种子依</p>
<p><strong><em>种子依；谓即此一切种子，执受所依，异熟摄阿赖耶识。</em></strong></p>
<p>　　「云何眼识自性？谓依眼了别色。彼所依者：俱有依；谓眼。等无间依；谓意。种子依；谓即此一切种子，执受所依，异熟所摄阿赖耶识」：这是十七地里面第一地「五识身相应地」。「五识身相应地」里面分两大段：第一段是「略辨」，这一段讲过了。现在是第二段「广显」。「广显」里边又分成两科。第一科是「别辨相」，就是说明眼识、耳识、鼻识、舌识、身识说明这五个识的相貌，那么又分成五科。一科说「眼识」，「眼识」里面又分五科。第一科说「自性」，这一科也说过去了。第二科说「所依」，就是眼识的生起，它不能自己独自的生起，它要依靠另外的力量，就叫做「所依」，这里面分成两科。第一科「别举三依」，就是眼识的生起要依靠这三种力量，第一个就是「俱有依」，第二个是「等无间依」，第三个是「种子依」，这三依就解释完了，上一次讲完了。</p>
<p>壬二、略释二依（分二科） 癸一、标列</p>
<p><strong><em>如是略说二种所依。谓色、非色。</em></strong></p>
<p>癸二、随释（分二科）　子一、辨类</p>
<p><strong><em>眼是色、余非色。</em></strong></p>
<p>　　这以下「略释二依」。前面举出了这个三依，这以下再解释这个三依，解释三依的一开始，把三依合成二依，三个依合成二个依。这一科里面又分成两段：第一段是「略列」，把这两个依把它标出来，「如是略说二种所依」。这以下就是简略说明两种所依，这个所依有二种，是什么呢？「谓色、非色」，一个是色，一个不是色。这个「色」，就是物质，但是这个「色」是说有组织的，有组织的色。一个没有色，这是标出来。以下「眼是色、余非色」，这是解释、「随释」这两种色，解释这两种依。</p>
<p>　　第一个是「色」，这个「色」是什么呢？「眼是色」，这个「俱有依」里面指什么说的呢？就是眼识所依止的眼根。眼根，我们彼此见面的时候，我看见你的眼，你也会看见我的眼，但是这个不是，这个是叫做扶根尘，它是保护眼根的物质，它不真实是能发眼识的根，下面有解释。现在说「眼是色」，就是能发眼识的那个根，是属于色的，是色法组成的。「余非色」，等无间依和种子依，这两种依不是色，它不是物质组成的，它不是色，这是这样的解释，「余非色」。</p>
<p>子二、出体（分三科）　丑一、眼</p>
<p><strong><em>眼：谓四大种所造，眼识所依净色；无见有对。</em></strong></p>
<p>　　这以下是「出体」，说出来什么叫做「眼」，什么叫做「眼」，怎么它是色，说明这个道理，也说明叫「余非色」，那个依和种子依这两种也加以解释的。先解释这个「眼是色」。「眼：谓四大种所造眼识」，这个眼识所依止的眼根，它是怎么成就的呢？「谓四大种所造」，这个「四大种」怎么讲呢？这个就是地、水、火、风叫做「四大种」。这个「大」，是广大的意思，就是它是非常广大的，它的作用非常广大。譬如说我们所看见的大山、大地、大海，都是「四大种」所创造的，所以可以称之为是「大」。这些大山、大海、大地，由「四大种」才能够增长、才能够成就，所以称之为「种」。「种」，是因的意思，因果的因的意思。它又是「种」、它又是「大」，故名为「大种」是这样意思。</p>
<p>　　现在也不说是大山、也不说大海、大地，是说我们的眼根，这个眼根是「四大种所造」，一切的色法都是「四大种所造」。我们的眼根也是地、水、火、风所创造的，不过这个地、水、火、风，它精微了一点，不是一般粗劣的地、水、火、风。「眼识所依净色」这样的「四大种所造」的眼根，是我们眼识的依止处，是眼的依止。不是一般的地、水、火、风，眼识不能够依止，那要适合它才可以，这样的地、水、火、风的色法，是「净色」，是特别的清净，特别微妙的一种物质，精微清净的一种物质组织成的。</p>
<p>　　「无见有对」，这样的我们这个眼根的地、水、火、风，我们见不到，我们不能见到它的，我们现在这个眼根，我看见你的眼，这个眼不是那个眼、不是那个眼根的眼，我们也不能见，不是我们眼根、眼识的境界，我们见不到。譬如我们平常说有鬼，有鬼，但是我们多数人看不见，不是眼识的境界，不是我们眼根的境界；要天眼的人可以看见鬼，有的人的眼根也是特别一点，也能看见鬼。那么但是有是有，鬼是有，但是我们不可以见。现在我们的眼根也是，是有眼根，但是我们不可以见。「有对」，「有对」这个地方有点意思的，这个「对」，这个字是个碍的意思，这个「有对」这个「对」这个字，当碍字讲，就是障碍的碍。在这里有三种碍，就是障碍的有对、境界有对、所缘有对，有这三种不同。障凝有对怎么讲呢？障凝有对，我们很容易明白的。譬如说是这里有一道墙，我们的身体，这道墙也是地、水、火、风，我们的身体也是地、水、火、风，我们想从这里过去，不可以，它有障碍。这个石头，这个大石头和大石头也是障碍的，那么这叫做障碍有对。这是一般性的都有这种情形，同在一时、同在一处都是有障碍的，这个障碍有对。</p>
<p>　　第二个是境界有对，这境界有对怎么讲呢？譬如我们的眼根，我们眼根，这个对声音来说，不管是人发出来的声音，或者是风、或者是火、或者是水，各种情况发出来的声音，我们的眼睛对它来说不行，我们这个眼睛对声音来说，是不可以发生作用的；要用耳才可以，耳才能听见声音，这个声音是耳的境界，是耳的境界。这个眼就不可以，眼就是不可以在那上面发生作用，眼只能在色，在这个青、黄、赤、白，长、短、方、圆，这些色的相貌上才是眼的境界，在这个境界上，眼在那上面活动，能发生作用，那么叫做境界有对。它们是合适的，这个地方这样讲，境界有对是这样讲。这样讲这个对是什么意思？要有障碍就叫做有对。这个有对，就是眼识在那个地方能够拘碍，拘束的拘。这个眼睛在那里，这是青色、这是黄色、这是白色，或这是光明、这是黑暗，眼识在那上面能拘碍你。如果这个耳在形色上，在这些一切色法上，就没有这种作用，就不能拘碍这个耳。我们的耳遇见一切形色的时候，就过去了，就不能在这上面，不能拘碍。</p>
<p>　　这经论上这样解释，这拘碍这样讲，这叫做境界有对。本来在我们一般的常识上，分别心上来解释，应该说我们的眼睛在声音上有障碍，我们不懂，我们的眼不能听声音，这声音有障碍；耳对于色，不能发生作用，有障碍；眼对色是无障碍，耳对声音无障碍，但现在不这样讲，眼对于色是有障碍的。这个障碍，就是拘碍，拘束的拘，拘碍，这样解释。它的理由就是说，因为若是眼睛离开了色，在声、香、味、触上，就不能发生作用，所以叫做拘碍，这样讲，这样解释。如果我们用容易明白的话来说，眼对色来说，色是眼的境界，声音对耳来说，声音是耳的境界，这叫做境界有对，这么解释。</p>
<p>　　第三个是所缘有对，这个所缘，就是对这个心法来说的，就是眼识在色的境界上，它能够缘虑。我们的眼对一切的形色，也能够发生作用，但是不能缘，因为这个眼根是物质，不是心法，它不能缘虑，它不可以缘虑的。能缘虑的是心法，眼识也是心，眼识对色法它有缘的作用，所以叫做所缘有对。若是声音，眼识就不可以，眼识不能去缘声音，那就不是所缘，不是它的所缘有对，这样解释。合起来说叫做无见有对。这里说有对，前面说「四大种所造，眼识所依净色」，那就是五个净色根，是无见有对。那么这里面，就包括了障碍有对、境界有对。因为这个「四大种所造」的净色，它也是色法，它也是物质，所以它也是有障碍，所以包括了障碍有对，而又是境界有对，但不是心法，所以不是所缘有对。所以是「无见有对」。</p>
<p>丑二、意</p>
<p><strong><em>意：谓眼识无间过去识。</em></strong></p>
<p>　　前面解释这个眼根的体相。这以下解释这个「意」的，就是等无间的相貌。这里说「意」，我们上一次说过，是以依止为意。这「意」，是依止的意思，叫做「意」，是依止的意思叫做意。「谓眼识无间过去识」，就是我们这依眼了别色的这个眼，这个眼识。「无间过去识」，就是前一剎那、后一剎那，中间是没有第三者来间隔它的，那么它过去了，就是灭了，灭了以后，后一剎那的眼识才能生起。如果前一剎那的眼识不灭，后一剎那的眼识不能生起。所以前一剎那的眼识的灭，是后一剎那生起的条件，所以叫做「等无间依」这个意思。乃至到意识，眼识、耳识、鼻识、舌识、身识、意识乃至到阿赖耶识，也是这样子，也是剎那剎那生灭生灭的这样子。所以从这上看，我们的识，是有生有灭，而不是常住。和《楞严经》说的不同了，这不是常住真心的，不能那么说了。这是有生灭变化的，不是常住的。说「谓眼识无间过去识」，这叫做「意」这样讲，当然这个「意」，也是心法，不是色法。</p>
<p>丑三、一切种子识</p>
<p><strong><em>一切种子识：谓无始时来乐着戏论熏习为因，所生一切种子异熟识。</em></strong></p>
<p>　　这个眼根和意，这二个依解释完了。现在是第三段解释这「一切种子识」的依。「一切种子识」，它也是眼识的依止，因为我们眼识的生起，它要靠种子才能够生起，靠种子才能生起。若没有种子，这个眼识不能生起，所以它也是眼识生起的重要的一个条件。这个「一切种子识」，就是所有的眼识、耳识、鼻识乃至意识，都是要有种子才能生起的，所以是很多很多的，剎那剎那的要依靠种子，是无量无边的。这种「种子识」从那里来的？怎么会有这么多的种子呢？「谓无始时来乐者戏论熏习」，这是说从无始以来，就是你找不到开始的那一天，你向前追，总是前面还有，前面还有。这是佛法里面讲的道理，和这个神教说的不一样，神教总是说：『万物是上帝造的，是神造的』。现在佛教里说：『一切是自己造的』。自己什么时候造的呢？「无始」，没有开头那一天。所以是「谓无始时」以来，来，一直来到现在。在这么长的时间内，「乐着戏论」，我们心里面就是欢喜戏论，爱乐味着。这个爱乐，就是指我们心说的，我们就是欢喜这样。这个着，就是黏上上去了，也就是系住了，把你困住了。如果我们自己心细致一点，静下来，细致点去观察的话，我们也会觉悟到我们爱什么，就被什么绑住了；你若不爱这件事，那件事对你不发生作用，你就是解脱了。</p>
<p>　　你爱什么就被什么绑住了，你不可以和它分开的，你分开心就不舒服。那么这个着，就是绑住了的意思。为什么绑住了呢？因为你爱乐它的关系。那么我们现在「无始时来」，我们爱乐什么事情呢？「戏论」，爱乐欢喜戏论，这个「戏论」是什么呢？这个就是我们现在学习这个《瑜伽师地论》后文都有解释，这些问、征都有解释。但是我们后文都有解释，但是我们现在就是念一遍，那也不感觉到有什么意味，也不好，还是要解释解释。后面文解释这个「戏论」解释什么呢？这个在我们日常生活，一切的事情，我们所做的事情。我们心里面所思惟分别的事情，我们语言上所分别，语言上所表达的这一切的事情，这个身、口、意这一切的事情，我们做的事情，『不能引义，能引无义』。『能引无义，不能引义』这就叫做「戏论」。</p>
<p>　　这个『义』是什么呢？这个『无义』是什么呢？这个「义」，就是我们的理智所希求的事情，所希求的事情。若用我们的语文来说，就是幸福的事情，这个幸福，和我们心里面所想的幸福又不一样，这个幸福的事情，没有罪过的事情，有功德的事情，这叫做「义」。这个「无义」，就是和这件事相反的，能令你使令你有罪，能令你苦恼的事情，它能引出这种事情。就是我们身、口、意所做的事情啊，『不能引义，能引无义』这些都是叫做「戏论」。那么究竟是什么东西呢？究竟是指什么说呢？就是大概的分类，就是一个我执、一个法执，就是这两类。就是执着有一个我，在这个色、受、想、行、识里边，在这生灭变化的色、受、想、行、识上面，执着有一个没有生灭变化的我，执着有我。用我为基础，去说话，去做事，这都『能引无义，不能引义』所以这就是一个「戏论」。</p>
<p>　　第二个「戏论」，执着一切都是真实的，眼、耳、鼻、舌、身、意也好，色、声、香、味、触、法也好，眼识、耳识乃至一切识，这些十八界，一切的境界，凡我们的一念分别心所面对的一切境界，我们都认为是真实的，都认为是真实的，认为是很美的，我们就是就起了贪、瞋、痴的烦恼在这上面活动。</p>
<p>　　我在家的时候，读书很少；出了家以后，也欢喜读历史。我感觉历史上的书就是三个字：『贪、瞋、痴』。国王，那些不管是好的国王，不好的国王，我看都还是这样子。不过是有点理智的国王，稍好一点。然而还是贪、瞋、痴。用贪心作这件事，用瞋心做这件事，总而言之，愚痴做这件事。多少有点好心肠，老百姓生活好一点；或者是虐待老百姓，不管老百姓死活。我要这样子，就这样子，都是贪、瞋、痴的活动。我们一般人也是贪、瞋、痴，比那有权势的人轻一点，轻一点。只是管自己；或者对别人，也是有点关系，但是那不能和国王比。那么这样子，在这句话来说，这就叫做「戏论」。</p>
<p>　　「乐着戏论」，这「乐着戏论」的结果呢？就叫做「熏习」。这个「熏习」我们学习《摄大乘论》的时候，曾经讲过的。什么叫做「熏习」。怎么叫做「熏习」呢？『谓与彼法俱生俱灭，此中有能生彼因性』那就叫「熏习」。这个「熏习」，这个「彼和此」，此中有能这个「此」，和『谓于彼法』的「彼」，就是此法与彼法。这个「此」是指什么说的呢？就是指阿赖耶识说。这个「彼」呢？就是转识，指转识说的。这个「此」阿赖耶识与「彼」转识这一切法在一起，不是分离的，是在一起的。『俱生俱灭』，同时的剎那生，同时的剎那灭。他这意思说，若是不生灭的话，就不能熏习了。若没有生灭，就没有变化，没有变化是不能熏习的。所以唯识宗的道理，就不承认《起信论》这真如受熏的。就是唯识经论上的道理是这样，它是有生灭变化的，所以阿赖耶识能受转识的影响，受他的熏习。转识，就是前七识，前七识都有所缘境，在所缘境上贪、瞋、痴的活动，就熏习了阿赖耶识，熏习了阿赖耶识。</p>
<p>　　就像箱子里面，这个木头箱子里面放了香，这香有什么变化？这个木头箱子有什么变化？那么那个香放出的香，木头箱子就受它熏习了，所以也有了香气。这个『此中有能生彼因性』，受了前七转识的熏习，阿赖耶识里面就有了一种种子，一种功能。种子就是功能，有了功能。这个功能又能生出来前七转识。『此中有能生彼因性』，此阿赖耶识里边有一种功能，所以这功能是生彼前七转识的因；前七转识就是所生的果了。这叫做「熏习」。『近朱者赤，近墨者黑』其实也是熏习。你同好人作朋友，你就受他的影响，你也变成好人了，这就叫做「熏习」。现在这里说「无始时来乐着戏论熏习为因」，就是说我们无始劫以来，就欢喜这个爱烦恼、见烦恼；或者我执、法执的熏习，这些戏论的熏习。熏习没有白熏习，就是在我们的阿赖耶识里面有了因，有了一种功能。由这功能它是能生的，能生的法生出来「所生」的「一切种子异熟识」，就生出来无量无边的种子，在阿赖耶识里边生出来种子，就是这样意思。</p>
<p>　　所以这「一切种子」是从那里来的？就是我们日常生活中来的，就是自己创造的，自己创造什么就是什么。欢喜作医生，他就是过去生有熏习，今生还欢喜作医生；我前生出过家，我拜佛、念经、学习佛法、欢喜打坐，他欢喜就是前生也这样熏习过，前生熏习过有那个种子，现在遇见因缘了，这种子就发生作用了，在心理上就是欢喜，是这么意思。人与人看见了欢喜，人与人看见了不高兴，就是前生有熏习，前生有过熏习。所以「谓无始来乐着戏论熏习为因，所生一切种子异熟识」。这个「异熟」我们上次讲过了，这个种子，就是储藏在「异熟识」里边。那么现在我们眼识，它要生起，要依靠以前熏习在阿赖耶识里面的眼识种子。要靠那个种子，那种子才能生起，不然不行的。</p>
<p>　　所以有的人，这眼识、眼根特别的威猛。看上去有威，有的人看上去好像刚睡醒，很没有精神，这是以前熏习的不同。说是在黑暗的地方，人在那走路不安全，你能发心在那里放一个光明，你若做了这件事，将来你的眼睛就特别。人家在那里放一个光明，你去破坏了，将来你眼睛也会有问题，你就有问题。这是熏习，如是因，如是果，都是自己创造的，我们佛法的理论是这样子，你自己创造的，是这样子。这个我看耶稣教的《圣经》上说，有人问耶稣：『说那人为什么眼睛盲了』？他说这是要显示上帝的大恩。我们的印顺老法师说，耶稣先生没能回答这个问题。佛法的道理是自己创造的，不是上帝，是自己创造的。这是一切种子识，这一切种子识是眼识生起的依，叫种子依。这是前面这一大段解释眼识的所依。这以下第三段是「所缘」，这眼识生起了，它要缘所缘境，缘这个所缘境。</p>
<p>辛三、所缘（分二科）　壬一、出体</p>
<p><strong><em>彼所缘者：谓色，有见有对。</em></strong></p>
<p>　　这个「缘」，是缘虑，去观察、思惟，叫做「缘」。这里又分成两段，第一段是「出体」，第二段是「辨类」。现在说「出体」。这个「所缘」，什么是眼识的所缘呢？「谓色」，就是这一些形色，眼色，这些色法。「有见有对」，这个「有见」，它是眼根，眼识的境界，所以就是「有见」。这些「显色、形色、表色」，这些色法是眼识的境界，所以这个见就发出了作用，发出了见的作用。若是声音，你发不出来眼识的作用。因为什么呢？它不是眼识的境界，发不出作用来。现在这个色，和眼识是相和的，所以是「有见」，「有见」的作用。也就是「有对」，这就是所缘「有对」，它是眼识所缘虑的。这是说出来这个所缘的色法的体相，但是这还只是简单的说。</p>
<p>壬二、辨类（分二科）　癸一、标多种</p>
<p><strong><em>此复多种。</em></strong></p>
<p>　　下面第二段是「辨类」。这个所缘也是有多少种类，又分成两科。第一科标释多种。「此复多种」，这个「有见有对」的色，还是有很多种类的，不就是一种。</p>
<p>癸二、略摄三（分二科）　子一、显形等三（分二科）　丑一、标列</p>
<p><strong><em>略说有三：谓显色、形色、表色。</em></strong></p>
<p>　　「略说有三」，这底下说这个色法是无量无边的，但是简略的就是把它归成类，一类一类的，这样说就是有三种色法。「谓显色、形色、表色」，分这么三种。这底下就解释这三种色。</p>
<p>丑二、体释（分二科）　寅一、别辨相（分三科）　卯一、第一义（分三科）　辰一、显色</p>
<p><strong><em>显色者：谓青、黄、赤、白、光、影、明、闇、云、烟、尘、雾、及空一显色。</em></strong></p>
<p>　　第一个是「显色者：谓青、黄、赤、白」。「显色」是什么呢？就是「青、黄、赤、白」，是青色的、是黄色的，赤是红色的，或是白色的。「光、影、明、闇」，这又是也是色，这个「光」和「明」，「光」也是色，「明」也是色，「影」是色，「暗」也是色。这「光」和「明」有什么不同呢？这个太阳发出来的叫做「光」。或者月亮、星辰，或者是灯，或者是其他的什么宝珠，发出来的叫做「明」。这样分别，这个色就是不一样。</p>
<p>　　这个「影」和「闇」有什么不同呢？就是太阳的光照在树上面，或者是照在一道墙上面，就现出了一个影，现出来个影，其实「影」也有多少「闇」。可是其他的色法在「影」里面还能显现出来，那就叫做「影」。若是光被遮住了以后，现出来的这个「影」，其他的色法在「影」里面看不见了，那就叫做「闇」。这个「影」和「闇」也就是程度的不同，淡一点的就叫做「影」。重了一点，就是叫做「闇」了。</p>
<p>　　「云、烟、尘、雾」，天空的「云」、还有「烟」、还有「尘」、还有「雾」。「云」，若在地面上，那就是「雾」；飘到高空，那就叫做「云」了。或者是下过雨了，太阳出来一照的时候，这个水蒸气多了，那就是「雾」。「及空一显色」，这又是一种色。这个「空一显色」是什么呢？就是我们太阳出来了，我们向高空上看，在高空上看，有那样的颜色，或者说是碧绿、碧色、或者说是青色，那就叫做「空一显色」。其他的《杂集论》上，还有其他的论上面，还有一个叫做迥色。这个迥色，也就是「空一显色」。但是有点分别，高空的叫做「空一显色」；不是高空的，我们这个眼睛平平的看去，远远的看去，那就叫做迥色。迥者，远也。远远看去，就叫做迥色。这「空一显色」。这一共列出来十三个色，「青、黄、赤、白、光、影、明、闇、云、烟、尘、雾，及空一显色」。这一共是列出了十三个色。</p>
<p>辰二、形色</p>
<p><strong><em>形色者：谓长、短、方、圆、麤、细、正、不正、高、下色。</em></strong></p>
<p>　　「形色者」，这个「形色」是什么呢？「谓长、短、方、圆」，就是「青、黄、赤、白」上看得出来，有「长」的、有「短」的、有「方」的、有「圆」的、有「麤、细」的。这个就是大，「麤」者，大也。「细」，就是小一点的。这个「正、不正」：「正」，就是整齐的。不整齐就叫「不正」。「高、下色」，看着高山，高起来，「高」；或者低下来，这个空谷低下来。</p>
<p>辰三、表色</p>
<p><strong><em>表色者：谓取、舍、屈、伸、行、住、坐、卧，如是等色。</em></strong></p>
<p>　　「表色者」，这个「形色、显色」，「显」，是显著，很明显的、很显著的显现出来。现在说这个「表色」怎么讲呢？「谓取、舍、屈、伸、行、住、坐、卧，如是等色」那么叫做「表色」。这个《大乘成业论》，《藏经》上有这部书，它那上面解释「表色」有四句话，就是那个《大乘成业论》有这么四句话：『由外发身语，表内心所思，譬彼潜渊鱼，鼓波而自表』。由于『外发身语』，你发动了你的身语在外面，发表在外边，你身体的行动和语言，那表示了你内心的思想，你内心这样思想表现在行动上、表现在语言上，那么就是由外发的身语，就知道你内心所思惟的了。『譬彼潜渊鱼，鼓波而自表』，说个譬喻潜藏深渊里面的鱼，它在水里面动，那个水在外面就有波浪，就表示那个地方有鱼，那么鱼在里面动，表示你心动。那么水有了波浪，就表现心发出来的身语的行动，所以叫做「表色」，「表色」是这样的意思。</p>
<p>　　现在这里说的「谓取、舍、屈、伸」，说我们手去拿东西叫「取」；或者放弃了；或者「屈、伸」，或者是身体的「屈、伸」，或者是背的「屈、伸」；或者你身体在「行」；或者是「住」；或者是「坐」；或者是「卧」，这样一切的表现于外的一种色，就是你内心的境界。因为外面的这个身语，他自己是不能动，一定是心先动，才表现在身语上，所以这叫做「表色」。这「表」这个字就是这样意思。表示你内心的活动，内心的活动表现在外面，这叫做「表色」。这是这一个的解释。</p>
<p>　　下面解释这三种，也是这个「显色、形色、表色」分三段。第一段的解释，这是解释了「显色」，也解释了「形色」，也解释了「表色」，这是按照它的体相来解释的。</p>
<p>卯二、第二义（分三科）　辰一、显色</p>
<p><strong><em>又显色者：谓若色显了，眼识所行。</em></strong></p>
<p>　　这以下是第二段解释，是约什么解释呢？这是约它得名的所以来解释。前面是约它的体相来解释；这是约得名所以来解释，这是第二段。为什么叫「显色」呢？这个安立这个名字什么原因呢？「谓若色显了，眼识所行」，所以叫做「显色」。就是这颜色非常的显著，非常的明显，譬如这个高大的山，一看上去，能令你很明了的显现出来；或者是夜间放出光明，这光明也是很显著的，所以这叫做「显色」。「谓若色显了」，很显著，很明了的，是「眼识所行」的境界，眼识所活动的地方，所以叫做「显色」。那个「青、黄、赤、白、光、影、明、闇、云、烟、尘、雾，及空一显色」都是，都是非常显著的，所以叫做「显色」。</p>
<p><strong><em>问：</em></strong>即色离色的识是怎么运作的，也就是前五识、六识、七识、八识是怎么样的程序？</p>
<p><strong><em>答：</em></strong>识的运作次序，这下面倒是有解释。如果由前五识，其实下面一段就在解释了，这个识的运作程序，先是由作意心所开始。这个在唯识的经论上说呢？这个第七识它是内缘，它是缘阿赖耶识；只有六识是外向攀缘，所以六识当然也要依止阿赖耶识和末那识，它发觉有境界的时候，就是作意心所。作意心所的时候，它先开始来警觉自己，我有事情了，警觉应该生起的心去接触外面的境界，先有这个作意心所，它来警觉一下，就象是看门口有个人，现在有人来找你了，他通知你一下，就是等于是这样子。</p>
<p>　　这样子这个作意，所以也提到有如理作意、或者不如理作意，那么它引来的心理作用，就受到了决定了。那么这个一警觉了以后，这个眼识就先发动，先去。如果是属于色，就是眼识；属于声音，那么就是耳识，这个就是—这个警觉，警觉是耳识要去，或者是眼识、鼻识、舌识、身识，这样子。这个前五识和外面境界一接触，一剎那，这个第六意识就开始了，就开始活动了，那么第六识开始活动的时候就会去，或者是熟悉的境界，或者是生疏的境界，这还不一样。这个若是熟悉的境界，一下子就决定了，是怎么回事情，就处理了。若是生疏，第六识就要经过寻求的阶段，寻求一下。寻求，就是观察、思惟一下，是怎么一回事情，寻求，先要考虑一下，所以第一个活动叫做率尔。</p>
<p>　　这个率尔，就是一下子就和境界接触了，这就是那个作意心所，他引导应该生起的心理，接触那个生疏的境界的时候，叫做率尔。不是有预谋的、不是有预谋的，叫做率尔。这个若是发觉这个事情是熟悉的，那么就不经过寻求就决定了。说我一看这是我父亲，心情立刻就决定了。这一看这人不认识，他姓什么？他怎么回事情？那么就是要经过寻求了。寻求以后，就决定了，决定这件事是怎么回事。决定以后，就开始行动了；或者是合乎如理作意，就是净、清净的。不如理作意，就是染污的了。这是有善恶的分别了。我们一般的人，不是没有宗教信仰的，不是佛教徒，或者没有宗教信仰的人，就只是去分别是利害的关系，对我有利，或对我有害，然后再决定怎么处理。若是有宗教信仰的人，先要分别是道德的、不道德的、是善的、是恶的，我要做善，不可以作恶。所以有染净，是染污的，是清净的，是决定的时候有这样的分别。有宗教信仰、没有宗教信仰，在这个地方有分别，染净。</p>
<p>　　染净以后，一剎那间这样做了以后，就等流，就相续下去，就叫做等流。这个等，就是前后一样的叫做等。流，是相续下去，等流。在这里边由第六意识来决定，前五识同他配合。这寻求也好，决定也好，染净也好，等流也好，就是六个识互相合作的，有各式各样的行动。这个寻求这个地方，也可能要经过很长的时间。也有可能的，经过很长的时间；也可能时间不长，这是不一定的，是这样子。这个识的运作程序，就是这样子。</p>
<p>　　无始以来的乐着戏论，就是这样子，乐着戏论，熏习了阿赖耶识的种子，由种子再发出来果报，得了果报，还是这样子率尔、寻求、决定、染净，等流，还是这样子，就是无穷无尽的延续下去。除非你遇见佛、法、僧了，遇见三宝了，改变自己的思想了，那就起变化了。但你还是你没成功以前，你还是率尔、寻求、决定、染净、等流，你还不能超过这范围的。</p>
<p><strong><em>问：</em></strong>那个见道的圣人，他那个程序怎么样？</p>
<p><strong><em>答：</em></strong>见道的圣人，他是有明，他在率尔、寻求、决定的时候，有明相应触。就是有般若的智慧，有般若的智慧，那和我们一般的道德、不道德善、恶的境界又不同，就是超越了一般的道德、不道德善、恶的境界。他有这样的想法，他有了大悲心、慈悲心，智慧的作用，那又和凡夫的境界不同了。这个我们凡夫有宗教信仰，有佛法的信仰，但是还是凡夫的时候，一方面要考虑利害关系，同时也考虑善、恶的关系，考虑道德、不道德的关系；然后斟酌处理，尽量减少过失，积集功德，尽量的做。但是其中还是不免有贪、瞋、痴的作用的，可能轻微一点，已经就是不错了。要是圣人的明相应触，是没有贪、瞋、痴的活动，没有这件事。</p>
<p>　　因为圣人，当然他也不做无义苦行。除了无义苦行之外，他是不怕死的，圣人是这样子，实在他不在乎，他不介意这件事，所以他能够保持住，对于他人一点不伤害，他不伤害别人。宁可自己死掉了，也不伤害任何人，也就是初果圣人都能做到这一点，宁可我死了，也不做恶事，这是严重的。初果圣人，轻微的会喝斥人的事情，也可能会有，但是严重杀、盗、淫的事不做，严重的事情不做。</p>
<h3 id="第10讲"><a href="#第10讲" class="headerlink" title="第10讲"></a><strong><em>第10讲</em></strong></h3><p>卯二、第二义（分三科）　辰一、显色</p>
<p><strong><em>又显色者：谓若色显了，眼识所行。</em></strong></p>
<p>　　现在的文是说眼识所缘虑的境界。这眼识所缘这个地方是「别辨相」，就是一条一条的，一样一样的说明它的相貌，这里分三科。第一科是「第一义」。第二科是「第二义」。现在这个第二义里面是说什么呢？就是说这个所缘的色法，得名的所以。昨天说过，在黑板上写过，得名的原因。为什么叫做「显」？为什么叫做「形」？为什么叫做「表」？「显、形、表」这三个名称的原因，安立这样名称的理由，这样意思。现在先说这个「显色」的理由。</p>
<p>　　这意思是说这色法显了，就是它很明显的，很显著的能令你明了，很显著的，不是很隐晦。这个他的颜色很明显的显现出来，使令你注目，能引起你的注意，这样多的颜色，很多，但是光明的颜色他很显著，那么在这一方面立名字为之「显」是这样意思。</p>
<p>　　「眼识所行」，它是眼识所活动的境界，别的不行，耳识、鼻识、舌识、身识都不行，都不能在这上面活动，只有眼识可以在这个色上活动，这就是「眼识所行」。这就是「显色」立名的一个所以，立名的原因。</p>
<p>辰二、形色</p>
<p><strong><em>形色者：谓若色积集长短等分别相。</em></strong></p>
<p>　　这以下解释「形色」立名的原因。「谓若色积集」，这意思是说若是这个「色」法的「积集」，就是组识成就了，它也是众缘所生，所以叫做「积集」。「长短等分别相」，这个色法因缘成就的时候，成就的是「长」的形相、成就的是「短」的形相，而这「长短」形相，长短方圆等形相。这些形相，当然形相本身并没有说话，说它：「我是长、我是短」没有说这话。是由人的分别，说这是长、这是短，这是不决定的。对短就说长，对长就说短；对这短就说它是长，对另外更长，就说它是短了。所以这是一个「分别相」。这是形相，这底下是说「表色」。</p>
<p>辰三、表色</p>
<p><strong><em>表色者：谓即此积集色，生灭相续，由变异因，于先生处，不复重生。转于异处，或无间、或有间、或近、或远差别生。或即于此处异生，是名表色。</em></strong></p>
<p>　　「表色」，由内心的活动表现在外边的相貌，叫做「表色」。「谓即此积集色」，也就是这因缘「积集」的「色」法。「生灭相续」，它是那剎那生灭而不中断的，是相续地生灭的。「由变异因，于先生处，不复重生」：这个「生灭相续」这句话是什么意思呢？如果不相续，就没有这件事了，就没有「由变异因，于先生处，不复重生，转于异处」这话，没这件事了，因为是剎那剎那相续的关系。「由变异因」，就这个色法的变化，有种种不同的变化的原因，原因主要的就是我们的心，我们的心是一切色法变化的原因。一切色法的变化，虽然也有其它的原因，但是主要是我们的心，主要是心，心在变化，这色就在变化。</p>
<p>　　这个心，譬如说我们这个手要动，手本身是不会动的，因为心有所求，去指挥这个手去动，所以手才会动。所以心动是变异的因，变异的一个原因。「于先生处，不复重生」，就是这个「表色」，说这个「表色」的相貌。原来这个心的意思是在这里，在这里这个手要这样动，或者头这样动，或者脚这样动；可是心又变了，心又改变主意了，又改变主意了，心一改变计划了，就原来的那个心所指挥的出来的那个形相就停下来了，「不复重生」，不继续重复的显现出来了。「转于异处」，就转到另外一个地方去了。我现在在这里，心里面又有另一个想法，要到别的地方去了。所以外面的这个色法里面，也就随着心的变异就变异了。</p>
<p>　　「或无间、或有间」：「或无间」，就是没有间断，譬如说我做这件事，就相续的把它做完了。虽然表现于外的这个色有变化，忽然间手动、忽然间头动、忽然间脚动，忽然间这样、忽然间那样，但是没有间断的把这件事做完了，那么这就叫做「无间」。「或有间」呢？，就是中间停下来了，不做这件事了。但是这件事，还是由心的命令，过了一段时间才继续的把这件事做完，那么叫做「有间」。「或近、或远差别生」，这件事或者在距离近地方，或者远的地方，有种种不同的这个「表色」现出来。「或即于此处变异生」，前面说是「转于异处」，或者是没有转于异处，就在原来的地方有变化，「是名表色」，这叫做「表色」。</p>
<p>卯三、第三义（分三科）　辰一、显色</p>
<p><strong><em>又显色者：谓光明等差别。</em></strong></p>
<p>　　这是「第三义」，「第三义」，显示色法的差别，每一个、每一种的、每一类的色法都是差别的。「又显色者：谓光明等差别」，有光影、明闇，各式各样的差别，这是「显色」的差别。</p>
<p>辰二、形色</p>
<p><strong><em>形色者：谓长短等积集差别。</em></strong></p>
<p>　　长、短、方、圆这也是有差别。</p>
<p>辰三、表色</p>
<p><strong><em>表色者：谓业用为依，转动差别。</em></strong></p>
<p>　　这个「表色」的差别指什么说的呢？就是「业用」，就是你内心是业，内心动了就是叫做「业」。「业」者，动也。就是心动了，心发生作用了。以此为依，以心动为依，你的身相有转动的差别；或者是行、住、坐、卧，各式各样的差别；或者是取、舍、屈、伸等等差别。</p>
<p>寅二、释异名</p>
<p><strong><em>如是一切显、形、表色，是眼所行、眼境界、眼识所行、眼识境界、眼识所缘；意识所行、意识境界、意识所缘，名之差别。</em></strong></p>
<p>　　「如是一切显、形、表色，是眼所行、眼境界」，这底下是解释异名，解释它的不同名称，不同的名字。「如是」，像前面的这一大段文是说到「显色」，一切的「显色」、一切的「形色」、一切的「表色」，这么多的色法是「眼所行、眼境界」，这两句话指眼根说的。就是眼根能在这里旅行，在这里游历，这个眼根在这里游历；耳根不可以在这里游历，不可以。它是眼的境界，眼能够领取这个境界，它能，这是眼根说。</p>
<p>　　「眼识所行、眼识境界」，这是说这个识，依根了境。这个识，要依根为所依，以境为所缘。现在这么多的色法，「显色、形色、表色」，是「眼识所行」的「境界」，所旅行的境界，是眼所旅行的范围，是眼识所领取的境界。「眼识所缘」，是眼识在这里才能有缘虑的作用。「意识所行、意识境界、意识所缘，名之差别」，这以前面说「眼根」和「眼识」，这又提到这个「意识」。就是这个「显色、形色、表色」，不但是眼根、眼识，同时也是「意识」所行的地方，意识相应的境界。这个「所行」和「境界」，也有一点不同。这个「行」，不去分别谁行、谁不行，不去分别这件事，就是直接地就说这意识在这里活动，就这样。说到「境界」呢？就是不行，它在这个境界可以，在那个境界就不可以，就是有这个分别了。这在前面的眼根、眼识，很明显的有这件事，它在色上可以相应，但在声上就不可以。</p>
<p>　　现在这里说到「意识」，「意识」它的「所行」、它的「境界」，要比前五识宽，比前五识广。前五识各别、各别的境界；但是「意识」就是完全都可以，完全都是可以。「意识所行、意识境界」，当然这是指人的，按照人的境界来说。如果天上的人的境界，那人就不如他们了。色界天的人，我们人间的人更是不可以，那就更不同了。这们肉眼的境界，对天眼的境界，就不是肉眼的境界了，这就是种种的不同了。现在是约人的境界说，说「意识境界，意识所缘，名之差别」。所缘的有「显色」的名的差别，有「形色」的名，有「表色」的名的不同，是这样意思。</p>
<p>子二、好恶等三</p>
<p><strong><em>又即此色，复有三种：谓若好显色、若恶显色、若俱异显色；似色显现。</em></strong></p>
<p>　　前面是解释「形色、显色、表色」这三个、三类。现在说「好、恶等三类」。「又即此」显、形、表这种色法，「复有三种」不同。「谓若」要「好」的「显色、若恶」的「显色」，不好的，令人不高兴的，恶的显色，丑陋的显色。「若俱异显色」，也不同意好，也不是好、也不是恶。这一切的色法，「似色显现」。这些色法都是约第六意识来说的，分别它是好、不好，这第六意识才会分别，眼、眼识是不会分别这件事的，眼识不能这样分别，所以这是指第六识说的。</p>
<p>　　「似色显现」，这「似色显现」呢？这一切的色法都是阿赖耶识的变现。我们的眼识和意识去缘虑的这个色法，和阿赖耶识所显现的色法是相似的。相似而不说就是，只是相似而已。意思是说阿赖耶识所变现的一切法，都是如化如幻的，就是依他起，都是如幻如化不真实的。但是我们的意识要去缘虑，就变成遍计执了，都认为都是真实的了，这个真实是个错误，但是和阿赖耶识所变现的有点相似，那么「似色显现」这样的意思。这个也可以说，阿赖耶识所变的如幻如化的一切的色法是不真实的，也可以说是毕竟空的，因为这一切色法，一切色法本身是没有的。说我这现在我就看见这屋子里有一条龙在这里飞，这条龙是没有的，是我眼睛有问题。所以从这条龙的本身上看，是没有这件事情，是毕竟空的。但我们就看见有一条龙，就是像真是有一条龙似的，所以叫做「似色显现」这样解释，也可以这样解释，「似色显现」。</p>
<p>　　说这样解释，这就有唯识观的意味了，就是由凡夫的境界向圣人的境界去了，向圣人的境界去了，不同于凡夫了。凡夫就是这样，这是好的、这是美的、这是丑陋的，这也不美、也不丑陋，认为都是真实的。若是圣人呢？都是假的，都是空的，没有这回事情，所以是「似色显现」。</p>
<p>辛四、助伴 （分三科）　王一、出体</p>
<p><strong><em>彼助伴者：谓彼俱有相应诸心所有法。谓作意、触、受、想、思，及余眼识俱有相应诸心所有法。</em></strong></p>
<p>　　这是第四科「助伴」。第一科是眼识的「自性」。第二科是眼识的「所依」：有「俱有依、等无间依、种子依」，眼识的自性，眼识的所依。第三科，是眼识的「所缘」。前面说的「显、形、表、好、恶、俱异」，这都是要「所缘」说的。我们的心，我们的识「所缘」的色法。现在第四段，说是眼识的「助伴」。「彼助伴者」，彼眼识的活动的时候，也不是孤独地活动的，还有帮助它活动的事情。「伴」，也就是它的伴侣，也就是帮助它活动的。谁是它的助伴呢？「谓彼俱有相应诸心所有法」，就是说彼眼识，与彼眼识同时地，同时存在的叫「俱有」。不是前后的、不是前后的，是同时地。和它「相应」，就是和它合作的，不是向它捣乱的，随顺它而同它合作，做随顺它，帮助它做事情，所以这叫做「相应」。</p>
<p>　　「诸心所有法」，这些助伴，它的名字叫做「心所」，说全了就是心所有法。这个心才有这种事情，这个色法没有这种事，色法是没有的，只有心才有这种事情，叫做「心所有法」。它是这种助伴的心所有法，恒依心起，与心相应，系属于心，所以叫「心所有法」。『恒依心起』，它一切时，一切处，这个心所有法，它一定依心而起，以心为依才能生起来，如果这个心，这个眼识如果是没有的话，它不能独自起来，它起不来的，要有眼识，然后眼识的心所有法才能生起的。第二个意思，『与心相应』，它生起来以后，它随顺眼识的活动，随顺它，与它是和合的，所以叫做「相应」。第三个意思，是『系属于心』的，归它统领的，它不是独自活动的，所以叫做「心所有法」。</p>
<p>　　「谓彼俱有相应诸心所有法」究竟指什么说的呢？「所谓作意」，这个「作意」的心所有法。这个「作意」，昨天我们讲过。这个「作意」，就是警觉的意思，它在那儿睡觉，现在有事情要做，去警觉它，你不要睡了，现在有事要做，叫它去做事情，那么警觉的意思。但是心很多很多的，很多很多的事情，现在警觉应起的心法。指现在有声音出现，那么警觉耳识；若有色法的出现，它就警觉眼识了，就各式各样的差别，所以警觉应起的心法，到境界那里去注意，这样的作用叫做「作意」。这样说这个「作意」是在眼识活动的前一剎那，它应该先是发生作用，这个是「作意」心所。</p>
<p>　　这个「触」，作意警觉它了，它不能继续睡觉了，它就起来了，去注意，就和那个境界接触了，那么叫做「触」。「受」，就是有感觉，有各式各样的感觉。「想」，就是去取得所缘境的相貌。这境界是怎么回事情，先查一查，先调查一下，不能够凭主观上的妄想，我认为你是这样子，不是的。要看一看，那境界是什么样子，这叫想认识，要认识外面的境界。「思」，就是有了动作了，认识了以后，本身有了行动，有意志的行动叫做「思」。</p>
<p>　　这个「作意、触、受、想、思」，这五叫做遍行心所。遍，就是普遍的，所有的眼识、耳识、鼻识、舌识、身识、意识，乃至第八阿赖耶识都有这种心所法，心所有法，都有这个「作意、触、受、想、思」都是有的，所以叫做遍行。不局限于某一部分，是遍行的。</p>
<p>　　「及余眼识俱有相应诸心所有法」，这不止这五个，眼识还有其他的「俱有」，也是同时有，而是「相应」的「诸心所有法」，他也有贪、瞋、痴，这个眼识也有贪、瞋、痴，各式各样的事情也是很多的。这在《成唯识论》里面说的很详细的。那么这么多的心所有法，为眼识的助伴，在所缘境上活动，这是这个意思。</p>
<p>壬二、辨相</p>
<p><strong><em>又彼诸法，同一所缘、非一行相，俱有相应，一一而转。</em></strong></p>
<p>　　前面是说这个彼「助伴」，是说这个心所有法的体相，心所有法的体，就是「作意、触、受、想、思」等，说出来这个心所有法的名体。这底下「又彼诸法，同一所缘」，就说出来这么多的助伴心所有法，和眼识在一起活动的相貌，是这样意思。「又彼诸法，同一所缘」，彼助伴的这么多的心所有法，和这个眼识在一起「同一所缘」，他们所缘的境界是无差别的，大家都是缘虑阿赖耶识所变的显、形、表，都是缘这个为色法，「同一所缘」。</p>
<p>　　「非一行相」，可是缘虑的时候，这个心所各式各样的心所的相貌还是不一样的。作意是一个相貌，触又是个相貌，受、想、思又是个相貌，说这贪、瞋、痴又一个相貌，所缘的境界是一样的；但这个心所在活动的时候，每一个心所的能缘的行相是不同的，能缘的相貌是不一样了。这个「行」，就指能缘虑的心行。在所缘境上，那个能缘虑的那个作用叫做「行」。因为能虑的心各式各样的，那就变成所缘虑的相也不同了，这个行相也可以说是「行」就是「相」，也可以说「行」不是「相」。「相」，是所缘虑的；「行」，是能缘虑的；那么本来是阿赖耶识所变的，是同一所缘，可是经过缘了以后就不同了，是「同一所缘，非一行相」。</p>
<p>　　「俱有相应，一一而转」，虽然不是同一行相，可是大家是和合的，互相随顺的，「一一而转」，一个一个的在这活动，是这样子的，这个合作的相貌是这样子。</p>
<p>壬三、释因</p>
<p><strong><em>又彼一切各各从自种子而生。</em></strong></p>
<p>　　这是第三个，第三科。第一科是「出体」。第二科是「辨相」。现在第三个是「释因」。「又彼一切各各从自种子而生」，彼这个心所有法，眼识是心王，这些助伴是心所，这王和所，这么多的心法，每一个每一个，各各的从他自己的过去熏习的种子生起的。你一活动，就熏习成种子了，那个贪心一动，在阿赖耶识里面就熏成种子了；你瞋心一动在阿赖耶里面就熏成种子了。这个种子就是给你再生起的一个力量，为什么还能生起？因为你以前你积蓄了力量，那力量使令你再生起，所以叫做「从自种子而生」。不是从别的种子生的，从你自己的种子出来的。所以人各有各的优点，不能说所有的事情都是你特别优秀，不是的。某一部分，某一部分事情你很擅长，就是你那一分的种子熏习得多，你的知识比别人强，就是因为你就是有那个种子；其他的事情你没有熏习过，或者熏习得浅，那就不是你擅长的，所以「各从自种子而生」是这样子。</p>
<p>辛五、作业 （分二科） 壬一、略标</p>
<p><strong><em>彼作业者：当知有六种。</em></strong></p>
<p>　　「彼作业者」，现在是第五段。前面这个「助伴」是第四段。现在是第五段，是「作业」。这个眼识一共分五科，「自性、所依、所缘、助伴、作业」这也是一共分五科，现在最后一科是「作业」，就是它做什么事情，它做什么工作，是这样的意思。「当知有六种」，这底下回答说是有六种事情。</p>
<p>壬二、别列（分二科）　癸一、初四了别业摄 （分二科）　子一、初业</p>
<p><strong><em>谓唯了别自境所缘，是名初业。</em></strong></p>
<p>　　这个眼识它第一件事，他就是唯独是其他的事情它不能做，它就是「了别自境所缘」，就是明了一样一样的，都是属于它自己这一部分的境界，是他所缘虑的，这就是第一件事。它能有这种能力，有这个本事做这件事。这个意思，譬如说这个第六意识，第六意识就不是「了别自境所缘」。就是眼识所缘的它也能缘，耳识的境界意识也能缘，眼、耳、鼻、舌、身所缘的境界，它都能缘。所以这个意识就特别宽广，所缘的境界宽广。但是眼识不能这么宽广「唯了别自境所缘」，它自己的境界它可以，那么耳识所缘的境界，他不可以了，所以「了别自境所缘，是名初业」。</p>
<p>子二、余业</p>
<p><strong><em>唯了别自相、唯了别现在、唯一剎那了别。</em></strong></p>
<p>　　这个眼识它所了别自己所缘的境界，它也不是都能缘的，它只能缘「自相」。「自相」是对共相说的，譬如说是缘这个灯的光，光是白的，白色的光，他就这么一了别就完了，那么这就叫「自相」。这个事情是很微细的，这是现量境界。那么共相是什么呢？说这个光是剎那剎那灭，是无常的，这无常就是和其他的，和这个墙壁、声音一切都是共有的，都有无常相，那么这就叫共相。这一切法都是无我的，这无我也是共相。那么那个「自相」，这个是白的，它是那个眼识，它只是一个明了而已，明了一个白，它明了那个白的「自相」了，这是不同于共相，这就是「唯了别自相」这又是一个业，第二个业。</p>
<p>　　「唯了别现在」，「了别自相」还是有点分别的，就是「了别现在」的一剎那，过去的现在的它不行，它不能了别。「唯一剎那」，现在它只是一剎那它就停下来，这眼识就停下来了，「唯一剎那」，「唯一剎那了别」。第二剎那不可以，为什么不可以呢？因为第六识活动了，第六识一活动了，眼识就停下来。当然第六识又指挥它，它可能又发生作用了，所以「唯一剎那了别」。这个第六识也可能「一剎那了别」就停下来了，但是也可能相续，相续一剎那、一剎那相续下去，这也是不决定。可是眼识、耳识、前五识都是一剎那，这那么这是几业？「唯了别自境所缘、为了别自相、唯了别现在、唯一剎那了别」，这是四个业，这个眼识有四个，四件事，它能有这四种功能。</p>
<p>癸二、后二随转等业摄 （分二科）　子一、标</p>
<p><strong><em>复有二业。</em></strong></p>
<p>　　还有二种功能。</p>
<p>子二、列 （分二科）　丑一、随转业</p>
<p><strong><em>谓随意识转、随善染转、随发业转。</em></strong></p>
<p>　　二种功能，「谓随意识转」，这是「随转业」。第二个业呢？就是「复能取爱非爱果」，这又是一业，加起来两个业，加前面那四业，就是第六业，一共是六种业。这个「随识转」这个业呢？这句话是总说的，底下是别说。「随善染转、随发业转」这「随转业」里面有开出来两种，开出两种业。这个「随善染转」这个意思是说，说这个眼识的活动，它不能够自主的活动，它不能。它是随意识的命令去活动的，所以叫做「随意识转」，随这个第六意识的活动，才能活动的。</p>
<p>　　那么怎么叫做「随意识转」呢？「随善染转」，就是这个意识，是有善、有染污的。，第六意识有的时候，它也是有好心肠的，无条件的帮助别人做事情，那么就是善。染污那就不是了，那它另外有事情了，有贪、瞋、痴的事情，那么就是染污转。这个第六意识，它有时候善，有时候染的活动，而眼识就随顺意识去活动，去随顺意识去活动，所以它也有善、有染了，是这样意思。但是在初一剎那的时候，还不能说善、染的。昨天我们说那个率尔，这个率尔那就不能说它有善、也不能说染，这还不能，这下面有解释。</p>
<p>　　「随发业转」，这个「随意识转」分两种。第一个，是「随善染转」。第二个，是「随发业转」。因为第六意识能发动出来行动，有目地的行动叫做业。它有的时候发出来善业，有时候发出来恶业。那么这个眼识，它也随着意识的意思去活动，所以叫做「随发业转」。</p>
<p>丑二、取果业</p>
<p><strong><em>又复能取爱非爱果、是第六业。</em></strong></p>
<p>　　「又复能取爱非爱果，是第六业」，这个意识有善、染，如果明白一点说就是烦恼，就是烦恼。发业，是烦恼的活动，这惑、业、苦，「随发业转」，是业。底下「取爱非爱果」，就是苦，惑业苦。「又复能取爱非爱果」，因为第六识发业的时候，这个眼识也随着发业，也随顺着去行动。所以它也等到受果报的时候，它也有它一份。「又复能取爱非爱果」说这眼识它也拿到、能取得、能得到「爱果」，得到可爱的果报，得到不可爱的果报。如果是染污的造了种种的恶，罪恶的事情，跑到三恶道去了，那就取得一个不可爱的眼睛，取得一个不可爱的异熟生眼，果报的眼睛。如果是随顺第六意识去做善业，那么到取果的时候，就取得一个在人天的世界，取得一个可爱的眼睛，就得那可爱的眼睛。这是第六业，是眼识的第六个业。</p>
<p>　　所以这个事情，第六意识是主，第六识是主，作善、作恶是它是主，而这个眼识是随从的，但它不是主。造业的那个时候你随顺，到果的时候你也是一样，也有你一份，也是这样子「是第六业」。这是把这个眼识，一共是分五科，到此结束了。</p>
<p>庚二、耳识摄（分四科）　辛一、自性</p>
<p><strong><em>云何耳识自性？谓依耳了别声。</em></strong></p>
<p>　　一共是分五科。眼识、耳识、鼻识、舌识、身识。「五识相应地」分这五科。眼识这一科是完了。现在是第二科说到这个「耳识」，「耳识摄」。这一大段文都是属于「耳识」这一部分的。它这一段分成四科。眼识是分成五科，但是这个耳识这里分成四科。第一科也是说它的「自性」。「云何耳识」的「自性」呢？「谓依耳了别声」，也不说耳，也不说声，直接的去说明耳识很难，很不容易。所以就是说「依耳去了别声」，这就是耳识的「自性」这么样解释。反正耳识要依耳根为依止处，所以去了别声音，这个「了别」的，就是耳识。因为它依止根的关系，根要特别强，这个耳识就特别强。你的眼根特别强，眼识也就特别强。根明利故，识也就明利；如果根不明利，识也就不明利，是这样的解释。现在说「依耳了别声」，这是耳识的「自性」，这是一段。那么第二段呢？就是又说「所依」，耳识的「所依」。</p>
<p>辛二、所依 （分二科）　壬一、举依（分三科）　癸一、俱有依</p>
<p><strong><em>彼所依者：俱有依，谓耳。</em></strong></p>
<p>　　耳根是耳识的「俱有依」，一定同时有的。耳根若坏了，耳识就不行了，也就坏了。不能没有耳识了，第二个是「等无间依」。</p>
<p>癸二、等无间依</p>
<p><strong><em>等无间依：谓意。</em></strong></p>
<p>　　这和前面解释是一样的。第三个是「种子依」。</p>
<p>癸三、种子依</p>
<p><strong><em>种子依：谓一切种子阿赖耶识。</em></strong></p>
<p>　　这个「种子依」和前面眼识也是一样的。「谓一切种子阿赖耶识」，这是「种子依」。</p>
<p>壬二、出体（分二科）　癸一、耳</p>
<p><strong><em>耳谓四大种所造，耳识所依净色，无见有对。</em></strong></p>
<p>　　这个前面是举出来这三种依：「俱有依、等无间依、种子依」。现在第二段「出体」，就说来这三种依的体相。这分二段。第一段是说「耳」。这个耳根俱有依的，耳识的俱有依就是耳根，耳根是什么东西呢？为「四大种所造」的，是「耳识所依」止的「净色」，是「无见」的，是「有对」的。因为这个耳根，它没有见的作用。耳根有闻的作用，而没有见的作用，所以是「无见」。它也是「有对」的，它是障碍有对的、境界有对，耳根就是这两个「有对」，没有这个所缘。而耳识呢？就加上一个所缘有对。这是说这个耳根。什么是耳根？它是「四大种所造」，它是「耳识所依」的「净色」。这个「净色」，是「四大种所造」的，是耳识所依止的，是「无见有对」这是第一节。第二节呢？</p>
<p>癸二、意等</p>
<p><strong><em>意及种子，如前分别。</em></strong></p>
<p>　　这个耳根说完了。这个「等无间依」和「种子依」这两种，像前面的眼识的分别，和那一样，和那是一样的。这个我若在这里说，这个「意」是什么呢？就是耳识的无间过去识，耳识无间灭的那个过去识，就是耳识的等无间依。那个种子依和前面也是一样，『一切种子识为无始时来，乐着戏论熏习为因，所生一切种子异熟识』像前面一样，但是属于耳识这一部份的。</p>
<p>辛三、所缘 （分二科）　壬一、出体性</p>
<p><strong><em>彼所缘者：谓声；无见有对。</em></strong></p>
<p>　　这是第三段。「自性」和「所依」解释完了。现在解释耳识「所缘」。「所缘」的是什么呢？「谓声」，「声」是它的所缘，这是出这个所缘的体性，是「声」。「无见有对」，这个声音，你这个眼不能在这里活动，所以叫「无见」。「有对」，声音也是有障碍的。因为你小的声音，就被大的声音障碍住了，这也是有障碍的。譬如太远了，太远了这个声音就不行，也有问题。</p>
<p>壬二、辨种类（分二科）　癸一、出多种</p>
<p><strong><em>此复多种：如螺贝声、大小鼓声、舞声、歌声、诸音乐声、俳戏叫声、女声、男声、风林等声，明了声、不明了声，有义声、无义声，下中上声，江河等声，斗诤喧杂声，受持演说声，论议抉择声，如是等类，有众多闻。</em></strong></p>
<p>　　这底下就继续说到这个所缘的声音的种类。「种类」第一个「出多种」。「多种」是多少种呢？「谓螺贝声」，那个螺的贝，它也能够发出声音来，你一吹，声音还是很大的。「大小鼓」的声音。和「舞」的声音，人会「舞」，「舞」的声音。和「歌」的声音，还有「诸音乐」的声音。「俳戏叫声」，「俳」，就是戏，做种种的戏，或是种种的声音。还有「女声」，女人的声音。「男声」。还有「风林」的声音，等等的声音。</p>
<p>　　是「明了声、不明了声」：这个「明了声」，就是它所诠的意，它能够明了的表示出来这个声音上，这个声音上能表达一种道理，叫「明了声」。「不明了声」，没有意义表示出来的。那个风在那吹的这个声音，那不表示什么；像人说话的声音，能够明了表示一种义。这是不按照深一层意思去解说，就是一般的这样解释，就「明了声、不明了声」，就是能了达意义的声音，不能明了意义的声音。这「有义声、无义声」，这是约凡、圣说，圣人会说出来甚深的道理，那是「有义声」。凡夫不懂的甚深的道理，所说的都是戏论，「无义声」。</p>
<p>　　这个在佛法的经论上看，佛法的态度是这样子。所以我们出家人不学习佛法，到社会上学校去读书，应应再想一想哦！当然这是思想的问题，你求什么呢？你何所求？要这样做呢？这有点关系。「下中上声」：「下声」，就是三恶道的众生发出来的声音。「中」，就是人，人发出来声音。天上的人发出来的声音，叫做「上声」。因为这个果报有关系，天上人的果报太妙了，他发出声音是太美了，这三恶道就是差一点。 「江河等声」，这个世界上地面上，有「江」、有「河」、有鸟兽所发出的声音。「斗诤喧杂声」，鸟兽也有斗诤的，人也有斗诤的。就是「斗诤」的「諠杂」的声音。「受持演说声」，佛教徒受持经、律、论，为人讲说的声音。「论议抉择声」，大家讨论佛法的时候，深一层的认识法相，那又「抉择」的这种声音。「如是等类，有众多声」，这个声音是很多的。</p>
]]></content>
      <categories>
        <category>佛学</category>
      </categories>
      <tags>
        <tag>buddhism</tag>
      </tags>
  </entry>
  <entry>
    <title>色彩理论</title>
    <url>/post/f236dd28/</url>
    <content><![CDATA[<h1 id="学习课程"><a href="#学习课程" class="headerlink" title="学习课程"></a>学习课程</h1><p><a href="https://www.coursera.org/learn/graphic-elements-design/home/welcome">Graphic Elements of Design: Color Theory and Image Formats - 首页 | Coursera</a></p>
<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul>
<li>了解基本色彩理论 <code>ROY G BIV</code> <code>CMYK</code> <code>Pantone(PMS)</code> <code>RGB</code></li>
<li>应用</li>
</ul>
<h1 id="1-理解色彩理论"><a href="#1-理解色彩理论" class="headerlink" title="1. 理解色彩理论"></a>1. 理解色彩理论</h1><h2 id="11-几种色彩理论"><a href="#1-1-几种色彩理论" class="headerlink" title="1.1 几种色彩理论"></a>1.1 几种色彩理论</h2><h3 id="roy-g-biv"><a href="#ROY-G-BIV" class="headerlink" title="ROY G BIV"></a>ROY G BIV</h3><p><a href="https://www.youtube.com/watch?v=5OxLfEq4Iv4">ROY G BIV | The Colors of the Rainbow | Jack Hartmann - YouTube</a></p>
<p><img src="https://th.bing.com/th/id/R.c1b6c1956238d05d1221798b46747ca2?rik=ZcWzISb%2fdZojRQ&amp;riu=http%3a%2f%2fimg3.wikia.nocookie.net%2f__cb20111026212102%2frainbows%2fimages%2f0%2f06%2f3.gif&amp;ehk=v1fKzYtCcF9FaGuCEBAdVrr2lARDIWyC23GIx%2bwi14k%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="查看源图像"></p>
<ul>
<li>彩虹色</li>
<li>包括red   orange   yellow   green   blue  indigo   violet</li>
</ul>
<h3 id="cmyk"><a href="#CMYK" class="headerlink" title="CMYK"></a>CMYK</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b2/CMYK_color_swatches.png" alt="img"></p>
<ul>
<li><strong>C</strong>：<strong>C</strong>yan ＝ 青色或“湛蓝”</li>
<li><strong>M</strong>：<strong>M</strong>agenta ＝ 洋红色</li>
<li><strong>Y</strong>：<strong>Y</strong>ellow ＝ 黄色</li>
<li><strong>K</strong>：<strong>K</strong>ey plate 因实务上多使用黑色，所以也可以简单视为blac<strong>K</strong></li>
</ul>
<h3 id="rgb"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/RGB_color_solid_cube.png/1280px-RGB_color_solid_cube.png" alt="img"></p>
<ul>
<li>将<a href="https://zh.wikipedia.org/wiki/红">红</a>（<strong>R</strong>ed）、<a href="https://zh.wikipedia.org/wiki/绿色">绿</a>（<strong>G</strong>reen）、<a href="https://zh.wikipedia.org/wiki/蓝">蓝</a>（<strong>B</strong>lue）三原色的色光以不同的比例相加，以合成产生各种色彩光</li>
</ul>
<h3 id="pantonepantone-matching-system"><a href="#Pantone-Pantone-Matching-System" class="headerlink" title="Pantone(Pantone Matching System)"></a>Pantone(Pantone Matching System)</h3><p><a href="https://www.pantone.com/color-systems/pantone-color-systems-explained">Pantone Color Systems - Introduction | Pantone</a></p>
<h2 id="12-比较rgb和cmyk"><a href="#1-2-比较RGB和CMYK" class="headerlink" title="1.2 比较RGB和CMYK"></a>1.2 比较RGB和CMYK</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://en.wikipedia.org/wiki/ROYGBIV">ROYGBIV - Wikipedia</a></p>
<p><a href="https://zh.wikipedia.org/wiki/印刷四分色模式">印刷四分色模式 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a href="https://zh.wikipedia.org/wiki/三原色光模式">三原色光模式 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(1)——面向对象设计原则</title>
    <url>/post/7c16c150/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="软件的可维护性和可复用性"><a href="#软件的可维护性和可复用性" class="headerlink" title="软件的可维护性和可复用性"></a>软件的可维护性和可复用性</h3><ul>
<li>恰当的复用可以改善系统的可维护性</li>
<li>复用的目标在于<strong>实现支持可维护性的复用</strong></li>
<li>在面向对象的设计里，<strong>可维护性复用都是以面向对象设计原则为基础</strong></li>
<li><strong>重构</strong>——不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更加合理，提高软件的扩展性和维护性</li>
</ul>
<h2 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SRP 单一职责原则</td>
<td style="text-align:center">类的职责要单一，不能将太多职责放在一个类里</td>
</tr>
<tr>
<td style="text-align:center">OCP 开闭原则</td>
<td style="text-align:center">软件实体对扩展开放，对修改关闭。在不修改一个软件实体的基础上扩展功能。</td>
</tr>
<tr>
<td style="text-align:center">LSP 里氏替换原则</td>
<td style="text-align:center">在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象。反之不然。</td>
</tr>
<tr>
<td style="text-align:center">DIP 依赖倒转原则</td>
<td style="text-align:center">针对抽象层编程，不要针对具体类编程</td>
</tr>
<tr>
<td style="text-align:center">ISP 接口隔离原则</td>
<td style="text-align:center">使用多个专门的接口来取代一个统一的接口</td>
</tr>
<tr>
<td style="text-align:center">CRP 合成复用原则</td>
<td style="text-align:center">尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系</td>
</tr>
<tr>
<td style="text-align:center">LoD 迪米特原则</td>
<td style="text-align:center">一个软件实体对其他实体的引用越少越好。如果两个类不必彼此直接通信，那么两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互</td>
</tr>
</tbody>
</table>
</div>
<h3 id="21-单一职责原则-single-responsibility-principlesrp"><a href="#2-1-单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="2.1 单一职责原则 Single Responsibility Principle(SRP)"></a>2.1 单一职责原则 Single Responsibility Principle(SRP)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个对象只包含<strong>单一的职责(single responsibility)</strong>，且该职责被完整地封装在一个类中</p>
<p>对一个类来说，<strong>仅有一个(never be more than one reasion)</strong>引起它变化的原因</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>一个类（模块、方法等同理）承担的职责越多，它被复用的可能性越小</li>
<li>职责在两方面：<ul>
<li>数据职责，通过<strong>属性</strong>体现</li>
<li>行为职责，通过<strong>方法</strong>体现</li>
</ul>
</li>
<li>实现<strong>高内聚、低耦合</strong>的指导方针</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>登录功能原结构</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/SRP_1.png" alt></p>
<p>按原则重构后</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/SRP_2.png" alt></p>
<h3 id="22-开闭原则-open-closed-principleocp"><a href="#2-2-开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="2.2 开闭原则 Open-Closed Principle(OCP)"></a>2.2 开闭原则 Open-Closed Principle(OCP)</h3><h4 id="定义"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>一个软件实体应当<strong>对扩展开放，对修改关闭(open for extension, closed for modification)</strong>。</p>
<h4 id="分析"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul>
<li><strong>抽象化</strong>是开闭原则的关键</li>
<li>“<strong>对可变性封装原则</strong>”</li>
</ul>
<h4 id="实例"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>图形界面的按钮编程</p>
<p>原结构</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/OCP_1.png" alt></p>
<p>重构后</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/OCP_2.png" alt></p>
<h3 id="23-里氏替换原则-liskov-substitution-principlelsp"><a href="#2-3-里氏替换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="2.3 里氏替换原则 Liskov Substitution Principle(LSP)"></a>2.3 里氏替换原则 Liskov Substitution Principle(LSP)</h3><h4 id="定义"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象</strong></p>
<h4 id="分析"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><ul>
<li><strong>在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</strong>把基类都替换成其子类，程序不会产生任何错误和异常，反之不成立。</li>
<li>LSP是实现OCP的重要方式之一。<strong>在程序中尽量使用基类类型来对对象进行定义，而运行时再确定其子类类型，而子类对象来替代弗雷对象。</strong></li>
</ul>
<h4 id="实例"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>原</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/LSP_1.png" alt></p>
<p>重构后</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/LSP_2.png" alt></p>
<h3 id="24-依赖倒转原则-dependency-inversion-principledip"><a href="#2-4-依赖倒转原则-Dependency-Inversion-Principle-DIP" class="headerlink" title="2.4 依赖倒转原则 Dependency Inversion Principle(DIP)"></a>2.4 依赖倒转原则 Dependency Inversion Principle(DIP)</h3><h4 id="定义"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>高层模块不应该依赖底层板块，它们都应该依赖抽象。<strong>抽象不应该依赖于细节，细节应该依赖于抽象(Abstractions should not depend upon details, details should depend upon abstractions)</strong>。</p>
<p>要<strong>针对接口编程</strong>，不要针对实现编程</p>
<h4 id="分析"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>同上定义</p>
<ul>
<li>实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现。如果说开闭原则的面向对象设计的目的的话，那么<strong>依赖倒转原则就是面向对象设计的主要目标</strong>。</li>
<li>常见的实现方式之一是<strong>在代码中使用抽象类，而将具体类放在配置文件中</strong>。也就是<strong>将抽象放进代码，将细节放进元数据(Put Abstractions in Code, Details in Metadata)</strong></li>
<li>类之间的耦合<ul>
<li><strong>零耦合关系</strong></li>
<li><strong>具体耦合关系</strong></li>
<li><strong>抽象耦合关系</strong>——以抽象方式耦合是依赖倒转原则的关键</li>
</ul>
</li>
<li><strong>依赖注入</strong><ul>
<li>构造注入：通过<strong>构造函数</strong>注入实例变量</li>
<li>设值注入：通过<strong>Setter方法</strong>注入实例变量</li>
<li>接口注入：通过<strong>接口方法</strong>注入实例变量</li>
</ul>
</li>
</ul>
<h4 id="实例"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>将来自不同数据源的数据转换为多种格式的数据转换模块</p>
<p>原</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/DIP_1.png" alt></p>
<p>重构后</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/DIP_2.png" alt></p>
<h3 id="25-接口隔离原则-interface-segregation-principleisp"><a href="#2-5-接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="2.5 接口隔离原则 Interface Segregation Principle(ISP)"></a>2.5 接口隔离原则 Interface Segregation Principle(ISP)</h3><h4 id="定义"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>客户端不应该依赖那些它不需要的接口</p>
<p>一旦一个接口太大，则需要将它<strong>分割成一些更细小的接口(split into smaller and more specific interfaces)</strong>，使用该接口的客户端仅需知道与之相关的方法即可。</p>
<h4 id="分析"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><ul>
<li><strong>使用多个专门的接口，而不使用单一的总接口。</strong>每个接口应承担一种相对独立的角色。<ul>
<li><strong>一个接口就只表示一个角色</strong>，每个角色都有其特定的一个接口——“角色隔离原则”</li>
<li>接口<strong>仅仅提供客户端需要的行为</strong>，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li>
</ul>
</li>
<li>使用该原则拆分接口时，首先必须满足<strong>单一职责原则</strong>，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口的方法越少越好。</li>
<li>在进行系统设计时采用<strong>定制服务</strong>的方式，即<strong>为不同的客户端提供宽窄不同的接口</strong>，只提供用户需要的行为，而隐藏用户不需要的行为。</li>
</ul>
<h4 id="实例"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><p>拥有多个客户类的系统，在系统中定义一个胖接口服务所有客户类</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/ISP_1.png" alt></p>
<p>重构后</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/ISP_2.png" alt></p>
<h3 id="26-合成复用原则-composite-reuse-principlecrp"><a href="#2-6-合成复用原则-Composite-Reuse-Principle-CRP" class="headerlink" title="2.6 合成复用原则 Composite Reuse Principle(CRP)"></a>2.6 合成复用原则 Composite Reuse Principle(CRP)</h3><h4 id="定义"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p><strong>尽量使用对象组合</strong>，而不是继承来达到复用的目的。</p>
<h4 id="分析"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><ul>
<li>CRP指在一个新对象里通过<strong>关联关系（包括组合关系和聚合关系）</strong>来使用一些已有的对象，使之成为新对象的一部分；新对象通过<strong>委派调用</strong>已有对象的方法达到复用其已有功能的目的。——<strong>尽量使用组合/聚合关系，少用继承</strong>。</li>
<li>两种复用对比<ul>
<li>继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（<strong>“白箱”复用</strong>）</li>
<li>组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（<strong>“黑箱”复用</strong> ）</li>
</ul>
</li>
<li><strong>慎重使用继承复用</strong></li>
</ul>
<h4 id="实例"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><p>教学管理系统部分数据库访问类设计</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/CRP_1.png" alt></p>
<p>重构后</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/CRP_2.png" alt></p>
<h3 id="27-迪米特法则-law-of-demeterlod"><a href="#2-7-迪米特法则-Law-of-Demeter-LoD" class="headerlink" title="2.7 迪米特法则 Law of Demeter(LoD)"></a>2.7 迪米特法则 Law of Demeter(LoD)</h3><h4 id="定义"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>(1) <strong>不要和“陌生人”说话</strong>。Don’t talk to strangers.</p>
<p>(2) <strong>只与你的直接朋友通信</strong>。Talk only to your immediate friends.</p>
<p>(3) <strong>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.</p>
<h4 id="分析"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><ul>
<li>迪米特法则就是指<strong>一个软件实体应当尽可能少的与其他实体发生相互作用</strong>。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。</li>
<li>其“朋友”包括几类，除此之外是“陌生人”<ul>
<li>当前对象本身(this)</li>
<li>以参数形式传入到当前对象方法中的对象</li>
<li>当前对象的成员对象</li>
<li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li>
<li>当前对象所创建的对象</li>
</ul>
</li>
<li>狭义的LoD：<strong>可以降低类之间的耦合</strong>，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会<strong>造成系统的不同模块之间的通信效率降低</strong>，使得系统的不同模块之间不容易协调。</li>
<li>广义的LoD：指<strong>对对象之间的信息流量、流向以及信息的影响的控制</strong>，主要是<strong>对信息隐藏的控制</strong>。</li>
<li>主要用途是<strong>控制信息的过载</strong><ul>
<li>在类的划分上，应尽量<strong>创建松耦合的类</strong></li>
<li>在类的结构设计上，每一个类都应当<strong>尽量降低其成员变量和成员函数的访问权限</strong></li>
<li>在类的设计上，只要有可能，<strong>一个类型应当设计成不变类</strong></li>
<li>在对其他类的引用上吗，<strong>一个对象对其他对象的引用应当降到最低</strong></li>
</ul>
</li>
</ul>
<h4 id="实例"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h4><p>某系统界面类和数据访问类之间的调用关系</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/LoD_1.png" alt></p>
<p>重构后</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/LoD_2.png" alt></p>
]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(0) 介绍</title>
    <url>/post/9ae13a6d/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>与所有工程学一致，好的解决方案总是会被软件工程师在实践中反复使用，并且往往用过一个好方案、尝到了甜头，以后就喜欢重复使用这个模式，因此设计方案和经验对于软件工程师来说都是招牌技能般的存在。</p>
<p>但是实践环境千变万化，现实需求日益复杂、庞大驱使软件开发更复杂，只掌握少数几个解决方案恐怕是杯水车薪。所以想开辟新的板块，通过实例学习<strong>《设计模式：可复用面向对象软件的基础》</strong>里面的大量“招式”，并且通过这些“秘技”深入理解面向对象的“心法”原则。</p>
<h2 id="2-描述"><a href="#2-描述" class="headerlink" title="2. 描述"></a>2. 描述</h2><blockquote>
<p>以一种松散的方式把一些模式串接在一起来建造建筑是可能的。这样的建筑仅仅是一些模式的堆砌，而不紧凑。这不够深刻。然而另有一种组合模式的方式，许多模式重叠在同一个物理空间里：这样的建筑非常紧凑，在一小块空间里集成了许多内涵；由于这种紧凑，它变得深刻。</p>
<p>——A Pattern Language</p>
</blockquote>
<p>我记得老师说过一句话，大概意思是，程序编写不再是手工艺式的、建立在个别人“手艺”的了，而是能以工程的方式批量生产。所以，纳入工程范畴的概念，应当都得到<strong>科学的、明确的</strong>描述，应当有可进行批量复制的基础范式。</p>
<p>我曾有过的经验是，有时一个问题解决了，但是不知道是在哪里、如何将它解决的，在程序设计中这种“神秘”的想法不应当成为习惯。而最好的方式就是事后用准确的语言来描述<strong>解决方案的痛点和具体解决过程</strong>。</p>
<p>设计模式也经历了从手工艺式的经验到标准范式的信息描述结构，以下为<strong>设计模式的信息描述结构</strong></p>
<h3 id="21-信息描述结构"><a href="#2-1-信息描述结构" class="headerlink" title="2.1 信息描述结构"></a>2.1 信息描述结构</h3><ul>
<li><p><strong>模式名和分类</strong></p>
</li>
<li><p><strong>意图</strong>  设计模式是做什么的？它的基本原理和意图是什么？它解决的特定设计问题？</p>
</li>
<li><p><strong>别名</strong></p>
</li>
<li><p><strong>动机</strong>  说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景</p>
</li>
<li><p><strong>适用性</strong>  什么情况下用？用来改进哪些不良设计？如何识别这些情况？</p>
</li>
<li><p><strong>结构</strong></p>
</li>
<li><p><strong>参与者</strong></p>
</li>
<li><p><strong>协作</strong></p>
</li>
<li><p><strong>效果</strong></p>
</li>
<li><p><strong>实现</strong>  实现需要知道的一些提示、技术要点、应避免的缺陷，是否存在某些特定于实现语言的问题</p>
</li>
<li><p><strong>代码示例</strong></p>
</li>
<li><p><strong>已知应用</strong></p>
</li>
<li><p><strong>相关模式</strong></p>
</li>
</ul>
<h3 id="22-词汇表"><a href="#2-2-词汇表" class="headerlink" title="2.2 词汇表"></a>2.2 词汇表</h3><p>真的多 TAT</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/cihuibiao1.PNG" alt></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/cihuibiao2.PNG" alt></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/cihuibiao3.PNG" alt></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/cihuibiao4.PNG" alt></p>
<h2 id="3-图示"><a href="#3-图示" class="headerlink" title="3. 图示"></a>3. 图示</h2><p>这应当是设计模式中最常见的内容了 比如各种考试 :）</p>
<p>放几个个学习的链接吧</p>
<h3 id="31-类图"><a href="#3-1-类图" class="headerlink" title="3.1 类图"></a>3.1 类图</h3><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/class_pic.png" alt></p>
<p>以下为类图的组成</p>
<h4 id="311-类"><a href="#3-1-1-类" class="headerlink" title="3.1.1 类"></a>3.1.1 类</h4><p>对一组具有相同属性、操作、关系、语义的事物的抽象。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/class_introduction.png" alt></p>
<h4 id="312-继承"><a href="#3-1-2-继承" class="headerlink" title="3.1.2 继承"></a>3.1.2 继承</h4><p>唐老鸭属于鸭的一种，或者说是鸭的细化划分，而鸭属于鸟类，鸟类属于动物，这里无论表达成“是”还是属于，就是这样一个直观的关系。用实线一端带空心三角箭头表示。箭头指向父类。</p>
<h4 id="313-依赖"><a href="#3-1-3-依赖" class="headerlink" title="3.1.3 依赖"></a>3.1.3 依赖</h4><p>凡是动物，生存都需要水和空气，这种必须的需求，我们称之为依赖关系。用虚线一端带箭头表示，箭头指向依赖物。</p>
<h4 id="314-组合-聚合"><a href="#3-1-4-组合、聚合" class="headerlink" title="3.1.4 组合、聚合"></a>3.1.4 组合、聚合</h4><p>大雁和雁群的经典例子</p>
<p> 很多大雁聚合在一起变成雁群，也可以说雁群里有雁，所以是<strong>整体和个体之间的关系</strong>,即<strong>has-a</strong>的关系，此时<strong>整体与部分之间是可分离的，他们可以具有各自的生命周期</strong>。即雁群可以不存在了，但是孤雁仍然存在。</p>
<p>一只鸟由两个翅膀组合而成，即一只鸟有两个翅膀。虽然组合和聚合我们都说“有”什么，但是这个“有”是不同的，他体现的是一种<strong>contains-a</strong>的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，<strong>整体的生命周期结束也就意味着部分的生命周期结束</strong>，比如这只鸟死了，自然这两个翅膀也就不存在了。</p>
<h4 id="315-关联"><a href="#3-1-5-关联" class="headerlink" title="3.1.5 关联"></a>3.1.5 关联</h4><p>企鹅和气候有关联，关联是最常见的关系，表示类与类之间的联接, 它使一个类知道另一个类的属性和方法。关联有两个端点, 在每个端点可以有一个基数, 表示这个关联的类可以有几个实例.<br> 常见的基数及含义: 0..1:0 或1 个实例.<br>​                                  0..<em>: 对实例的数目没有限制.<br>​                                  1: 只能有一个实例.<br>​                                  1..</em>: 至少有一个实例. </p>
<h4 id="316-接口"><a href="#3-1-6-接口" class="headerlink" title="3.1.6 接口"></a>3.1.6 接口</h4><p>最后就是接口了，接口有两栏组成，第一栏的顶端加上<strong>《interface》</strong>后下方写接口名称，第二栏是接口方法。接口有自己的表示方法“实现”，虚线一端带空心三角形。实际开发中，为了更好的实现”开-闭原则”，一般都是定义接口，依赖于接口，依赖于抽象。</p>
<p><a href="https://blog.csdn.net/wangdingqiaoit/article/details/12119293">uml中的类图</a></p>
<p><a href="https://www.cnblogs.com/jisijie/p/5062109.html">UML</a></p>
<h3 id="32-对象图"><a href="#3-2-对象图" class="headerlink" title="3.2 对象图"></a>3.2 对象图</h3><p><a href="https://blog.csdn.net/mj_ww/article/details/53020346">类图和对象图</a></p>
<h3 id="33-交互图"><a href="#3-3-交互图" class="headerlink" title="3.3 交互图"></a>3.3 交互图</h3><p><a href="https://blog.csdn.net/king110108/article/details/78217816">uml中的交互图</a></p>
]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（2） 创建型模式 ABSTRACT FACTORY 抽象工厂模式</title>
    <url>/post/1711a5b3/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>本节关于ABSTRACT FACTORY 抽象工厂模式 —— 对象创建模式</p>
<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>提供一个创建一系列相关或互相依赖对象的接口，而无需指定其具体的类。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2. 别名"></a>2. 别名</h2><p>Kit</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3. 动机"></a>3. 动机</h2><p>简单工厂——当你需要什么，只需要传入相应参数就能获得对象，但无须知道其创建细节。</p>
<p>如下图，支持多种视图标准的用户界面工具包，例如Motif和Presenation Manager。不同视感(look-and-feel)风格为诸如滚动条、窗口、按钮等用户界面“窗口组件”定义不同的外观和行为。</p>
<p>问题：要求视感风格标准间可移植；一个应用不应该为一个特定的视感外观直接编码其窗口组件；整个应用中实例化特定视感风格的窗口组件类使得以后很难改变视感风格。</p>
<p>如下图解决该问题</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/abstract_factory_1.png" alt></p>
<p>定义一个抽象的WidgetFactory类，这个类声明了一个用来创建每一类基本窗口组件的接口。每一类窗口组件都有一个抽象类，而具体子类实现窗口组件的特定视感风格。</p>
<p><strong>体现原则</strong>：单一职责SRP、开闭原则OCP</p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4. 适用性"></a>4. 适用性</h2><ul>
<li>一个系统要独立于它的产品的创建、组合、表示</li>
<li>一个系统要由多个产品系列中的一个来配置</li>
<li>要强调一系列相关产品对象的设计以便联合使用</li>
<li>提供一个产品类库，但只想显示它们的接口而不是实现</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5. 结构"></a>5. 结构</h2><p>上图拓展</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/abstract_factory_2.png" alt></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6. 参与者"></a>6. 参与者</h2><ul>
<li><p>AbstractFactory (WidgetFactory) </p>
<ul>
<li><p>声明一个创建抽象产品对象的操作接口</p>
</li>
<li><p>ConcreteFactory(MotifWidgetFactory, PMWidgetFactory)</p>
<ul>
<li>实现创建具体产品对象的操作</li>
</ul>
</li>
</ul>
</li>
<li>AbstractProduct(Window, ScrollBar)<ul>
<li>为一类产品对象声明一个接口</li>
</ul>
</li>
<li>ConcreteProduct(MotifWindow, MotifScrollBar)<ul>
<li>定义一个将被相应的具体工厂创建的产品对象</li>
<li>实现AbstractProduct接口</li>
</ul>
</li>
<li>Client<ul>
<li>仅使用由AbstractFactory和AbstractProduct类声明的接口</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7. 协作"></a>7. 协作</h2><ul>
<li>在运行时刻创建一个ConcreteFactory类的实例。这一具体工厂创建具有特定实现的产品对象。<strong>为创建不同的产品对象，客户应使用不同的具体工厂。</strong></li>
<li>AbstractFactory将产品对象的<strong>创建延迟</strong>到其ConcreteFactory子类</li>
</ul>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8. 效果"></a>8. 效果</h2><ul>
<li><p>优点</p>
<ol>
<li><p>分离了具体的类</p>
</li>
<li><p>易于交换产品系列</p>
</li>
<li><p>有利于产品的一致性</p>
</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>难以支持新种类的产品。AbstractFactory接口确定了可以被创建的产品集合，新 种类产品需要扩展该工厂接口，这会导致AbstractFactory类及其所有子类的改变。下一节会说解决方法。</li>
</ol>
</li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9. 实现"></a>9. 实现</h2><ul>
<li>将工厂作为单件</li>
<li>创建产品</li>
<li>定义可扩展的工厂</li>
</ul>
<h2 id="10-示例"><a href="#10-示例" class="headerlink" title="10. 示例"></a>10. 示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryExample</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentA</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(ICardFactory cardfactory)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">			IPaymentcard mastercard = cardfactory.createCard(<span class="string">&quot;debit&quot;</span>);</span><br><span class="line">			<span class="keyword">boolean</span> checkValidity = mastercard.CheckValidity();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICardFactory</span> </span>&#123;</span><br><span class="line">		<span class="function">IPaymentcard <span class="title">createCard</span><span class="params">(String cardType)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralFactory</span> <span class="keyword">implements</span> <span class="title">ICardFactory</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> IPaymentcard <span class="title">createCard</span><span class="params">(String cardtype)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">			<span class="keyword">switch</span>(cardtype)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;debit&quot;</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> DebitCard();</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;credit&quot;</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> CreditCard();</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Card type not found&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPaymentcard</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">boolean</span> <span class="title">CheckValidity</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function">IPaymentcard <span class="title">requestNewCard</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebitCard</span> <span class="keyword">implements</span> <span class="title">IPaymentcard</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckValidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> IPaymentcard <span class="title">requestNewCard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> <span class="keyword">implements</span> <span class="title">IPaymentcard</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckValidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> IPaymentcard <span class="title">requestNewCard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="11-应用"><a href="#11-应用" class="headerlink" title="11. 应用"></a>11. 应用</h2><h2 id="12-相关模式"><a href="#12-相关模式" class="headerlink" title="12. 相关模式"></a>12. 相关模式</h2>]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(3) 创建型模式 BUILDER 生成器</title>
    <url>/post/4b55dd87/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>本节关于BUILDER 生成器模式 —— 对象创建模式</p>
<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>将一个复杂对象的<strong>构建</strong>与它的<strong>表示分离</strong>，使得<strong>同样的构建过程可以创建不同的表示</strong>。</p>
<h2 id="2-动机"><a href="#2-动机" class="headerlink" title="2. 动机"></a>2. 动机</h2><p>如下图，一个Rich Text Format文档交换格式的阅读器能将RTF转换为多种正文格式。该阅读器可以将RTF文档转换为<strong>ASCII文本或转换为一个能以交互方式编辑的正文窗口组件</strong>。</p>
<p>问题：<strong>转换的数目无穷</strong>；需要容易实现新转换的增加，同时不改变RTF阅读器</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/builder_1.png" alt></p>
<p>解决方法：TextConverter对象——将RTF转换为另一种正文表示——配置RTFReader类。其负责进行<strong>数据转换以及用特定格式表示该标记</strong>。TextConvert的子类对不同转换和不同格式进行特殊处理。</p>
<p>每种转换器类将创建和装配一个复杂对象的机制隐含在<strong>抽象接口</strong>后面。转换器独立于阅读器，阅读器负责对一个RTF文档进行语法分析。</p>
<p>每一个转换器类在该模式中被称为<strong>生成器（builder）</strong>，而阅读器则称为<strong>导向器（director）</strong>。</p>
<h2 id="3-适用性"><a href="#3-适用性" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><ul>
<li>当创建复杂对象的算法应<strong>独立</strong>于该对象的组成部分以及其装配方式时</li>
<li>当构造过程必须允许被构造的对象有<strong>不同的表示</strong>时</li>
</ul>
<h2 id="4-结构"><a href="#4-结构" class="headerlink" title="4. 结构"></a>4. 结构</h2><p>上图的扩展咯</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/builder.png" alt></p>
<h2 id="5-参与者"><a href="#5-参与者" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul>
<li>Builder (TextConverter)<ul>
<li>为创建一个Product对象的各个部件指定抽象接口</li>
</ul>
</li>
<li>ConcreteBuilder (ASCIIConverter, TeXConverter, TextWidgetConverter)<ul>
<li>实现Builder的接口以构造和装配该产品的各个部件</li>
<li>定义并明确它所创建的表示</li>
<li>提供一个检索产品的接口(例如GetASCIIText和GetTextWidget)</li>
</ul>
</li>
<li>Director (RTFReader)<ul>
<li>构造一个使用Builder接口的对象</li>
</ul>
</li>
<li>Product (ASCIIText, TeXText, TextWidget)<ul>
<li>表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义其装配过程。</li>
<li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
</ul>
</li>
</ul>
<h2 id="6-协作"><a href="#6-协作" class="headerlink" title="6. 协作"></a>6. 协作</h2><p>Builder和Director交互图</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/jiaohutu_1.png" alt></p>
<ul>
<li>客户创建Director对象，并用它所想要的Builder对象进行配置</li>
<li>一旦产品部件生产，导向器就会通知生成器</li>
<li>生成器处理导向器的请求，并将部件添加到该产品中</li>
<li>客户从生成器中检索产品</li>
</ul>
<h2 id="7-效果"><a href="#7-效果" class="headerlink" title="7. 效果"></a>7. 效果</h2><ul>
<li>它使你可以改变一个产品的内部实现</li>
<li>它可以将构造代码和表示代码分开</li>
<li>它使你可对构造过程进行更精细的控制</li>
</ul>
<h2 id="8-实现"><a href="#8-实现" class="headerlink" title="8. 实现"></a>8. 实现</h2><p>通常有一个抽象的Builder类为导向者可能要求创建的每一个构件定义一个操作。这些操作缺省情况下什么都不做。一个ConcreBuilder类对它有兴趣创建的构件重定义这些操作。</p>
<ul>
<li>装配和构造接口</li>
<li>为什么产品没有抽象类</li>
<li>在Builder中缺省的方法为空</li>
</ul>
<h2 id="9-代码示例"><a href="#9-代码示例" class="headerlink" title="9. 代码示例"></a>9. 代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MazeBuilder</span> &#123;</span>   <span class="comment">//这个是Builder</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildMaze</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildRoom</span><span class="params">(<span class="keyword">int</span> room)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> BuildDoor</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> Maze * <span class="title">GetMaze</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">MazeBuilder</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Maze * <span class="title">MazeGame::CreateMaze</span><span class="params">(MazeBuilder &amp; builder)</span> </span>&#123;   <span class="comment">//这个就是Director</span></span><br><span class="line">    builder.<span class="built_in">BuildMaze</span>();</span><br><span class="line"></span><br><span class="line">    builder.<span class="built_in">BuildRoom</span>(<span class="number">1</span>);</span><br><span class="line">    builder.<span class="built_in">BuildRoom</span>(<span class="number">2</span>);</span><br><span class="line">    builder.<span class="built_in">BuildRoom</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.GetMaze;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StanderdMazeBuilder</span> :</span> <span class="keyword">public</span> MazeBuilder &#123;    <span class="comment">//这个是ConcreteBuilder</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StandardMazeBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildMaze</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildRoom</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildDoor</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Maze * <span class="title">GetMaze</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Direction <span class="title">CommonWall</span><span class="params">(Room *, Room*)</span></span>;</span><br><span class="line">    Maze * _currentMaze;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StandardMazeBuiler::StandardMazeBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _currentMaze = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StandardMazeBuiler::BuildMaze</span><span class="params">()</span> </span>&#123;    <span class="comment">//这是ConcreteBuilder的BuilPartA</span></span><br><span class="line">        _currentMaze = <span class="keyword">new</span> Maze;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Maze * <span class="title">StandardMazeBuiler::GetMaze</span><span class="params">()</span> </span>&#123;    <span class="comment">//这是ConcreteBuilder的GetResult</span></span><br><span class="line">        Return _currentMaze;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StandardMazeBuiler::BuildRoom</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;    <span class="comment">//这是ConcreteBuilder的BuilPartB</span></span><br><span class="line">    Room * room = <span class="keyword">new</span> <span class="built_in">Room</span>(n);</span><br><span class="line">    room-&gt;<span class="built_in">SetSide</span>(North, <span class="keyword">new</span> Wall);</span><br><span class="line">    room-&gt;<span class="built_in">SetSide</span>(South, <span class="keyword">new</span> Wall);</span><br><span class="line">    room-&gt;<span class="built_in">SetSide</span>(West, <span class="keyword">new</span> Wall);</span><br><span class="line">    room-&gt;<span class="built_in">SetSide</span>(East, <span class="keyword">new</span> Wall);</span><br><span class="line"></span><br><span class="line">    _currentMaze-&gt;<span class="built_in">AddRoom</span>(room)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为Client:</span></span><br><span class="line">Maze *maze;</span><br><span class="line">MazeGame game; <span class="comment">//aDirector</span></span><br><span class="line">StandardMazeBuilder builder; <span class="comment">//aConcreteBuilder</span></span><br><span class="line"></span><br><span class="line">Game.<span class="built_in">CreateMaze</span>(builder); <span class="comment">//Constructor</span></span><br><span class="line">maze = builder.<span class="built_in">GetMaze</span>();  <span class="comment">//getResult</span></span><br></pre></td></tr></table></figure>
<h2 id="10-已知应用"><a href="#10-已知应用" class="headerlink" title="10. 已知应用"></a>10. 已知应用</h2><p>RTF转换器应用来自来自ET++</p>
<h2 id="11-相关模式"><a href="#11-相关模式" class="headerlink" title="11. 相关模式"></a>11. 相关模式</h2><p>Abstract Factory与Builder相似，因为它也可以创建复杂对象。</p>
<p>主要区别是<strong>Builder着重于一步步构造一个复杂对象</strong>。<strong>Abstract Factory着重于多个系列产品对象构造</strong>。</p>
]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(4) 创建型模式 FACTORY METHOD 工厂方法</title>
    <url>/post/5da200/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>本节关于FACTORY METHOD 工厂方法 —— 对象创建模式</p>
<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的<strong>实例化延迟</strong>到其子类。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2. 别名"></a>2. 别名</h2><p>虚构造器（Virtual Constructor）</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3. 动机"></a>3. 动机</h2><p>框架使用抽象类定义和维护对象之间的关系。这些对象的创建通常也由框架负责。</p>
<p>问题：某应用框架向用户显示多个文档。两个主要的抽象是抽象类Application和Document，客户通过其子类来做与具体应用相关的实现。但Application只知道一个新文档何时被创建，而不知道哪一种Document将被创建。这使得：<strong>框架必须实例化类，但它只知道不能被实例化的类。</strong></p>
<p>解决方法如下：</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/FactoryMethod_1.png" alt></p>
<p><strong>封装哪一个Document子类将被创建的信息并将这些信息从该框架中分离出来。</strong>Application的子类重定义Application的抽象操作CreateDocument以返回适合的Document子类对象。一旦一个Application子类实例化后，它就可以实例化与应用相关的文档，而无需知道这些文档的类。</p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4. 适用性"></a>4. 适用性</h2><ul>
<li>当一个类不知道它所必须创建的对象的类</li>
<li>当一个类希望由其子类来指定它所创建的对象</li>
<li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5. 结构"></a>5. 结构</h2><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/FactoryMethod_2.png" alt></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6. 参与者"></a>6. 参与者</h2><ul>
<li>Product(Document)<ul>
<li>定义工厂方法所创建的对象的接口</li>
</ul>
</li>
<li>ConcreteProduct(MyDocument)<ul>
<li>实现Product接口</li>
</ul>
</li>
<li>Creator(Application)<ul>
<li>声明工厂方法，该方法返回一个Product类型的对象。Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象</li>
<li>可以调用工厂方法以创建一个Product对象</li>
</ul>
</li>
<li>ConcreteCreate(MyApplication)<ul>
<li>重定义工厂方法以返回一个ConcreteProduct对象</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7. 协作"></a>7. 协作</h2><ul>
<li>Creator依赖于其子类来定义工厂方法，所以它返回一个适当的ConcreteProduct实例</li>
</ul>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8. 效果"></a>8. 效果</h2><ul>
<li>为子类提供挂钩（hook）</li>
<li>连接平行的类层次</li>
</ul>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9.  实现"></a>9.  实现</h2><ul>
<li><p>Factory Method主要有两种不同的情况</p>
<ul>
<li>Create</li>
</ul>
</li>
</ul>
<ul>
<li>参数化工厂方法</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10. 代码示例"></a>10. 代码示例</h2>]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(6) 对象行为型模式 STATE 状态</title>
    <url>/post/4a9e02a0/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>本节关于STATE 状态模式 —— 对象行为型模式</p>
<h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>允许一个对象<strong>在其内部状态改变时改变它的行为</strong>，以至于对象看起来似乎修改了它的类。</p>
<p>依赖倒转原则：针对接口编程</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2. 别名"></a>2. 别名</h2><p>状态对象 Objects for Status</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3. 动机"></a>3. 动机</h2><p>网络连接的类TCPConnection。一个TCPConnection对象的状态处于若干不同状态之一：Established、Listening、Closed。当一个TCPConnection对象收到其他对象的请求时，它<strong>根据自身的当前状态作出不同反应</strong>。State模式描述了TCPConnection如何在每一种状态下表现出不同的行为。</p>
<p>关键思想——<strong>引入TCPState的抽象类来表示网络的连接状态。TCPState类为各表示不同的操作状态的子类声明一个公共接口。TCPState的子类实现与特定状态相关的行为。</strong></p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/state_1.png" alt></p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4. 适用性"></a>4. 适用性</h2><ul>
<li>一个对象的<strong>行为取决于其状态</strong>，并且它必须<strong>在运行时刻根据状态改变其行为</strong></li>
<li>一个操作中<strong>含有庞大的多分支的条件语句</strong>，且这些<strong>分支依赖于该对象的状态</strong>。该状态通常用一个或多个枚举常量表示。</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5. 结构"></a>5. 结构</h2><h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6. 参与者"></a>6. 参与者</h2><h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7. 协作"></a>7. 协作</h2><h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8. 效果"></a>8. 效果</h2><h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9. 实现"></a>9. 实现</h2><h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10. 代码示例"></a>10. 代码示例</h2><h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11. 已知应用"></a>11. 已知应用</h2>]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(5) 对象行为型模式 Strategy 策略设计模式</title>
    <url>/post/c840ad9/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>定义一系列算法并封装，使它们可相互替换。算法可独立于使用它的客户而变化。</p>
<h2 id="2-别名"><a href="#2-别名" class="headerlink" title="2. 别名"></a>2. 别名</h2><p>Policy</p>
<h2 id="3-动机"><a href="#3-动机" class="headerlink" title="3. 动机"></a>3. 动机</h2><p>考虑许多算法对一个正文流进行分析，不可将算法直接code进使用他们的类。</p>
<p>如下图，定义一些类来封装不同的换行算法。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/strategy_1.png" alt></p>
<p>Composition类维护和更新正文换行，但换行策略是由抽象的Composition的子类各自独立完成。Composition维护对Compositor对象的一个引用。一旦Composition重新格式化其正文，将这个职责转发给它的Compositor对象。<strong>Composition的客户指定使用哪一种Compositor的方法就是将想要的Compositor装入Composition</strong>。</p>
<h2 id="4-适用性"><a href="#4-适用性" class="headerlink" title="4. 适用性"></a>4. 适用性</h2><ul>
<li>许多相关的类仅仅是<strong>行为</strong>有差异。此模式提供一种用多个可选行为中的一个行为配置一个类的方法。</li>
<li>需要使用一个算法的不同变体。同上</li>
<li>算法使用client不不应该知道的数据。可以<strong>隐藏复杂的、与算法相关的数据结构</strong>。</li>
<li>一个类中的多种行为操作以多个条件语句形式出现，可以将<strong>各个条件分支移入各自的Strategy类</strong>以代替条件语句</li>
</ul>
<h2 id="5-结构"><a href="#5-结构" class="headerlink" title="5. 结构"></a>5. 结构</h2><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/strategy_2.png" alt></p>
<h2 id="6-参与者"><a href="#6-参与者" class="headerlink" title="6. 参与者"></a>6. 参与者</h2><ul>
<li>Strategy 策略<ul>
<li>定义所有支持算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。</li>
</ul>
</li>
<li>ConcreteStrategy 具体策略<ul>
<li>以Strategy接口实现某具体算法</li>
</ul>
</li>
<li>Context 上下文<ul>
<li>用一个ConcreteStrategy对象来配置</li>
<li>维护一个对Strategy对象的引用</li>
<li>可定义一个接口来让Strategy访问其数据</li>
</ul>
</li>
</ul>
<h2 id="7-协作"><a href="#7-协作" class="headerlink" title="7. 协作"></a>7. 协作</h2><ul>
<li>Strategy和Context相互作用以实现选定的算法。</li>
<li>Context将它的客户的请求转发给它的Strategy。</li>
</ul>
<h2 id="8-效果"><a href="#8-效果" class="headerlink" title="8. 效果"></a>8. 效果</h2><p>优点</p>
<ol>
<li>相关算法系列</li>
<li>一个替代继承的方法</li>
<li>消除一些条件语句</li>
<li>实现有多种选择</li>
</ol>
<p>缺点</p>
<ol>
<li>客户必须了解不同的Strategy以选择一个合适的Strategy，这将向用户暴露具体的实现问题。</li>
<li>Strategy和Context之间的通信开销。</li>
<li>增加对象的数量。</li>
</ol>
<h2 id="9-实现"><a href="#9-实现" class="headerlink" title="9. 实现"></a>9. 实现</h2><ul>
<li>定义Strategy和Context接口</li>
<li>使用Strategy作为模板参数</li>
<li>使Strategy对象可选</li>
</ul>
<h2 id="10-代码示例"><a href="#10-代码示例" class="headerlink" title="10. 代码示例"></a>10. 代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将值传给Compositor，它使用这些值决定换行的最佳位置</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composition</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">composition</span>(Compositor*);</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">Repair</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	Compositor* _compositor;</span><br><span class="line">    	component* _ components;</span><br><span class="line">    	<span class="keyword">int</span> _componentCount;</span><br><span class="line">    	<span class="keyword">int</span> _lineWidth;</span><br><span class="line">    	<span class="keyword">int</span>* _lineCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类，具体子类定义特定的换行策略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compositor</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Compose</span><span class="params">(Coord natural[], Coord stretch[], Coord shrink[], <span class="keyword">int</span> componentCount, <span class="keyword">int</span> lineWidth, <span class="keyword">int</span> breaks[])</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Compositor</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体子类一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCompositor</span> :</span> <span class="keyword">public</span> Compositor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SimpleCompositor</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Compose</span><span class="params">(Coord natural[], Coord stretch[], Coord shrink[], <span class="keyword">int</span> componentCount, <span class="keyword">int</span> lineWidth, <span class="keyword">int</span> breaks[])</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体子类二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeXCompositor</span> :</span> <span class="keyword">public</span> Compositor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TeXCompositor</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Compose</span><span class="params">(Coord natural[], Coord stretch[], Coord shrink[], <span class="keyword">int</span> componentCount, <span class="keyword">int</span> lineWidth, <span class="keyword">int</span> breaks[])</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化Composition需要把想要使用的Compositor传递给它</span></span><br><span class="line">Composition* quick = <span class="keyword">new</span> <span class="built_in">Composition</span>(<span class="keyword">new</span> SimpleCompositor);</span><br><span class="line">Composition* slick = <span class="keyword">new</span> <span class="built_in">Composition</span>(<span class="keyword">new</span> TeXCompositor);</span><br></pre></td></tr></table></figure>
<h2 id="11-已知应用"><a href="#11-已知应用" class="headerlink" title="11. 已知应用"></a>11. 已知应用</h2><p>ET++和InterViews</p>
]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(8) 两阶段终止模式 （Two-Phase Termination Patter）</title>
    <url>/post/34140c88/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><ul>
<li>当我们想要结束一个线程或者关闭jvm的时候，通过此模式可以优雅安全的关闭线程，让线程可以完成它本应完成的当前任务并可以附加一些收尾工作后再进行关闭</li>
<li>此模式下关闭线程会有一定延迟，主要在于被关闭线程需要执行完后，再进行关闭</li>
<li>首先Java jdk中并没有关于安全的直接的停止线程的Api 我知道你想到了Interrupt。Interrupt快速解读传送门 <a href="http://blog.csdn.net/crazyzxljing0621/article/details/56666418">http://blog.csdn.net/crazyzxljing0621/article/details/56666418</a></li>
</ul>
<p>此模式的设计，就是线程中不断对一个参数进行验证，满足条件时线程跳出并执行结束后的收尾工作，最后安全关闭。</p>
]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(7) 对象行为型模式 VISTOR 访问者</title>
    <url>/post/6a4d4071/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-意图"><a href="#1-意图" class="headerlink" title="1. 意图"></a>1. 意图</h2><p>作用于某对象结构中各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<h2 id="2-动机"><a href="#2-动机" class="headerlink" title="2. 动机"></a>2. 动机</h2><p>对于系统中的某些对象，它们存储在同一个集合中，且具有<strong>不同的类型</strong>，而且对于该集合中的对象，可以接受一类称为<strong>访问者的对象</strong>来访问，而且<strong>不同的访问者其访问方式有所不同</strong>，访问者模式为解决这类问题而诞生。</p>
<p>在实际使用时，对同一集合对象的操作<strong>并不是唯一</strong>的，对相同的元素对象可能存在<strong>多种不同的操作方式</strong>。而且这些操作方式<strong>并不稳定</strong>，可能还需要<strong>增加新的操作</strong>，以满足新的业务需求。</p>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/visitor_2.png" alt></p>
<h2 id="3-适用性"><a href="#3-适用性" class="headerlink" title="3. 适用性"></a>3. 适用性</h2><ul>
<li>一个对象结构包含很多类对象，并相对这些对象实施一些依赖于具体类的操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，并且避免污染这些对象类</li>
<li>用户对对象类比较熟悉，定义对象结构的类很少改变，但需要经常在结构上定义新操作</li>
</ul>
<h2 id="4-结构"><a href="#4-结构" class="headerlink" title="4. 结构"></a>4. 结构</h2><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/visitor_1.png" alt></p>
<h2 id="5-参与者"><a href="#5-参与者" class="headerlink" title="5. 参与者"></a>5. 参与者</h2><ul>
<li>Visitor</li>
<li>ConcreteVisitor</li>
<li>Element</li>
<li>ConcreteElement</li>
<li>ObjectStructure</li>
</ul>
<h2 id="6-协作"><a href="#6-协作" class="headerlink" title="6. 协作"></a>6. 协作</h2><p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/visitor_3.png" alt></p>
<h2 id="7-效果优缺点"><a href="#7-效果（优缺点）" class="headerlink" title="7. 效果（优缺点）"></a>7. 效果（优缺点）</h2><p>优点</p>
<ul>
<li>增加新的操作——增加新的访问者无须修改原有系统，系统具有较好的可扩展性。</li>
<li>集中存在逻辑相关的操作而剥离无关操作</li>
<li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作</li>
<li>可以访问不具有相同父类的对象。可以对一个Visitor接口增加任何类型的对象</li>
<li>累积状态——没有访问者，状态需要作为额外的参数传递给进行便利的操作或定义为全局变量</li>
</ul>
<p>缺点</p>
<ul>
<li>破坏封装——强迫提供访问元素内部状态的公共操作</li>
<li>增加新的ConcreteElement类很困难——每新增一个ConcreteElement类都要在Visitor中添加一个新的抽象操作</li>
</ul>
<h2 id="8-实现"><a href="#8-实现" class="headerlink" title="8. 实现"></a>8. 实现</h2><h2 id="9-代码示例"><a href="#9-代码示例" class="headerlink" title="9. 代码示例"></a>9. 代码示例</h2><p>课上给的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//雇员类 基类</span></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span> string name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> income;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vacationDays;</span><br><span class="line">	<span class="keyword">public</span> string Name&#123;</span><br><span class="line">		get &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">		set &#123; name = value; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> Income&#123;</span><br><span class="line">		get &#123; <span class="keyword">return</span> income; &#125;</span><br><span class="line">		set &#123; income = value; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> VacationDays&#123;</span><br><span class="line">		get &#123; <span class="keyword">return</span> vacationDays; &#125;</span><br><span class="line">		set &#123; vacationDays = value; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function">abstract <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//教师类 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> Employee&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(string name, <span class="keyword">double</span> income,<span class="keyword">int</span> vacationDays)</span></span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">		Income = income;</span><br><span class="line">		VacationDays = vacationDays;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Accept</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">		visitor.<span class="built_in">Visit</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工程师类 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> :</span> Employee&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Engineer</span><span class="params">(string name, <span class="keyword">double</span> income,<span class="keyword">int</span> vacationDays)</span></span>&#123;</span><br><span class="line">		Name = name;</span><br><span class="line">		Income = income;</span><br><span class="line">		VacationDays = vacationDays;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Accept</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">		visitor.<span class="built_in">Visit</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问者类</span></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&#123;</span></span><br><span class="line">	<span class="function">abstract <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Employee element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理收入的访问者类，管理收入是被集中的具体操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncomeVisitor</span> :</span> Visitor</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Employee element)</span></span>&#123;</span><br><span class="line">		element.Income *= <span class="number">1.10</span>;</span><br><span class="line">		Console.<span class="built_in">WriteLine</span>(element.Name + <span class="string">&quot;的新工资是: &quot;</span> + element.Income);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理假期的访问者类，管理假期是被集中的具体操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VacationVisitor</span> :</span> Visitor&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Employee element)</span></span>&#123;</span><br><span class="line">		element.VacationDays += <span class="number">3</span>;</span><br><span class="line">		Console.<span class="built_in">WriteLine</span>(element.Name + <span class="string">&quot;的新假期是&quot;</span> + element.VacationDays);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//雇员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employees</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList employees = <span class="keyword">new</span> <span class="built_in">ArrayList</span>();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">		employees.<span class="built_in">Add</span>(employee);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Detach</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">		employees.<span class="built_in">Remove</span>(employee);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accept</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">		foreach (Employee e in employees)</span><br><span class="line">		e.<span class="built_in">Accept</span>(visitor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span>&#123;</span><br><span class="line">	Teacher zhangsan = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">2500.0</span>, <span class="number">14</span>);</span><br><span class="line">	Engineer lisi = <span class="keyword">new</span> <span class="built_in">Engineer</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">3500.0</span>, <span class="number">16</span>);</span><br><span class="line">	Employees e = <span class="keyword">new</span> <span class="built_in">Employees</span>();</span><br><span class="line">	e.<span class="built_in">Attach</span>(zhangsan);</span><br><span class="line">	e.<span class="built_in">Attach</span>(lisi);</span><br><span class="line">	IncomeVisitor v1 = <span class="keyword">new</span> <span class="built_in">IncomeVisitor</span>();</span><br><span class="line">	VacationVisitor v2 = <span class="keyword">new</span> <span class="built_in">VacationVisitor</span>();</span><br><span class="line">	e.<span class="built_in">Accept</span>(v1);</span><br><span class="line">	e.<span class="built_in">Accept</span>(v2);</span><br><span class="line">	Console.<span class="built_in">Read</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-已知应用"><a href="#10-已知应用" class="headerlink" title="10. 已知应用"></a>10. 已知应用</h2><p>实际工业界的例子</p>
<p>静态程序分析，比如检查代码抄袭——用一段程序分析源代码</p>
<p>特点</p>
<ul>
<li><p>主要特点是Element的结构树非常复杂，各种代码语法成分、各种语句分类、词法、控制流、数据流，如下图所示</p>
</li>
<li><p>代码分析的需求变化频繁</p>
</li>
</ul>
<p><img src="https://songzi-blog-pic.oss-cn-hangzhou.aliyuncs.com/抽象语法树.png" alt></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>存在反面向对象，打破数据+操作 </p>
<p>与面向对象思想相反，不同对象之间存在逻辑关系的操作从类中间剥离，并集合在一起</p>
]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>软件构造之语句</title>
    <url>/post/2aa66caa/</url>
    <content><![CDATA[<h1 id="补指针构造技巧"><a href="#补：指针构造技巧" class="headerlink" title="补：指针构造技巧"></a>补：指针构造技巧</h1><h2 id="按照正确的顺序删除链表中的指针"><a href="#按照正确的顺序删除链表中的指针" class="headerlink" title="按照正确的顺序删除链表中的指针"></a>按照正确的顺序删除链表中的指针</h2><p>可以先新后旧</p>
<h2 id="不要吝啬指针变量的使用-要专建专用"><a href="#不要吝啬指针变量的使用、要专建专用" class="headerlink" title="不要吝啬指针变量的使用、要专建专用"></a>不要吝啬指针变量的使用、要专建专用</h2><h2 id="避免之争的强制类型转换"><a href="#避免之争的强制类型转换" class="headerlink" title="避免之争的强制类型转换"></a>避免之争的强制类型转换</h2><p>错误示范<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = l;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">float *p1 = (float*)p;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除和释放指针"><a href="#删除和释放指针" class="headerlink" title="删除和释放指针"></a>删除和释放指针</h2><p>指针、动态内存…　　悬空指针、二次释放</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Assert(NULL!=pointers, &quot;...&quot;);</span><br><span class="line">delete pointers;</span><br><span class="line">point = NULL;</span><br></pre></td></tr></table></figure>
<p>删除变量之前检查非法指针<br>在删除或释放指针后把他们设为NULL</p>
<h2 id="cs-auto_ptr"><a href="#c-’s-AUTO-PTR" class="headerlink" title="c++’s AUTO_PTR"></a>c++’s AUTO_PTR</h2><p><a href="http://https://en.cppreference.com/w/cpp/memory/auto_ptr">智能指针</a></p>
<p>注意：拷贝和赋值会转移指针所有权</p>
<hr>
<h1 id="语句-statement"><a href="#语句-statement" class="headerlink" title="语句　statement"></a>语句　statement</h1><p><strong>正确性</strong>、<strong>可读性</strong>、<strong>可维护性</strong></p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="首先写正常路径"><a href="#首先写正常路径" class="headerlink" title="首先写正常路径"></a>首先写正常路径</h3><h3 id="检查最后一位else"><a href="#检查最后一位else" class="headerlink" title="检查最后一位else"></a>检查最后一位<code>else</code></h3><h3 id="检查等量的分支"><a href="#检查等量的分支" class="headerlink" title="检查等量的分支"></a>检查等量的分支</h3><h3 id="if后跟一个有意义的子句"><a href="#if后跟一个有意义的子句" class="headerlink" title="if后跟一个有意义的子句"></a><code>if</code>后跟一个有意义的子句</h3><h3 id="布尔函数的策略"><a href="#布尔函数的策略" class="headerlink" title="布尔函数的策略"></a><strong>布尔函数</strong>的策略</h3><p>——例如，短路求值：c++和java以下是正确的<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(i &lt; MAX_ELEMENTS and item[i] &lt;&gt; 0)</span><br></pre></td></tr></table></figure><br>利用短路求值的判断<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((debominator != 0 &amp;&amp; ((item / denominator) &gt; MIN_VALUE))...</span><br></pre></td></tr></table></figure><br>效率用上面的写法，保证正确性的写法是使用嵌套例子</p>
<h3 id="问题深层嵌套-避免的方法"><a href="#问题——深层嵌套-避免的方法" class="headerlink" title="问题——深层嵌套 避免的方法"></a>问题——<strong>深层嵌套</strong> 避免的方法</h3><ol>
<li>重复判断某一部分条件——判断会变得更复杂</li>
<li><p>转换为<code>if-then-else</code></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//不合理的嵌套,需要用更利于理解逻辑的写法</span><br><span class="line">if(10 &lt; quantity)&#123;</span><br><span class="line">	if(100 &lt; quantity)&#123;</span><br><span class="line">		if(1000 &lt; quantity)&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换为<code>case</code></p>
</li>
<li>使用单独的子程序——循环体提取为子程序</li>
<li>使用OO方法——多态，不同的类封装不同的子程序</li>
</ol>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="判断循环是否会终止死循环"><a href="#判断循环是否会终止（死循环）" class="headerlink" title="判断循环是否会终止（死循环）"></a>判断循环是否会终止（死循环）</h3><p>循环种类:<strong>计数循环</strong>、无限循环、迭代器循环、</p>
<h3 id="循环灵活性和检查位置"><a href="#循环灵活性和检查位置" class="headerlink" title="循环灵活性和检查位置"></a>循环灵活性和检查位置</h3><ol>
<li><p><strong>带出口循环</strong>：半循环 改为 带出口的无限循环</p>
<p>把所有退出条件放在一起，防止检测调试时遗漏</p>
</li>
<li>使循环尽量模块化</li>
</ol>
<h3 id="三方面考虑循环控制"><a href="#三方面考虑循环控制" class="headerlink" title="三方面考虑循环控制"></a>三方面考虑循环控制</h3><h4 id="如何进入循环"><a href="#如何进入循环" class="headerlink" title="如何进入循环"></a>如何进入循环</h4><ol>
<li>只从一个位置进入循环——goto不用于跳出循环</li>
<li>初始化代码放在循环前面</li>
<li>while(true) 无限循环</li>
<li>多使用for循环——控制代码集中在一起</li>
<li>在while循环更适用时，不用for——控制部分比较复杂</li>
</ol>
<h4 id="如何退出循环"><a href="#如何退出循环" class="headerlink" title="如何退出循环"></a>如何退出循环</h4><ol>
<li>要确认循环是否终止</li>
<li>终止条件要明显</li>
<li>为了终止循环，改变for的下标值</li>
<li>避免出现依赖于循环下标最终取值的行为——不要在循环终止后继续使用循环下标，因为下标值不可确定，且不易读</li>
</ol>
<p>……</p>
<h3 id="决策点decision-point度量法"><a href="#决策点（DECISION-POINT）度量法" class="headerlink" title="决策点（DECISION POINT）度量法"></a>决策点（DECISION POINT）度量法</h3><h3 id="子程序的多处返回"><a href="#子程序的多处返回" class="headerlink" title="子程序的多处返回"></a>子程序的多处返回</h3><h3 id="缩进层次过深的循环"><a href="#缩进层次过深的循环" class="headerlink" title="缩进层次过深的循环"></a>缩进层次过深的循环</h3><h3 id="使用防卫子句重写"><a href="#使用防卫子句重写" class="headerlink" title="使用防卫子句重写"></a>使用防卫子句重写</h3><h3 id="留心栈空间"><a href="#留心栈空间" class="headerlink" title="留心栈空间"></a>留心栈空间</h3><p><em>递归 = 循环+栈……</em></p>
<h3 id="goto"><a href="#GOTO" class="headerlink" title="GOTO"></a>GOTO</h3>]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>语言学概论</title>
    <url>/post/1a03062b/</url>
    <content><![CDATA[<p>钉子</p>
<h2 id="01-语言能力与语言系统"><a href="#01-语言能力与语言系统" class="headerlink" title="01 语言能力与语言系统"></a>01 语言能力与语言系统</h2><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>重点分析人的先天语言能力及其和语言系统的关系</p>
<ul>
<li>基于任意性原则的语言编码能力（<strong>任意性原则</strong>）</li>
<li>基于类推的还原生成能力（<strong>聚合关系和组合关系</strong>）</li>
<li>区分两种基本单位的能力，即符号的<strong>两层性</strong>。难点！</li>
</ul>
<h3 id="11-易境性"><a href="#1-1-易境性" class="headerlink" title="1.1 易境性"></a>1.1 易境性</h3><p>通过语言传递经验和知识，不一定要“在场”，这和没有语言的“在场”传递方式有根本区别。</p>
<ul>
<li><p>动物交流的特点：<strong>在场传递</strong></p>
<ul>
<li>动物只能获得集体模仿行为，不能获得集体观念。</li>
<li>例如</li>
</ul>
</li>
<li><p>人类：<strong>不在场传递</strong>——<strong>易境性</strong></p>
<ul>
<li><p>在场与直接经验</p>
</li>
<li><p>在场与间接经验</p>
</li>
<li><strong>不在场信息传递</strong>：语言是关键；人类获得经验的方式不需要在场；儿童获得语言前，活动经验的方式和动物相似</li>
</ul>
</li>
</ul>
<h3 id="12-基于类推的还原生成能力"><a href="#1-2-基于类推的还原生成能力" class="headerlink" title="1.2 *基于类推的还原生成能力"></a>1.2 *基于类推的还原生成能力</h3><blockquote>
<p>洪堡特：语言是一种创造性活动（<strong>从单位到句子</strong>）</p>
<p>乔姆斯基：语言是有限规则和单位生成无限的句子</p>
</blockquote>
<p><strong>通过有限的句子<em>还原</em>出有限的规则和单位，并通过这些单位生成无限的句子</strong></p>
<blockquote>
<p>已知：弹钢琴 弹三弦 学吉他 学古琴</p>
<p>未知：弹吉他 弹古琴 学钢琴 学三弦</p>
</blockquote>
<h4 id="人类语言学习的自然还原能力"><a href="#人类语言学习的自然还原能力" class="headerlink" title="人类语言学习的自然还原能力"></a>人类语言学习的自然还原能力</h4><ul>
<li>所谓自然，是指只要存在一定数量的句子，不需要通过人为划分，就可以还原出有限的规则和单位，产生无限的句子</li>
</ul>
<h4 id="儿童还原生成能力观察"><a href="#儿童还原生成能力观察" class="headerlink" title="儿童还原生成能力观察"></a>儿童还原生成能力观察</h4><blockquote>
<p>爸爸吃苹果，妈妈吃梨</p>
</blockquote>
<p>让机器大数据学习自然语言</p>
<h4 id="动物语言能力问题"><a href="#动物语言能力问题" class="headerlink" title="动物语言能力问题"></a>动物语言能力问题</h4><p>多数动物的呼叫或姿态表现是一个整体，不是单位的组合。所以动物的句子是有限的。</p>
<p>目前判断，黑猩猩有一定的生成能力，学习符号能力，但未能观察到还原能力。</p>
<p>因此，局限：不能自动编码，只有被动任意性，缺乏主动任意性；不能还原出单位，类推能力不充分。</p>
<h3 id="13-基于任意性原则的符号编码能力"><a href="#1-3-基于任意性原则的符号编码能力" class="headerlink" title="1.3 * 基于任意性原则的符号编码能力"></a>1.3 * 基于任意性原则的符号编码能力</h3><p><strong>编码能力</strong>：能够在任意性原则上把<strong>所指</strong>和<strong>能指</strong>结合成符号的能力。</p>
<ul>
<li>所指：声音、颜色、图形</li>
<li>能指：声音等对应的概念、事物等</li>
</ul>
<p><strong>任意性</strong>：<strong>词的语音形式A和意义B的关系是任意的</strong>，没有必然联系、因果联系或可论证联系。</p>
<h4 id="动物语言的非任意性的等级"><a href="#动物语言的非任意性的等级" class="headerlink" title="动物语言的非任意性的等级"></a>动物语言的非任意性的等级</h4><ul>
<li>动物语言的形式和意义之间任意性成分很少</li>
<li>有的动物语言具有少量任意性、分等级</li>
<li>动物有些与生俱来的交流行为</li>
</ul>
<p>蜜蜂舞蹈的任意性：蜜蜂进行着社会性学习</p>
<p>黑猩猩的有限编码能力</p>
<h4 id="荀子的任意性思想"><a href="#荀子的任意性思想" class="headerlink" title="荀子的任意性思想"></a>荀子的任意性思想</h4><blockquote>
<p>名无固宜，约之以命。约定俗成谓之宜，异于约则谓之不宜。</p>
</blockquote>
<p>人类可以通过编码创制各种符号系统，但自然语言的编码主要是约定俗成的。</p>
<h4 id="反对任意性-关于音义关联说的两个证据"><a href="#反对任意性、关于音义关联说的两个证据" class="headerlink" title="反对任意性、关于音义关联说的两个证据"></a>反对任意性、关于音义关联说的两个证据</h4><ul>
<li>拟声说：建立在临摹基础上。这两种临摹方式都是有限的，不构成自然语言符号系统的必要条件。</li>
<li>右文说：本质是引申。</li>
</ul>
<h4 id="坚持任意性原则的材料包括"><a href="#坚持任意性原则的材料包括" class="headerlink" title="坚持任意性原则的材料包括"></a>坚持任意性原则的材料包括</h4><ol>
<li>同一个概念在不同的语言中声音不一样</li>
<li>语言中有大量的虚词、抽象词无法象声</li>
</ol>
<h3 id="14-符号的二层性"><a href="#1-4-符号的二层性" class="headerlink" title="1.4 符号的二层性"></a>1.4 符号的二层性</h3><p>指的是自然语言有两种最基本的单位，一种是区别意义的单位，即<strong>音位</strong>；一种是表达意义的单位，即<strong>语素</strong>。</p>
<p>其他符号系统的两层性问题：</p>
<ul>
<li>两层性的文化功能在于用最少的区别性单位表达尽可能多的符号。</li>
<li>在没有两层性的符号系统中，三种颜色只能表达三种符号，在有两层性的符号系统中，三种颜色至少表达6种符号。</li>
<li>两层性意味着可以用<strong>有限的手段</strong>（主要是语音）<strong>产生无限的符号形式</strong>（和有限的符号产生无限的符号组合不一样）</li>
</ul>
<p>人类自然语言由低到高有</p>
<ul>
<li>音位层</li>
<li>音节层</li>
<li>语素层</li>
<li>词汇层</li>
<li>词组层</li>
<li>句子层</li>
</ul>
<p>这些层次中，最重要的是<strong>区别意义层</strong>和<strong>表达意义层</strong>。</p>
<p>音位系统是区别意义层，语素系统是表达意义层。这即是自然语言两层性。</p>
<p>两层性的存在为自然语言提供了足够多的表意单位。</p>
<h3 id="15-语言能力与语言系统之间的关系"><a href="#1-5-语言能力与语言系统之间的关系" class="headerlink" title="1.5 语言能力与语言系统之间的关系"></a>1.5 语言能力与语言系统之间的关系</h3><hr>
<h2 id="第二讲-1语言相对论"><a href="#第二讲-1-语言相对论" class="headerlink" title="第二讲 1.语言相对论"></a>第二讲 1.语言相对论</h2><p>洪堡特 《论人类语言结构的区别及其对人类精神发展的影响》</p>
<blockquote>
<p>每一个人，不管操什么语言，都可以看作是一种特殊世界观的承担者。世界观本身的形成要通过这一手段才能实现……每种语言中都会有自己的世界观。</p>
</blockquote>
<h3 id="沃尔夫"><a href="#沃尔夫" class="headerlink" title="沃尔夫"></a>沃尔夫</h3><h4 id="沃尔夫-论语言-思维和现实"><a href="#沃尔夫-《论语言、思维和现实》" class="headerlink" title="沃尔夫 《论语言、思维和现实》"></a>沃尔夫 《论语言、思维和现实》</h4><ul>
<li>Humboldt-Boas-Sapir-Whorf 语言文化相对论</li>
<li>Saussure-Bloomfield-Harris 结构主义</li>
<li>Humboldt-Chomsky 生成语法</li>
</ul>
<h4 id="沃尔夫的观察隐形范畴"><a href="#沃尔夫的观察：隐形范畴" class="headerlink" title="沃尔夫的观察：隐形范畴"></a>沃尔夫的观察：隐形范畴</h4><ul>
<li>任何“中性”属性的知识也不能告诉我们的观察者为什么指称生物种属的名字（如：动物、鸟、鱼等）用代词it</li>
<li>小动物通常用it；较大的动物经常用he；狗、鹰一般用he；猫一般用she</li>
</ul>
<h4 id="sae标准欧洲语"><a href="#SAE，标准欧洲语" class="headerlink" title="SAE，标准欧洲语"></a>SAE，标准欧洲语</h4><ul>
<li>沃尔夫认为欧洲人都具有<strong>相同的世界图</strong>式，各种科学<strong>观念</strong>都是建立在这个世界图式基础上的。</li>
<li>Hopi语蕴含着不同于SAE所蕴含的世界图式。<ul>
<li>例如Hopi不用空间的词表示时间（汉语可以，如时间很长）</li>
</ul>
</li>
</ul>
<h4 id="沃尔夫-语言相对论"><a href="#沃尔夫-语言相对论" class="headerlink" title="沃尔夫 语言相对论"></a>沃尔夫 语言相对论</h4><ul>
<li>没有哪个人可以毫无偏见地描述自然，即便他认为是最自由的时候，他也被迫采取了某些方式，在这些方面，最自由的人，就是那些熟习了很多差别很大的语言体系的语言学家。迄今为止，还没有一个语言学家具备这样的能力。于是，我得到一个新的相对论原理。</li>
<li>这个原理认为：<strong>同一个物理证据，并不使所有的观察者都得到相同的宇宙图式，除非他们的语言背景相似或相同。</strong></li>
</ul>
<h4 id="沃尔夫思想总结"><a href="#沃尔夫思想总结" class="headerlink" title="沃尔夫思想总结"></a>沃尔夫思想总结</h4><ol>
<li>所有高层次（如何算高？）的思维都依赖语言</li>
<li>习以为常的语言结构影响着我们理解环境的方式，讲不同语言的人具有不同的世界图式。</li>
</ol>
<h3 id="哲学的语言转向"><a href="#哲学的语言转向" class="headerlink" title="哲学的语言转向"></a>哲学的语言转向</h3><h4 id="维特根斯坦"><a href="#维特根斯坦" class="headerlink" title="维特根斯坦"></a>维特根斯坦</h4><blockquote>
<p>凡能够说的，都能够说清楚；凡不能谈论的，就应该保持沉默。 ——逻辑哲学导论</p>
<p>意义即用法。 ——《哲学研究》</p>
</blockquote>
<h4 id="海德格尔"><a href="#海德格尔" class="headerlink" title="海德格尔"></a>海德格尔</h4><p>存在主义的创始人。《存在与时间》《在通向语言的途中》</p>
<ul>
<li>不是我们在说语言，而是语言在说我们</li>
<li><p>语言是栖居的家园</p>
</li>
<li><p>海德格尔认为任何人对“存在”这一重大哲学问题作出解释时都受到前结构(Vorsicht)的约束，这种前结构就是解释者的<strong>先入之见</strong>、<strong>背景知识</strong>和<strong>假设前提</strong>，它们存在于语言之中，因此<strong>对存在的解释就是对语言的解释</strong>（严格来说是对语言书写的文本的解释）</p>
</li>
</ul>
<h3 id="语言相对论的遗留问题"><a href="#语言相对论的遗留问题" class="headerlink" title="语言相对论的遗留问题"></a>语言相对论的遗留问题</h3><p><strong>反对</strong>萨丕尔-沃尔夫假说的人的理由</p>
<ul>
<li>为什么在SAE的基础上能发展成不同的学说？</li>
<li>人们是否只能被动的适应语言的分类？生成性的作用沃尔夫是否没有考虑？语言的差异背后还存在普遍现象。</li>
<li>众多实验</li>
</ul>
<h2 id="第二讲-2思维的四个层面"><a href="#第二讲-2-思维的四个层面" class="headerlink" title="第二讲 2.思维的四个层面"></a>第二讲 2.思维的四个层面</h2><p>为什么会形成语言相对论？<strong>语言与思维的关系</strong></p>
<p>要弄清语言的思维的关系，首先要<strong>弄清一系列重要概念</strong>。</p>
<p>例子：表述有矛盾——“思维离不开语言”    “语言不同，思维相同”</p>
<h3 id="语言能力-语言系统-语言应用"><a href="#语言能力、语言系统、语言应用" class="headerlink" title="语言能力、语言系统、语言应用"></a>语言能力、语言系统、语言应用</h3><p>语言能力生来具有，但是必须掌握一种语言系统，才能进行语言应用</p>
<p>语言能力（共相论）</p>
<ul>
<li>语言能力是由<strong>遗传</strong>决定的</li>
<li>这种能力主要表现（第一讲的任意性、自然还原能力）：<ul>
<li>人类具有通过有限的单位和规则生成无限句子的能力</li>
<li>在一定句子中还原出规则和单位的能力</li>
<li>通过任意性原则将概念和语音形式相结合的编码能力</li>
</ul>
</li>
</ul>
<p>语言系统（自相论或相对论）</p>
<ul>
<li>语言系统是由特定范畴组成的复杂系统，经过漫长的历史形成，并且不断被发展</li>
<li>从历史角度看，它体现了<strong>人类语言能力和后天经验的相互作用</strong></li>
<li>语言运用不仅仅是语言能力的运用，也是语言系统的运用</li>
<li><strong>非遗传的，后天的</strong>？</li>
</ul>
<p>语言运用</p>
<ul>
<li>语言运用不仅仅是语言能力的运用，也是语言系统的运用</li>
<li>Chomsky提到的<strong>和原则相对的参数</strong>，实际上就是由语言系统决定</li>
</ul>
<h3 id="思维的四个层面"><a href="#思维的四个层面" class="headerlink" title="思维的四个层面"></a>思维的四个层面</h3><h4 id="1-思维能力"><a href="#1-思维能力" class="headerlink" title="1. 思维能力"></a>1. 思维能力</h4><ul>
<li>思维能力是天生的，人类进化过程中形成的先天能力</li>
<li>包括<ul>
<li><strong>类比</strong>：比较两个事实或事件的共性和差异</li>
<li><strong>语言能力</strong>：符号化活动</li>
<li><strong>归纳和演绎</strong>：<strong>反思或元分析能力</strong>可以看成归纳和符号化的结果</li>
</ul>
</li>
<li>从儿童智力发展观察，<strong>思维能力先于语言</strong>，而且可以<strong>独立于语言</strong>。</li>
</ul>
<h4 id="2-思维轨迹"><a href="#2-思维轨迹" class="headerlink" title="2. 思维轨迹"></a>2. 思维轨迹</h4><ul>
<li><p>后天形成</p>
</li>
<li><p>思维轨迹是思维能力在语言系统中的实现</p>
</li>
<li>思维轨迹实例分析：<strong>汉语量词</strong>实验<ul>
<li><strong>语言浇铸思维轨迹的根深蒂固性</strong>可以从学习第二语言和人工语言中观察到；轨迹不熟练</li>
</ul>
</li>
<li>思维轨迹实例分析：<strong>进位制转换</strong>实验<ul>
<li>课上的实验</li>
</ul>
</li>
<li>思维能力导致语言普遍性的产生，语言系统导致思维轨迹<strong>差异</strong>的产生。<strong>语言组织经验必然要将经验范畴化</strong>。</li>
<li>对于个体来说，语言轨迹的差异是语言系统<strong>决定</strong>的。<strong>语言浇铸了思维轨迹</strong>。</li>
</ul>
<h4 id="3-思维模式"><a href="#3-思维模式" class="headerlink" title="3. 思维模式"></a>3. 思维模式</h4><ul>
<li>人们运思时形成的一种<strong>范式</strong>。<strong>对整个思维习惯的一种抽象、更高的抽象</strong>。</li>
<li>人们常常按照特定的方式去思维，因而形成了<strong>前后统一的模式</strong>；不同的人、群体、民族因此形成了<strong>不同的范式类型</strong></li>
<li>思维模式中最具代表性的类型是<strong>中西方思维模式</strong>——大多数学者承认<strong>汉民族思维模式的直觉把握特征</strong>和<strong>印欧民族的逻辑分析特征</strong> </li>
</ul>
<h4 id="4-思维方法"><a href="#4-思维方法" class="headerlink" title="4. 思维方法"></a>4. 思维方法</h4><ul>
<li>思维方法是在思维能力、思维轨迹、思维模式的基础上形成的<strong>一种解决问题的策略或技巧</strong>。不仅与以上三个有关，也与<strong>后天习得的知识结构</strong>有关。</li>
<li>例如数学的记忆游戏，一些解密方法</li>
</ul>
<h2 id="第二讲-3-思维的三个阶段"><a href="#第二讲-3-思维的三个阶段" class="headerlink" title="第二讲 3. 思维的三个阶段"></a>第二讲 3. 思维的三个阶段</h2><h3 id="前语言思维"><a href="#前语言思维" class="headerlink" title="前语言思维"></a>前语言思维</h3><ul>
<li>皮亚杰的观察资料</li>
<li>前语言思维是个人的，两种可能<ul>
<li>没有符号化，因此<strong>没有社会化</strong>，观念得不到巩固和继承</li>
<li>也可能这个阶段有一些个人符号，但是个人符号得不到集体的认同——<strong>不稳定</strong></li>
</ul>
</li>
<li>前语言思维没有模式、无序，不能组织复杂的经验活动</li>
</ul>
<h3 id="语言思维"><a href="#语言思维" class="headerlink" title="语言思维"></a>语言思维</h3><ul>
<li>在语言基础上的思维</li>
<li>语言思维有<strong>群体性、有模式（语言浇铸的模式）、有序、能组织复杂的经验活动</strong>。</li>
<li>通过语言有序化的思维轨迹增加了思维活动的广度和深度</li>
<li>语言思维充分利用了语言群体的知识</li>
</ul>
<h3 id="超语言思维"><a href="#超语言思维" class="headerlink" title="超语言思维"></a>超语言思维</h3><ul>
<li>在语言思维的基础上超脱语言思维，如禅宗的领悟、围棋过程、对一幅画的领悟等</li>
</ul>
<h3 id="语言思维的重要性"><a href="#语言思维的重要性" class="headerlink" title="语言思维的重要性"></a>语言思维的重要性</h3><ul>
<li>从文化的群体性看，语言思维最重要。语言浇铸思维轨迹也是在这个层面上展开的。</li>
<li><strong>语言是观察思维的重要窗口</strong>。语言是大脑认知活动最深沉的积淀，最重要的切入点。</li>
</ul>
<hr>
<h2 id="第四讲-1-什么是语素"><a href="#第四讲-1-什么是语素" class="headerlink" title="第四讲 1. 什么是语素"></a>第四讲 1. 什么是语素</h2><h3 id="语素的定义"><a href="#语素的定义" class="headerlink" title="语素的定义"></a>语素的定义</h3><ul>
<li>语素是一级重要的单位，音系、词法、句法研究的基础</li>
<li>语素是<strong>最小的音义结合体</strong></li>
</ul>
<h3 id="聚合关系-组合关系-对比原则"><a href="#聚合关系-组合关系-对比原则" class="headerlink" title="聚合关系 组合关系 对比原则"></a>聚合关系 组合关系 对比原则</h3><h4 id="bloomfield语言论中的对比法"><a href="#Bloomfield《语言论》中的对比法" class="headerlink" title="Bloomfield《语言论》中的对比法"></a>Bloomfield《语言论》中的对比法</h4><p>音义部分相似原则来提取语素</p>
<p>不看了</p>
<hr>
<h2 id="第五讲-1语素与词"><a href="#第五讲-1-语素与词" class="headerlink" title="第五讲 1.语素与词"></a>第五讲 1.语素与词</h2><ul>
<li>语素是最小的有意义的语法单位</li>
<li>词是最小的有意义的能够自由运用的语法单位</li>
</ul>
<h3 id="语素的规则组合和不规则组合"><a href="#语素的规则组合和不规则组合" class="headerlink" title="语素的规则组合和不规则组合"></a>语素的规则组合和不规则组合</h3><ul>
<li>不规则组合：铁路</li>
<li><strong>理解性</strong>规则组合：桌子、盖儿</li>
<li><strong>生成性</strong>规则组合：买书、老张</li>
</ul>
]]></content>
      <categories>
        <category>语言学</category>
      </categories>
      <tags>
        <tag>linguistics</tag>
      </tags>
  </entry>
  <entry>
    <title>软工一</title>
    <url>/post/6a633f42/</url>
    <content><![CDATA[<p>主要介绍</p>
<p>java、面向对象编程、其他</p>
<p>可参考<a href="http://songzi.info/2018/12/28/Java(1">Java(1)—JavaSE</a>—JavaSE/&gt;)</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>软件过程与管理</title>
    <url>/post/3c6c6472/</url>
    <content><![CDATA[<p>管理信息系统——诺兰阶段模型：</p>
<p>前三个——计算机时代、后三个——信息时代</p>
<ul>
<li><strong>初始阶段</strong>：计算机刚进入企业，只作为办公设备使用；企业对计算机基本不了解，少数人使用，并不普及</li>
<li><strong>传播阶段</strong>：企业对计算机有一定了解应用需求增加；但此时缺少规划和计划，应用水平不高，IT整体效用无法显现</li>
<li><strong>控制阶段</strong>：IT投资增长快，但收益不理想，于是在客观上要求组织协调，解决数据共享问题；一些职能部门内部实现网络化，如财务系统、人事系统等；但软件系统之间存在壁垒、“信息孤岛”，信息系统呈现单点、分散的特点，系统和资源利用率不高</li>
<li><strong>集成阶段</strong>：企业的IT建设开始由分散和单点发展成体系。建立集中式的DB及显影的IS；增加大量硬件，预算费用迅速增长</li>
<li><strong>数据管理阶段</strong>：信息成为企业的重要资源；企业开始选定统一的数据库平台、数据管理体系和信息管理平台，统一数据的管理和使用，各部门、各系统基本实现资源整合、信息共享。IT系统的规划及资源利用更加高效。</li>
<li><strong>成熟阶段</strong>：企业真正把IT同管理过程结合起来，将组织内部、外部的资源充分整合和利用，从而提升了企业的竞争力和发展潜力。</li>
</ul>
<h1 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h1><h2 id="生命周期模型与软件过程"><a href="#生命周期模型与软件过程" class="headerlink" title="生命周期模型与软件过程"></a>生命周期模型与软件过程</h2><h3 id="典型生命周期模型"><a href="#典型生命周期模型" class="headerlink" title="典型生命周期模型"></a>典型生命周期模型</h3><ul>
<li><strong>瀑布模型</strong><ul>
<li>最基本最有效、严格按照<strong>需求 -&gt;分析-&gt;设计-&gt;编码-&gt;测试</strong>的阶段进行；</li>
<li>保证整个软件产品较高的质量,保证缺陷能够提前的被发现和解决；</li>
<li>前期需求不明确,而又很难短时间明确清楚的项目则很难很好的利用瀑布模型</li>
</ul>
</li>
<li><strong>螺旋模型</strong><ul>
<li>遵从瀑布模型的.即需求-&gt;架构-&gt;设计-&gt;开发-&gt;测试的路线，将瀑布模型的多个阶段转化到多个迭代过程中。</li>
<li>螺旋模型的每一次迭代只包含了瀑布模型的某一个或两个阶段.。如第二次迭代重点是需求,第三次迭代是总体设计和后续设计开发计划等。</li>
<li>因此这是和RUP提倡 的迭代模型是有区别的,RUP（Rational Unified Process统一软件开发过程）的每一次迭代都会包含需求,设计,开发和测试等各个阶段的活动。RUP迭代的目的在于逐步求精而不是仅仅完成瀑布模型某一阶段的工作.</li>
</ul>
</li>
<li><strong>增量和迭代式模型</strong><ul>
<li>假设现在要开发 A,B,C,D四个大的业务功能,每个功能都需要开发两周的时间</li>
<li>对于增量方法而言可以将<strong>四个功能分为两次增量</strong>来完成,<strong>第一个增量完成A,B功能</strong>,第二 次增量完成C,D功能;<strong>先一后二</strong></li>
<li>对于迭代开发来将则是<strong>分两次迭代来开发</strong>,第一次迭代完成A,B,C,D四个基本业务功能但不含复杂的业务逻辑,而第二个功能再逐渐<strong>细化补充完整</strong>相关的业务逻辑原型法；<strong>逐步完善</strong></li>
</ul>
</li>
<li><strong>原型法</strong><ul>
<li>启发式的方法，没有经验，没有过多需求分析，需要调研和挖掘功能的时候使用</li>
</ul>
</li>
<li>快速和敏捷方法论</li>
</ul>
<p>管理的目的——为了让软件过程在<strong>开发效率、质量</strong>等方面有着更好的<strong>性能绩效</strong></p>
<h1 id="软件过程的历史演变和经典工作"><a href="#软件过程的历史演变和经典工作" class="headerlink" title="软件过程的历史演变和经典工作"></a>软件过程的历史演变和经典工作</h1><h3 id="三大阶段"><a href="#三大阶段" class="headerlink" title="三大阶段"></a>三大阶段</h3><ul>
<li>软硬件一体化阶段（50年代~10年代）<ul>
<li>软件完全依附于硬件</li>
<li>软件作坊</li>
</ul>
</li>
<li>软件成为独立的产品（70年代~90年代）</li>
<li>网络化和服务化（90年代中期至今）<ul>
<li>软件功能更复杂，规模更大</li>
<li>用户数量急剧增加</li>
<li>快速演化和需求不确定</li>
<li>分发方式的变化（SaaS）</li>
</ul>
</li>
</ul>
<h3 id="成熟度模型-cmmi模型"><a href="#成熟度模型-CMMI模型：" class="headerlink" title="成熟度模型 CMMI模型："></a>成熟度模型 <strong>CMMI模型</strong>：</h3><ul>
<li>Level1: Initial</li>
<li>Level2: Managed</li>
<li>Level3: Defined</li>
<li>Level4: Quantitatively Managed</li>
<li>Level5: Optimizing</li>
</ul>
<p>过程改进模型而非软件过程或者软件过程模型</p>
<h3 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h3><ul>
<li><strong>个体和互动</strong>胜过流程和工具</li>
<li><strong>可以工作的软件</strong>胜过详尽的文档</li>
<li><strong>客户合作</strong>胜过合同谈判</li>
<li><strong>响应变化</strong>胜过遵循计划</li>
</ul>
<h3 id="典型软件实践方法"><a href="#典型软件实践方法" class="headerlink" title="典型软件实践方法"></a>典型软件实践方法</h3><ul>
<li>XP方法：偏重于工程实践的描述</li>
<li>SCRUM:管理框架和管理时间</li>
<li>Kanban：精益生产；可视化工作流、限定WIP、管理周期时间</li>
<li>开源软件开发</li>
</ul>
<p>DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。”</p>
<h3 id="软件开发典型特征"><a href="#软件开发典型特征" class="headerlink" title="软件开发典型特征"></a>软件开发典型特征</h3><ul>
<li>空前强大的开发和部署环境——XaaS<ul>
<li>IaaS</li>
<li>PaaS</li>
<li>SaaS、FaaS</li>
</ul>
</li>
<li>共享文化</li>
<li>潜在支撑——AI, Bigdata, Cloud…</li>
</ul>
<h3 id="典型devops实践和方法"><a href="#典型Devops实践和方法" class="headerlink" title="典型Devops实践和方法"></a>典型Devops实践和方法</h3><ul>
<li>方法论基础是<strong>敏捷软件开发</strong>、<strong>精益思想</strong>、<strong>看板方法</strong></li>
<li>以领域驱动设计为指导的微服务架构方法</li>
<li>大量虚拟化技术的使用</li>
<li>一切皆服务XaaS</li>
<li>构件强大的工具链，支持高水平自动化</li>
</ul>
<p>用户名1：15801939795  密码：gGvs3ib4kxeLvvE</p>
<p>用户名2：18801595789  密码：DevOpsFrank</p>
<h3 id="敏捷软件开发敏捷宣言"><a href="#敏捷软件开发；敏捷宣言" class="headerlink" title="敏捷软件开发；敏捷宣言"></a>敏捷软件开发；敏捷宣言</h3><p>Agile敏捷 Lean精益</p>
<h3 id="看板方法"><a href="#看板方法" class="headerlink" title="看板方法"></a>看板方法</h3><p>渐进增量式的过程改进方法学</p>
<h4 id="可视化工作流程项目可视化"><a href="#可视化工作流程——项目可视化" class="headerlink" title="可视化工作流程——项目可视化"></a>可视化工作流程——项目可视化</h4><p>使用物理白板——信息辐射器；电子看板——冰箱</p>
<p>使用白板</p>
<ol>
<li><p>为每个工作项建立一个记事贴</p>
</li>
<li><p>用列映射团队工作流——可视化工作流</p>
<ul>
<li>每列标识工作流的一部分</li>
<li>应当包含工作全部阶段，从工作进入到工作离开团队</li>
<li>PDCA：检视并调整</li>
</ul>
</li>
</ol>
<p>所有的工作显示在白板上，信息传递给所有人，沟通交流成本被极大地降低   </p>
<p>白板上的工作项</p>
<ul>
<li>工作项描述</li>
<li>电子系统中的唯一标识</li>
<li>完成期限</li>
<li>谁在处理这个工作项</li>
<li><p>工作类型（bug or 常规工作）</p>
<p>尽可能保证每个工作项的工作量不要偏差太大（3天）</p>
</li>
</ul>
<h4 id="限制进行中的工作"><a href="#限制进行中的工作" class="headerlink" title="限制进行中的工作"></a>限制进行中的工作</h4><p><strong>个人效率</strong>、<strong>团队效率</strong></p>
<p>减少在制品使快速流过整个工作流，可以使前置时间缩短</p>
<p>个人效率下降，但团队的效率增加了</p>
<p>在制品规模高会有工作闲置；在制品规模低会有人要闲置</p>
<h3 id="精益-lean"><a href="#精益-Lean" class="headerlink" title="精益 Lean"></a>精益 Lean</h3><p>起源于制造业 丰田</p>
<ul>
<li><strong>消除浪费</strong></li>
<li>增强学习</li>
<li>尽量延迟决定：早期很多信息是得不到的</li>
<li>尽快发布</li>
<li>下放授权</li>
<li>内置完整性</li>
<li>全局优化</li>
</ul>
<h4 id="消除浪费"><a href="#消除浪费" class="headerlink" title="消除浪费"></a>消除浪费</h4><p>任何不能为用户创造价值的做法都是浪费</p>
<ul>
<li>创建不必要的功能和产品</li>
<li>需求管理不当</li>
<li>返工</li>
<li>不必要的复杂解决方案</li>
<li>过度认知负担</li>
<li>心理压力</li>
<li>等待、多任务（相互等待）WIP</li>
<li>无效沟通</li>
</ul>
<h1 id="psp-个体软件过程"><a href="#PSP-个体软件过程" class="headerlink" title="PSP 个体软件过程"></a>PSP 个体软件过程</h1><p>TDD（Test-Driven Development, 测试驱动开发）已经成为现代软件开发中非常重要的概念之一。</p>
<p>CI（Continuous Integration）持续集成，最重要的服务对象是TDD，它是一个集合概念，包括自动构建build项目，自动分析代码，自动测试，自动邮件报告，自动预编译检查，自动发布等等，这些都围绕一个中心词“Auto”，当然它不能帮您自动完成代码 ：）。所有这些操作，直接解放了项目管理者，每日构建集成（Build every day）将会很大程度上提高项目的稳定性，代码的健壮性及随时反馈。</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑学导论</title>
    <url>/post/39b513f9/</url>
    <content><![CDATA[<h1 id="学习课程"><a href="#学习课程" class="headerlink" title="学习课程"></a>学习课程</h1><p><a href="https://www.coursera.org/learn/logic-introduction/home/info">Introduction to Logic - Stanford University - 课程信息 | Coursera</a></p>
<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul>
<li>熟悉逻辑学的基本术语、重要概念</li>
<li>逻辑训练： 自然语言和论点如何被形式化及分析</li>
</ul>
<h1 id="1-introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p> key elements of Logic : <strong>logical sentences, logical entailment, and logical proofs</strong></p>
<h2 id="11-interpersonal-relationship-的例子"><a href="#1-1-Interpersonal-relationship-的例子" class="headerlink" title="1.1 Interpersonal relationship 的例子"></a>1.1 Interpersonal relationship 的例子</h2><p><img src="http://intrologic.stanford.edu/images/worldall.png" alt="img"></p>
<p>给定四个女孩，有 16 种可能的 likes relationship 实例 - Abby 喜欢 Abby，Abby 喜欢 Bess，Abby 喜欢 Cody，Abby 喜欢 Dana，Bess 喜欢 Abby，等等。这十六个中的每一个都可以是真或假。这些真假可能性有 2^16 (65,536) 种可能的组合，因此有 2^16 个可能的世界。</p>
<h2 id="12-logical-sentences"><a href="#1-2-logical-sentences" class="headerlink" title="1.2 logical sentences"></a>1.2 logical sentences</h2><blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>Dana likes Cody.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Abby does <strong>not</strong> like Dana.</td>
</tr>
<tr>
<td>Dana does <strong>not</strong> like Abby.</td>
</tr>
<tr>
<td>Bess likes Cody <strong>or</strong> Dana.</td>
</tr>
<tr>
<td>Abby likes <strong>everyone</strong> that Bess likes.</td>
</tr>
<tr>
<td>Cody likes <strong>everyone</strong> who likes her.</td>
</tr>
<tr>
<td><strong>Nobody</strong> likes herself</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<p>这类的句子限制了世界的可能方式。每个句子将上述2^16种可能世界分为两个子集，其中句子为真和句子为假。</p>
<p>给定两个句子，我们知道世界必须在第一个句子为<code>True</code>的世界集合和第二个句子为<code>True</code>的世界集合的交集中。理想情况下，当我们有足够的句子时，我们就可以确切地知道事情的发展。</p>
<h2 id="13-logical-entailment"><a href="#1-3-logical-entailment" class="headerlink" title="1.3 logical entailment"></a>1.3 logical entailment</h2><p>即使一组句子不能确定一个唯一的世界，但通常情况下，某些句子在满足给定句子的每个世界中都是正确的。这类句子被称为从给定句子中得出的<em>逻辑结论 logical conclusion</em> </p>
<p>检查一组句子在逻辑上<strong>是否包含结论</strong>的一种方法：检查给定句子为<strong>真</strong>的所有世界的集合。</p>
<h2 id="14-logical-proofs"><a href="#1-4-logical-proofs" class="headerlink" title="1.4 logical proofs"></a>1.4 logical proofs</h2><p>然而，通过穷举并检查所有可能性来确定<em>logical entailment</em>通常是不切实际的。此外，在某些情况下，可能世界的数量是<em>无限</em>的。因此穷举法并不都是可行的。</p>
<p>另一种选择是<em>逻辑推理 logical proofs</em>，即。推理规则的应用得出逻辑结论和产生逻辑证明。(the application of <strong>reasoning rules</strong> to derive <strong>logical conclusions</strong> and produce <strong>logical proofs</strong> , ie sequences of reasoning steps that leads from premises to conclusions)</p>
<h3 id="推理模式-reasoning-patterns"><a href="#推理模式-reasoning-patterns" class="headerlink" title="推理模式 reasoning patterns"></a>推理模式 reasoning patterns</h3><p>for well-behaved logics, logical entailment and provability are identical - a set of premises logically entails a conclusion if and only if the conclusion is provable from the premises.</p>
<p>举例子：</p>
<blockquote>
<p>All Accords are Hondas.<br>All Hondas are Japanese.<br>Therefore, all Accords are Japanese.</p>
</blockquote>
<p>其推理模式则是</p>
<blockquote>
<p><em>所有 x 都是 y。</em><br><em>所有 y 都是 z。</em><br><em>因此，所有 x 都是 z。</em></p>
</blockquote>
<p>这种推理模式是逻辑的基础，但也有很重要的问题——<strong>哪些模式是正确的？</strong></p>
<p>完全错误的推理模式如下</p>
<blockquote>
<p><em>所有 x 都是 y。</em><br><em>一些 y 是 z。</em><br><em>因此，一些 x 是 z。</em></p>
</blockquote>
<p>但是这种推理模式可能会得出正确的结论、也可能会得出错误的结论</p>
<p>因此，正确模式与不正确模式的区别在于，<strong>它必须<em>始终</em>得出正确的结论——即只要它们所基于的前提是正确的，它们就必须是正确的</strong>。这也是<strong><em>演绎(deduction)</em></strong>的定义标准。</p>
<h3 id="推理模式的种类"><a href="#推理模式的种类" class="headerlink" title="推理模式的种类"></a>推理模式的种类</h3><ul>
<li>演绎 Deduction 如上所述</li>
</ul>
<p>有一些不符合这种严格的正确模式的定义，但是很好用：</p>
<ul>
<li><p>归纳 Induction </p>
</li>
<li><blockquote>
<p><em>I have seen 1000 black ravens.</em><br><em>I have never seen a raven that is not black.</em><br><em>Therefore, every raven is black.</em><br>Now try red Hondas.</p>
</blockquote>
</li>
<li><p>溯因 Abduction </p>
</li>
<li><blockquote>
<p><em>If there is no fuel, the car will not start.</em><br><em>If there is no spark, the car will not start.</em><br><em>There is spark.</em><br><em>The car will not start.</em><br><em>Therefore, there is no fuel.</em><br>What if the car is in a vacuum chamber?</p>
</blockquote>
</li>
<li><p>类比 analogy </p>
</li>
<li><blockquote>
<p><em>The flow in a pipe is proportional to its diameter.</em><br><em>Wires are like pipes.</em><br><em>Therefore, the current in a wire is proportional to diameter.</em><br>Now try price.</p>
</blockquote>
</li>
</ul>
<h2 id="15-形式化-formalization"><a href="#1-5-形式化-Formalization" class="headerlink" title="1.5 形式化 Formalization"></a>1.5 形式化 Formalization</h2><p>自然语言存在局限性：复杂、暧昧、模糊、对语言的错误理解会导致推理上的错误<br>例如： <em>There’s a girl in the room with a telescope</em>. 我是说有一个女孩在一个装有望远镜的房间里吗？还是我说房间里有一个女孩，她拿着望远镜？</p>
<p>用自然语言句子推理时会出现错误的说明。<br>例子：利用关系的传递性规则</p>
<ul>
<li>正确的情况<ul>
<li>Champagne is better than beer.<br>Beer is better than soda.<br>Therefore, champagne is better than soda.</li>
</ul>
</li>
<li>错误的情况<ul>
<li>Bad dessert is better than nothing.<br>Nothing is better than good dessert.<br>Therefore, bad dessert is better than good dessert.</li>
</ul>
</li>
</ul>
<h3 id="formalization-in-reasoning"><a href="#Formalization-in-reasoning" class="headerlink" title="Formalization in reasoning"></a>Formalization in reasoning</h3><p>Logic eliminates these difficulties through the use of <strong>a formal language for encoding information</strong>. 例如代数应用问题。</p>
<p>考虑以下逻辑问题</p>
<blockquote>
<p><em>If Mary loves Pat, then Mary loves Quincy. If it is Monday and raining, then Mary loves Pat or Quincy. If it is Monday and raining, does Mary love Quincy?</em></p>
</blockquote>
<p>第一步：形式化</p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="27.135ex" height="2.161ex" role="img" focusable="false" viewbox="0 -750 11993.6 955"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(780.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z" transform="translate(278,0)"/></g><g data-mml-node="mi" transform="translate(2114.6,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mi" transform="translate(3165.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(3694.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4145.6,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4635.6,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mi" transform="translate(5316.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(5801.6,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(6286.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(6752.6,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mi" transform="translate(7503.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(8032.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(8393.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">的</text></g><g data-mml-node="mi" transform="translate(9293.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">可</text></g><g data-mml-node="mi" transform="translate(10193.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">能</text></g><g data-mml-node="mi" transform="translate(11093.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">性</text></g></g></g></svg></mjx-container>
</div>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="30.635ex" height="2.161ex" role="img" focusable="false" viewbox="0 -750 13540.6 955"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(737.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z" transform="translate(278,0)"/></g><g data-mml-node="mi" transform="translate(2071.6,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mi" transform="translate(3122.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(3651.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4102.6,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4592.6,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mi" transform="translate(5273.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(5758.6,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(6243.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(6709.6,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"/></g><g data-mml-node="mi" transform="translate(7500.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(8072.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(8417.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(9017.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(9450.6,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(9940.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">的</text></g><g data-mml-node="mi" transform="translate(10840.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">可</text></g><g data-mml-node="mi" transform="translate(11740.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">能</text></g><g data-mml-node="mi" transform="translate(12640.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">性</text></g></g></g></svg></mjx-container>
</div>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex" xmlns="http://www.w3.org/2000/svg" width="25.994ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 11489.6 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1155.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z" transform="translate(278,0)"/></g><g data-mml-node="mi" transform="translate(2489.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">当</text></g><g data-mml-node="mi" transform="translate(3389.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">天</text></g><g data-mml-node="mi" transform="translate(4289.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">是</text></g><g data-mml-node="mi" transform="translate(5189.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">星</text></g><g data-mml-node="mi" transform="translate(6089.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">期</text></g><g data-mml-node="mi" transform="translate(6989.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">一</text></g><g data-mml-node="mi" transform="translate(7889.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">的</text></g><g data-mml-node="mi" transform="translate(8789.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">可</text></g><g data-mml-node="mi" transform="translate(9689.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">能</text></g><g data-mml-node="mi" transform="translate(10589.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">性</text></g></g></g></svg></mjx-container>
</div>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex" xmlns="http://www.w3.org/2000/svg" width="20.956ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 9262.6 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(728.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z" transform="translate(278,0)"/></g><g data-mml-node="mi" transform="translate(2062.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">当</text></g><g data-mml-node="mi" transform="translate(2962.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">天</text></g><g data-mml-node="mi" transform="translate(3862.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">下</text></g><g data-mml-node="mi" transform="translate(4762.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">雨</text></g><g data-mml-node="mi" transform="translate(5662.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">的</text></g><g data-mml-node="mi" transform="translate(6562.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">可</text></g><g data-mml-node="mi" transform="translate(7462.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">能</text></g><g data-mml-node="mi" transform="translate(8362.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">性</text></g></g></g></svg></mjx-container>
</div>


<p>第二步：</p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="5.698ex" height="1.627ex" role="img" focusable="false" viewbox="0 -525 2518.6 719"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(780.8,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"/></g><g data-mml-node="mi" transform="translate(2058.6,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g></g></svg></mjx-container>
</div>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="13.734ex" height="1.792ex" role="img" focusable="false" viewbox="0 -598 6070.4 792"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1100.2,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(1989.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2718.2,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"/></g><g data-mml-node="mi" transform="translate(3996,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(4721.2,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mi" transform="translate(5610.4,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g></g></svg></mjx-container>
</div>

<p>第三步：</p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="24.065ex" height="2.009ex" role="img" focusable="false" viewbox="0 -694 10636.6 888"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mn" transform="translate(503,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1003,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mo" transform="translate(1670,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(2114.7,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(2559.3,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(3004,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(3671,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(4174,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(4972.8,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"/></g><g data-mml-node="mi" transform="translate(6250.6,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mn" transform="translate(6710.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7210.6,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mo" transform="translate(7877.6,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(8322.2,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(8766.9,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(9211.6,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mi" transform="translate(9878.6,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(10338.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g></g></g></svg></mjx-container>
</div>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="25.361ex" height="1.561ex" role="img" focusable="false" viewbox="0 -666 11209.6 690"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(451,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(951,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mo" transform="translate(1618,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(2062.7,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(2507.3,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(2952,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(3619,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4070,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5225.8,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"/></g><g data-mml-node="mi" transform="translate(6503.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mn" transform="translate(6972.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7472.6,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mo" transform="translate(8139.6,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(8584.2,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(9028.9,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(9473.6,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mi" transform="translate(10140.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(10609.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>
</div>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="50.935ex" height="2.009ex" role="img" focusable="false" viewbox="0 -694 22513.4 888"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mn" transform="translate(503,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1003,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mo" transform="translate(1670,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(2114.7,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(2559.3,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(3004,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(3671,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(4174,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(4917.2,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(5806.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(6257.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(6757.4,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mo" transform="translate(7424.4,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(7869.1,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(8313.8,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(8758.4,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(9425.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(9876.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(11032.2,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"/></g><g data-mml-node="mi" transform="translate(12310,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mn" transform="translate(12770,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(13270,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mo" transform="translate(13937,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(14381.7,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(14826.3,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(15271,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mi" transform="translate(15938,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(16398,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mo" transform="translate(16918.2,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mi" transform="translate(17807.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mn" transform="translate(18276.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(18776.4,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mo" transform="translate(19443.4,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(19888.1,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(20332.8,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mo" transform="translate(20777.4,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mi" transform="translate(21444.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(21913.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>
</div>

<p>得出结论</p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="10.081ex" height="1.792ex" role="img" focusable="false" viewbox="0 -598 4456 792"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1100.2,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(1989.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2718.2,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"/></g><g data-mml-node="mi" transform="translate(3996,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g></g></svg></mjx-container>
</div>

<p>即：如果是星期一下雨，那么玛丽爱昆西</p>
<h2 id="16-自动化-automation"><a href="#1-6-自动化-Automation" class="headerlink" title="1.6 自动化 Automation"></a>1.6 自动化 Automation</h2><p>主要是逻辑的应用</p>
<h2 id="17-之后的课程内容"><a href="#1-7-之后的课程内容" class="headerlink" title="1.7 之后的课程内容"></a>1.7 之后的课程内容</h2><p>分为三个部分 命题逻辑、关系逻辑、功能逻辑</p>
<ol>
<li><em>Propositional Logic</em> is the logic of propositions. Symbols in the language represent “conditions” in the world, and complex sentences in the language express interrelationships among these conditions. The primary operators are Boolean connectives, such as <em>and</em>, <em>or</em>, and <em>not</em>.</li>
<li><em>Relational Logic</em> expands upon Propositional Logic by providing a means for explicitly talking about individual objects and their interrelationships (not just monolithic conditions). In order to do so, we expand our language to include object constants and relation constants, variables and quantifiers.</li>
<li><em>Functional Logic</em> takes us one step further by providing a means for describing worlds with infinitely many objects. The resulting logic is much more powerful than Propositional Logic and Relational Logic. Unfortunately, as we shall see, some of the nice computational properties of the first two logics are lost as a result.</li>
</ol>
<h1 id="2-命题逻辑-propositional-logic"><a href="#2-命题逻辑-Propositional-Logic" class="headerlink" title="2. 命题逻辑 Propositional Logic"></a>2. 命题逻辑 Propositional Logic</h1><h2 id="21-introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1 Introduction"></a>2.1 Introduction</h2><p>粗略地说，<strong><em>命题</em>是世界的一种可能情况</strong>，既可以为真、也可以为假。 A proposition is a possible condition of the world that is either true or false, eg the possibility that it is raining, the possibility that it is cloudy, and so forth.</p>
<p>本章内容：命题逻辑语言的句法规则 the syntactic rules 、truth assignment、a mechanical method for evaluating sentences for a given truth assignment、a mechanical method for finding truth assignments that satisfy sentences</p>
<h2 id="22-syntax-语法"><a href="#2-2-Syntax-语法" class="headerlink" title="2.2 Syntax 语法"></a>2.2 Syntax 语法</h2><p>命题逻辑，包含两种类型的句子：</p>
<ul>
<li>简单句 simple sentences：表示关于世界的简单事实</li>
<li>复合句 compound sentences：表示组成复合句的简单句之间的逻辑关系</li>
</ul>
<p>简单句子经常被称为 <strong>命题常数proposition constants</strong>，有时被称为<strong>逻辑常数 logical constants </strong>命题常数 写成由字母、数字、下划线组成的字符串：<code>raining_or_snowing</code> <code>raining</code>(类似变量取名)</p>
<p>复杂句子有简单句子组成，表达简单句子之间的逻辑关系。有五种类型 <strong>否定 negations, 合取 conjunctions, 析取 disjunctions, 蕴含 implications, and 双重条件 biconditionals</strong>.</p>
<ul>
<li><p>negations = negation operator ¬  + an arbitrary sentence，称为 target</p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.407ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1948 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(389,0)"><g data-mml-node="mo"><path data-c="AC" d="M56 323T56 336T70 356H596Q603 353 611 343V102Q598 89 591 89Q587 89 584 90T579 94T575 98T572 102L571 209V316H70Q56 323 56 336Z"/></g></g><g data-mml-node="mi" transform="translate(1056,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1559,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>
</div>
</li>
<li><p>conjunction = sentences separated by occurrences of the ∧ operator and enclosed in parentheses，组成的句子称为<em>conjuncts</em></p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.453ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2852.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1114.2,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(2003.4,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2463.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>
</div>
</li>
<li><p>disjunction = sentences separated by occurrences of the ∨ operator and enclosed in parentheses，组成的句子称为<em>disjuncts</em></p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.453ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2852.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1114.2,0)"><path data-c="2228" d="M55 580Q56 587 61 592T75 598Q86 598 96 580L333 48L570 580Q579 596 586 597Q588 598 591 598Q609 598 611 580Q611 574 546 426T415 132T348 -15Q343 -22 333 -22T318 -15Q317 -14 252 131T121 425T55 580Z"/></g><g data-mml-node="mi" transform="translate(2003.4,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2463.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>
</div>
</li>
<li><p>implication = sentences separated by the ⇒ operator and enclosed in parentheses，符号左边称为<em>前件 antecedent</em>，右边称为<em>后件 consequent</em></p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.458ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3296.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1169.8,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"/></g><g data-mml-node="mi" transform="translate(2447.6,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2907.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>
</div>
</li>
<li><p>biconditional = a implication + a reverse implication</p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.458ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3296.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1169.8,0)"><path data-c="21D4" d="M308 524Q318 526 323 526Q340 526 340 514Q340 507 336 499Q326 476 314 454T292 417T274 391T260 374L255 368Q255 367 500 367Q744 367 744 368L739 374Q734 379 726 390T707 416T685 453T663 499Q658 511 658 515Q658 525 680 525Q687 524 690 523T695 519T701 507Q766 359 902 287Q921 276 939 269T961 259T966 250Q966 246 965 244T960 240T949 236T930 228T902 213Q763 137 701 -7Q697 -16 695 -19T690 -23T680 -25Q658 -25 658 -15Q658 -11 663 1Q673 24 685 46T707 83T725 109T739 126L744 132Q744 133 500 133Q255 133 255 132L260 126Q265 121 273 110T292 84T314 47T336 1Q341 -11 341 -15Q341 -25 319 -25Q312 -24 309 -23T304 -19T298 -7Q233 141 97 213Q83 221 70 227T51 235T41 239T35 243T34 250T35 256T40 261T51 265T70 273T97 287Q235 363 299 509Q305 522 308 524ZM792 319L783 327H216Q183 294 120 256L110 250L120 244Q173 212 207 181L216 173H783L792 181Q826 212 879 244L889 250L879 256Q826 288 792 319Z"/></g><g data-mml-node="mi" transform="translate(2447.6,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2907.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>
</div>
</li>
<li><p>注意：上述的五个符号的优先级从上到下依次降低，即先计算上面的符号。例如</p>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="18.942ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8372.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="AC" d="M56 323T56 336T70 356H596Q603 353 611 343V102Q598 89 591 89Q587 89 584 90T579 94T575 98T572 102L571 209V316H70Q56 323 56 336Z"/></g></g><g data-mml-node="mi" transform="translate(667,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(1392.2,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(2281.4,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(3019.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(4075,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mo" transform="translate(4464,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4853,0)"><g data-mml-node="mo"><path data-c="AC" d="M56 323T56 336T70 356H596Q603 353 611 343V102Q598 89 591 89Q587 89 584 90T579 94T575 98T572 102L571 209V316H70Q56 323 56 336Z"/></g></g><g data-mml-node="mi" transform="translate(5520,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(6023,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(6634.2,0)"><path data-c="2227" d="M318 591Q325 598 333 598Q344 598 348 591Q349 590 414 445T545 151T611 -4Q609 -22 591 -22Q588 -22 586 -21T581 -20T577 -17T575 -13T572 -9T570 -4L333 528L96 -4Q87 -20 80 -21Q78 -22 75 -22Q57 -22 55 -4Q55 2 120 150T251 444T318 591Z"/></g><g data-mml-node="mi" transform="translate(7523.4,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(7983.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>
</div>
<div>
<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="27.013ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 11939.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(780.8,0)"><path data-c="21D4" d="M308 524Q318 526 323 526Q340 526 340 514Q340 507 336 499Q326 476 314 454T292 417T274 391T260 374L255 368Q255 367 500 367Q744 367 744 368L739 374Q734 379 726 390T707 416T685 453T663 499Q658 511 658 515Q658 525 680 525Q687 524 690 523T695 519T701 507Q766 359 902 287Q921 276 939 269T961 259T966 250Q966 246 965 244T960 240T949 236T930 228T902 213Q763 137 701 -7Q697 -16 695 -19T690 -23T680 -25Q658 -25 658 -15Q658 -11 663 1Q673 24 685 46T707 83T725 109T739 126L744 132Q744 133 500 133Q255 133 255 132L260 126Q265 121 273 110T292 84T314 47T336 1Q341 -11 341 -15Q341 -25 319 -25Q312 -24 309 -23T304 -19T298 -7Q233 141 97 213Q83 221 70 227T51 235T41 239T35 243T34 250T35 256T40 261T51 265T70 273T97 287Q235 363 299 509Q305 522 308 524ZM792 319L783 327H216Q183 294 120 256L110 250L120 244Q173 212 207 181L216 173H783L792 181Q826 212 879 244L889 250L879 256Q826 288 792 319Z"/></g><g data-mml-node="mi" transform="translate(2058.6,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2796.3,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"/></g><g data-mml-node="mi" transform="translate(4074.1,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4802.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(5858.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(6247.7,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mo" transform="translate(7028.4,0)"><path data-c="21D4" d="M308 524Q318 526 323 526Q340 526 340 514Q340 507 336 499Q326 476 314 454T292 417T274 391T260 374L255 368Q255 367 500 367Q744 367 744 368L739 374Q734 379 726 390T707 416T685 453T663 499Q658 511 658 515Q658 525 680 525Q687 524 690 523T695 519T701 507Q766 359 902 287Q921 276 939 269T961 259T966 250Q966 246 965 244T960 240T949 236T930 228T902 213Q763 137 701 -7Q697 -16 695 -19T690 -23T680 -25Q658 -25 658 -15Q658 -11 663 1Q673 24 685 46T707 83T725 109T739 126L744 132Q744 133 500 133Q255 133 255 132L260 126Q265 121 273 110T292 84T314 47T336 1Q341 -11 341 -15Q341 -25 319 -25Q312 -24 309 -23T304 -19T298 -7Q233 141 97 213Q83 221 70 227T51 235T41 239T35 243T34 250T35 256T40 261T51 265T70 273T97 287Q235 363 299 509Q305 522 308 524ZM792 319L783 327H216Q183 294 120 256L110 250L120 244Q173 212 207 181L216 173H783L792 181Q826 212 879 244L889 250L879 256Q826 288 792 319Z"/></g><g data-mml-node="mo" transform="translate(8306.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(8695.2,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(9433,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"/></g><g data-mml-node="mi" transform="translate(10710.8,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(11161.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(11550.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>
</div>
</li>
<li><p>优先级一致的符号，从左往右计算</p>
</li>
</ul>
<h2 id="23-semantics-语义"><a href="#2-3-Semantics-语义" class="headerlink" title="2.3 Semantics 语义"></a>2.3 Semantics 语义</h2><p>逻辑中对语义的处理，类似代数中的处理。逻辑同代数一样，不关心命题常数在现实世界中的意义，而关心<strong>简单句的真值</strong>和<strong>包含简单句的复杂句的真值</strong>之间的关系。</p>
<p>真值分配 a truth assignment： a <em>truth assignment</em> for a propositional vocabulary is a function assigning a truth value to each of the proposition constants of the vocabulary<br>虽然不关心现实世界中的意义，但是将真值分配明确并考虑各种分配是必要的。</p>
<p>真值与五种运算</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>φ</strong></th>
<th><strong>¬φ</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>φ</strong></th>
<th><strong>φ</strong></th>
<th><strong>φ ∧ φ</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>φ</strong></th>
<th><strong>φ</strong></th>
<th><strong>φ ∨ φ</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>实质蕴含 material implication: 当且仅当其前件为真且其后件为假时，implication的真值为假；否则，真值为true。<br>| <strong>φ</strong> | <strong>φ</strong> | <strong>φ ⇒ φ</strong> |<br>| ——- | ——- | ————- |<br>| 1     | 1     | 1         |<br>| 1     | 0     | 0         |<br>| 0     | 1     | 1         |<br>| 0     | 0     | 1         |</p>
<p>当且仅当其成分的真值一致时，biconditional 才是真的<br>| <strong>φ</strong> | <strong>φ</strong> | <strong>φ ⇔ φ</strong> |<br>| ——- | ——- | ————- |<br>| 1     | 1     | 1         |<br>| 1     | 0     | 0         |<br>| 0     | 1     | 0         |<br>| 0     | 0     | 1         |</p>
<h2 id="24-evaluation"><a href="#2-4-Evaluation" class="headerlink" title="2.4 Evaluation"></a>2.4 Evaluation</h2><p>Evaluation = 在给定命题常数真值的真值分配的情况下确定复合句子真值的过程</p>
<p>已知，</p>
<script type="math/tex; mode=display">
p^i = 0 \\
q^i = 1 \\
r^i = 0</script><p>在这种情况下，j 不满足 <code>( p ∨ q ) ∧ (¬ q ∨ r )</code>，推导过程：</p>
<script type="math/tex; mode=display">
(p ∨ q) ∧ (¬q ∨ r)</script><script type="math/tex; mode=display">
(0 ∨ 1) ∧ (¬1 ∨ 0)</script><script type="math/tex; mode=display">
1 ∧ 0</script><script type="math/tex; mode=display">
0</script><h2 id="25-satisfaction-可满足性"><a href="#2-5-Satisfaction-可满足性" class="headerlink" title="2.5 Satisfaction 可满足性"></a>2.5 Satisfaction 可满足性</h2><p><em>Satisfaction</em> is the opposite of evaluation.<br>我们从一个或多个复合句子开始，并试图找出哪些真值分配满足这些句子。<br>本节使用truth tables的方法</p>
<p>考虑 <code>p ∨ q ⇒ q ∧ r</code>，为p q r构建一个真值表来满足这个句子的所有真值分配</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>r</th>
<th>p ∨ q ⇒ q ∧ r</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<h1 id="3-命题分析-propositional-analysis"><a href="#3-命题分析-Propositional-Analysis" class="headerlink" title="3. 命题分析 Propositional Analysis"></a>3. 命题分析 Propositional Analysis</h1><h2 id="本章内容"><a href="#本章内容：" class="headerlink" title="本章内容："></a>本章内容：</h2><ul>
<li>单个句子的逻辑属性 <strong>logical properties</strong>（并非句子之间的关系）：validity, contingency, and unsatisfiability 有效性、偶然性、不满足性</li>
<li>句子之间的逻辑关系 <strong>logical relationship</strong>：logical entailment, logical equivalence, and logical consistency. 包含、等价、一致</li>
<li>单个句子的逻辑属性、句子之间的逻辑关系 之间的关系</li>
</ul>
<h2 id="32-逻辑属性-logical-properties"><a href="#3-2-逻辑属性-logical-properties" class="headerlink" title="3.2  逻辑属性 logical properties"></a>3.2  逻辑属性 logical properties</h2><p>三个不相交的类别</p>
<h3 id="321-valid"><a href="#3-2-1-valid" class="headerlink" title="3.2.1 valid"></a>3.2.1 valid</h3><ol>
<li>valid：A sentence is valid if and only if it is satisfied by every truth assignment.<script type="math/tex; mode=display">
( p ∨ ¬ p )</script></li>
</ol>
<p>以上句子为valid，p = true or false，结果都为true</p>
<h3 id="322-unsatisfiable"><a href="#3-2-2-unsatisfiable" class="headerlink" title="3.2.2 unsatisfiable"></a>3.2.2 unsatisfiable</h3><ol>
<li><p>unsatisfiable：A sentence is unsatisfiable if and only if it is not satisfied by any truth assignment.</p>
<script type="math/tex; mode=display">
( p ∧ - p )</script></li>
<li></li>
</ol>
<p>以上句子为unsatisfiable，p = true or false，结果都为false</p>
<h3 id="323-contingent"><a href="#3-2-3-contingent" class="headerlink" title="3.2.3 contingent"></a>3.2.3 contingent</h3><ol>
<li>contingent ：a sentence is contingent if and only if there is some truth assignment that satisfies it and some truth assignment that falsifies it.<script type="math/tex; mode=display">
( p ∧ q )</script></li>
</ol>
<p>以上句子为contingent，p 、q = true or false，true false都有可能</p>
<h3 id="324-satisfiable"><a href="#3-2-4-satisfiable" class="headerlink" title="3.2.4 satisfiable"></a>3.2.4 satisfiable</h3><p>将以上三中类别再合并成两组：</p>
<ol>
<li>satisfiable = valid + contingent</li>
<li>unsatisfiable</li>
</ol>
<h2 id="33-逻辑关系-logical-relationship"><a href="#3-3-逻辑关系-logical-relationship" class="headerlink" title="3.3  逻辑关系 logical relationship"></a>3.3  逻辑关系 logical relationship</h2><h3 id="331-等价关系-logical-equivalence"><a href="#3-3-1-等价关系-Logical-Equivalence" class="headerlink" title="3.3.1 等价关系 Logical Equivalence"></a>3.3.1 等价关系 Logical Equivalence</h3><p>a sentence φ is logically equivalent to a sentence ψ if and only if every truth assignment that satisfies φ satisfies ψ and every truth assignment that satisfies ψ satisfies φ.<br>每个满足 φ 的真值赋值都满足 ψ并且每个满足 ψ 的真值赋值都满足 φ</p>
<p>例如 ：句子 <strong>¬( <em>p</em> ∨ <em>q</em> )</strong> 在逻辑上等价于句子 <strong>(¬ <em>p</em> ∧ ¬ <em>q</em> )</strong>。如果<em>p</em>和<em>q</em>都为真，那么这两个句子都是假的。如果<em>p</em>为真或<em>q</em>为真，则第一句为假。同样，如果<em>p</em>为真或<em>q</em>为真，则第二个句子为假。由于两个句子都满足相同的真值分配，因此它们在逻辑上是等价的。</p>
<p>substitutability 可替代性</p>
<ul>
<li>等价关系的一个重要特性</li>
<li>如果一个句子 φ 在逻辑上等价于一个句子 ψ，那么我们可以在任何命题逻辑句子中用 φ 代替 ψ，结果将在逻辑上等价于原句。（但是这在 Relational Logic 并不完全正确）</li>
</ul>
<h3 id="332-蕴含关系-logical-entailment"><a href="#3-3-2-蕴含关系-Logical-Entailment" class="headerlink" title="3.3.2 蕴含关系 Logical Entailment"></a>3.3.2 蕴含关系 Logical Entailment</h3><script type="math/tex; mode=display">
Δ ⊨ ψ</script><p>满足 Δ 中所有句子的每个真值分配也满足 ψ<br>a set of sentences Δ logically entails a sentence ψ (written Δ ⊨ ψ) if and only if every truth assignment that satisfies all of the sentences in Δ also satisfies ψ.</p>
<p>例子：<em>p</em>在逻辑上包含句子 ( <em>p</em> ∨ <em>q</em> )。因为只要其中一个为真，( <em>p</em> ∨ <em>q</em> )就为真，因此，只要<em>p为真，(</em> <em>p</em> ∨ <em>q</em> ) 就必须为真。另一方面，句子<em>p</em>在逻辑上不包含 ( p <em>∧</em> q <em>)</em>。一个连词当且仅当它的两连词都为真且<em>q</em>可能为假时才为真。因此可以写作</p>
<script type="math/tex; mode=display">
p ⊨  ( p ∨ q )</script><h3 id="333-逻辑一致性-logical-consistency"><a href="#3-3-3-逻辑一致性-Logical-Consistency" class="headerlink" title="3.3.3 逻辑一致性  Logical Consistency"></a>3.3.3 逻辑一致性  Logical Consistency</h3><p>a sentence φ is consistent with a sentence ψ if and only if there is a truth assignment that satisfies both φ and ψ.</p>
<p>例如：句子 ( <em>p</em> ∨ <em>q</em>) 与句子 (¬ <em>p</em> ∨ ¬ <em>q</em> ) 一致，与 (¬ <em>p</em> ∧ ¬ <em>q</em>)不一致。第2、3行的赋值使 <em>p</em> ∨ <em>q</em> 与 ¬<em>p</em> ∨ ¬<em>q</em> 真值相同，而不存在赋值使得 <em>p</em> ∨ <em>q</em> 与 <em>  ¬</em>p<em> ∧ ¬</em>q* 真值相同。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th><em>p</em> ∨ <em>q</em></th>
<th>¬<em>p</em> ∨ ¬<em>q</em></th>
<th>¬<em>p</em> ∧ ¬<em>q</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>两个句子在逻辑上一致，不等同于两个句子在逻辑上等价，也不等同于一个句子在逻辑上包含另一个</p>
<p>如果一个句子是不可满足的，那么就没有满足它的真值分配。因此，根据定义，满足 该不可满足的句子的每个真值分配（当然这并不存在）都可以满足另一个句子。<br><strong>any unsatisfiable sentence or set of sentences logically entails everything</strong><br>这也就是为什么要在逻辑推理中避免unsatisfiable的句子集</p>
<h2 id="34-属性和关系之间的联系-connections-between-properties-and-relationships"><a href="#3-4-属性和关系之间的联系-Connections-Between-Properties-and-Relationships" class="headerlink" title="3.4 属性和关系之间的联系 Connections Between Properties and Relationships"></a>3.4 属性和关系之间的联系 Connections Between Properties and Relationships</h2><h3 id="341-等价定理-equivalence-theorem"><a href="#3-4-1-等价定理-Equivalence-Theorem" class="headerlink" title="3.4.1 等价定理 Equivalence Theorem"></a>3.4.1 等价定理 Equivalence Theorem</h3><p>当且仅当句子 (φ ⇔ ψ) 有效时，句子 φ 和句子 ψ 在逻辑上是等价的。</p>
<h3 id="342-演绎定理-deduction-theorem"><a href="#3-4-2-演绎定理-Deduction-Theorem" class="headerlink" title="3.4.2 演绎定理 Deduction Theorem"></a>3.4.2 演绎定理 Deduction Theorem</h3><p>当且仅当 (φ ⇒ ψ) 有效时，一个句子 φ 在逻辑上包含一个句子 ψ。</p>
<p>更一般地，当且仅当复合句 (φ 1 ∧ … ∧ φ <em>n</em> ⇒ φ) 有效时，一组有限的句子 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.493ex" xmlns="http://www.w3.org/2000/svg" width="10.489ex" height="2ex" role="img" focusable="false" viewbox="0 -666 4636 884"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D711" d="M92 210Q92 176 106 149T142 108T185 85T220 72L235 70L237 71L250 112Q268 170 283 211T322 299T370 375T429 423T502 442Q547 442 582 410T618 302Q618 224 575 152T457 35T299 -10Q273 -10 273 -12L266 -48Q260 -83 252 -125T241 -179Q236 -203 215 -212Q204 -218 190 -218Q159 -215 159 -185Q159 -175 214 -2L209 0Q204 2 195 5T173 14T147 28T120 46T94 71T71 103T56 142T50 190Q50 238 76 311T149 431H162Q183 431 183 423Q183 417 175 409Q134 361 114 300T92 210ZM574 278Q574 320 550 344T486 369Q437 369 394 329T323 218Q309 184 295 109L286 64Q304 62 306 62Q423 62 498 131T574 278Z"/></g><g data-mml-node="mn" transform="translate(654,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1154,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(1598.7,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mo" transform="translate(2937.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3382,0)"><path data-c="1D711" d="M92 210Q92 176 106 149T142 108T185 85T220 72L235 70L237 71L250 112Q268 170 283 211T322 299T370 375T429 423T502 442Q547 442 582 410T618 302Q618 224 575 152T457 35T299 -10Q273 -10 273 -12L266 -48Q260 -83 252 -125T241 -179Q236 -203 215 -212Q204 -218 190 -218Q159 -215 159 -185Q159 -175 214 -2L209 0Q204 2 195 5T173 14T147 28T120 46T94 71T71 103T56 142T50 190Q50 238 76 311T149 431H162Q183 431 183 423Q183 417 175 409Q134 361 114 300T92 210ZM574 278Q574 320 550 344T486 369Q437 369 394 329T323 218Q309 184 295 109L286 64Q304 62 306 62Q423 62 498 131T574 278Z"/></g><g data-mml-node="mi" transform="translate(4036,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 在逻辑上包含 φ</p>
<h3 id="343-不可满足定理-unsatisfiability-theorem"><a href="#3-4-3-不可满足定理-Unsatisfiability-Theorem" class="headerlink" title="3.4.3 不可满足定理 Unsatisfiability Theorem"></a>3.4.3 不可满足定理 Unsatisfiability Theorem</h3><p>当且仅当句子集合 Δ ∪ {¬φ} 不可满足时，一组句子 Δ 在逻辑上包含一个句子 φ。</p>
<h3 id="344-一致性定理-consistency-theorem"><a href="#3-4-4-一致性定理-Consistency-Theorem" class="headerlink" title="3.4.4 一致性定理 Consistency Theorem"></a>3.4.4 一致性定理 Consistency Theorem</h3><p>当且仅当句子 (φ ∧ ψ) 可满足时，句子 φ 与句子 ψ 逻辑上一致。</p>
<p>更一般地，当且仅当复合句 (φ 1 ∧ … ∧ φ <em>n</em> ∧ φ) 是可满足的时，句子 φ 与有限的句子集 {φ 1 , … , φ n } 在逻辑上是一致的。</p>
<h2 id="35-等价重写-equivalence-rewritings"><a href="#3-5-等价重写-Equivalence-Rewritings" class="headerlink" title="3.5 等价重写 Equivalence Rewritings"></a>3.5 等价重写 Equivalence Rewritings</h2><script type="math/tex; mode=display">
¬¬φ ⇔ φ</script><script type="math/tex; mode=display">
¬¬φ ⇔ φ
¬(φ ∧ ψ) ⇔ (¬φ ∨ ¬ψ)</script><script type="math/tex; mode=display">
(φ ⇒ ψ) ⇔ (¬φ ∨ ψ)</script><script type="math/tex; mode=display">
(φ ⇔ ψ) ⇔ (φ ⇒ ψ) ∧ (ψ ⇒ φ)</script><h1 id="4-直接证明-direct-proofs"><a href="#4-直接证明-Direct-Proofs" class="headerlink" title="4. 直接证明 Direct Proofs"></a>4. 直接证明 Direct Proofs</h1><h2 id="41-本章内容"><a href="#4-1-本章内容" class="headerlink" title="4.1 本章内容"></a>4.1 本章内容</h2><ul>
<li>axiom schemas 公理, rules of inference 推理规则, direct proofs 直接证明</li>
<li>证明系统：the Hilbert system ；判断证明系统的标准： soundness and completeness 健全性、完整性</li>
<li>hierarchical proofs and meta-theorems about proofs. 层次证明与证明的元定义</li>
</ul>
<h2 id="42-公理模式-axiom-schemas"><a href="#4-2-公理模式-axiom-schemas" class="headerlink" title="4.2 公理模式 axiom schemas"></a>4.2 公理模式 axiom schemas</h2><p>公理模式是个在<a href="https://zh.wikipedia.org/wiki/公理系统">公理系统</a>的语言中的一个<a href="https://zh.wikipedia.org/wiki/合式公式">合式公式</a>，其中有一个以上的<a href="https://zh.wikipedia.org/w/index.php?title=模式變數&amp;action=edit&amp;redlink=1">模式变数</a>出现。这些模式变数属于<a href="https://zh.wikipedia.org/wiki/元語言">元语言</a>的一种，代表系统内的任一<a href="https://zh.wikipedia.org/wiki/一階邏輯#項">项</a>或任一<a href="https://zh.wikipedia.org/wiki/一階邏輯#公式">公式</a>。这些变数通常需要有部分是<a href="https://zh.wikipedia.org/w/index.php?title=自由變數&amp;action=edit&amp;redlink=1">自由</a>的，亦即有些不出现在公式或项中的变数。</p>
<script type="math/tex; mode=display">
φ ⇒ (ψ ⇒ φ)</script><p>当且仅当模式中每个实例都有效时，公理模式才有效。</p>
<script type="math/tex; mode=display">
Reflexivity\\ φ ⇒ φ</script><script type="math/tex; mode=display">
Negation Elimination \\    ¬¬φ ⇒ φ</script><script type="math/tex; mode=display">
Negation Introduction \\    φ ⇒ ¬¬φ</script><script type="math/tex; mode=display">
Tautology \\    φ ∨ ¬φ</script><h2 id="43-推理规则-rules-of-inference"><a href="#4-3-推理规则-rules-of-inference" class="headerlink" title="4.3 推理规则 rules of inference"></a>4.3 推理规则 rules of inference</h2><p>推理规则是一种推理模式。由一些模式（称为 前提premises ），和一个或多个附加模式（称为结论conclusions）组成。推理规则可写成下面这种形式，线以上的属于前提，线以下的属于结论。</p>
<script type="math/tex; mode=display">
\begin{align}
&φ ⇒ ψ \\\\
&φ\\\\
\hline
&ψ\\\\
\end{align}</script><ul>
<li>蕴含消除 Implication Elimination (or IE)</li>
</ul>
<p>eliminates the implication from the first premise</p>
<script type="math/tex; mode=display">
\begin{align}&φ ⇒ ψ \\\\&φ\\\\\hline&ψ\\\\\end{align}</script><ul>
<li>蕴含分布 <em>Implication Distribution</em> (ID)</li>
</ul>
<p>Implication can be distributed over other implications. If (φ ⇒ (ψ ⇒ χ)) is true, then we can infer ((φ ⇒ ψ) ⇒ (φ ⇒ χ)).</p>
<script type="math/tex; mode=display">
\begin{align}
&φ ⇒ (ψ ⇒ χ)\\\\
\hline
&(φ ⇒ ψ) ⇒ (φ ⇒ χ)\\\\
\end{align}</script><ul>
<li>蕴含反转<em>Implication Reversal</em> (IR) </li>
</ul>
<p>allows us to infer an implication if we have an implication with the arguments reversed and negated. If we know (¬ψ ⇒ ¬φ), we can infer (φ ⇒ ψ).</p>
<script type="math/tex; mode=display">
\begin{align}
&¬ψ ⇒ ¬φ\\\\ 
\hline
&φ ⇒ ψ \\\\
\end{align}</script><p>也可以用复杂句代替普通变量</p>
<script type="math/tex; mode=display">
\begin{align}
&(p ⇒ q) ⇒ (q ⇒ r)\\\\
&(p ⇒ q)\\\\
\hline
&(q ⇒ r)\\\\
\end{align}</script><h2 id="44-直接证明-direct-proofs"><a href="#4-4-直接证明-Direct-Proofs" class="headerlink" title="4.4 直接证明 Direct Proofs"></a>4.4 直接证明 Direct Proofs</h2><p>同一组前提的结论的直接证明。是一系列以结论结尾的句子，其中每一项要么是</p>
<ul>
<li>(1) a premise,  前提</li>
<li>(2) an instance of an axiom schema, 公理模式的实例</li>
<li>(3) the result of applying a rule of inference to earlier items in sequence. 前项的推理结果</li>
</ul>
<p>例子如下</p>
<script type="math/tex; mode=display">
\begin{align}
&1. \\; p    &Premise\\\\
&2.\\;    p ⇒ q    &Premise\\\\
&3.\\;    (p ⇒ q) ⇒ (q ⇒ r)    &Premise\\\\
&4.\\;    q    &Implication Elimination: 2, 1\\\\
&5.\\;    q ⇒ r    &Implication Elimination: 3, 2\\\\
&6.\\;    r    &Implication Elimination: 5, 4\\\\
\end{align}</script><p>另举一例</p>
<script type="math/tex; mode=display">
\begin{align}
&1.\\;    p ⇒ q    &Premise\\\\
&2.\\;    q ⇒ r    &Premise\\\\
&3.\\;    p ⇒ (q ⇒ r)    &Implication Creation: 2\\\\
&4.\\;    (p ⇒ q) ⇒ (p ⇒ r)    &Implication Distribution: 3\\\\
&5.\\;    p ⇒ r    &Implication Elimination: 4, 1\\\\
\end{align}</script><p>令 R 为一组推理规则。如果使用 R 中的推理规则在一组 Δ 的前提中存在一个句子 φ 的证明，我们说 φ 可以使用 R 从 Δ<em>证明</em>。我们通常使用可证明算子 ⊢ (有时称为单闸门 <em>turnstile</em>），将其写为 </p>
<script type="math/tex; mode=display">
Δ ⊢ R_φ</script><p>如果从上下文中可以清楚地看到规则集，我们通常只写</p>
<script type="math/tex; mode=display">
Δ ⊢ φ</script><h2 id="45-证明系统-proof-systemshibert-system"><a href="#4-5-证明系统-Proof-Systems：Hibert-System" class="headerlink" title="4.5 证明系统 Proof Systems：Hibert System"></a>4.5 证明系统 Proof Systems：<em>Hibert System</em></h2><p>此处只讨论 <strong>有效公理模式</strong>和<strong>健全的推理规则</strong>的证明系统</p>
<p><em>Hibert System</em>属于命题逻辑证明系统，它有一个推理规则 为 Implication Elimination</p>
<script type="math/tex; mode=display">
\begin{align}&φ ⇒ ψ \\\\&φ\\\\\hline&ψ\\\\\end{align}</script><p><em>Hibert System</em>有三个公理模式</p>
<script type="math/tex; mode=display">
\begin{align}
&Implication Creation (IC)    &φ &⇒ (ψ ⇒ φ)\\\\
&Implication Distribution (ID)    &(φ ⇒ (ψ ⇒ χ)) &⇒ ((φ ⇒ ψ) ⇒ (φ ⇒ χ))\\\\
&Implication Reversal (IR)    &(¬ψ ⇒ ¬φ) &⇒ (φ ⇒ ψ)\\\\
\end{align}</script><p>举个例子，前提：（<em>p⇒q</em>）和（<em>q⇒r</em>）；目标：证明（<em>p⇒r</em>）</p>
<script type="math/tex; mode=display">
\begin{align}
&1.\\;    p ⇒ q    &Premise\\\\
&2.\\;    q ⇒ r    &Premise\\\\
&3.\\;    (q ⇒ r) ⇒ (p ⇒ (q ⇒ r))    &Implication Creation\\\\
&4.\\;    p ⇒ (q ⇒ r)    &Implication Elimination: 3, 2\\\\
&5.\\;    (p ⇒ (q ⇒ r)) ⇒ ((p ⇒ q) ⇒ (p ⇒ r))    &Implication Distribution\\\\
&6.\\;    (p ⇒ q) ⇒ (p ⇒ r)    &Implication Elimination: 5, 4\\\\
&7.\\;    p ⇒ r    &Implication Elimination: 6, 1\\\\
\end{align}</script>]]></content>
      <categories>
        <category>逻辑</category>
      </categories>
      <tags>
        <tag>logic</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑错误</title>
    <url>/post/b9b1da5a/</url>
    <content><![CDATA[<h1 id="01-稻草人-straw-man"><a href="#01-稻草人-Straw-man" class="headerlink" title="01 稻草人 Straw man"></a><strong>01 稻草人 Straw man</strong></h1><p>夸张、歪曲，甚至凭空创造别人的观点，来让你的观点显得更加合理。用“稻草人”来比喻这种情况，是因为稻草人本身是薄弱的，所谓打击稻草人，就是专门捡出别人论述里的一些薄弱细节，加以歪曲和攻击。</p>
<p><strong>例如：</strong></p>
<ol>
<li>某专家去世，A评论了他的学术水平。<br>B说，人都死了，你竟敢评价他的学术水平？你对死者太不敬了。如果没有他，有你吗？大师又走了一个，现在再也没有这样的大师了，再也培养不出这样的大师了。呜呼哀哉，中国的传统文化灭亡了。</li>
<li>某大V发微博：今天天气好差。<br>路人：呵呵，发这博文就是居心叵测。美国几十年前污染更严重，想要空气好你到美国去啊！别在中国呆着。</li>
<li>甲：同性恋是正当的，且一点都不可耻。<br>乙：你去跟你爸妈、学校、公司公开说同性恋是正当的呀！不敢的话你敢说同性恋是正当的吗？（“正当”和“敢公开宣扬”并无必然关系。）</li>
<li>卅猫说政府应该在健康和教育上投入更多。w子回应道：“你这么不爱国，居然想减少国防开支来让国家处于危险中。</li>
</ol>
<h1 id="02-错误归因-false-cause"><a href="#02-错误归因-False-Cause" class="headerlink" title="02 错误归因 False Cause"></a><strong>02 错误归因 False Cause</strong></h1><p>看到了两个事物同时存在，就觉得其中一个事物是另一个的起因。</p>
<p>错误在于，同时存在的两个事物未必有因果关系，可能这两个事物有共同的起因，或者两个事物根本没有因果关系，它们直接的共存只是巧合。</p>
<p><strong>例如：</strong></p>
<ol>
<li>因为我国人民做菜油烟太大，所以才会造成空气质量这么差！</li>
<li>儿子考试成绩那么差，一定是因为他天天玩游戏机的关系。</li>
<li>某名校有学生坠楼，所以说名校学业压力太大了，我们的教育体制太糟糕了。</li>
<li>你看村里的狗蛋连自己名字都不会写，还能成为包工头身价上千万，所以读书并没有什么用。</li>
<li>A指出温度在这几个世纪不断上升，与此同时海盗的数量在减少。由此得出海盗能降低全球温度，进而认为全球变暖就是一个骗局。</li>
</ol>
<h1 id="03-诉诸感情-appeal-to-emotion"><a href="#03-诉诸感情-Appeal-to-Emotion" class="headerlink" title="03 诉诸感情 Appeal to Emotion"></a><strong>03 诉诸感情 Appeal to Emotion</strong></h1><p>试图通过操作别人的感情来取代一个有力的论述。操作的感情可能包括恐惧、嫉妒、怜悯、骄傲等等。</p>
<p>一个逻辑严谨的论述可能激起别人的情感波动，但是如果只用感情操作而不用逻辑论述，那你就犯了诉诸感情的错误。</p>
<p>每个心智健康的人都会受感情影响，所以这种谬误很有效。</p>
<p><strong>例如：</strong></p>
<ol>
<li>爱狗人士对吃狗肉的人说：“你怎么可以吃狗肉，狗狗是人类最好的朋友，你忍心伤害朋友吗？”</li>
<li>某明星在演唱会上被曝出假唱，招致网友的负面评价。他的粉丝在评论里反击网友道：“为什么要这么黑他！你知道他有多不容易吗？你知道他一路走来，有多努力吗？” </li>
<li>如果你是受害者父母，你还会认为判处药家鑫死刑是不对的吗？</li>
<li>你家里就没有老人/孩子/孕妇/病人/……吗？</li>
<li>你不给老人让座，就是不尊重中华民族的传统美德，就是犯罪！</li>
<li>我都是为你好！我怎么可能害你呢？</li>
<li>A不想吃羊脑和剁碎的甘蓝，母亲教育他说世界上还有许多吃不上饭的孩子。</li>
</ol>
<h1 id="04-诉诸权威-appeal-to-authority"><a href="#04-诉诸权威-Appeal-to-Authority" class="headerlink" title="04 诉诸权威 Appeal to Authority"></a><strong>04 诉诸权威 Appeal to Authority</strong></h1><p>利用一个权威人物/机构的观点来取代一个有力的论述。但权威人物/机构也是会犯错误的，所以不能无条件地假设合理性。</p>
<p><strong>例如：</strong></p>
<ol>
<li>听爸妈的，你考公务员一定是没错的，铁饭碗！</li>
<li>某某专家说，吃绿豆就不会得癌症。</li>
<li>某某名人说过，真理总是掌握在少数人手里的。</li>
<li>无法反驳进化论，A便搪塞道自己认识一个科学家也是反对进化论的。</li>
</ol>
<h1 id="05-诉诸无知-appeal-to-ignorance"><a href="#05-诉诸无知-Appeal-to-Ignorance" class="headerlink" title="05 诉诸无知 Appeal to Ignorance"></a><strong>05 诉诸无知 Appeal to Ignorance</strong></h1><p>人们断定一件事物是正确，只是因为它未被证明是错误，或断定一件事物是错误，只因为它未被证明是正确，都属诉诸无知。</p>
<p><strong>例如：</strong><br>因为你不能证明上帝不存在，所以上帝是存在的。<br>科学不能证伪中医理论，所以中医理论是正确的。<br>没有人能证明外星人的存在，因此外星人不存在。</p>
<h1 id="06-诉诸传统-appeal-to-tradition"><a href="#06-诉诸传统-Appeal-to-tradition" class="headerlink" title="06 诉诸传统 Appeal to tradition"></a><strong>06 诉诸传统 Appeal to tradition</strong></h1><p>宣称某观念或事物行之已久，因此是好的。(类似主流思想谬误)(例如:占星、宗教、奴隶)只因为人们以此为传统,与它本身的存活能力无关。</p>
<p><strong>例如：</strong></p>
<ol>
<li>我们的传统一向是男主外女主内，因此妇女不应该外出工作。</li>
<li>自古以来，杀人偿命，天经地义，所以不该废除死刑。</li>
<li>不孝有三，无后为大，所以你不能不结婚，更不能不生孩子！</li>
<li>喝酒是我们几千年的酒文化，你必须干了这一杯白酒。</li>
</ol>
<h1 id="07-鬼祟谬误诉诸阴谋-furtive-fallacy"><a href="#07-鬼祟谬误-诉诸阴谋-Furtive-Fallacy" class="headerlink" title="07 鬼祟谬误/诉诸阴谋 Furtive Fallacy"></a><strong>07 鬼祟谬误/诉诸阴谋 Furtive Fallacy</strong></h1><p>主张事情的真相一定是某些人在背后操作。有些会宣称某事件缺乏详细证据，就是那些阴谋份子蓄意掩饰证据所致。 </p>
<p><strong>例如：</strong></p>
<ol>
<li>9.11事件绝对是美国政府自导自演，目的就是制造借口发动战争，以控制全世界！</li>
<li>秋裤是前苏联发明出来，用以对中华民族体质造成毁灭性损害的阴谋！目的是为了让中国人穿上秋裤，永远失去在严寒的苏联远东地区生存的能力。 </li>
<li>禽流感病毒是M国为了攻打伊拉克，牵制中国而对中国使用的生物心理武器。 </li>
</ol>
<h1 id="08-滑坡谬误-slippery-slope"><a href="#08-滑坡谬误-Slippery-Slope" class="headerlink" title="08 滑坡谬误 Slippery Slope"></a><strong>08 滑坡谬误 Slippery Slope</strong></h1><p>认为如果A发生了，那么Z也一定会发生，但是你完全无法给出任何证据来证明A的发生一定会造成极端事物Z的发生，所以这是一种诉诸恐惧的谬误，也影响了人们讨论A时候的客观性。</p>
<p><strong>例如：</strong></p>
<ol>
<li>如果你买日本货，日本公司就会盈利；如果日本公司盈利，那么日本公司就会发展壮大；如果日本公司发展壮大，那日本国力就会成为世界第一；如果日本国力成为世界第一，那么日本就会侵略中国。所以如果你买日本货，你就是在帮助日本侵略中国。</li>
<li>你不好好学习就进不了好的大学，进不了好的大学就找不到好的工作，找不到好的工作就挣不了钱，挣不了钱就找不到老婆，找不到老婆就得打一辈子光棍……（以下滑坡可以无限延伸）</li>
<li>你今天问我借10块钱，明天又会跟我借100块，接下来就会借一千块、一万块、一百万，那我岂不要破产？</li>
<li>如果允许同性恋之间结婚，接着人们就会同意和父母结婚，和卡车结婚，和猴子结婚。</li>
</ol>
<h1 id="09-人身攻击-ad-hominem"><a href="#09-人身攻击-Ad-Hominem" class="headerlink" title="09 人身攻击 Ad Hominem"></a><strong>09 人身攻击 Ad Hominem</strong></h1><p>讨论时针对对方的人格、动机、态度、地位、阶级或处境等进行攻击或评论，并以此当作依据去驳斥对方的论证或去支持自己的论点。也就是“对人不对事”或“因人废言”。这条是中国网民的重灾区。</p>
<p><strong>例如：</strong></p>
<p>柴静抽烟，私生活混乱，所以她拍的纪录片完全是瞎扯！<br>方舟子是秃头，方舟子的老婆论文剽窃，方舟子说的话你也信？<br>有人对疯转的“人贩子应该一律判死刑”提出不同意见，然后评论区里出现大量的观点是：等你有了孩子再来评论，没有孩子的人不要乱发表意见。<br>在你获得奥斯卡之前没有资格给这部电影差评。<br>你的妈妈是怎么教你的，别出来丢人现眼了！</p>
<h1 id="10-诉诸虚伪-to-quoque-appeal-to-hypocrisy"><a href="#10-诉诸虚伪-To-quoque-Appeal-to-Hypocrisy" class="headerlink" title="10 诉诸虚伪 To quoque/ Appeal to Hypocrisy"></a><strong>10 诉诸虚伪 To quoque/ Appeal to Hypocrisy</strong></h1><p>不正面回应别人对你的批评，而是用批评别人作为你的回复。你想要把通过用批评回应批评的方式，免去你为自己辩护的责任。你通过这种方法来暗示对方是个虚伪的人，但是不管别人虚伪与否，你都只是在回避别人对你的批评。</p>
<p><strong>例如：</strong></p>
<ol>
<li>他随地吐痰，所以我也可以随地吐痰。<br>“凭什么他做了你不说他，我做了你就要批评我？”</li>
<li>A：“自习期间请不要大声讲话”<br>B：“你不也在讲话？”</li>
<li>A指出B犯了一个逻辑谬误，B反击道A在之前的讨论中也犯了逻辑谬误</li>
</ol>
<h1 id="11-个人怀疑-personal-incredulity"><a href="#11-个人怀疑-Personal-Incredulity" class="headerlink" title="11 个人怀疑 Personal Incredulity"></a><strong>11 个人怀疑 Personal Incredulity</strong></h1><p>因为自己不明白或者知识水平不够，就认为一个事物可能是假的。有一些很复杂的概念，比如生物进化等，需要一些基本的理解和知识。但不能因为不理解这些复杂的概念而觉得这些东西是错误的。</p>
<p><strong>例如：</strong></p>
<ol>
<li>你觉得进化论是对的，那么请你证明一下我面前这块石头是如何进化的？</li>
<li>不要给我说真实案例和现象，不科学严谨，我们要看数据。</li>
<li>不要给我说数据，数据都是人做的，不真实可靠，我们要看真实案例和现象。</li>
<li>A画了一个半人半鱼的怪物，并鄙夷的责问B说B居然蠢到会相信鱼可以进化成人，如果是的，怎么没出现这种怪物啊。</li>
</ol>
<h1 id="12-片面谬误特例谬误-special-pleading"><a href="#12-片面谬误-特例谬误-Special-Pleading" class="headerlink" title="12 片面谬误/特例谬误 Special Pleading"></a><strong>12 片面谬误/特例谬误 Special Pleading</strong></h1><p>当你的观点被证明是错误的时候，你用特例来给自己开脱。人类都不喜欢被证明是错的，所以当他们被证明是错的时候总会想办法给自己开脱。只有诚实和勇敢的人才能面对自己的错误，并且承认自己犯错了。</p>
<p><strong>例如：</strong></p>
<ol>
<li>我虽然考试作弊，但是我爱国啊。</li>
<li>我虽然抄袭你的作品，可是这本书红了啊，你也因为我成名了啊。</li>
<li>孩子还小，不懂事，谁家孩子不会犯错误啊。</li>
<li>说自己会膜法，但是他的“能力”在科学环境下测试却消失了。卅猫生气地说：“只有有人信我的时候我才能发挥出膜法！”</li>
</ol>
<h1 id="13-诱导性问题-loaded-question"><a href="#13-诱导性问题-Loaded-Question" class="headerlink" title="13 诱导性问题 Loaded Question"></a><strong>13 诱导性问题 Loaded Question</strong></h1><p>在提出问题的时候加入了诱导的成分，使得对方只能按着你的意思来回答，从而破坏理性的讨论。</p>
<p><strong>例如：</strong></p>
<p>甲：你还在抽烟吗？<br>乙：没有。<br>甲：看吧！你果然抽过烟！<br>甲的问题已预设乙抽过烟，乙无论回答“是”或“否”，皆无异于承认以前抽过烟。 如果乙根本没抽过烟，最安全的做法是回答“我从未抽过烟。”或干脆不回答。<br>“你不打老婆了吗？”<br>若正面回答，等同承认有老婆，且以前曾经打过老婆。<br>“为什么私人企业总是比公营企业有效率？”<br>若正面回答，等同承认“私人企业总是比公营企业有效率”是事实。</p>
<h1 id="14-语义模糊-ambiguity"><a href="#14-语义模糊-Ambiguity" class="headerlink" title="14 语义模糊 Ambiguity"></a><strong>14 语义模糊 Ambiguity</strong></h1><p>用双关语或者意思存有歧义的语言来歪曲事实。当被别人批评的时候又利用这些有歧义的语言作为自己的挡箭牌。</p>
<p><strong>例如：</strong></p>
<ol>
<li>一切都是因缘，工作不顺利不是你的错，不必自责。（此处“因缘”是模糊词）</li>
<li>例如男友接女友，女友说“再一下子就好”，结果男友等了二十分钟。导致两人争论。男友说：“一下子一般指一两分钟的事，怎么这么久！”，女友说：“很多人化妆要一小时，化妆二十分钟算很快了！”。（这里是因为两人对“一下子”的定义不明确所致。</li>
</ol>
<h1 id="15-乐队花车-bandwagon"><a href="#15-乐队花车-Bandwagon" class="headerlink" title="15 乐队花车 Bandwagon"></a><strong>15 乐队花车 Bandwagon</strong></h1><p>因为很多人都在做同一件事情/相信同一件事物，所以这件事情就是对的。</p>
<p><strong>例如：</strong></p>
<ol>
<li>《货币战争》这么多人都看过，我相信一定是罗斯柴尔德和共济会在背后操纵着整个世界。</li>
<li>“大家都这样，所以这样一定不会错。”</li>
<li>“吸烟的人很多，所以吸烟不会有害健康。”</li>
</ol>
<h1 id="16-合成谬误-compositiondivision"><a href="#16-合成谬误-Composition-Division" class="headerlink" title="16 合成谬误 Composition/Division"></a><strong>16 合成谬误 Composition/Division</strong></h1><p>认为一个总体的组成部分所具有的特性，对于这个总体的其它部分也是普适的。很多时候，对于一个组成部分存在合理性的事物，对于其它组成部分并不具有合理性。</p>
<p><strong>例如：</strong></p>
<ol>
<li>广东的人什么都吃，你是广东人，那么你肯定吃过老鼠了</li>
<li>你是学计算机的啊，那你肯定会修电脑吧？来帮我修一下？</li>
<li>今天我遇到一个小偷是河南人，所以所有河南人素质都低。</li>
<li>男人没有一个好东西！</li>
<li><p>A是个喜欢自己思考的早熟孩子。他了解到原子是看不见的，而自己又是由原子构成的，由此推演自己是透明的。不幸的是，他因此输掉了躲猫猫游戏。</p>
<h1 id="17-没有真正的苏格兰人-no-true-scotsman"><a href="#17-没有真正的苏格兰人-No-True-Scotsman" class="headerlink" title="17 没有真正的苏格兰人 No True Scotsman"></a><strong>17 没有真正的苏格兰人 No True Scotsman</strong></h1></li>
</ol>
<p>你提出了一个观点，并收到了别人的批评，你试图通过马后炮和修改标准的方式来维护自己那有缺陷的观点。</p>
<p><strong>例如：</strong></p>
<ol>
<li>A：中国武术的高手都很厉害。<br>B：上次那个中国武林高手某某上台不是被泰拳打成渣了么？<br>A：我说的是“真正的”中国武术高手。<br>这里A就犯了没有真正的苏格兰人谬误。他随时更改他的标准，来使自己立于不败之地，你永远不能胜过他。</li>
<li>甲：人都是善良的。<br>乙：那为什么世界上有那么多为非作歹的人？<br>甲：那些人不是真正的人，因为他们不善良。</li>
<li><p>卅猫说没有苏格兰的家伙在稀饭里面放糖。然而w子就是苏格兰人，他说自己就是甜党。卅猫生气了，大声嗷呜：真正的纯苏格兰人是不放糖的。</p>
<h1 id="18-基因谬误-genetic"><a href="#18-基因谬误-Genetic" class="headerlink" title="18 基因谬误 Genetic"></a><strong>18 基因谬误 Genetic</strong></h1></li>
</ol>
<p>通过一个事物的出身来判断它的好坏，而逃避正面的讨论。这种做法和 “人身攻击”类似，都是想试图通过已有的负面印象来从侧面攻击对方，却不能正面的回应对方的论述。</p>
<p><strong>例如：</strong></p>
<ol>
<li>我不关心你说了什么，我只关心你是谁，要是你这个人有问题或者我不喜欢，你说的什么都是错的。</li>
<li>长得丑的人说什么都是错的。</li>
</ol>
<h1 id="19-非黑即白-black-or-white"><a href="#19-非黑即白-Black-or-White" class="headerlink" title="19 非黑即白 Black-or-White"></a><strong>19 非黑即白 Black-or-White</strong></h1><p>使用简单粗暴的假二分法，来掩盖其它可能性的存在。你想通过非黑即白的选择来误导讨论，破坏辩论的建设性。</p>
<p><strong>例如：</strong></p>
<ol>
<li>只要你努力了，你就一定成功，如果你没成功，那只是你不努力。</li>
<li>你不支持我的观点，就是反对我的观点，你反对我的这个观点，就否定了我整个人。</li>
<li>如果你不支持反恐战争，你就是支持恐怖分子。</li>
<li>卅猫大王推出了一项可能损害公民权益的政策，然后她说：“要么支持我，要么去投靠敌人。</li>
</ol>
<h1 id="20-循环论证-circular-argument"><a href="#20-循环论证-circular-argument" class="headerlink" title="20 循环论证 circular argument"></a><strong>20 循环论证 circular argument</strong></h1><p>你采用循环论证的方法来证明一个被包含在前提里面的观点。这是一种逻辑智商破产的谬误，因为你把你的前提假设默认为真的，然后利用循环论证的方式来证明它。</p>
<p><strong>例如：</strong></p>
<p>甲：为什么我最近脾气特别暴躁？<br>乙：因为你肝火旺。<br>甲：怎么知道我肝火旺？<br>乙：因为你脾气特别暴躁。<br>甲：为什么肝火旺会脾气特别暴躁？<br>乙：因为情绪是肝主管的。<br>甲：我该怎么办？<br>乙：我开个“清肝丸”给你，这种丸药可以清肝火。<br>甲：对了，怎么知道情绪是肝主管的？<br>乙：因为当脾气大的时候，给清肝火的药可以改善。<br>甲：为什么这丸药可以清肝火？<br>乙：因为当肝火旺的时候，给这丸药可以改善。</p>
<h1 id="21-涅槃谬误-nirvana-fallacy"><a href="#21-涅槃谬误-Nirvana-fallacy" class="headerlink" title="21 涅槃谬误 Nirvana fallacy"></a><strong>21 涅槃谬误 Nirvana fallacy</strong></h1><p>宣称某个解决方案无法做到完美，因此不可行。较白话的诠释是：“不能做到完美，就不应该做”。</p>
<p><strong>例如：</strong></p>
<ol>
<li>活着有什么意义呢？我们终归一死。</li>
<li>抓酒驾有什么意义呢？反正天天都还是有人酒驾。</li>
<li>起床叠被子干嘛呢？反正晚上被子又要被摊开。</li>
</ol>
<h1 id="22-轶事证据-anecdotal"><a href="#22-轶事证据-Anecdotal" class="headerlink" title="22 轶事证据 Anecdotal"></a><strong>22 轶事证据 Anecdotal</strong></h1><p>试图用个人经验或者单独事例来取代逻辑论述或者有力的证据。比起复杂而确凿的证据来说，轶事证据更容易获得，但是却要粗浅很多。在绝大多数情况下，量化衡量的科学数据/确凿证据比个人经验/轶事要更加可信。</p>
<p><strong>例如：</strong></p>
<ol>
<li>印度有位瑜珈大师不吃不喝也能生存，所以所有人都可以不用吃喝就能生存。</li>
<li>某某庙真的很神，我朋友跟我说，他本来得了不治之症，连医生都宣告无药可医，结果他去那个庙拜拜之后，竟然不治而愈。</li>
<li>吸烟与肺癌无关。我有个亲戚，每天5支烟，活到了90多岁；有个朋友，从来也不吸，40多岁就得肺癌死了。</li>
<li>A说自己的亲戚每天抽30根烟也活到了97岁，所以不要相信任何书上或是研究出的玩意。</li>
</ol>
<h1 id="23-德克萨斯神枪手-the-texas-sharpshooter"><a href="#23-德克萨斯神枪手-the-Texas-Sharpshooter" class="headerlink" title="23 德克萨斯神枪手 the Texas Sharpshooter"></a><strong>23 德克萨斯神枪手 the Texas Sharpshooter</strong></h1><p>在大量的数据/证据中小心地挑选出对自己的观点有利的证据，好像先开了一枪，然后在子弹击中的地方画上靶心，搞得自己真是个神枪手一样。而不使用那些对自己不利的数据/证据。</p>
<p><strong>例如：</strong></p>
<ol>
<li>某慈善机构为了证明自己尽到了职责，到处宣传自己拨出了上亿的善款，却只字不提自己公款消费的奢侈无度。</li>
<li>在谈论美国禁枪话题时，有人举例说瑞士几乎人人持枪，但枪击案比例极低，以此证明人人持枪并不是禁枪的理由。但他避而不谈美国枪击案发生率稳居世界前列的事实。</li>
<li>A推销SCD饮料，研究发现在SCD销量最高的五个国家中，三个在地球最健康的十个国家里面，因此w子宣称SCD饮料有益健康。</li>
</ol>
<h1 id="24-中间立场-middle-ground"><a href="#24-中间立场-Middle-Ground" class="headerlink" title="24 中间立场 Middle Ground"></a><strong>24 中间立场 Middle Ground</strong></h1><p>觉得两个极端观点的妥协，或者说中间立场，肯定是对的，俗称各打五十大板。虽然大多数时候，真理确实存在于两种极端的中间地带，但中间立场也不一定就是对的。很可能谎言和实话的中间地带依然是谎言。</p>
<p><strong>例如：</strong></p>
<ol>
<li>你说西瓜是你的，他说西瓜是他的，这样好了，我们把西瓜分成两半，一人一半吧！</li>
<li>甲认为喝绿茶会导致肥胖，乙认为喝绿茶不可能导致肥胖，丙则认为偶尔喝绿茶不会使人肥胖，但长期喝绿茶则有发胖的风险。</li>
<li>A说牛痘疫苗会引起自闭症，他的朋友B却从文献中得出这个观点完全是无稽之谈。C折中认为一部分疫苗会引起自闭，一部分不会引起。</li>
</ol>
]]></content>
      <categories>
        <category>逻辑</category>
      </categories>
      <tags>
        <tag>logic</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基准测试工具使用记录</title>
    <url>/post/8aabd1de/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol>
<li><p>主流数据库分类：关系型数据库、NoSQL、NewSQL</p>
</li>
<li><p>MySQL主流分支：MySQL、Percona Server、MariaDB</p>
</li>
<li><p>MySQL优点：</p>
<ul>
<li>体积小、速度快<br>开源免费，工具生态完善<br>简单易用，维护成本低<br>兼容性好，支持多种操作系统<br>提供多种API接口<br>支持多种开发语言<br>社区及用户活跃<br>支持事务、MVCC、易扩展、集群、高可用</li>
</ul>
</li>
<li><p>MySQL经常遇到的坑：</p>
<ul>
<li>flush-Logs导致hang住无法写入数据<br>忘记密码<br>cache-full<br>延迟<br>2013<br>1064<br>死锁<br>主键冲突<br>掉电<br>字符集错误<br>删库跑路<br>脑裂<br>慢查询<br>断网<br>Query-Cache<br>metadata-lock<br>没备份<br>ulimit-u导致创建链接失败<br>表数据碎片<br>大小写敏感</li>
</ul>
</li>
<li><p>内容丰富：</p>
<ul>
<li>系统<br>网络<br>硬件<br>原理<br>部署<br>优化<br><strong>InnoDB</strong><br>复制<br>备份/还原<br>监控<br>架构设计<br>容量规划<br>技术生态<br>编程<br>高可用</li>
</ul>
</li>
<li><p>书籍：</p>
<p>《MySQL官方手册》<br>《MySQL运维内参》<br>《MySQL8 Cookbook（中文版）》<br>《MySQL技术内幕InnoDB存储引擎》<br>《高性能MySQL》<br>《数据库索引设计与优化》<br>《MySQL内核InnoDB存储引擎》<br>《深入理解MySQL核心技术》<br>《Effective MySQL Replication Techniques in Depth》</p>
</li>
</ol>
<p>问题：</p>
<p>事务的四大特性？ </p>
<p>数据库的三大范式 </p>
<p>事务隔离级别有哪些？ </p>
<p>索引  </p>
<ul>
<li>什么是索引？ </li>
<li>索引的优缺点？ </li>
<li>索引的作用？ </li>
<li>什么情况下需要建索引？ </li>
<li>什么情况下不建索引？ </li>
<li>索引的数据结构 </li>
<li>Hash索引和B+树索引的区别？ </li>
<li>为什么B+树比B树更适合实现数据库索引？ </li>
<li>索引有什么分类？ </li>
<li>什么是最左匹配原则？ </li>
<li>什么是聚集索引？ </li>
<li>什么是覆盖索引？ </li>
<li>索引的设计原则？ </li>
<li>索引什么时候会失效？ </li>
<li>什么是前缀索引？ </li>
</ul>
<p>常见的存储引擎有哪些？ </p>
<p>MyISAM和InnoDB的区别？ </p>
<p>MVCC 实现原理？ </p>
<p>快照读和当前读 </p>
<p>共享锁和排他锁 </p>
<p>大表怎么优化？ </p>
<p>MySQL 执行计划了解吗？ </p>
<p>bin log/redo log/undo log </p>
<p>bin log和redo log有什么区别？ </p>
<p>讲一下MySQL架构？ </p>
<p>分库分表 </p>
<p>什么是分区表？ </p>
<p>分区表类型 </p>
<p>分区的问题？ </p>
<p>查询语句执行流程？ </p>
<p>更新语句执行过程？ </p>
<p>exist和in的区别？ </p>
<p>MySQL中int(10)和char(10)的区别？　 </p>
<p>truncate、delete与drop区别？ </p>
<p>having和where区别？ </p>
<p>什么是MySQL主从同步？ </p>
<p>为什么要做主从同步？ </p>
<p>乐观锁和悲观锁是什么？ </p>
<p>用过processlist吗？</p>
<h1 id="一-体系结构与存储引擎"><a href="#一、体系结构与存储引擎" class="headerlink" title="一、体系结构与存储引擎"></a>一、体系结构与存储引擎</h1><h2 id="1mysql体系结构"><a href="#1-MySQL体系结构" class="headerlink" title="1.MySQL体系结构"></a>1.MySQL体系结构</h2><p>1.1 体系结构图示</p>
<h3 id="12-select执行轨迹"><a href="#1-2-Select执行轨迹" class="headerlink" title="1.2 Select执行轨迹"></a>1.2 Select执行轨迹</h3><h2 id="2什么是存储引擎及其分类"><a href="#2-什么是存储引擎及其分类" class="headerlink" title="2.什么是存储引擎及其分类"></a>2.什么是存储引擎及其分类</h2><p>存储引擎：MySQL中具体与文件打交道的子系统。根据MySQL AB公司提供的<strong>文件访问层抽象接口</strong>定制的一种<strong>文件访问机制</strong></p>
<p>分类：InnoDB、MyISAM、ArkDB ……</p>
<h3 id="innodb体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h3><ol>
<li>实例层</li>
</ol>
<h2 id="3innodb存储引擎体系结构mysql56"><a href="#3-InnoDB存储引擎体系结构-MySQL5-6-·" class="headerlink" title="3.InnoDB存储引擎体系结构(MySQL5.6)·"></a>3.InnoDB存储引擎体系结构(MySQL5.6)·</h2><h2 id="4innodb存储引擎体系结构的优化与改进mysql57和mysql80"><a href="#4-InnoDB存储引擎体系结构的优化与改进-MySQL5-7和MySQL8-0" class="headerlink" title="4.InnoDB存储引擎体系结构的优化与改进(MySQL5.7和MySQL8.0)"></a>4.InnoDB存储引擎体系结构的优化与改进(MySQL5.7和MySQL8.0)</h2><h2 id="5innodb成王mylsam败寇的原因"><a href="#5-InnoDB“成王”MylSAM“败寇”的原因" class="headerlink" title="5.InnoDB“成王”MylSAM“败寇”的原因"></a>5.InnoDB“成王”MylSAM“败寇”的原因</h2><h2 id="6innodb几大核心特性详解"><a href="#6-InnoDB几大核心特性详解" class="headerlink" title="6.InnoDB几大核心特性详解"></a>6.InnoDB几大核心特性详解</h2><h1 id="二-事务与锁机制"><a href="#二、事务与锁机制" class="headerlink" title="二、事务与锁机制"></a>二、事务与锁机制</h1><h1 id="三-库表设计"><a href="#三、库表设计" class="headerlink" title="三、库表设计"></a>三、库表设计</h1><h1 id="四-高性能索引"><a href="#四、高性能索引" class="headerlink" title="四、高性能索引"></a>四、高性能索引</h1><h1 id="五-数据库架构设计"><a href="#五、数据库架构设计" class="headerlink" title="五、数据库架构设计"></a>五、数据库架构设计</h1><h1 id="六-查询优化"><a href="#六、查询优化" class="headerlink" title="六、查询优化"></a>六、查询优化</h1><h1 id="七-mysql高可用"><a href="#七、MySQL高可用" class="headerlink" title="七、MySQL高可用"></a>七、MySQL高可用</h1><h1 id="八-自动化运维体系构建"><a href="#八、自动化运维体系构建" class="headerlink" title="八、自动化运维体系构建"></a>八、自动化运维体系构建</h1><h1 id="九-可拓展mysql规划"><a href="#九、-可拓展MySQL规划" class="headerlink" title="九、 可拓展MySQL规划"></a>九、 可拓展MySQL规划</h1><h1 id="十-其他项目"><a href="#十、其他项目" class="headerlink" title="十、其他项目"></a>十、其他项目</h1>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
