---
title: 笔试练习
date: 2020-02-26 14:23:24
tags: [test]
copyright: true
categories: 笔试
---

@[toc]



# 一

- 关系代数运算的五种基本运算 
- 并、差、选择、投影、乘积

---



- 线程进程关系
- 1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。**线程是操作系统可识别的最小执行和调度单位**。
  2. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享**代码段(代码和常量)**，**数据段(全局变量和静态变量)**，**扩展段(堆存储)**。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。
  3. 处理机分给线程，即真**正在处理机上运行的是线程**。
  4. 线程在执行过程中，需要协作**同步**。不同进程的线程间要利用消息通信的办法实现同步。

---



- unix系统
- 1. UNIX系统是一个**多用户**、多任务操作系统，支持多种处理器架构（并行处理能力）。
  2. UNIX的系统结构可分为三部分：Unix**内核**（Kernel）：系统核心，指挥调度机器运行，直接控制计算机资源，内核提供一种硬件抽象的方法来完成**对硬件操作**。 Unix**外壳**（Shell）：内核与用户的接口。工具以及应用程序：vi编辑器、文件查找、备份
  3. UNIX系统大部分是由**C**语言编写的，这使得系统易读，易修改，易移植。
  4. UNIX提供了丰富的，精心挑选的系统调用，整个系统的实现十分紧凑，简洁。
  5. UNIX提供了功能强大的可编程的Shell语言（外壳语言）作为用户界面具有简洁，高效的特点。
  6. UNIX系统采用树状目录结构，具有良好的安全性，保密性和可维护性。
  7. UNIX系统采用进程对换（Swapping）的内存管理机制和请求调页的存储方式，实现了虚拟内存管理，大大提高了内存的使用效率。
  8. UNIX系统提供多种通信机制，如：管道通信，软中断通信，消息通信，共享存储器通信，信号灯通信

---



- 信号量和互斥锁的异同，并对使用场景进行举例
- 1. 互斥锁用于线程的**互斥**，信号量用于线程的**同步**
  2. 互斥锁的加锁和解锁必须由同一线程分别对应使用（互斥），信号量可以由一个线程释放，另一个线程获得（同步）；因此，互斥锁可用于**控制一段临界代码**，如果释放和获取不在同一个线程就必须要用**信号量**了
  3. 互斥锁值只能是0/1，信号量值可以是任意正整数，所以它们意义不同，信号量值一般是可使用资源数，互斥锁值可以看成开锁关锁状态

---



- 至少三种tcp拥塞控制机制，并描述一种工作原理
- 四种拥塞控制算法分别是：**慢启动**，**拥塞控制**，**快重传**和**快恢复**。其中TCP 主要通过四种算法来进行拥塞控制：**慢开始、拥塞避免、快重传、快恢复**。

---



- 5个PM和3个QA围一圆桌而坐，只考虑每个人左边和右边是谁，要求3个QA互不相邻，问有多少种坐法。

- 先放5个PM ，然后基于他们剩下的可坐位置对QA进行分配。

  先5个人坐，考虑方向问题，以其中一个为最左边，所有元素在其右边排列，应该有24种排法

  然后1 @ 2@3@4@5@

  有5个@位可以用来选择放3个QA 选择3个位子，有10种选择

  然后三个QA之间的顺序有中排法

  综合有24 * 10 * 6=1440 

---



- 4个RD来到公司并将雨伞留在门外，下班时他们每人随机带走一把雨伞，问所有人都拿错的概率。
- 一共4*3*2中拿法，24-C(1,4)-C(2,4)-C(3,4)-C(4,4)=24-4-6-4-1=9,答案3/8

---



- 编程题:diamond_shape_with_a_dot_inside:：小明认为某些数字不吉利，付账时会尽可能少的多付一些钱，使得价格中不包含这些不吉利数字，并且不出现0。例如，不吉利数字为1，4，7，8，商品价格为1000，小明实际支付2222.实现程序，输入商品原来的价格price，不吉利数字集合unlucky_numbers，求小明付账时的价格lucky_price.

- ```java
  //java
  int getLuckyPrice(int price, List<Integer> unlucky_numbers){
      
  }
  ```

---



- 编程题:diamond_shape_with_a_dot_inside:：一个一维维数组中只有1和-1，实现程序，求和为0的最长子串长度，并在注释中给出时间和空间复杂度。

- 思路:diamond_shape_with_a_dot_inside:：i从0到n，计算sum(i)，sum(i)表示从0到i的元素之和，并且保存在字典dic中，value是索引i，在往后的遍历中每得到一个sum(i)就看dic的keys是否已有此sum(i)值，如果有则用当前i位置减去保存的i，并与maxLen比较，取大的那个。遍历结束，给出结果。时间复杂度O(n)，空间复杂度O(1)。

- ```java
  int getLongestLength(List<Integer> array){
      int max = 0;
      int sum = 0;
      HashMap<Integer, Integer> map = new HashMap<>();
      map.put(0,-1);
      for(int i=0 ; i<a.length ; i++){
          sum += a[i];
          if(map.get(sum) == null){
              map.put(sum, i);
          } else {
              int tmp = i-map.get(sum);
              if(max < tmp){
                  max = tmp;
              }
          }
      }
      return max;
  }
  ```



# 二

### 1

第一行 x,y,n (0<x<=30, 0<y<=30, 0<=n<= 20) 表示x,y小虾的座位坐标,n 表示boss的数量（ n <= 20）

接下来有n行, 表示boss们的坐标(0<xi<= x, 0<yi<=y，不会和小虾位置重合)

x1, y1

x2, y2

……

xn, yn

输出可能的路径

```java
package test;

import java.util.Scanner;

public class test_1 {
	public static void main(String [] args) {
		Scanner sc = new Scanner(System.in);
		int x = sc.nextInt();
		int y = sc.nextInt();
		int n = sc.nextInt();
		
		long [][] location = new long[x+1][y+1];
		for(int i=0 ; i<x ; i++) {
			for(int j=0 ; j<y ; j++) {
				location[i][j] = 0;
			}
		}
		for(int i=0 ; i<n ; i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			location[a][b] = -1;
		}
		for(int i=0 ; i<=x ; i++) location[i][0] = 1;
		for(int j=0 ; j<=y ; j++) location[0][j] = 1;
		for(int i=1 ; i<=x ; i++) {
			for(int j=1 ; j<=y ; j++) {
				if(location[i][j] == -1) continue;
				if(location[i-1][j] != -1) location[i][j] += location[i-1][j];
				if(location[i][j-1] != -1) location[i][j] += location[i][j-1];
				System.out.println(location[i][j]);
			}
		}
		System.out.println(location[x][y]);
		sc.close();
	}
}

```



### 2

在Linux Shell命令下通配符'*'表示0个或多个字符, 现编写一段代码实现通配符'*'的功能，注意只需要实现'*', 不用实现其他通配符。

##### **输入描述:**

第一行输入通配字符串
第二行输入要匹配查找的字符串

```java
package test;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

//第一行输入通配字符串
//第二行输入要匹配查找的字符串

//在Linux Shell命令下通配符'*'表示0个或多个字符, 现编写一段代码实现通配符'*'的功能，注意只需要实现'*', 不用实现其他通配符。
public class test_3 {
	
	public static void main(String [] args) {
		Scanner sc = new Scanner(System.in);
		String matchStr = sc.next();
		String str = sc.next();
		
		List<Integer[]> list = getMatchPosAndLen(matchStr, str);
		for(Integer[] arr : list) {
			System.out.println(arr[0] + " " + arr[1]);
		}
	}

	private static List<Integer[]> getMatchPosAndLen(String matchStr, String str) {
		// TODO Auto-generated method stub
		List<Integer[]> res = new ArrayList<Integer[]>();
		for(int i=0 ; i<str.length() ; i++) {
			if(matchStr.charAt(0) != '*' && matchStr.charAt(0) != str.charAt(i)) continue;
			for(int j=i ; j<str.length() ; j++) {
				if(matchStr.charAt(0) != '*' && matchStr.charAt(0) != str.charAt(i)) {
					continue;
				}
				if(match(matchStr, str.substring(i, j+1), 0, 0)) {
					res.add(new Integer[] {i, j-i+1});
				}
			}
		}
		if(res.size() == 0) res.add(new Integer[] {-1, 0});
		return res;
	}

	private static boolean match(String matchStr, String str, int matchIdx, int idx) {
		// TODO Auto-generated method stub
		if(matchIdx == matchStr.length() && idx == str.length()) {
			return true;
		}
		if (idx >= str.length() && matchIdx < matchStr.length() && matchStr.charAt(matchIdx) == '*') {
            return match(matchStr, str, matchIdx + 1, idx);
        }
        if (matchIdx >= matchStr.length() || idx >= str.length()) {
            return false;
        }
        if (matchStr.charAt(matchIdx) != '*' && matchStr.charAt(matchIdx) != str.charAt(idx)) {
            return false;
        }
        boolean flag = false;
        if (matchStr.charAt(matchIdx) == '*') {
            flag = match(matchStr, str, matchIdx + 1, idx) || match(matchStr, str, matchIdx, idx + 1);
        }
        if (matchStr.charAt(matchIdx) == str.charAt(idx)) {
            flag |= match(matchStr, str, matchIdx + 1, idx + 1);
        }
		return flag;
	}
}

```



### 3

> 输入
>
> 4
> 0 1 1 0
> 1 1 0 1
> 0 0 1 0
> 0 0 0 0
>
> 先输入方阵阶数，然后逐行输入房子和空地的数据，以空格分隔。

```java
package test;

import java.util.*;

public class test_4 {

	public static void main(String [] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
			int n = sc.nextInt();
			int [][] location = new int[n][n];
			ArrayList<int[]> list = new ArrayList<int[]>();
			for(int i=0 ; i<n ; i++) {
				for(int j=0 ; j<n ; j++) {
					location[i][j] = sc.nextInt();
					if(location[i][j] == 1) {
						int[] house = new int[2];
						house[0] = i;
						house[1] = j;
						list.add(house);
					}
				}
			}
			int res = Integer.MAX_VALUE;
			for(int i=0 ; i<n ; i++) {
				for(int j=0 ; j<n ; j++) {
					int tmp = 0;
					if(location[i][j] == 0) {
						for(int k=0 ; k<list.size() ; k++) {
							tmp += Math.abs(list.get(k)[0]-i) + Math.abs(list.get(k)[1]-j);
						}
						res = res>tmp?tmp:res;
					}
				}
			}
			System.out.println(res==Integer.MAX_VALUE?-1:res);
		}
		sc.close();
	}
}

```

