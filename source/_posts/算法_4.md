---
title: 算法_4 动态规划
copyright: false
date: 2019-06-20 11:19:06
tags: [algorithm]
categories: 算法
---



@[toc]



## 什么是动态规划

动态规划是一种**多阶段决策**最优解模型，一般用来求最值问题，多数情况下可以采用**自下而上**的递推方式来得到每个子问题的最优解（即最优子结构），进而自然而然地得出依赖子问题的原问题的最优解。

1. **多阶段决策**：问题可以拆分成多个子问题进行求解
2. **最优子结构**：
3. **自下而上**：



## 别的一些例题

### 子串模糊匹配

> 从字符串string开始完整匹配子串sub，返回匹配到的字符个数。
> sub中如果出现'?'表示可以匹配一到三个除'\0'以外的任意字符。如果sub还有找不到匹配的字符，则说明不能完整匹配。
> 如果能完整匹配，返回匹配到的字符个数，如果有多种匹配方式，返回匹配字符数最少的那个，如果不能完整匹配，返回-1

输入描述

第一行输入字符串string，第二行输入子串sub

#### 动态规划解法

```java
import java.util.Scanner;
public class Main{
    public static void main(String [] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String string = sc.next();
            String sub = sc.next;
            int index1=0, index2 = 0;
            if(string.size()==0 || s.size()==0){
                System.out.println("-1");
            } else {
                System.out.println(isMatch(string,sub,index1,index2));
            }
        }
    }
    
    public static int isMatch(String s, String sub, int index1, int index2){
        int len1 = s.size();
        int len2 = s.size();
        while(index1 < len1 && index2 < len2){
            if(s2[index2]!='?' && s1[index1]!=s2[index2]) return -1;
            if(index1 - index2 > 3) return -1;
            if(s1[index1] == s2[index2]){
                index1++;
                index2++;
                continue;
            }
            if(s2[index2]=='?'&&s1[index1]!='\0'){
                if(s1[index1+1] == s2[index2+1]){
                    int temp = 0;
                    if(temp=isMatch(s, sub, index1++, index2++)!=-1){
                        return temp;
                    } else {
                        index1++;
                    }
                } else {
                    index1++;
                }
            }
            if(index1 != index2) return -1;
            else return index1;
        }
        
    }
  
}
```



### 取球

> 有K种颜色的小球(K<=10)，每种小球有若干个，总数小于100个。
> 现在有一个小盒子，能放N个小球(N<=8)，现在要从这些小球里挑出N个小球，放满盒子。
> 想知道有哪些挑选方式。注：每种颜色的小球之间没有差别。
> 请按数字递增顺序输出挑选小球的所有方式。
> 如有3种颜色，每种颜色小球的个数分别为a:1,b:2,c:3，挑出3个小球的挑法有：
> 003,012,021,102,111,120

每种小球分别取0~max值

```java
public class Main{
    private static List<Integer> path = new ArrayList<>();
    public static void print(List<Integer> l, int k) {
        StringBuilder sb = new StringBuilder();
        l.forEach(u -> sb.append(u));
        for (int i = l.size(); i < k; i++) {
            sb.append(0);
        }
        System.out.println(sb.toString());
    }
    public static void run(int[] colors, int k, int n, int level) {
        if (k == 1) {
            System.out.println(n);
            return;
        }
        for (int i = 0; i <= colors[0]; i++) {
            turn1.add(Arrays.asList(i));
        }
        List<Integer> temp;
        for (int i = 1; i < k; i++) {
            List<List<Integer>> lastTurn = turn1;
            List<List<Integer>> nowTurn = new ArrayList<>();
            for (int j = 0; j < lastTurn.size(); j++) {
                for (int z = 0; z <= colors[i]; z++) {
                    temp = new ArrayList<>();
                    temp.addAll(lastTurn.get(j));
                    temp.add(z);
                    if (i == k-1) {
                        if (temp.stream().reduce(0, (u1, u2)->u1 + u2) == n) {
                            print(temp, k);
                        }
                    } else {
                        if (temp.stream().reduce(0, (u1, u2)->u1 + u2) <= n) {
                            nowTurn.add(temp);
                        }
                    }
                }
            }
            turn1 = nowTurn;
        }
    }
 
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            int k = scanner.nextInt();
            int n = scanner.nextInt();
            int[] colors = new int[k];
            for (int i = 0; i < k; i++) {
                colors[i] = scanner.nextInt();
            }
            run(colors, k, n, 0);
        }
    }
}
```



### 下棋

> 8x8的棋盘上，布有黑白两色棋子，白子先下，当白子下N手后，棋盘上最多有可能留下多少颗白子？
>
> 下法规则：
>
> 1. 每次落子后，以该棋子为中心的8个方向(米字形的8条直线)，如果有同色棋子，
>    且两个同色棋子之间连续排列着若干个异色棋子，无空白及同色棋子。则，这次落子可以把这些夹在中间的异色棋子全部翻色（即黑变白，白变黑）。
>
> 2. 黑白子交错落子。
>
> 3. 如果一个位置上有棋子，不能继续在该位置上落子；
>
> 4. 如果一个位置上落子后，不能翻对手的棋子，则该位置不能落子；
>
> 1表示黑色，2表示白色，0表示空白未落子  



### 摆长方体

> 一个长方体，长宽高分别为x,y,z，都为自然数。
>
> 现在要把若干个相同的长方体摆成高为N的一根柱形体。
>
> 每层摆1个，如果两种摆法的高度是一样的，则认为这两种摆法等价，所以每层只有三种摆法。
>
> 求一共有多少种摆法。  

解法：设dp【i】【j】为第i层，高度为j的方案数，那么第i+1层的高度为j+x j+y j+z的方案数都等于第i层的方案数，所以可以的出递推式为

```
dp[i][j+x]+=dp[i-1][j]
dp[i][j+y]+=dp[i-1][j]
dp[i][j+z]+=dp[i-1][j]
```

再把高度为n的方案数加起来得出总和即可。

```java
import java.util.*;
public class Solution{
    public static void main(String [] args){
        Scanner sc = new Scanner();
        int n = sc.nextInt();
        int x = sc.nextInt();
        int y = sc.nextInt();
        int z = sc.nextInt();
        int [][] dp = new int[200][400];
        dp[1][x] = 1;
        dp[1][y] = 1;
        dp[1][z] = 1;
        for(int i=2 ; i<200 ; i++){
            for(int j=0 ; j<300 ; j++){
                dp[i][j+x]+=dp[i-1][j];
				dp[i][j+y]+=dp[i-1][j];
				dp[i][j+z]+=dp[i-1][j];
            }
        }
        int sum = 0;
        for(int i=0 ; i<200 ; i++){
            sum += dp[i][n];
        }
        System.out.println(sum);
        sc.close();
    }
}
```

