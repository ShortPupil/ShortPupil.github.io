---
title: 算法_4 动态规划
copyright: false
date: 2019-06-20 11:19:06
tags: [algorithm]
categories: 算法
---



@[toc]



## 什么是动态规划

动态规划是一种**多阶段决策**最优解模型，一般用来求最值问题，多数情况下可以采用**自下而上**的递推方式来得到每个子问题的最优解（即最优子结构），进而自然而然地得出依赖子问题的原问题的最优解。

1. **多阶段决策**：问题可以拆分成多个子问题进行求解
2. **最优子结构**：
3. **自下而上**：



## 别的一些例题

### 子串模糊匹配

> 从字符串string开始完整匹配子串sub，返回匹配到的字符个数。
> sub中如果出现'?'表示可以匹配一到三个除'\0'以外的任意字符。如果sub还有找不到匹配的字符，则说明不能完整匹配。
> 如果能完整匹配，返回匹配到的字符个数，如果有多种匹配方式，返回匹配字符数最少的那个，如果不能完整匹配，返回-1

输入描述

第一行输入字符串string，第二行输入子串sub

#### 动态规划解法

```java
import java.util.Scanner;
public class Main{
    public static void main(String [] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String string = sc.next();
            String sub = sc.next;
            int index1=0, index2 = 0;
            if(string.size()==0 || s.size()==0){
                System.out.println("-1");
            } else {
                System.out.println(isMatch(string,sub,index1,index2));
            }
        }
    }
    
    public static int isMatch(String s, String sub, int index1, int index2){
        int len1 = s.size();
        int len2 = s.size();
        while(index1 < len1 && index2 < len2){
            if(s2[index2]!='?' && s1[index1]!=s2[index2]) return -1;
            if(index1 - index2 > 3) return -1;
            if(s1[index1] == s2[index2]){
                index1++;
                index2++;
                continue;
            }
            if(s2[index2]=='?'&&s1[index1]!='\0'){
                if(s1[index1+1] == s2[index2+1]){
                    int temp = 0;
                    if(temp=isMatch(s, sub, index1++, index2++)!=-1){
                        return temp;
                    } else {
                        index1++;
                    }
                } else {
                    index1++;
                }
            }
            if(index1 != index2) return -1;
            else return index1;
        }
        
    }
  
}
```



### 取球

> 有K种颜色的小球(K<=10)，每种小球有若干个，总数小于100个。
> 现在有一个小盒子，能放N个小球(N<=8)，现在要从这些小球里挑出N个小球，放满盒子。
> 想知道有哪些挑选方式。注：每种颜色的小球之间没有差别。
> 请按数字递增顺序输出挑选小球的所有方式。
> 如有3种颜色，每种颜色小球的个数分别为a:1,b:2,c:3，挑出3个小球的挑法有：
> 003,012,021,102,111,120

每种小球分别取0~max值

```java
public class Main{
    private static List<Integer> path = new ArrayList<>();
    public static void print(List<Integer> l, int k) {
        StringBuilder sb = new StringBuilder();
        l.forEach(u -> sb.append(u));
        for (int i = l.size(); i < k; i++) {
            sb.append(0);
        }
        System.out.println(sb.toString());
    }
    public static void run(int[] colors, int k, int n, int level) {
        if (k == 1) {
            System.out.println(n);
            return;
        }
        for (int i = 0; i <= colors[0]; i++) {
            turn1.add(Arrays.asList(i));
        }
        List<Integer> temp;
        for (int i = 1; i < k; i++) {
            List<List<Integer>> lastTurn = turn1;
            List<List<Integer>> nowTurn = new ArrayList<>();
            for (int j = 0; j < lastTurn.size(); j++) {
                for (int z = 0; z <= colors[i]; z++) {
                    temp = new ArrayList<>();
                    temp.addAll(lastTurn.get(j));
                    temp.add(z);
                    if (i == k-1) {
                        if (temp.stream().reduce(0, (u1, u2)->u1 + u2) == n) {
                            print(temp, k);
                        }
                    } else {
                        if (temp.stream().reduce(0, (u1, u2)->u1 + u2) <= n) {
                            nowTurn.add(temp);
                        }
                    }
                }
            }
            turn1 = nowTurn;
        }
    }
 
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            int k = scanner.nextInt();
            int n = scanner.nextInt();
            int[] colors = new int[k];
            for (int i = 0; i < k; i++) {
                colors[i] = scanner.nextInt();
            }
            run(colors, k, n, 0);
        }
    }
}
```

