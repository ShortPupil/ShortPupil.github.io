---
title: 设计模式（一）——面向对象设计原则
copyright: true
date: 2018-11-12 11:25:27
tags: design pattern
---

# 目录

@[toc]



## 1. 概述

### 软件的可维护性和可复用性

- 恰当的复用可以改善系统的可维护性
- 复用的目标在于**实现支持可维护性的复用**
- 在面向对象的设计里，**可维护性复用都是以面向对象设计原则为基础**
- **重构**——不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更加合理，提高软件的扩展性和维护性



## 2. 设计原则

### 简介

| 名称 |                             简介                             |
| :--: | :----------------------------------------------------------: |
| SRP  |          类的职责要单一，不能将太多职责放在一个类里          |
| OCP  | 软件实体对扩展开放，对修改关闭。在不修改一个软件实体的基础上扩展功能。 |
| LSP  | 在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象。反之不然。 |
| DIP  |              针对抽象层编程，不要针对具体类编程              |
| ISP  |            使用多个专门的接口来取代一个统一的接口            |
| CRP  |  尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系  |
| LoD  | 一个软件实体对其他实体的引用越少越好。如果两个类不必彼此直接通信，那么两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互 |



### 2.1 单一职责原则 Single Responsibility Principle(SRP)

#### 定义

一个对象只包含**单一的职责(single responsibility)**，且该职责被完整地封装在一个类中

对一个类来说，**仅有一个(never be more than one reasion)**引起它变化的原因



#### 分析

- 一个类（模块、方法等同理）承担的职责越多，它被复用的可能性越小
- 职责在两方面：
  - 数据职责，通过**属性**体现
  - 行为职责，通过**方法**体现
- 实现**高内聚、低耦合**的指导方针



#### 实例

登录功能原结构

![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/SRP_1.png)

按原则重构后

![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/SRP_2.png)



### 2.2 开闭原则 Open-Closed Principle

#### 定义

一个软件实体应当**对扩展开放，对修改关闭(open for extension, closed for modification)**。



#### 分析

- **抽象化**是开闭原则的关键
- “**对可变性封装原则**”



#### 实例

图形界面的按钮编程

原结构

![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/OCP_1.png)

重构后

![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/OCP_2.png)



### 2.3 里氏替换原则 Liskov Substitution Principle

#### 定义

**所有引用基类（父类）的地方必须能透明地使用其子类的对象**



#### 分析

- **在软件中如果能够使用基类对象，那么一定能够使用其子类对象。**把基类都替换成其子类，程序不会产生任何错误和异常，反之不成立。
- LSP是实现OCP的重要方式之一。**在程序中尽量使用基类类型来对对象进行定义，而运行时再确定其子类类型，而子类对象来替代弗雷对象。**



#### 实例

原

![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/LSP_1.png)

重构后

![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/LSP_2.png)



### 2.4 依赖倒转原则 Dependency Inversion Principle

#### 定义

高层模块不应该依赖底层板块，它们都应该依赖抽象。**抽象不应该依赖于细节，细节应该依赖于抽象(Abstractions should not depend upon details, details should depend upon abstractions)**。

要**针对接口编程**，不要针对实现编程



#### 分析

同上定义

- 实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现。如果说开闭原则的面向对象设计的目的的话，那么**依赖倒转原则就是面向对象设计的主要目标**。
- 常见的实现方式之一是**在代码中使用抽象类，而将具体类放在配置文件中**。也就是**将抽象放进代码，将细节放进元数据(Put Abstractions in Code, Details in Metadata)**
- 类之间的耦合
  - **零耦合关系**
  - **具体耦合关系**
  - **抽象耦合关系**——以抽象方式耦合是依赖倒转原则的关键
- **依赖注入**
  - 构造注入：通过**构造函数**注入实例变量
  - 设值注入：通过**Setter方法**注入实例变量
  - 接口注入：通过**接口方法**注入实例变量



#### 实例

将来自不同数据源的数据转换为多种格式的数据转换模块

原

![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/DIP_2.png)

重构后

![](https://raw.githubusercontent.com/ShortPupil/ShortPupil.github.io/hexo/source/_posts/pictures/DIP_2.png)



### 2.5 接口隔离原则 Interface Segregation Principle

#### 定义



#### 分析



#### 实例





### 2.6 合成复用原则 Composite Reuse Principle

#### 定义



#### 分析



#### 实例





### 2.7 迪米特法则 Law of Demeter

#### 定义



#### 分析



#### 实例



