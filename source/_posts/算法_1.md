---
title: 算法_1
copyright: false
date: 2019-04-05 13:19:06
tags: [algorithm]
categories: 算法
---

@[toc]

## day1

### 冒泡排序

```java
public class BubbleSort {

    //沉底
	public static void bubbleSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int e = arr.length - 1; e > 0; e--) {
			for (int i = 0; i < e; i++) {
				if (arr[i] > arr[i + 1]) {
					swap(arr, i, i + 1);
				}
			}
		}
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
	}
}
```

时间复杂度O(N^2)，额外空间复杂度O(1)



### 选择排序

```java
public class SelectionSort {

	public static void selectionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int i = 0; i < arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < arr.length; j++) {
                //找到最小的下标在哪里
				minIndex = arr[j] < arr[minIndex] ? j : minIndex;
			}
            //i~N-1上最小的数和i上的数交换
			swap(arr, i, minIndex);
		}
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
}
```

时间复杂度O(N^2)，额外空间复杂度O(1)



### 插入排序

```java
//扑克牌整理牌
public class InsertionSort {

	public static void insertionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int i = 1; i < arr.length; i++) {
            //跟前面的比，小就交换，不小不交换
			for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
				swap(arr, j, j + 1);
			}
		}
	}

	public static void swap(int[] arr, int i, int j) {
		arr[i] = arr[i] ^ arr[j];
		arr[j] = arr[i] ^ arr[j];
		arr[i] = arr[i] ^ arr[j];
	}
}
```

时间复杂度O(N^2)，额外空间复杂度O(1)

与数据状况有关，最好O(N)，最坏O(N^2)



### 对数器

准备模板

```java
	//生成长度随机的数组
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}
		public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}

	// 选择一个绝对正确的方法
	public static void comparator(int[] arr) {
		Arrays.sort(arr);
	}

	// 大样本测试
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr1 = generateRandomArray(maxSize, maxValue);
			int[] arr2 = copyArray(arr1);
			bubbleSort(arr1);
			comparator(arr2);
			if (!isEqual(arr1, arr2)) {
				succeed = false;
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");

		int[] arr = generateRandomArray(maxSize, maxValue);
		printArray(arr);
		bubbleSort(arr);
		printArray(arr);
	}

		// for test
	public static boolean isEqual(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}

	// for test
	public static void printArray(int[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}
```



### 归并排序

```java
public class MergeSort {

	public static void mergeSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		mergeSort(arr, 0, arr.length - 1);
	}

	public static void mergeSort(int[] arr, int l, int r) {
		if (l == r) {
			return;
		}
        //左边排好序，右边排好序，再总体排好序
		int mid = l + ((r - l) >> 1);
        
		mergeSort(arr, l, mid);
		mergeSort(arr, mid + 1, r);
		merge(arr, l, mid, r);
	}

	public static void merge(int[] arr, int l, int m, int r) {
		int[] help = new int[r - l + 1];
		int i = 0;
		int p1 = l;
		int p2 = m + 1;
		while (p1 <= m && p2 <= r) {
			help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
		}
        //两个有且只有一个越界
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[l + i] = help[i];
		}
	}
}
```

时间复杂度O(N*logN)，额外空间复杂度O(N)



### 实例

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

归并思想

```java
public class SmallSum {

	public static int smallSum(int[] arr) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		return mergeSort(arr, 0, arr.length - 1);
	}

	public static int mergeSort(int[] arr, int l, int r) {
		if (l == r) {
			return 0;
		}
		int mid = l + ((r - l) >> 1);
		return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r);
	}

	public static int merge(int[] arr, int l, int m, int r) {
		int[] help = new int[r - l + 1];
		int i = 0;
		int p1 = l;
		int p2 = m + 1;
		int res = 0;
		while (p1 <= m && p2 <= r) {
			res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0; //与归并代码的唯一区别
			help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
		}
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[l + i] = help[i];
		}
		return res;
	}
}
```



逆序对问题。



## day2

### 荷兰国旗问题

小于区域  等于区域 待定区域 大于区域

```java
public class NetherlandsFlag {

	public static int[] partition(int[] arr, int l, int r, int p) {
		int less = l - 1;
		int more = r + 1;
        int cur = l;
		while (cur < more) {
			if (arr[cur] < p) {
				swap(arr, ++less, cur++);
			} else if (arr[cur] > p) {
				swap(arr, --more, cur);
			} else {
				cur++;
			}
		}
		return new int[] { less + 1, more - 1 };
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
}
```



### 快排

```java
public class QuickSort {

	public static void quickSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		quickSort(arr, 0, arr.length - 1);
	}

	public static void quickSort(int[] arr, int l, int r) {
		if (l < r) {
			swap(arr, l + (int) (Math.random() * (r - l + 1)), r);
			int[] p = partition(arr, l, r);
			quickSort(arr, l, p[0] - 1);
			quickSort(arr, p[1] + 1, r);
		}
	}

	public static int[] partition(int[] arr, int l, int r) {
		int less = l - 1;
		int more = r;
		while (l < more) {
			if (arr[l] < arr[r]) {
				swap(arr, ++less, l++);
			} else if (arr[l] > arr[r]) {
				swap(arr, --more, l);
			} else {
				l++;
			}
		}
		swap(arr, more, r);
		return new int[] { less + 1, more };
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
}
```

**在工程，快排不用递归**

```java
//partition不变
//递归变成非递归
private static void quickSort(int[] a, int start, int end) {
	LinkedList<Integer> stack = new LinkedList<Integer>(); // 用栈模拟
	if (start < end) {
		stack.push(end);
        stack.push(start);
        while (!stack.isEmpty()) {
			int l = stack.pop();
			int r = stack.pop();
            int index = partition(a, l, r);
            if (l < index - 1) {
                stack.push(index - 1);
                stack.push(l);
            }
            if (r > index + 1) {
                stack.push(r);
                stack.push(index + 1);
            }
        }
    }
}
```





### 随机快排

不是找第一个 而是随机选一个

时间复杂度O(N*logN)，额外空间复杂度O(logN)



### 堆排序

堆——完全二叉树（满二叉树）

数组定义——左孩子：`2 * i +1`；右孩子：`2 * i +2`

大根堆、小根堆

```java
public class HeapSort {

	public static void heapSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			heapInsert(arr, i);
		}
		int size = arr.length;
		swap(arr, 0, --size);
		while (size > 0) {
			heapify(arr, 0, size);
			swap(arr, 0, --size);
		}
	}

    //堆插入，建立大根堆过程
	public static void heapInsert(int[] arr, int index) {
		while (arr[index] /*当前index位置*/
               >
               arr[(index - 1) / 2] /*父位置*/ ) {
			swap(arr, index, (index - 1) / 2);
			index = (index - 1) / 2;
		}
	}

    //注意
	public static void heapify(int[] arr, int index, int size) {
		int left = index * 2 + 1;
		while (left < size) {
			int largest = left + 1 < size 
                && arr[left + 1] > arr[left] 
                ? left + 1 : left;
			largest = arr[largest] > arr[index] 
                ? largest : index;
			if (largest == index) {
				break;
			}
			swap(arr, largest, index);
			index = largest;
			left = index * 2 + 1;
		}
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
}
```

时间复杂度O(N*logN)，额外空间复杂度O(1)

堆结构非常重要

1，堆结构的heapInsert与heapify

2，堆结构的增大和减少

3，如果只是建立堆的过程，时间复杂度为O(N)

4，优先级队列结构，就是堆结构



### 排序的稳定性

| 排序     | 稳定性                                       | 复杂度 |
| -------- | -------------------------------------------- | ------ |
| 冒泡排序 | 可以实现成稳定的（不往前换）                 | O(N^2) |
| 插入排序 | 可以实现成稳定的（不往前插）                 | O(N^2) |
| 选择排序 | 不可能稳定                                   | O(N^2) |
| 归并排序 | 可以实现成稳定的（遇到相等的就先拷贝左边的） |        |
| 快速排序 | 不可以稳定                                   |        |
| 堆排序   | 做不到稳定（二叉树）                         |        |



### 排序问题的补充

- 归并排序，**内部缓存法**，空间复杂度可以变成O(1)，但极难
- 快排可以做到稳定性问题，但非常难，**01 stable sort**



### 不基于比较的排序

桶排序 计数排序 基数排序

- 非基于比较的排序，与被排序的样本的实际数据状况很有关系，所以实际中并不经常使用 
- 时间复杂度O(N)，额外空间复杂度O(N) 
- 稳定的排序



### 补充问题

**MaxGap**：给定一个数组，求如果排序之后，相邻两数的最大差值，要求**时间复杂度O(N)**，且要求不**能用非基于比较的排序**。

借用了桶的概念，但没进行桶排序

1. 准备桶，有n个数，就准备n+1个桶

2. 先遍历整个数组，找到max  min

3. 如果 max==min，说明只有一种树，return 0

4. 如果 max!=min，最小值放在第0号桶，最大值放在第n号桶里，中间范围被等分，数放在相应范围的桶里

   例如：[] 9个数；0~99 10个桶；

5. 中间必然存在一个空桶，一个桶内部的差值一定不是我们要的答案

```java
public class MaxGap {

	public static int maxGap(int[] nums) {
		if (nums == null || nums.length < 2) {
			return 0;
		}
		int len = nums.length;
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
        
        //找最值
		for (int i = 0; i < len; i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
		if (min == max) {
			return 0;
		}
        
        //长度为n+1的；表示0~n号桶的n+1组信息
		boolean[] hasNum = new boolean[len + 1];//是否有值
		int[] maxs = new int[len + 1];//最大值
		int[] mins = new int[len + 1];//最小值
		int bid = 0;
        
        //只存桶里的最大最小值，和是否存了值，别的全扔了
		for (int i = 0; i < len; i++) {
			bid = bucket(nums[i], len, min, max); //在哪个桶
			mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];
			maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];
			hasNum[bid] = true;
		}
        
        //临近的两个非空桶，一个的最小值和上一个最大值的差
		int res = 0;
		int lastMax = maxs[0];
		int i = 1;
		for (; i <= len; i++) {
			if (hasNum[i]) {
                //全局最大值
				res = Math.max(res, mins[i] - lastMax);
				lastMax = maxs[i];
			}
		}
		return res;
	}

	public static int bucket(long num, long len, long min, long max) {
		return (int) ((num - min) * len / (max - min));
	}
｝
```



### 工程常用

数组长度极短——插入排序

数组中是基础类型——快排，基础类型相同值无差别

自己定义的类型, Object的字段——归并排序



## day3

### 用数组结构实现大小固定的队列和栈

```java
public class Code_01_Array_To_Stack_Queue {

    //栈
	public static class ArrayStack {
		private Integer[] arr;
		private Integer size;//就是指针

        //空间开多大
		public ArrayStack(int initSize) {
			if (initSize < 0) {
				throw new IllegalArgumentException("The init size is less than 0");
			}
			arr = new Integer[initSize];
			size = 0;
		}

        //返回栈顶，但留着它
		public Integer peek() {
			if (size == 0) {
				return null;
			}
			return arr[size - 1];
		}

		public void push(int obj) {
			if (size == arr.length) {
				throw new ArrayIndexOutOfBoundsException("The queue is full");
			}
			arr[size++] = obj;
		}

		public Integer pop() {
			if (size == 0) {
				throw new ArrayIndexOutOfBoundsException("The queue is empty");
			}
			return arr[--size];
		}
	}

    //队列
	public static class ArrayQueue {
		private Integer[] arr;
		private Integer size;//约束大小的，
		private Integer first;//这是指针，指头
		private Integer last;//这也是指针，指尾指针的后一个位置

		public ArrayQueue(int initSize) {
			if (initSize < 0) {
				throw new IllegalArgumentException("The init size is less than 0");
			}
			arr = new Integer[initSize];
			size = 0;
			first = 0;
			last = 0;
		}

		public Integer peek() {
			if (size == 0) {
				return null;
			}
			return arr[first];
		}

		public void push(int obj) {
			if (size == arr.length) {
				throw new ArrayIndexOutOfBoundsException("The queue is full");
			}
			size++;
			arr[last] = obj;
			last = last == arr.length - 1 ? 0 : last + 1;//跳回到0
		}

		public Integer poll() {
			if (size == 0) {
				throw new ArrayIndexOutOfBoundsException("The queue is empty");
			}
			size--;
			int tmp = first;
			first = first == arr.length - 1 ? 0 : first + 1;
			return arr[tmp];
		}
	}
}
```



### 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。

- pop、push、getMin操作的时间复杂度都是O(1)。 

- 设计的栈类型可以使用现成的栈结构。

```java
	public static class MyStack2 {
		private Stack<Integer> stackData;
		private Stack<Integer> stackMin;

		public MyStack2() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum < this.getmin()) {
				this.stackMin.push(newNum);
			} else {
				int newMin = this.stackMin.peek();
				this.stackMin.push(newMin);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			this.stackMin.pop();
			return this.stackData.pop();
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}
```





### 如何仅用队列结构实现栈结构？ 如何仅用栈结构实现队列结构？

```java
package class_03;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class StackAndQueueConvert {

    //栈实现队列结构
	public static class TwoStacksQueue {
        //定义两个栈
		private Stack<Integer> stackPush;
		private Stack<Integer> stackPop;

		public TwoStacksQueue() {
			stackPush = new Stack<Integer>();
			stackPop = new Stack<Integer>();
		}

        //直接进栈
		public void push(int pushInt) {
			stackPush.push(pushInt);
		}

        //把push的倒进pop
        //一次要倒完！
        //pop栈有东西，push栈一定不要倒
		public int poll() {
			if (stackPop.empty() && stackPush.empty()) {
				throw new RuntimeException("Queue is empty!");
			} else if (stackPop.empty()) {
				while (!stackPush.empty()) {
					stackPop.push(stackPush.pop());
				}
			}
			return stackPop.pop();
		}

		public int peek() {
			if (stackPop.empty() && stackPush.empty()) {
				throw new RuntimeException("Queue is empty!");
			} else if (stackPop.empty()) {
				while (!stackPush.empty()) {
					stackPop.push(stackPush.pop());
				}
			}
			return stackPop.peek();
		}
	}

    //队列实现栈结构
	public static class TwoQueuesStack {
        //定义两个队列
		private Queue<Integer> queue;
		private Queue<Integer> help;

		public TwoQueuesStack() {
			queue = new LinkedList<Integer>();
			help = new LinkedList<Integer>();
		}

        //直接先进queue队列
		public void push(int pushInt) {
			queue.add(pushInt);
		}

        //同pop
		public int peek() {
			if (queue.isEmpty()) {
				throw new RuntimeException("Stack is empty!");
			}
			while (queue.size() != 1) {
				help.add(queue.poll());
			}
			int res = queue.poll();
			help.add(res);
			swap();
			return res;
		}

        //因为要先进的后出，pop就不停地把queue的树poll并且add进help，queue剩下一个数，就是要pop的数，然后再交换help和queue，因为此时help保存所有剩余数
		public int pop() {
			if (queue.isEmpty()) {
				throw new RuntimeException("Stack is empty!");
			}
			while (queue.size() > 1) {
				help.add(queue.poll());
			}
			int res = queue.poll();
			swap();
			return res;
		}

		private void swap() {
			Queue<Integer> tmp = help;
			help = queue;
			queue = tmp;
		}

	}

}

```



### 猫狗队列



### 转圈打印矩阵 

> 【题目】 给定一个整型矩阵matrix，请按照转圈的方式打印它。 
>
> 例如： 
>
> 1 2 3 4 
>
> 5 6 7 8 
>
> 9 10 11 12 
>
> 13 14 15 16
>
> 打印结果为：1，2，3，4，8，12，16，15，14，13，9， 5，6，7，11， 10 
>
> 【要求】 额外空间复杂度为O(1)

```java
public class ZigZagPrintMatrix {

	public static void printMatrixZigZag(int[][] matrix) {
		int tR = 0;
		int tC = 0;
		int dR = 0;
		int dC = 0;
		int endR = matrix.length - 1;
		int endC = matrix[0].length - 1;
		boolean fromUp = false;
		while (tR != endR + 1) {
			printLevel(matrix, tR, tC, dR, dC, fromUp);
			tR = tC == endC ? tR + 1 : tR;
			tC = tC == endC ? tC : tC + 1;
			dC = dR == endR ? dC + 1 : dC;
			dR = dR == endR ? dR : dR + 1;
			fromUp = !fromUp;
		}
		System.out.println();
	}

	public static void printLevel(int[][] m, int tR, int tC, int dR, int dC,
			boolean f) {
		if (f) {
			while (tR != dR + 1) {
				System.out.print(m[tR++][tC--] + " ");
			}
		} else {
			while (dR != tR - 1) {
				System.out.print(m[dR--][dC++] + " ");
			}
		}
	}
}
```

