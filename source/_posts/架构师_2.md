@[toc]

# 第1章 操作系统

## 操作系统的类型与结构

根据考试大纲要求，在操作系统方面，要求考生掌握以下知识点：

（1）操作系统的类型和结构；

（2）操作系统基本原理；

（3）网络操作系统及网络管理；

（4）嵌入式操作系统与实时操作系统。

本章主要介绍操作系统方面的基本知识，有关网络管理方面的知识，将在第4章中介绍；有关嵌入式操作系统与实时操作系统方面的知识，将在第3章介绍。操作系统是计算机系统中的核心系统软件，负责管理和控制计算机系统中硬件和软件资源，合理地组织计算机工作流程和有效利用资源，在计算机与用户之间起接口的作用。



## 操作系统的类型

根据使用环境和对作业的处理方式，操作系统可分为**批处理操作系统**、**分时操作系统**、**实时操作系统**、**网络操作系统**和**分布式操作系统**。

（1）批处理操作系统把用户提交的作业分类，把一批中的作业编成一个作业执行序列。批处理又可分为联机批处理和脱机批处理。批处理系统的主要特征有：用户脱机使用计算机、成批处理、多道程序运行。批处理操作系统主要用在早起的大型机上，现在基本上已经被淘汰了。

（2）分时操作系统采用分时技术，使多个用户同时以会话方式控制自己程序的运行，每个用户都感到似乎各自有一台独立的、支持自己请求服务的系统。分时技术把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮时再继续运行。分时系统的主要特征有：交互性、多用户同时性、独立性。例如，Unix和Linux就是典型的分时操作系统。

（3）实时操作系统往往是专用的，系统与应用很难分离，常常紧密结合在一起。实时系统并不强调资源利用率，而更关心及时性(时间紧迫性)、可靠性和完整性。实时系统又分为实时过程控制与实时信息处理两种。实时系统的主要特征有：提供即时响应、高可靠性。例如，Windows CE、嵌入式Linux、VxWorks等都属于实时操作系统。

（4）网络操作系统按照网络架构的各个协议标准进行开发，包括网络管理、通信、资源共享、系统安全和多种网络应用服务等。在网络系统中，各计算机的操作系统可以互不相同，它需要一种机制来支持互连的网络环境下的异种计算机系统之间的进程通信，实现协同工作和应用集成。网络操作系统的主要特征有：互操作性、协作处理。例如，Windows Server、Unix等都可以看作是网络操作系统。

（5）分布式操作系统要求一个统一的操作系统，实现系统操作的统一性，负责全系统的资源分配和调度，为用户提供统一的界面。它是一个逻辑上紧密耦合的系统。目前还没有真正实现的分布式操作系统。

不管哪种操作系统，都应该具有五个基本功能，即**处理机管理**、**存储管理**、**设备管理**、**文件管理**和**作业管理**。



## 操作系统的结构

操作系统的结构可以分为**无序结构**、**层次结构**、**面向对象结构**、**对称多处理结构**和**微内核结构**。

（1）无序结构，又称整体结构或模块组合结构。它以大型表格和队列为中心，操作系统的各部分程序围绕着表格运行，整个系统是一个程序。这种操作系统常称为面向过程的操作系统。操作系统由许多标准的、可兼容的基本单位构成（称为模块），各模块相对独立，模块之间通过规定的接口相互调用。模块化设计方法的优点是缩短了系统的开发周期，缺点是模块之间调用关系复杂、相互依赖，从而使分析、移植和维护系统较易出错。

（2）层次结构。把一个大型复杂的操作系统分解成若干个单向依赖的层次，由多层的正确性保证操作系统的可靠性。层次结构清晰，大大地简化了接口的设计，且有利于系统功能的增加或删改，易于保证可靠性，也便于维护和移植。

（3）面向对象结构。基于面向对象程序设计的概念，采用了各种不同的对象技术。在计算机系统中对象是操作系统管理的信息和资源的抽象，是一种抽象的数据类型。可以把对象作为系统中的最小单位，由对象、对象操作、对象保护组成的操作系统，就是面向对象的操作系统。如Windows Server中有执行体对象（例如，进程、线程、文件和令牌等）和内核对象（例如，时钟、事件和信号等）。面向对象结构的优点是适用于网络操作系统和分布式操作系统中。

（4）对称多处理结构。如果一个操作系统在系统中的所有处理机运行且共享同一内存（内存储器、主存、实存），这样的系统就是一个对称多处理系统。优点是适合共享存储器结构的多处理机系统，即紧耦合的多处理机系统。

（5）微内核结构。把系统的公共部分抽象出来，形成一个底层核心，提供最基本的服务，其他功能以服务器形式建立在微内核之上。它具有良好的模块化和结构化特征，模块之间和上下层之间通过消息来通信。建立在微内核上的服务器可以根据不同的需要构造，从而形成不同的操作系统。

现代操作系统大多拥有两种工作状态：核心态和用户态。我们使用的一般应用程序工作在用户态，而内核模块和最基本的操作系统核心工作在核心态。

微内核结构由一个非常简单的硬件抽象层和一组比较关键的原语或系统调用组成，这些原语仅仅包括了建立一个系统必需的几个部分，如线程管理，地址空间和进程间通信等。微内核的目标是将系统服务的实现和系统的基本操作规则分离开来。例如，进程的输入/输出锁定服务可以由运行在微内核之外的一个服务组件来提供。这些非常模块化的用户态服务用于完成操作系统中比较高级的操作，这样的设计使内核中最核心的部分的设计更简单。一个服务组件的失效并不会导致整个系统的崩溃，内核需要做的，仅仅是重新启动这个组件，而不必影响其它的部分。

 

微内核技术的主要优点如下：

（1）统一的接口，在用户态和核心态之间无需进程识别。

（2）可伸缩性好，能适应硬件更新和应用变化。

（3）可移植性好，所有与具体机器特征相关的代码，全部隔离在微内核中，如果操作系统要移植到不同的硬件平台上，只需修改微内核中极少代码即可。

（4）实时性好，微内核可以方便地支持实时处理。

（5）安全可靠性高，微内核将安全性作为系统内部特性来进行设计，对外仅使用少量应用编程接口。

（6）支持分布式系统，支持多处理器的架构和高度并行的应用程序。

（7）真正面向对象的操作系统。

由于操作系统核心常驻内存，而微内核结构精简了操作系统的核心功能，内核规模比较小，一些功能都移到了外存上，所以微内核结构十分适合嵌入式的专用系统，对于通用性较广的系统，将使CPU（Central Processing Unit，中央处理单元）的通信开销增大，从而影响到计算机的运行速度。



## 处理器管理

在单用户多任务的操作系统中，或者多用户多任务的操作系统中，系统同时运行多个程序，这些程序的并行运行势必形成对系统资源的竞争使用。因此，操作系统必须能够处理和管理这种并行运行的程序，使之对资源的使用按照良性的顺序进行。



## 进程的状态

进程是一个程序关于某个数据集的一次运行。进程是程序的一次运行活动，是一个动态的概念，而程序是静态的概念，是指令的集合。进程具有动态性和并发性，程序是进程运行所对应的运行代码，一个进程对应于一个程序，一个程序可以同时对应于多个进程。在操作系统中进程是进行系统资源分配、调度和管理的最小单位（注意，现代操作系统中还引入了线程（thread）这一概念，它是处理器分配资源的最小单位）。从静态的观点看，进程由程序、数据和进程控制块（Process Control Block，PCB）组成；从动态的观点看，进程是计算机状态的一个有序集合。

PCB是进程存在的唯一标志，PCB描述了进程的基本情况。其中的内容可分成为调度信息和执行信息两大部分。调度信息供进程调度使用，包括进程当前的一些基本属性；执行信息即现场，规划了进程的执行情况。PCB随着进程的建立而产生，随着进程的完成而撤消。一个进程从创建而产生至撤销而消亡的整个生命周期，可以用一组状态加以刻画，为了便于管理进程，把进程划分为几种状态，分别有三态模型和五态模型。

### 1．三态模型

按照进程在执行过程中的不同状况，至少可以定义三种不同的进程状态：

（1）运行态：占有处理器正在运行。

（2）就绪态：具备运行条件，等待系统分配处理器以便运行。

（3）等待态（阻塞态）：不具备运行条件，正在等待某个事件的完成。

一个进程在创建后将处于就绪状态。每个进程在执行过程中，任一时刻当且仅当处于上述三种状态之一。同时，在一个进程执行过程中，它的状态将会发生改变。图1-1表示进程的状态转换。

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps6.png) 

 运行状态的进程将由于出现等待事件而进入等待状态，当等待事件结束之后等待状态的进程将进入就绪状态，而处理器的调度策略又会引起运行状态和就绪状态之间的切换。引起进程状态转换的具体原因如下：

（1）运行态→等待态：等待使用资源，如等待外设传输；等待人工干预。

（2）等待态→就绪态：资源得到满足，如外设传输结束；人工干预完成。

（3）运行态→就绪态：运行时间片到；出现有更高优先权进程。

（4）就绪态→运行态：CPU空闲时选择一个就绪进程。

### 2．五态模型

在三态模型中，总是假设所有的进程都在内存中。事实上，可能出现这样一些情况，例如由于进程的不断创建，系统的资源已经不能满足进程运行的要求，这个时候就必须把某些进程挂起，对换到磁盘镜像区中，暂时不参与进程调度，起到平滑系统操作负荷的目的。引起进程挂起的原因是多样的，主要有：

（1）系统中的进程均处于等待状态，处理器空闲，此时需要把一些阻塞进程对换出去，以腾出足够的内存装入就绪进程运行。

（2）进程竞争资源，导致系统资源不足，负荷过重，此时需要挂起部分进程以调整系统负荷，保证系统的实时性或让系统正常运行。

（3）把一些定期执行的进程（如审计程序、监控程序、记账程序）对换出去，以减轻系统负荷。

（4）用户要求挂起自己的进程，以便根据中间执行情况和中间结果进行某些调试、检查和改正。

（5）父进程要求挂起自己的后代子进程，以进行某些检查和改正。

（6）操作系统需要挂起某些进程，检查运行中资源使用情况，以改善系统性能；或当系统出现故障或某些功能受到破坏时，需要挂起某些进程以排除故障。

 给出了具有挂起进程功能的系统中的进程状态。在此类系统中，进程增加了两个新状态：**静止就绪态**和**静止阻塞态**。为了区别，而把三态模型中的等待态改名为活跃阻塞态，就绪态改名为活跃就绪态。静止就绪态表明进程具备运行条件但目前在二级存储器（外存储器、外存、辅存）中，只有当它被对换到内存才能被调度执行。静止阻塞态则表明进程正在等待某一个事件且在二级存储器中。

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps7.png) 

 具有挂起功能系统的进程状态及其转换引起进程状态转换的具体原因如下：

 （1）活跃阻塞态→静止阻塞态：如果当前不存在活跃就绪进程，那么至少有一个等待态进程将被对换出去成为静止阻塞态；操作系统根据当前资源状况和性能要求，可以决定把活跃阻塞态进程对换出去成为静止阻塞态。

（2）静止阻塞态→静止就绪态：引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态。

（3）静止就绪态→活跃就绪态：当内存中没有活跃就绪态进程，或者静止就绪态进程具有比活跃就绪态进程更高的优先级，系统将把静止就绪态进程转换成活跃就绪态。

（4）活跃就绪态→静止就绪态：操作系统根据当前资源状况和性能要求，也可以决定把活跃就绪态进程对换出去成为静止就绪态。

（5）静止阻塞态→活跃阻塞态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是，当一个进程退出后，内存已经有了一大块自由空间，而某个静止阻塞态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。

不难看出：一个挂起进程等同于不在内存的进程，因此挂起的进程将不参与进程调度直到它们被对换进内存。一个挂起进程具有如下特征：

（1）该进程不能立即被执行。

（2）挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。

（3）进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。

（4）结束进程挂起状态的命令只能通过操作系统或父进程发出。

（5）阻塞态：进入阻塞态通常是因为在等待I/O完成或等待分配到所需资源。



## 信号量与PV操作 

对于本知识点的考查，重点在于理解信号量与PV操作的基本概念，能够正确地理解在互斥、同步方面的控制应用，并能够灵活地运用，相对来说是个难点。

在操作系统中，进程之间经常会存在**互斥（都需要共享独占性资源时）**和**同步（完成异步的两个进程的协作）**两种关系。为了有效地处理这两种情况，W·Dijkstra在1965年提出信号量和PV操作。

（1）信号量：是一种特殊的变量，表现形式是一个整型S和一个队列。

（2）P操作：S=S-1，若S<0，进程暂停执行，进入等待队列。

（3）V操作：S=S+1，若S≤0，唤醒等待队列中的一个进程。

### 1．互斥控制

互斥控制是为了**保护共享资源，不让多个进程同时访问这个共享资源**，换句话说，就**是阻止多个进程同时进入访问这些资源的代码段**，这个代码段称为临界区，而这种一次只允许一个进程访问的资源称为临界资源。为了实现进程互斥地进入自己的临界区，代码可以如下所示：

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps9.png) 

由于只允许一个进程进入，因此信号量S的初值应该为1。该值表示可以允许多少个进程进入，当S<0时，其绝对值就是等待使用临界资源的进程数，也就是等待队列中的进程数。而当一个进程从临界区出来时，执行V操作（S=S+1），如果等待队列中还有进程（S≤0），则调入一个新的进程进入（唤醒）。

### 2．同步控制

最简单的同步形式是**进程A在另一个进程B到达L2以前，不应前进到超过点L1**，这样就可以使用如下程序：

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps10.png) 

因此，要确保进程B执行V操作之前，不让进程A的运行超过L1，就要设置信号量S的初值为0。这样，如果进程A先执行到L1，那么执行P操作（S=S-1）后，则S<0，就停止执行。直到进程B执行到L2时，将执行V操作（S=S+1），唤醒A以继续执行。

### 3．生产者-消费者问题

生产者-消费者是一个经典的问题，它不仅要解决生产者进程与消费者进程的同步关系，还要处理缓冲区的互斥关系，因此通常需要三个信号量来实现，如表1-1所示。

| 信号量 | 功能类别 | 功能说明                                                     |
| ------ | -------- | ------------------------------------------------------------ |
| empty  | 同步     | 说明**空闲的缓冲区数量**，因为程序开始时，缓冲区全部为空。所以，其初始值应为**缓冲区的总个数**。 |
| full   | 同步     | 说明**已填充的缓冲区数量**，因为程序开始时，所有缓冲区都为空（未填充）。所以，其**初始值为0**。 |
| mutex  | 互斥     | 保证同时只有一个进程在写缓冲区，因此其初始值为1              |

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps11.png) 

如果对缓冲区的读写无须进行互斥控制的话，那么就可以省去mutex信号量。

### 4．理解P、V操作

信号量与PV操作的概念比较抽象，在历年的考试中总是难倒许多考生，其实主要还是没有能够正确地理解信号量的含义。

（1）信号量与P、V操作是用来**解决并发问题**的，而在并发问题中最重要的是互斥与同步两个关系，也就是说只要有这两个关系存在，信号量就有用武之地。因此，在解题时，应该先从寻找互斥与同步关系开始。这个过程可以套用简单互斥、简单同步、生产者-消费者问题。

（2）通常来说，一个互斥或一个同步关系可以使用一个信号量来解决，但要注意经常会忽略一些隐藏的同步关系。例如：在生产者-消费者问题中，就有**两个同步关系**，**一个是判断是否还有足够的空间给生产者存放产物**，**另一个是判断是否有足够的内容让消费者使用**。

（3）信号量的初值通常就是表示资源的可用数。而且通常对于初始为0的信号量，会先做V操作。

（4）在资源使用之前，将会使用P操作；在资源用完之后，将会使用V操作。在互斥关系中，P、V操作是在一个进程中成对出现的；而在同步关系中，则P、V操作一定是在两个进程甚至是多个进程中成对出现的。

### 5．实际应用

......



## 死锁问题

死锁是指**多个进程之间互相等待对方的资源，而在得到对方资源之前又不释放自己的资源，这样，造成循环等待的一种现象**。如果一个进程在等待一个不可能发生的事件，则进程就死锁了。如果一个或多个进程产生死锁，就会造成系统死锁。

### 1．死锁发生的必要条件

 产生死锁的根本原因在于系统提供的资源个数少于并发进程所要求的该类资源数。产生死锁有四个必要条件：**互斥条件**，**不可抢占条件**，**保持与等待条件（部分分配条件）**、**循环等待条件**。

（1）互斥条件：即一个资源每次只能被一个进程使用。

（2）保持与等待条件：有一个进程已获得了一些资源，但因请求其他资源被阻塞时，对已获得的资源保持不放。

（3）不可抢占条件：有些系统资源是不可抢占的，当某个进程已获得这种资源后，系统不能强行收回，只能由进程使用完时自己释放。

（4）循环等待条件：若干个进程形成环形链，每个都占用对方要申请的下一个资源。

### 2．银行家算法

所谓银行家算法，是指在分配资源之前先看清楚，资源分配后是否会导致系统死锁。如果会死锁，则不分配，否则就分配。

按照银行家算法的思想，当进程请求资源时，系统将按如下原则分配资源：

 （1）当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程。

（2）进程可以分期请求资源，但请求的总数不能超过最大需求量。

（3）当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源。

（4）当系统现有的资源能满足进程尚需资源数时，必须测试系统现存的资源能否满足该进程尚需的最大资源数，若能满足则按当前的申请量分配资源，否则也要推迟分配。

### 例子

### 3．解决死锁的策略

 对待死锁的策略主要有：

（1）**死锁预防**：破坏导致死锁必要条件中的任意一个就可以预防死锁。例如，要求用户申请资源时一次性申请所需要的全部资源，这就破坏了保持和等待条件；将资源分层，得到上一层资源后，才能够申请下一层资源，它破坏了环路等待条件。预防通常会降低系统的效率。

（2）**死锁避免**：避免是指进程在每次申请资源时判断这些操作是否安全，例如，使用银行家算法。死锁避免算法的执行会增加系统的开销。

（3）**死锁检测**：死锁预防和避免都是事前措施，而死锁的检测则是判断系统是否处于死锁状态，如果是，则执行死锁解除策略。

（4）**死锁解除**：这是与死锁检测结合使用的，它使用的方式就是剥夺。即将某进程所拥有的资源强行收回，分配给其他的进程。



## 管程与线程 

管程由**管程名**、**局部子管程的变量说明**、**使用共享资源并在数据集上进行操作的若干过程**，以及**对变量赋初值的语句**等四个基本部分组成。每一个管程管理一个临界资源。当有几个进程调用某管程时，仅允许一个进程进入管程，其他调用者必须等待，也就是申请进程必须互斥地进入管程。方法是通过调用特定的管程入口进入管程，然后通过管程中的一个过程使用临界资源。当某进程通过调用请求访问某临界资源而未能满足时，管程调用相应同步原语使该进程等待，并将它排在等待队列上。当使用临界资源的进程访问完该临界资源并释放之后，管程又调用相应的同步原语唤醒等待队列中的队首进程。为了表示不同的等待原因，设置条件变量，条件变量是与普通变量不同的变量，条件变量不能取任何值，只是一个排队栈。

线程是进程的活动成分，是处理器分配资源的最小单位，它可以共享进程的资源与地址空间，通过线程的活动，进程可以提供多种服务（对服务器进程而言）或实行子任务并行（对用户进程而言）。每个进程创建时只有一个线程，根据需要在运行过程中创建更多的线程（前者也可称“主线程”）。显然，只有主线程的进程才是传统意义下的进程。内核负责线程的调度，线程的优先级可以动态地改变。采用线程机制的最大优点是节省开销，传统的进程创建子进程的办法内存开销大，而且创建时间也长。

在多线程系统中，一个进程可以由一个或多个线程构成，每一线程可以独立运行，一个进程的线程共享这个进程的地址空间。有多种方法可以实现多线程系统，一种方法是核心级线程，另一种方法是用户级线程，也可以把两者组合起来。

多线程实现的并行避免了进程间并行的缺点：创建线程的开销比创建进程要小，同一进程的线程共享进程的地址空间，所以线程切换（处理器调度）比进程切换快。例如，Windows Server内核采用基于优先级的方案选定线程执行的次序。高优先级线程先于低优先级线程执行，内核周期性地改变线程的优先级，以确保所有线程均能执行。



## 文件管理

文件管理是**对外部存储设备上的以文件方式存放的信息的管理**。文件的结构是指文件的组织形式，从用户观点所看到的文件组织形式，称为文件的逻辑结构。文件的物理结构是指文件在存储设备上的存放方法，侧重于提高存储器的利用效率和降低存取时间。文件的存储设备通常划分为大小相同的物理块，物理块是分配和传输信息的基本单位。用户通过对文件的访问（读写）来完成对文件的查找、修改、删除和添加等操作。常用的访问方法有两种，即顺序访问和随机访问。



## 文件的逻辑组织 

文件的逻辑组织是**为了方便用户的使用**，逻辑结构是用户可见的结构。文件的逻辑结构可以分为**无结构的字符流文件**和**有结构的记录**（有格式文件）文件两种。记录文件由记录组成，即文件的内容划分成多个记录，以记录为单位组织和使用信息。

常用的**记录式结构**有**连续结构**、**多重结构**、**转置结构**、**顺序结构**。

（1）连续结构：连续结构是一种把记录按生成的先后顺序排列的逻辑结构。连续结构的特点是适用性强，可用于所有文件，且记录的排列顺序与记录的内容无关。缺点是搜索性能较差。

（2）多重结构：多重文件把记录按键和记录名排列成行列式结构，一个包含n个记录名、m个键的文件构成一个m*n维行列式。

（3）转置结构：转置结构把含有相同键的记录指针全部指向该键，也就是说，把所有与同一键对应的记录的指针连续地置于目录中该键的位置下。转置结构最适合于给定键后的记录搜索。

（4）顺序结构：顺序结构把文件中的键按规定的顺序排列起来。

 用户通过对文件的存取来完成对文件的修改、追加和搜索等操作，常用的存取方法有顺序存取法、随机存取法（直接存取法）和按键存取法。



## 文件的物理组织 

在文件系统中，文件的存储设备通常划分为若干个大小相等的物理块。文件的物理结构是指文件在存储设备上的存储方法，常用的文件物理结构有连续文件、串联文件和索引文件。

 （1）**连续文件（顺序文件）**：连续文件是一种最简单的物理文件结构，它把一个在逻辑上连续的文件信息依次存放到物理块中。连续文件的优点是一旦知道文件在文件存储设备上的起始位置和文件长度，就能进行存取。连续文件适合于顺序存取，在连续存取相邻信息时，存取速度快。其缺点是在文件建立时必须指定文件的信息长度，以后不能动态增长，一般不宜于需要经常修改的文件。

（2）**串联文件（链接文件）**：串联文件用非连续的物理块来存放文件信息，这些物理块之间没有顺序关系，其中每个物理块设有一个指针，指向下一个物理块的地址，这样，所有的物理块都被链接起来，形成一个链接队列。串联文件的优点是可以解决存储器的碎片问题，提高存储空间利用率。由于串联文件只能按照队列中的链接指针顺序查找，因此搜索效率低，一般只适用于顺序访问，不适用于随机存取。

（3）**索引文件**：索引文件是另一种**对文件存储不连续分配**的方法。为每个文件建立一张索引表，索引表中的每一表项指出文件信息所在的逻辑块号和与之对应的物理块号。索引文件既可以满足文件动态增长的要求，又可以方便而迅速地实现随机存取。对一些大的文件，当索引表的大小超过一个物理块时，会发生索引表的分配问题。一般采用多级（间接索引）技术，这时在由**索引表指出的物理块中存放的不是文件地址而是存放文件信息的物理块地址**。这样，如果一个物理块能存储n个地址，则一级间接索引，将使可寻址的文件长度变成n2块，对于更大的文件可以采用二级甚至三级间接索引（例如，Unix操作系统采用三级索引结构）。索引文件的优点是既适用于顺序存取，又适用于随机存取。缺点是索引表增加了存储空间的开销。另外，在存取文件时至少需要访问两次磁盘，一次是访问索引表，另一次是根据索引表提供的物理块号访问文件信息。为了提高效率，一种改进的方法是，在对某个文件进行操作之前，预先把索引表调入内存。这样，文件的存取就能直接从在内存的索引表中确定相应的物理块号，从而只需要访问一次磁盘。



## 树形目录结构

文件控制块的集合称为文件目录，文件目录也被组织成文件，常称为目录文件。文件管理的一个重要方面是对文件目录进行组织和管理。文件系统一般采用一级目录结构、二级目录结构和多级目录结构。DOS、Unix、Windows系统都是采用多级树形目录结构。

在多级树形目录结构中，整个文件系统有一个根，然后在根上分枝，任何一个分枝上都可以再分枝，枝上也可以长出树叶。根和枝称为目录或文件夹。而树叶则是一个个的文件。实践证明，这种结构的文件系统效率比较高。例如：图1-5就是一个树形目录结构，其中方框代表目录，圆形代表文件。

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps21.png) 

在树形目录结构中，树的根节点为根目录，数据文件作为树叶，其他所有目录均作为树的节点。系统在建立每一个目录时，都会自动为它设定两个目录文件，一个是“.”，代表该目录自己，另一个是“..”，代表该目录的父目录。对于根目录，“.”和“..”都代表其自己。

从逻辑上讲，用户在登录到系统中之后，每时每刻都处在某个目录之中，此目录被称作工作目录或当前目录，工作目录是可以随时改变的。

对文件进行访问时，需要用到路径的概念。路径是指从树形目录中的某个目录层次到某个文件的一条道路。在树形目录结构中，从根目录到任何数据文件之间，只有一条唯一的通路，从树根开始，把全部目录文件名与数据文件名依次用“/”连接起来，构成该数据文件的路径名，且每个数据文件的路径名是唯一的。这样，可以解决文件重名问题，不同路径下的同名文件不一定是相同的文件。例如：在图1-5中，根目录下的文件f1和/D1/W1目录下的文件f1可能是相同的文件，也可能是不相同的文件。

用户在对文件进行访问时，要给出文件所在的路径。路径又分相对路径和绝对路径。绝对路径是指从根目录开始的路径，也称为完全路径；相对路径是从用户工作目录开始的路径。应该注意到，在树形目录结构中到某一确定文件的绝对路径和相对路径均只有一条。绝对路径是确定不变的，而相对路径则随着用户工作目录的变化而不断变化。用户要访问一个文件时，可以通过路径名来引用。例如：在图1-5中，如果当前目录是D1，则访问文件f2的绝对路径是/D1/W2/f2，相对路径是W2/f2。如果当前目录是W1，则访问文件f2的绝对路径仍然是/D1/W2/f2，但相对路径变为../W2/f2。在Windows系统中，有两种格式的文件，分别是FAT32（FAT16）文件和NTFS文件。NTFS在使用中产生的磁盘碎片要比FAT32少，安全性也更高，而且支持单个文件的容量更大，超过了4GB，特别适合现在的大容量存储。NTFS可以支持的分区（如果采用动态磁盘则称为卷）大小可以达到2TB，而Windows 2000中的FAT32支持分区的大小最大为32GB。



## 存储空间管理 

 由于文件存储设备是分成许多大小相同的物理块，并以块为单位交换信息，因此，**文件存储设备的管理，实质上是对空闲块的组织和管理问题，它包括空闲块的组织、空闲块的分配与空闲块的回收等问题。**

### 1．空闲表法

空闲表法属于**连续分配**，系统为外存上的所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项，包括序号、第一空闲盘块号和空闲盘块数。

### 2．空闲链表法

将所**有空闲盘区，拉成一条空闲链**，根据构成链所用的基本元素的不同，可把链表分成两种形式：

（1）空闲盘块链。将磁盘上所有空闲区空间，以盘块为单位拉成一条链，当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块链给用户。当用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。空闲盘块链分配和回收一个盘块的过程非常简单，但在为一个文件分配盘块时，可能要重复多次操作。

（2）空闲盘区链。将磁盘上所有空闲盘区拉成一条链，在每个盘区上包含若干用于指示下一个空闲盘区的指针，指明盘区大小的信息。分配盘块时，通常采用首次适应算法（显式链接法）。在回收时，要将回收区与空闲盘区相合并。

### 3．位图法

位图（bitmap）用二进制位表示磁盘中的一个盘块的使用情况，0表示空闲，1表示已分配。磁盘上的所有盘块都与一个二进制位相对应，由所有的二进制位构成的集合，称为位图。位图法的优点是**很容易找到一个或一组相邻的空闲盘块**。位图小，可以把它保存在内存中，从而节省了磁盘的启动操作。

### 4．成组链接法

成组链接法将**空闲表和空闲链表法结合**形成的一种空闲盘块管理方法，适用于大型文件系统。



## 存储管理

对于本知识点，主要考查虚拟存储器（虚存），特别是页式存储管理。所谓虚拟存储技术，即在内存中保留一部分程序或数据，在外存中放置整个地址空间的副本。程序运行过程中可以随机访问内存中的数据或程序，但需要的程序或数据不在内存时，就将内存中部分内容根据情况写回外存，然后从外存调入所需程序或数据，实现作业内部的局部转换，从而允许程序的地址空间大于实际分配的存储区域。它在内存和外存之间建立了层次关系，使得程序能够像访问内存一样访问外存，主要用于解决内存的容量问题。其逻辑容量由内存和外存容量之和以及CPU可寻址的范围来决定，其运行速度接近于内存速度，成本也下降。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、中、小型及微型机中。



## 地址变换

由进程中的目标代码、数据等的虚拟地址组成的虚拟空间称为虚拟存储器，虚拟存储器允许用户用比内存容量大得多的地址空间来编程，以运行比内存实际容量大得多的程序。**用户编程所用的地址称为逻辑地址（虚地址**），而**实际的内存地址则称为物理地址（实地址）**。每次访问内存时都要进行逻辑地址到物理地址的转换，这种转换是由硬件完成的，而内存和外存间的信息动态调度是硬件和操作系统两者配合完成的。

（1）**静态重定位**：静态重定位是**在虚空间程序执行之前由装配程序完成地址影射工作**。静态重定位的优点是不需要硬件的支持。缺点是无法实现虚拟存储器，必须占用连续的内存空间且难以做到程序和数据的共享。

（2）**动态重定位**：动态重定位是**在程序执行过程中，在CPU访问内存之前，将要访问的程序或数据地址转换为内存地址**。动态重定位依靠硬件地址变换机构完成，其优点主要有：可以对内存进行非连续分配；提供了虚拟存储器的基础；有利于程序段的共享。



## 存储组织 

 虚拟存储器可以分为单一连续分区、固定分区、可变分区、可重定位分区、页式、段式、段页式7种。

（1）**单一连续分区**。把所有用户区都分配给唯一的用户作业，当作业被调度时，进程全部进入内存，一旦完成，所有内存恢复空闲，因此，它不支持多道程序设计。

（2）**固定分区**。这是支持多道程序设计的最简单的存储管理方法，它把内存划分成若干个固定的和大小不同的分区，每个分区能够装入一个作业，分区的大小是固定的，算法简单，但是容易生成较多的存储器碎片。

（3）**可变分区**。引入可变分区后虽然内存分配更灵活，也提高了内存利用率，但是由于系统在不断地分配和回收中，必定会出现一些不连续的小的空闲区，尽管这些小的空闲区的总和超过某一个作业要求的空间，但是由于不连续而无法分配，产生了碎片。解决碎片的方法是拼接（紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。

（4）**可重定位分区**。这是克服固定分区碎片问题的一种存储分配方法，它能够把相邻的空闲存储空间合并成一个完整的空区，还能够整理存储器内各个作业的存储位置，以达到消除存储碎片和紧缩存储空间的目的。紧缩工作需要花费大量的时间和系统资源。

（5）**页式**。页式存储组织的基本原理是将各进程的虚拟空间划分为若干个长度相等的页，把内存空间以与页相等的大小划分为大小相等的片或页面，采用请求调页或预调页技术实现内外存的统一管理。页式存储组织的主要优点是利用率高，产生的内存碎片小，内存空间分配及管理简单。主要缺点是要有相应的硬件支持，增加了系统开销；请求调页的算法如选择不当，有可能产生抖动现象。

（6）**段式**：一个作业是由若干个具有逻辑意义的段（如主程序、子程序、数据段等）组成。段式存储管理中，允许程序（作业）占据内存中若干分离的分区。分段系统中的虚地址是一个有序对（段号，段内位移）。系统为每一个作业建立一个段表，其内容包括段号与内存起始地址的对应关系、段长和状态等。状态指出这个段是否已调入内存，若已调入内存，则指出这个段的起始地址位置，状态同时也指出这个段的访问权限。如果该段尚未调入内存，则产生缺段中断，以便装入所需要的段。段式存储管理的主要优点是便于多道程序共享内存，便于对存储器的保护，各段程序修改互不影响。其缺点是内存利用率低，内存碎片浪费大。

 （7）**段页式**。这是分段式和分页式结合的存储管理方法，充分利用了分段管理和分页管理的优点。作业按逻辑结构分段，段内分页，内存分块。作业只需部分页装入即可运行，所以支持虚拟存储，可实现动态连接和装配。现在，最常见的虚存组织有分段技术、分页技术、段页式技术三种。

表1-3 常见的虚存组织

| 项目         | 段式管理                                                   | 页式管理                     | 段页式管理                                                   |
| ------------ | ---------------------------------------------------------- | ---------------------------- | ------------------------------------------------------------ |
| **划分方式** | 段（不定长），每个作业一张段表                             | 页（定长），每个进程一张页表 | 先将内存分为等长页，每个作业一张段表（通常有一个基号指向它），每段对应一组页表 |
| **虚地址**   | (s,d), 即(段号，段内偏移)                                  | (p,d), 即(页号，页内偏移)    | (s,p,d)即(段号，段内页号，页内偏移)                          |
| **虚实转换** | 段表内找出初始地址，然后+段内偏移                          | 页表内找出其实地址+页内偏移  | 先在段表中找到页表的起始位置，然后在页表中找到起始地址，最后+页内偏移 |
| **主要优点** | 简化了任意增长和收缩的数据段管理，利于进程间共享过程和数据 | 消除了页外碎片               | 结合了段与页的优点；便于控制存取访问                         |
| **主要缺点** | 段外碎片降低了利用率                                       | 存在页内碎片                 | 增长复杂度，增加硬件；存在页内碎片                           |

说明：段内偏移也称为段内地址，页内偏移也称为页内地址。



例如：某页式存储系统的地址变换过程如图1-6所示。假定页面的大小为8K，图1-6中所示的十进制逻辑地址9612经过地址变换后，形成的物理地址a应为十进制多少呢？

因为8K=213，所以页内地址有13位。逻辑地址9612转换成二进制，得到10 0101 1000 1100，这里的低13位为页内偏移量，最高一位则为页号，所以逻辑地址9612的页号为1，根据图1-6的对照表，即物理块号为3（二进制形式为11）。把物理块号和页内偏移地址拼合得到110 0101 1000 1100，再转换为十进制，得到25996。

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps27.png)

图1-6 页式存储系统的地址变换过程

在现行的虚存组织方面，最常见的就是段页式管理。在进行虚实地址转换时，可以采用的公式如下：

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps28.png) 其中x为基号，s为段号，p为段内页号，d为页内偏移，n的值为d的总位数，（x）表示x里的内容。



## 存储管理

在虚拟存储器的管理中，涉及载入（调入）、放置（放入分区）和置换（swapping）等问题。

 （1）**调入策略**：即**何时将一页或一段从外存中调入内存**，通常有两种策略，一种是请求调入法，即需要使用时才调入；另一种是先行调入法，即将预计要使用的页/段先行调入内存。

（2）**放置策略**：也就是调入后，**放在内存的什么位置**，这与内存管理基本上是一致的。

（3）**置换策略**：由于实际内存是小于虚存的，因此可能会发生内存中已满，但需要使用的页不在内存中这一情况（称为缺页中断）。这时就需要进行置换，即将**一些内存中的页淘汰到外存，腾出空间给要使用的页**，这个过程也称为Swapping。

### 1．置换算法

常见的置换算法如下：

（1）**最优（Optimized，OPT）算法**：选择淘汰不再使用或最将来才使用的页，这是理想的算法，但难以实现，常用于淘汰算法的比较。

（2）**随机（Rand）算法**：随机地选择淘汰的页，开销小，但可能选中立即就要访问的页。

（3）**先进先出（First In and First Out，FIFO）算法**：选择淘汰在内存驻留时间最长的页，似乎合理，但可能淘汰立即要使用的页。另外，使用FIFO算法时，在未给予进程分配足够的页面时，有时会出现给予进程的页面数越多，缺页次数反而增加的异常现象，这称为Belady现象。例如，若某个进程访问页面的顺序（称页面访问序列）是432143543215，当进程拥有3个主存页面时，发生缺页率比拥有4个主存页面时要小。

（4）**最近最少使用（Least Recently Used，LRU）算法**：选择淘汰离当前点时刻最近的一段内使用得最少的页。例如，若某个进程拥有3个主存页面，已访问页面的顺序是4314，现在如果要访问第2页，则需要淘汰第3页，因为第1、4页刚刚使用了。这个算法的主要出发点是，如果某页被访问了，则它可能马上就要被访问。OPT算法和LRU算法都不会发生Belady异常现象。

### 2．局部性原理

存储管理策略的基础是局部性原理，即进程往往会不均匀地高度局部化地访问内存。局部性分为**时间局部性**和**空间局部性**。时间局部性是指最近访问存储位置，很可能不久的将来还要访问；空间局部性是指存储访问有成组的倾向：当访问了某个位置后，很可能也要访问其附近的位置。

根据局部性原理的特征性，Denning阐述了程序性能的工作集理论。**工作集**是进程频繁访问的页面的集合。工作集理论指出，为使进程有效地运行，它的页面工作集应驻留内存中。否则，由于进程频繁地从外存请求页面，而出现称为“颠簸”（抖动）的过度的页面调度活动。此时，处理页面调度的时间超过了程序的执行时间。显然，此时CPU的有效利用率会急速下降。

通常用两种等价的方法确定进程的工作集，一种是将工作集确定为在定长的页面访问序列（工作集窗口）中的页面集合，另一种是将工作集确定为在定长时间间隔中涉及到页面的集合。工作集的大小依赖于工作集窗口的大小，在进程执行时，工作集会发生变化。有时，当进程进入另一个完全不同的执行阶段时，工作集会出现显著的变化。不过在一个进程的执行过程中，工作集的大小处于稳定状态的时间基本上占绝大多数。

另一种控制颠簸的技术是**控制缺页率**。操作系统规定缺页率的上下限，当一个进程的缺页率高于上限时，表明该进程需要更大的内存空间，则分配较多的内存页面给它，当进程的缺页率低于下限时，表明该进程占用的内存空间过大，可以适当地收回若干内存页面。



## 作业管理

操作系统中用来控制作业的进入、执行和撤销的一组程序称为作业管理程序，这些控制功能也能通过把作业细化，通过进程的执行来实现。在作业管理中，系统为每一个作业建立—个作业控制块（Job Control Block，JCB）。系统通过JCB感知作业的存在。JCB包括的主要内容有作业名、作业状态、资源要求、作业控制方式、作业类型以及作业优先权等。



### 作业的状态 

 一个作业从交给计算机系统到执行结束退出系统，一般都要经历**提交、后备、执行和完成**四个状态。其状态转换如图1-7所示。

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps32.png) （1）**提交状态**。作业由输入设备进入外存储器（也称输入井）的过程称为提交状态。处于提交状态的作业，其信息正在进入系统。

（2）**后备状态**。当作业的全部信息进入外存后，系统就为该作业建立一个作业控制块。

（3）**执行状态**。一个后备作业被作业调度程序选中分配了必要的资源并进入了内存，作业调度程序同时为其建立了相应的进程后，该作业就由后备状态变成了执行状态。

（4）**完成状态**：当作业正常运行结束，它所占用的资源尚未全部被系统回收时的状态为完成状态。

 

 

## 作业调度 

处理器调度通常分为三级调度，即低级调度、中级调度和高级调度。

（1）**高级调度**。高级调度也称为**作业调度**。高级调度的主要功能是在**批处理作业的后备作业队列中选择一个或者一组作业**，为它们建立进程，分配必要的资源，使它们能够运行起来。

（2）**中级调度**。中级调度也称为**交换调度**，中级调度**决定进程在内、外存之间的调入、调出**。其主要功能是在内存资源不足时将某些处于等待状态或就绪状态的进程调出内存，腾出空间后，再将外存上的就绪进程调入内存。

（3）**低级调度**。低级调度也称为**进程调度**，低级调度的主要功能是**确定处理器在就绪进程间的分配**。



 作业调度主要完成从后备状态到执行状态的转变，及从执行状态到完成状态的转变。**作业调度算法**有：

（1）**先来先服务（First Come and First Served，FCFS）**。按作业到达的先后次序调度，它不利于短作业。

（2）**短作业优先（Short Job First，SJF）**。按作业的估计运行时间调度，估计运行时间短的作业优先调度。它不利于长作业，可能会使一个估计运行时间长的作业迟迟得不到服务。

（3）**响应比高者优先（Highest Response_ratio Next，HRN）**。对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。响应比R定义： `R = (W+T)/T = 1+W/T`. 其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。这样，即使是长作业，随着它等待时间的增加，W/T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRN方式时其吞吐量将小于采用SJF 法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。

（4）**优先级调度**。根据作业的优先级别，优先级高者先调度。



## 设备管理

在计算机系统中，除了处理器和内存之外，其他的大部分硬设备称为外部设备。它包括输入/输出设备，外存设备及终端设备等。为了完成上述主要任务，设备管理程序一般要提供下述功能：

（1）**提供和进程管理系统的接口**。当进程要求设备资源时，该接口将进程要求转达给设备管理程序。

（2）**进行设备分配**。按照设备类型和相应的分配算法把设备和其他有关的硬件分配给请求该设备的进程，并把未分配到所请求设备或其他有关硬件的进程放入等待队列。

（3）实现设备和设备、设备和CPU等之间的**并行操作**。

（4）**进行缓冲区管理**。主要减少外部设备和内存与CPU之间的数据速度不匹配的问题，系统中一般设有缓冲区(器)来暂放数据。设备管理程序负责进行缓冲区分配、释放及有关的管理工作。



## 数据传输控制方式

在计算机中，输入/输出（Input/Output，I/O）系统可以有5种不同的工作方式，分别是程序控制方式、程序中断方式、DMA（Direct Memory Access，直接内存存取）工作方式、通道方式、输入/输出处理机。

（1）**程序控制方式**。CPU直接利用I/O指令编程，实现数据的输入输出。CPU发出I/O命令，命令中包含了外设的地址信息和所要执行的操作，相应的I/O系统执行该命令并设置状态寄存器；CPU不停地（定期地）查询I/O系统以确定该操作是否完成。由程序主动查询外设，完成主机与外设间的数据传送，方法简单，硬件开销小。

（2）**程序中断方式**。CPU利用中断方式完成数据的输入/输出，当I/O系统与外设交换数据时，CPU无需等待也不必去查询I/O的状态，当I/O系统完成了数据传输后则以中断信号通知CPU。CPU然后保存正在执行程序的现场，转入I/O中断服务程序完成与I/O系统的数据交换。然后返回原主程序继续执行。与程序控制方式相比，中断方式因为CPU无需等待而提高了效率。在系统中具有多个中断源的情况下，常用的处理方法有：多中断信号线法、中断软件查询法、雏菊链法、总线仲裁法和中断向量表法。

（3）**DMA方式**。使用DMA控制器（Direct Memory Access Controler，DMAC）来控制和管理数据传输。DMAC和CPU共享系统总线，并且具有独立访问存储器的能力。在进行DMA时，CPU放弃对系统总线的控制而由DMAC控制总线；由DMAC提供存储器地址及必需的读写控制信号，实现外设与存储器之间的数据交换。DMAC获取总线的3种方式：暂停方式、周期窃取方式和共享方式。

（4）**通道方式**。通道是一种通过执行通道程序管理I/O操作的控制器，它使主机与I/O操作之间达到更高的并行程度。在具有通道处理机的系统中，当用户进程请求启动外设时，由操作系统根据I/O要求构造通道程序和通道状态字，将通道程序保存在内存中，并将通道程序的首地址放到通道地址字中，然后执行启动I/O指令。按照所采取的传送方式，可将通道分为字节多路通道、选择通道和数组多路通道三种。

（5）**输入输出处理机**。输入输出处理机也称为外围处理机，它是一个专用处理机，也可以是一个通用的处理机，具有丰富的指令系统和完善的中断系统。专用于大型、高效的计算机系统处理外围设备的输入输出，并利用共享存储器或其他共享手段与主机交换信息。从而使大型、高效的计算机系统更加高效地工作。与通道相比，输入输出处理机具有比较丰富的指令系统，结构接近于一般的处理机，有自己的局部存储器。





## 磁盘调度算法 

访问磁盘的时间由三部分构成，它们是**寻道（查找数据所在的磁道）时间**、**等待（旋转等待扇区）时间**和**数据传输时间**，其中**寻道时间（查找时间）是决定因素**。

 （1）**FCFS算法**：有些文献称为FIFO算法。FCFS是一种最简单的磁盘调度算法，按先来先服务的次序，未作优化。这种算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不满足的情况。此算法未对寻道进行优化，致使平均寻道时间可能较长。

（2）**SSTF（Shortest Seek Time First，最短寻道时间优先）算法**：选择这样的进程，其要求访问的磁道距当前磁头所在的磁道距离最近，以使每次寻道的时间最短。FCFS会引起读写头在盘面上的大范围移动，SSTF查找距离磁头最短（也就是查找时间最短）的请求作为下一次服务的对象。SSTF查找模式有高度局部化的倾向，会推迟一些请求的服务，甚至引起无限拖延（这种现象称为“饥饿”）。

（3）**SCAN（电梯）算法**：不仅考虑到欲访问的磁道与当前磁道的距离，而且优先考虑的是磁头的当前移动方向，是在磁头前进方向上的最短查找时间优先算法，它排除了磁头在盘面局部位置上的往复移动。SCAN算法在很大程度上消除了SSTF算法的不公平性，但仍有利于对中间磁道的请求。SCAN算法的缺陷是当磁头刚由里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时进程必须等待，待磁头由里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被严重地推迟。

（4）**N-SCAN（N步SCAN）算法**：这是对SCAN算法的改良，磁头的移动与SCAN算法是一样的，不同的是扫描期间只对那些在扫描开始前已等待服务的请求提供服务。在服务期间，新到达的请求即使在磁头前进方向上也得不到服务，直到下一个新扫描周期开始。。N-SCAN算法的实质是把FCFS和SCAN的优点结合起来，以便取得较好的性能。如果新到达的请求按优化次序排列，则下一个扫描周期必然花费最少的磁头移动时间。

（5）**C-SCAN（循环扫描）算法**：这是对SCAN算法的另一种改良，是单向服务的N步SCAN算法，C-SCAN算法规定磁头单向移动。C-SCAN算法彻底消除了对两端磁道请求的不公平。



## 虚设备与SPOOLING技术 

SPOOLing（Simultaneous Peripheral Operation On Line）的意思是外部设备同时联机操作，又称为假脱机输入输出操作或排队转储技术，采用一组程序或进程模拟一台输入输出处理器。它在输入和输出之间增加了“输入井”和“输出井”的排队转储环节，SPOOLing系统的组成如图

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps38.png) 

 

从图1-8可以看出，SPOOLing系统主要包括以下3个部分：

 （1）**输入井和输出井**：这是在**磁盘上开辟出来的两个存储区域**。输入井模拟脱机输入时的磁盘，用于存放I/O设备输入的数据；输出井模拟脱机输出时的磁盘，用于存放用户程序的输出数据。因此，SPOOLing系统必须有高速、大容量、随机存取的外存的支持。

（2）**输入缓冲区和输出缓冲区**：这是在**内存中开辟的两个缓冲区**。输入缓冲区用于**暂存**有输入设备送来的数据，以后在传送到输出井。输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备。

（3）**输入进程和输出进程**：输入进程模拟脱机输入时的外围控制机，将用户要求的数据有输入设备到输入缓冲区，再送到输入井。当CPU需要输入设备时，直接从输入井读入内存。输出进程模拟脱机输出时的外围控制机，把用户要求输入的数据，先从内存送到输出井，待输出设备空闲时，再将输出井中的数据，经过输出缓冲区送到输出设备上。

 

SPOOLing技术的**主要特点**如下：

（1）**提高了I/O速度**。从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作，如同脱机操作一样，提高了I/O速度，缓和了CPU与低速I/O设备速度不匹配的矛盾。

（2）**设备并没有分配给任何进程**。在输入井或输出井中，分配给进程的是一存储区和建立一张I/O请求表。

（3）**实现了虚拟设备功能**。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，不过，该设备是逻辑上的设备。采用SPOOLing技术，可以将低速的独占设备改造成一种可共享的设备，而且一台物理设备可以对应若干台虚拟的同类设备。

 

 

 

 

 

 

 

 

第 1 章：操作系统

 

## 网络操作系统 

网络操作系统是指能使网络上个计算机方便而有效的共享网络资源，为用户提供所需的各种服务的操作系统软件。



## 网络操作系统概述 

如果网络操作系统相等地分布在网络上的所有节点，则称之为对等式网络操作系统；如果网络操作系统的主要部分驻留在中心节点，则称为集中式网络操作系统。集中式网络操作系统下的中心节点称为服务器，使用由中心节点所管理资源的应用称为客户。因此，集中式网络操作系统下的运行机制是C/S（Client/Server，客户/服务器）架构。

网络操作系统除了具备单机操作系统所需的功能外，还应具有下列功能：

（1）提供高效可靠的网络通讯能力。

（2）提供多项网络服务功能，例如，远程管理、文件传输、电子邮件、远程打印等。

 网络操作系统一般具有以下特征：

（1）硬件独立。网络操作系统应当独立于具体的硬件平台，即系统应该可以运行于各种硬件平台之上。为此，Microsoft提出了HAL（Hardware Abstraction Layer，硬件抽象层）的概念。HAL与具体的硬件平台无关，一旦改变具体的硬件平台，只要改变其HAL，系统就可以作平稳转换。

（2）网络特性。应当管理计算机资源并提供良好的用户界面。

（3）可移植性和可集成性。

（4）多用户、多任务。在多进程系统中，为了避免两个进程并行处理所带来的问题，可以采用多线程的处理方式。支持多处理机技术是对现代网络操作系统的基本要求。

 

## 网络操作系统的组成 

网络操作系统由网络驱动程序、子网协议和应用层协议等3个方面组成。网络操作系统通过网络驱动程序与网络硬件通信，因此它是作为网卡和子网协议间的联系体来工作的。子网协议是经过网络发送应用和系统管理信息所必须的通信协议。应用层协议则与子网协议进行通信，并实现网络操作系统对网络用户的服务。

（1）**网络驱动程序**。网络驱动程序涉及OSI/RM（Open System Interconnection ReferenceModel，开放系统互连参考模型）的第2层（数据链路层）和第3层（网络层），是网卡和高层协议间的接口。网络驱动程序把网卡如何对来自和发往高层的包所使用的方法进行了屏蔽，使高层不必了解收发操作的复杂性，而网络驱动程序本身则必须对网卡的操作有详细的了解。由于对标准的具体实现不同，网络驱动程序也就不同。正因为这样，网络集成商对所使用的网卡必须选择配对的驱动程序，并将所用的网络驱动程序同网络操作系统集成到一起。

（2）**子网协议**。子网协议涉及OSI/RM的第3层、第4层（传输层）和第5层（会话层）。第3层建立在第2层提供的点到点连接上，主要任务是如何对通信量进行路由选择，提供拥塞和流量控制，提供统一的网络寻址方法，以便令牌环和以太网络能理解。第4层可对第3层提供的服务进行提高，能确保可靠的数据交付。第5层提供有序的会话服务，如在会话上可提供会话控制，权标管理和活动管理

（3）**应用层协议**。应用层协议最重要的是NCP（Netware Core Proeocol）。NCP作为应用层的协议，提供了下述主要功能：在不同方式下打开文件；关闭打开的文件；从打开的文件读取数据块；将数据块写入打开的文件；获取目录项表；处理服务器数据库；提供高级连接服务；提供同步操作。





# 第2章 数据库系统

## 数据库管理系统

现在的大型系统几乎都是基于数据库的系统，作为系统架构设计师，要深入了解数据库方面的知识，系统掌握有关数据库建模和设计的技术。根据考试大纲，本章要求考生掌握以下知识点：

（1）**信息系统综合知识**：包括数据库管理系统的类型、数据库管理系统结构和性能评价、常用的关系型数据库管理系统、数据库模式、数据库规范化、分布式数据库系统、并行数据库系统、数据仓库与数据挖掘技术、数据库工程、备份恢复。

（2）**系统架构设计案例分析和论文**：数据库建模、数据库设计、数据库系统的备份与恢复。数据管理技术的发展大致经历了人工管理阶段、文件系统阶段、数据库阶段和高级数据库技术阶段。数据库是长期储存在计算机内的、有组织的、可共享的数据的集合。

数据库管理系统（DataBase Management System，DBMS）是一种负责数据库的定义、建立、操作、管理和维护的软件系统。其目的是保证数据安全可靠，提高数据库应用的简明性和方便性。DBMS的工作机理是把用户对数据的操作转化为对系统存储文件的操作，有效地实现数据库三级之间的转化。数据库管理系统的主要职能有：数据库的定义和建立、数据库的操作、数据库的控制、数据库的维护、故障恢复和数据通信。

 数据库系统（DataBase System，DBS）是实现有组织地、动态地存储大量关联数据、方便多用户访问的计算机软件、硬件和数据资源组成的系统。一个典型的DBS包括数据库、硬件、软件（应用程序）和数据库管理员（DataBase Administrator，DBA）四个部分。根据计算机的系统结构，DBS可分成集中式、客户/服务器式、并行式和分布式四种。

与文件系统阶段相比，数据库技术的数据管理方式具有以下特点：

（1）采用复杂的数据模型表示数据结构，数据冗余小，易扩充，实现了数据共享。

（2）具有较高的数据和程序独立性。包括数据库的独立性有物理独立性和逻辑独立性。

（3）数据库系统为用户提供了方便的用户接口。

（4）数据库系统提供四个方面的数据控制功能，分别是并发控制、恢复、完整性和安全性。数据库中各个应用程序所使用的数据由数据库系统统一规定，按照一定的数据模型组织和建立，由系统统一管理和集中控制。

（5）增加了系统的灵活性。

高级数据库技术阶段的主要标志是**分布式数据库系统**和**面向对象数据库系统**的出现。分布式数据库系统的主要特点是数据在物理上分散存储，在逻辑上是统一的。分布式数据库系统的多数处理就地完成，各地的计算机由数据通信网络相联系；面向对象数据库系统是面向对象的程序设计技术与数据库技术相结合的产物。面向对象数据库系统的主要特点是具有面向对象技术的封装性和继承性，提高了软件的可重用性。



## 数据库模式 

DBS的设计目标是**允许用户逻辑地处理数据**、而不必涉及这些数据在计算机中是怎样存放的，在数据组织和用户应用之间提供某种程度的独立性。数据库技术中采用分级的方法，将数据库的结构划分为多个层次。最著名的是美国ANSI/SPARC数据库系统研究组1975年提出的三级划分法，如图2-1所示。

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps43.png) 

### 1．三级模式

 数据库系统可以分为外模式、概念模式和内模式三个层次。

（1）**概念模式（模式、逻辑模式）**：用以**描述整个数据库中数据库的逻辑结构，描述现实世界中的实体及其性质与联系，定义记录、数据项、数据的完整性约束条件及记录之间的联系，是数据项值的框架。**概念模式通常还包含有访问控制、保密定义、完整性检查等方面的内容，以及概念/物理之间的映射。概念模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个概念模式。

（2）**外模式（子模式、用户模式）**：用以**描述用户看到或使用的那部分数据的逻辑结构，用户根据外模式用数据操作语句或应用程序去操作数据库中的数据。**外模式主要描述组成用户视图的各个记录的组成、相互关系、数据项的特征、数据的安全性和完整性约束条件。外模式是数据库用户（包括程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。一个数据库可以有多个外模式。一个应用程序只能使用一个外模式。

（3）**内模式**：是**整个数据库的最低层表示，不同于物理层，它假设外存是一个无限的线性地址空间。**内模式定义的是存储记录的类型、存贮域的表示、存贮记录的物理顺序，指引元、索引和存贮路径等数据的存贮组织。内模式是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。概念模式是数据库的中心与关键；内模式依赖于概念模式，独立于外模式和存储设备；外模式面向具体的应用，独立于内模式和存储设备；应用程序依赖于外模式，独立于概念模式和内模式。

### 2．三个级别

与三级模式相对应，数据库系统可以划分为三个抽象级，分别是用户级、概念级和物理级。

（1）**用户级数据库**：对应于外模式，是最接近于用户的一级数据库，是用户看到和使用的数据库，又称用户视图。用户级数据库主要由外部记录组成，不同用户视图可以互相重叠，用户的所有操作都是针对用户视图进行。一个数据库可有多个不同的用户视图，每个用户视图由数据库某一部分的抽象表示所组成。 

（2）**概念级数据库**：对应于概念模式，介于用户级和物理级之间，是所有用户视图的最小并集，是DBA看到和使用的数据库，所以又称为DBA视图。概念级数据库由概念记录组成，一个数据库应用系统只有一个DBA视图，它把数据库作为一个整体的抽象表示。概念级模式把用户视图有机地结合成一个整体，综合平衡考虑所有用户要求，实现数据的一致性、最大限度降低数据冗余、准确地反映数据间的联系。

（3）**物理级数据库**：对应于内模式，是数据库的低层表示，它描述数据的实际存储组织，是最接近于物理存储的级，又称为内部视图。**物理级数据库由内部记录组成，物理级数据库并不是真正的物理存储，而是最接近于物理存储的级。**

### 3．两级独立性

DBS两级独立性是指物理独立性和逻辑独立性。三个抽象级间通过两级映射（外模式/模式映射，模式/内模式映射）进行相互转换，使得数据库的三级形成一个统一的整体。

（1）**物理独立性**。物理独立性是指用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的。当数据的物理存储改变时，应用程序不需要改变。物理独立性存在于概念模式和内模式之间的映射转换，说明物理组织发生变化时应用程序的独立程度。

（2）**逻辑独立性**。逻辑独立性是指用户的应用程序与数据库中的逻辑结构是相互独立的。当数据的逻辑结构改变时，应用程序不需要改变。逻辑独立性存在于外模式和概念模式之间的映射转换，说明概念模式发生变化时应用程序的独立程度。

逻辑独立性比物理独立性更难实现。



## 数据模型 

设计DBS时，一般先用图或表的形式抽象地反映数据彼此之间的关系，称为建立数据模型。现有的数据库系统均是基于某种数据模型的，因此，了解数据模型的基本概念是学习数据库系统的基础。



## 数据模型的分类

数据模型主要有两大类，分别是**概念数据模型（实体联系模型）**和**基本数据模型（结构数据模型）**。 

概念数据模型是按照用户的观点来对数据和信息建模，主要用于数据库设计。概念模型主要用实体-联系方法（Entity-Relationship Approach）表示，所以也称E-R模型。有关E-R模型的设计方法，请阅读2.5节。 

基本数据模型是按照计算机系统的观点来对数据和信息建模，主要用于DBMS的实现。基本数据模型是数据库系统的核心和基础，通常由数据结构、数据操作和完整性约束三部分组成，其中数据结构是对系统静态特性的描述，数据操作是对系统动态特性的描述，完整性约束是一组完整性规则的集合。

常用的基本数据模型有层次模型、网状模型、关系模型和面向对象模型。

（1）**层次模型**：用树型结构表示实体类型及实体间联系。层次模型的优点是记录之间的联系通过指针来实现，查询效率较高。层次模型的缺点是只能表示1:n联系，虽然有多种辅助手段实现m:n联系，但较复杂，用户不易掌握。由于层次顺序的严格和复杂，引起数据的查询和更新操作很复杂，应用程序的编写也比较复杂。

（2）**网状模型**：用有向图表示实体类型及实体间联系。网状模型的优点是记录之间的联系通过指针实现，m:n联系也容易实现，查询效率高。其缺点是编写应用程序比较复杂，程序员必须熟悉数据库的逻辑结构。

（3）**关系模型**：用表格结构表达实体集，用外键（外码）表示实体间联系。其优点有：建立在严格的数学概念基础上；概念单一（关系），结构简单、清晰，用户易懂易用；存取路径对用户透明，从而数据独立性、安全性好，简化数据库开发工作。关系模型的缺点主要是由于存取路径透明，查询效率往往不如非关系数据模型。

（4）**面向对象模型**：用面向对象观点来描述现实世界实体的逻辑组织、对象间限制、联系等的模型。一个面向对象数据库系统是一个持久的、可共享的对象库的存储和管理者，而一个对象库是由一个面向对象模型所定义的对象的集合体。面向对象数据库模式是类的集合，面向对象模型提供了一种类层次结构。在面向对象数据库模式中，一组类可以形成一个类层次，一个面向对象数据库可能有多个类层次。在一个类层次中，一个类继承其所有超类的全部属性、方法和消息。面向对象的数据库系统在逻辑上和物理上从面向记录上升为面向对象、面向可具有复杂结构的一个逻辑整体。允许用自然的方法，并结合数据抽象机制在结构和行为上对复杂对象建立模型，从而大幅度提高管理效率，降低用户使用复杂性。



## 关系模型

我们先学习几个相关的基本概念。

（1）**域**：一组具有相同数据类型的值的集合。

（2）**笛卡尔积**：给定一组域D1、D2、…、Dn，这些域中可以有相同的。它们的笛卡尔积为：D1×D2×…×Dn = {(d1，d2，…，dn)|dj∈Dj，j＝1，2，…，n}。其中每一个元素（d1，d2，…，dn）叫作一个n元组（简称为元组）。元组中的每一个值dj叫作一个分量。

（3）**关系**：D1×D2×…×Dn的子集叫作在域D1、D2、…、Dn上的关系，用R(D1，D2，…，Dn)表示。这里R表示关系的名字，n是关系的目或度。

关系中的每个元素是关系中的元组，通常用t表示。关系是笛卡尔积的子集，所以关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性。

 若关系中的某一属性组（一个或多个属性）的值能唯一地标识一个元组，则称该属性组为候选码（候选键）。若一个关系有多个候选码，则选定其中一个作为主码（主键）。主码的所有属性称为主属性。不包含在任何侯选码中的属性称为非码属性（非主属性）。在最简单的情况下，侯选码只包含一个属性。在最极端的情况下，关系模式所有属性的组合构成关系模式的侯选码，称为全码。

关系可以有三种类型：基本关系（基本表、基表）、查询表和视图表。基本表是实际存在的表，它是实际存储数据的逻辑表示。查询表是查询结果对应的表。视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。

 基本关系具有以下**六条性质**：

（1）列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。

（2）不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。

（3）列的顺序无所谓，即列的次序可以任意交换。

（4）任意两个元组不能完全相同。但在大多数实际关系数据库产品中，例如ORACLE等，如果用户没有定义有关的约束条件，它们都允许关系表中存在两个完全相同的元组。

（5）行的顺序无所谓，即行的次序可以任意交换。

（6）分量必须取原子值，即每一个分量都必须是不可分的数据项。关系的描述称为关系模式，一个关系模式应当是一个五元组，它可以形式化地表示为：R(U，D，DOM，F)。其中R为关系名，U为组成该关系的属性名集合，D为属性组U中属性所来自的域，DOM为属性向域的映象集合，F为属性间数据的依赖关系集合。关系模式通常可以简记为R(A1，A2，…，An)。其中R为关系名，A1、A2、…、An为属性名。

关系实际上就是关系模式在某一时刻的状态或内容。也就是说，关系模式是型，关系是它的值。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。但在实际当中，常常把关系模式和关系统称为关系，读者可以从上下文中加以区别。

在关系模型中，实体以及实体间的联系都是用关系来表示。在一个给定的现实世界领域中，相应于所有实体及实体之间的联系的关系的集合构成一个关系数据库。

关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述，是关系模式的集合。关系数据库的值也称为关系数据库，是关系的集合。关系数据库模式与关系数据库通常统称为关系数据库。

 

## 规范化理论 

设有一个关系模式R（SNAME，CNAME，TNAME TADDRESS），其属性分别表示学生姓名、选修的课程名、任课教师姓名和任课教师地址。仔细分析一下，我们就会发现这个模式存在下列存储异常的问题：

（1）数据冗余：如果某门课程有100个学生选修，那么在R的关系中就要出现100个元组，这门课程的任课教师姓名和地址也随之重复出现100次。

（2）修改异常：由于上述冗余问题，当需要修改这个教师的地址时，就要修改100个元组中的地址值，否则就会出现地址值不一致的现象。

（3）插入异常：如果不知道听课学生名单，这个教师的任课情况和家庭地址就无法进入数据库；否则就要在学生姓名处插入空值。

（4）删除异常：如果某门课程的任课教师要更改，那么原来任课教师的地址将随之丢失。因此，关系模式R虽然只有四个属性，但却是性能很差的模式。如果把R分解成下列两个关系模式：R1（SNAME，CNAME）和R2（CNAME，TNAME，TADDRESS），则能消除上述的存储异常现象。

为什么会产生这些异常呢？与关系模式属性值之间的联系直接有关。在模式R中，学生与课程有直接联系，教师与课程有直接联系，而教师与学生无直接联系，这就产生了模式R的存储异常。因此，模式设计强调“每个联系单独表达”是一条重要的设计原则，把R分解成R1和R2是符合这条原则的。

### 1．函数依赖

设R(U)是属性U上的一个关系模式，X和Y是U的子集，r为R的任一关系，如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X，记为X→ Y。

从函数依赖的定义可以看出，如果有X→U在关系模式R(U)上成立，并且不存在X的任一真子集‘X′使X′→U成立，那么称X是R的一个候选键。也就是X值惟一决定关系中的元组。由此可见，函数依赖是键概念的推广，键是一种特殊的函数依赖。

 在R(U)中，如果X→Y，并且对于X的任何一个真子集X′，都有X′→Y不成立，则称Y对X完全函数依赖。若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖。在R(U)中，如果X→Y（Y不是X的真子集），且Y→X不成立，Y→Z，则称Z对X传递函数依赖。设U是关系模式R的属性集，F是R上成立的只涉及到U中属性的FD集，则有以下三条推理规则：

（1）自反性：若X Y U，则X→Y在R上成立；

（2）增广性：若X→Y在R上成立，且Z U，则XZ→YZ在R上成立；

（3）传递性：若X→Y和Y→Z在R上成立，则X→Z在R上成立。这里XZ，YZ等写法表示X∪Z，Y∪Z。

上述三条推理规则是函数依赖的一个正确的和完备的推理系统。

根据上述三条规则还可以推出其他三条常用的推理规则：

（1）合并规则：若X→Y和X→Z在R上成立，则X→YZ在R上成立；

（2）分解规则：若X→Y在R上成立，且Z∈Y，则X→Z在R上成立；

（3）伪传递规则：若X→Y和WY→Z在R上成立，则WX→Z在R上成立。 在关系模式R(U，F)中为F所逻辑蕴含的函数依赖全体叫做F的闭包，记作F+。

设F为属性集U上的一组函数依赖，X是U的子集，那么相对于F属性集X的闭包用X+表示，它是一个从F集使用推理规则推出的所有满足X→A的属性A的集合：X+={属性A|X→A在F+中}

如果G+=F+，就说函数依赖集F覆盖G（F是G的覆盖，或G是F的覆盖），或F与G等价。如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集，也称为最小依赖集或最小覆盖。

（1）F中任一函数依赖的右部仅含有一个属性；

（2）F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价；

（3）F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}∪{Z→A}与F等价。

### 2．范式

（1）第一范式（1NF）：如果关系模式R的每个关系r的属性值都是不可分的原子值，那么称 R是第一范式的模式，r是规范化的关系。关系数据库研究的关系都是规范化的关系。

（2）第二范式（2NF）：若关系模式R是1NF，且每个非主属性完全函数依赖于候选键，那么称R是2NF模式。

（3）第三范式（3NF）: 如果关系模式R是2NF，且每个非主属性都不传递依赖于R的候选码，则称R是3NF。

（4）BC范式（BCNF）：若关系模式R是1NF，且每个属性都不传递依赖于R的候选键，那么称R是BCNF模式。

上述四种范式之间有如下联系：

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps50.png) 

### 3．关系模式分解

如果某关系模式存在存储异常问题，则可通过分解该关系模式来解决问题。把一个关系模式分解成几个子关系模式，需要考虑的是该分解是否保持函数依赖，是否是无损联接。

无损联接分解的形式定义如下：设R是一个关系模式，F是R上的一个函数依赖（FD）集。R分解成数据库模式δ={R1，……，RK}。如果对R中每一个满足F的关系r 都有下式成立：

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml24672\wps51.png) 那么称分解δ相对于F是无损联接分解，否则称为损失联接分解。

下面是一个很有用的无损联接分解判定定理。

设ρ=｛R1，R2｝是R的一个分解，F是R上的FD集，那么分解ρ相对于F是无损分解的充分必要条件是：(R1∩R2)→(R1-R2)或(R1∩R2)→(R2-R1)。希赛教育专家提示：这两个条件只要有任意一个条件成立就可以了。

设数据库模式δ={R1……，RK}是关系模式R的一个分解，F是R上的FD集，δ中每个模式Ri上的FD集是Fi。如果{F1，F2，……，Fk}与F是等价的（即相互逻辑蕴涵），那么我们称分解δ保持FD。如果分解不能保持FD，那么δ的实例上的值就可能有违反FD的现象



## 反规范化理论

前文已经介绍了规范化理论，在对数据模型进行规范化时，主要通过**拆分**的方式达到目的，而不断的拆分带来了新的问题。因为**对多个拆分后的表进行查询操作时，需要涉及大量的连接操作，这使得查询变得费时与低效**。为了有效的解决此问题，提出了反规范化技术，该技术与规范化理论做法刚好相反，而希望达到的目标主要是**提高查询效率**。

常用的反规范技术包括：**增加冗余列**、**增加派生列**、**重新组表**、**分割表**。

### 1．增加派生列

加派生列指**增加的列由表中其它数据计算生成**。它的作用是**在查询时减少连接操作，避免使用集函数**。例如，表中有单价，也有数量，此时增加列“总额”，由于总额=单价*数量，所以总额就是一个派生列。 

### 2．增加冗余列

增加冗余列是指在多个表中具有相同的列，它常用来在查询时避免连接操作。

### 3．重新组表

 重新组表指如果许多用户需要查看两个表连接出来的结果数据，则**把这两个表重新组成一个表来减少连接而提高性能**。

### 4．分割表

有时对表做分割可以提高性能。表分割有两种方式：

**水平分割**：根据一列或多列数据的值把数据行放到两个独立的表中。水平分割通常在下面的情况下使用：

① 表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度。

② 表中的数据本来就有独立性。例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。

③ 需要把数据存放到多个介质上。水平分割会给应用增加复杂度，它通常在查询时需要多个表名，查询所有数据需要union操作。

在许多数据库应用中，这种复杂性会超过它带来的优点，因为只要索引关键字不大，则在索引用于查询时，表中增加两到三倍数据量，查询时也就增加读一个索引层的磁盘次数。

**垂直分割**：把主码和一些列放到一个表，然后把主码和另外的列放到另一个表中。如果一个表中某些列常用，而另外一些列不常用，则可以采用垂直分割，另外垂直分割可以使得数据行变小，一个数据页就能存放更多的数据，在查询时就会减少I/O次数。其缺点是需要管理冗余列，查询所有数据需要join操作。

 

 ### 数据库的控制功能

DBMS运行的基本工作单位是事务，事务是用户定义的一个数据库操作序列，这些操作序列要么全做要么全都不做，是一个不可分割的工作单位。事务具有以下特性（ACID特性）：

（1）原子性（Atomicity）：事务是数据库的逻辑工作单位，事务的所有操作在数据库中要么全做要么全都不做。

（2）一致性（Consistency）：事务的执行使数据库从一个一致性状态变到另一个一致性状态。

（3）隔离性（Isolation）：一个事务的执行不能被其他事务干扰。

（4）持续性（Durability，永久性）：指一个事务一旦提交，它对数据库的改变必须是永久的，即便系统出现故障时也是如此。

事务通常以BEGIN TRANSACTION（事务开始）语句开始，以COMMIT或ROLLBACK语句结束。COMMIT称为事务提交语句，表示事务执行成功地结束，把事务对数据库的修改写入磁盘（事务对数据库的操作首先是在缓冲区中进行的）。ROLLBACK称为事务回滚语句，表示事务执行不成功地结束，即把事务对数据库的修改进行恢复。

从**终端用户**来看，**事务是一个原子，是不可分割的操作序列**。事务中包括的所有操作要么都做，要么都不做（就效果而言）。事务不应该丢失，或被分割地完成。



## 并发控制

在多用户共享系统中，许多事务可能同时对同一数据进行操作，称为并发操作，此时数据库管理系统的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，同时避免用户得到不正确的数据。

### 1．并发操作的问题

数据库的并发操作带来的主要问题有：丢失更新问题，不一致分析问题（读过时的数据），依

赖于未提交更新的问题（读脏数据）。这3个问题需要DBMS的并发控制子系统来解决。

（1）丢失更新（丢失修改）：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，T1的修改被丢失。

（2）读过时的数据（不可重复读）：事务T1读取某一数据，事务T2读取并修改了同一数据，T1为了对读取值进行校对再读此数据，得到了不同的结果。例如，T1读取B＝100，T2读取B并把B改为200，T1再读B得200，与第一次读取值不一致。

（3）读脏数据。事务T1修改某一数据，事务T2读取同一数据，而T1由于某种原因被撤销，则T2读到的数据就为“脏”数据，即不正确的数据。例如，T1把C由100改为200，T2读到C为200，而事务T1由于被撤销，其修改宣布无效，C恢复为原值100，而T2却读到了C为200，与数据库内容不一致。

例如，假设某3个事务T1、T2和T3并发执行的过程如表2-1所示。

表2-1事务并发执行的过程

| 时间 | T1          | T2       | T3       |
| ---- | ----------- | -------- | -------- |
| t1   | 读D1=50     |          |          |
| t2   | 读D2=100    |          |          |
| t3   | 读D3=300    |          |          |
| t4   | X1=D1+D2+D3 |          |          |
| t5   |             | 读D2=100 |          |
| t6   |             | 读D3=300 |          |
| t7   |             |          | 读D2=100 |
| t8   |             | D2=D3-D2 |          |
| t9   |             | 写D2     |          |
| t10  | 读D1=50     |          |          |
| t11  | 读D2=200    |          |          |
| t12  | D3=300读    |          |          |
| t13  | X1=D1+D2+D3 |          |          |
| t14  | 验算不对    |          | D2=D2+50 |
| t15  |             |          | 写D2     |

在表2-1中，事务T1、T2分别对数据D1、D2和D3进行读写操作，在t4时刻，事务T1将D1、D2和D3相加存入X1，X1等于450。在t8时刻，事务T2将D3减去D2存入D2，D2等于200。在t13时刻，事务T1将D1、D2和D3相加存入X1，X1等于550，验算结果不对。这种情况就属于**不可重复读**。在t14时刻事务T3将D2加50存入D2，D2等于150。这样，就丢失了事务T2对D2的修改，这种情况就属于**丢失更新**。

### 2．封锁的类型

处理并发控制的主要方法是采用封锁技术，主要有有两种类型的封锁，分别是**X封锁**和**S封锁**。

（1）排他型封锁（X封锁）：如果事务T对数据A（可以是数据项、记录、数据集以至整个数据库）实现了X封锁，那么只允许事务T读取和修改数据A，其他事务要等事务T解除X封锁以后，才能对数据A实现任何类型的封锁。可见X封锁只允许一个事务独锁某个数据，具有排他性。

（2）共享型封锁（S封锁）：X封锁只允许一个事务独锁和使用数据，要求太严。需要适当从宽，如可以允许并发读，但不允许修改，这就产生了S封锁概念。S封锁的含义是：如果事务T对数据A实现了S封锁，那么允许事务T读取数据A，但不能修改数据A，在所有S封锁解除之前决不允许任何事务对数据A实现X封锁。

### 3．封锁协议

 在多个事务并发执行的系统中，主要采取封锁协议来进行处理。

（1）一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。一级封锁协议可防止丢失更新，并保证事务T是可恢复的。但不能保证可重复读和不读脏数据。

（2）二级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，读完后即可释放S锁。二级封锁协议可防止丢失更新，还可防止读脏数据。但不能保证可重复读。

（3）三级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，直到事务结束才释放。三级封锁协议可防止丢失更新、防止读脏数据与数据重复读。

（4）两段锁协议：所有事务必须分两个阶段对数据项加锁和解锁。其中扩展阶段是在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；收缩阶段是在释放一个封锁之后，事务不能再申请和获得任何其他封锁。若并发执行的所有事务均遵守两段封锁协议，则对这些事务的任何并发调度策略都是可串行化的（可以避免丢失更新、不可重复读和读脏数据问题）。遵守两段封锁协议的事务可能发生死锁。

所谓封锁的粒度即是被封锁数据目标的大小，在关系数据库中封锁粒度有属性值、属性值集、元组、关系、某索引项（或整个索引）、整个关系数据库、物理页（块）等几种。

**封锁粒度小则并发性高，但开销大；封锁粒度大则并发性低，但开销小，综合平衡照顾不同需求以合理选取适当的封锁粒度是很重要的。**

### 4．死锁

采用封锁的方法固然可以有效防止数据的不一致性，但封锁本身也会产生一些麻烦，最主要就是死锁问题。

死锁是指**多个用户申请不同封锁，由于申请者均拥有一部分封锁权而又需等待另外用户拥有的部分封锁而引起的永无休止的等待**。

死锁是可以避免的，目前采用的办法有如下几种。

（1）**预防法**：采用一定的操作方式以避免死锁的出现，顺序申请法、一次申请法等即是此类方法。顺序申请法是指对封锁对象按序编号，用户申请封锁时必须按编号顺序（从小到大或反之）申请，这样能避免死锁发生；一次申请法是指用户在一个完整操作过程中必须一次性申请它所需要的所有封锁，并在操作结束后一次性归还所有封锁，这样能避免死锁的发生。

（2）**死锁的解除法**：允许产生死锁，并在死锁产生后通过解锁程序以解除死锁。这种方法中需要有两个程序，一个是死锁检测程序，用它测定死锁是否发生；另一个是解锁程序，一旦检测到系统已产生死锁，则启动解锁程序以解除死锁。



## 备份与恢复技术

数据库系统中可能发生各种各样的故障，大致可以分以下几类：

（1）**事务内部的故障**。事务内部的故障有的是可以通过事务程序本身发现的，有的是非预期的，不能由事务程序处理。例如，输入数据违反完整性约束、运算溢出、并行事务发生死锁而被选中撤销该事务等。事务故障意味着事务没有到达预期的终点（COMMIT或者显式的ROLLBACK），因此，数据库可能处于不正确状态。这样，系统就要强行回滚此事务，即撤销该事务已经做出的任何对数据库的修改，使得该事务好像根本没有启动一样。

（2）**系统范围内的故障**。系统故障是指造成系统停止运转的任何事件，使得系统要重新启动。例如，中央处理器故障、操作系统故障、突然停电等，这类故障影响正在运行的所有事务，但不破坏数据库。这时内存中的内容，尤其是数据库缓冲区中的内容都将丢失，使得运行事务都非正常终止，从而造成数据库可能处于不正确的状态，数据库恢复子系统必须在系统重新启动时让所有非正常终止的事务回滚，把数据库恢复到正确的状态。

（3）**介质故障**。系统故障常称为软故障（SoftCrash），介质故障称为硬故障（HardCrash）。硬故障指外存故障，如磁盘的磁头碰撞、瞬时的强磁场干扰等。这类故障将破坏数据库或部分数据库，并影响正存取这部分数据的所有事务，这类故障比前两类故障发生的可能性小得多，但破坏性最大。

（4）**计算机病毒**。计算机病毒是一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序，这种程序与其他程序不同，它像微生物学所称的病毒一样可以繁殖和传播，并造成对计算机系统包括数据库的危害。

总结各类故障，对数据库的影响有两种可能性，**一是数据库本身被破坏**，**二是数据库没有被破坏，但数据可能不正确，这是因为事务的运行被终止所造成的**。

### 1．数据备份

备份（转储）是指DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本（后援副本）。当数据库遭到破坏后就可以利用后备副本把数据库恢复，这时，数据库只能恢复到备份时的状态，从那以后的所有更新事务必须重新运行才能恢复到故障时的状态。备份可分为静态备份（冷备份）和动态备份（热备份）。静态备份是指备份期间不允许（或不存在）对数据库进行任何存取、修改活动。静态备份简单，但备份必须等待用户事务结束才能进行，同样，新的事务必须等待备份结束才能执行。显然，这会降低数据库的可用性；动态备份是指备份期间允许对数据库进行存取或修改，即备份和用户事务可以并发执行。动态备份可克服静态备份的缺点，但是，备份结束时后援副本上的数据并不能保证正确有效。备份还可以分为海量备份和增量备份。海量备份是指每次备份全部数据库。增量备份则指每次只备份上次备份后更新过的数据。如果数据库很大，事务处理又十分频繁，则增量备份方式是很有效的。

### 2．日志文件

事务日志是针对数据库改变所做的记录，它可以记录针对数据库的任何操作，并将记录结果保存在独立的文件中。这种文件就称为日志文件。对于任何一个事务，事务日志都有非常全面的记录，根据这些记录可以将数据文件恢复成事务前的状态。从事务动作开始，事务日志就处于记录状态，事务执行过程中对数据库的任何操作都记录在内，直到用户提交或回滚后才结束记录。日志文件是用来记录对数据库每一次更新活动的文件，在动态备份方式中，必须建立日志文件，后援副本和日志文件综合起来才能有效地恢复数据库；在静态备份方式中，也可以建立日志文件，当数据库毁坏后可重新装入后援副本把数据库恢复到备份结束时刻的正确状态，然后利用日志文件，把已完成的事务进行重做处理，对故障发生时尚未完成的事务进行撤销处理。这样不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态。例如，在热备份期间的某时刻t1，系统把数据A=100备份到了磁带上，而在时刻t2，某一事务对A进行了修改使A=200。备份结束，后备副本上的A已是过时的数据了。为此，必须把备份期间各事务对数据库的修改活动登记下来，建立日志文件。这样，后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态。事务在运行过程中，系统把事务开始、事务结束（包括COMMIT和ROLLBACK），以及对数据库的插入、删除、修改等每一个操作作为一个登记记录存放到日志文件中。每个记录包括的主要内容有：执行操作的事务标识、操作类型、更新前数据的旧值（对插入操作而言此项为空值）、更新后的新值（对删除操作而言此项为空值）。登记的次序严格按并行事务操作执行的时间次序，同时遵循“先写日志文件”的规则。写一个修改到数据库中和写一个表示这个修改的日志记录到日志文件中是两个不同的操作，有可能在这两个操作之间发生故障，即这两个写操作只完成了一个，如果先写了数据库修改，而在日志记录中没有登记这个修改，则以后就无法恢复这个修改了。因此，为了安全，应该先写日志文件，即首先把修改记录写到日志文件上，然后再写数据库的修改。这就是“先写日志文件”的原则。

### 3．数据恢复

把数据库从错误状态恢复到某一个已知的正确状态的功能，称为数据库的恢复。数据恢复的基本原理就是冗余，建立冗余的方法有数据备份和登录日志文件等。可根据故障的不同类型，采用不同的恢复策略。

#### （1）事务故障的恢复

事务故障的恢复是由**系统自动完成**的，对用户是透明的（不需要DBA的参与）。其步骤如下：

①反向扫描日志文件，查找该事务的更新操作。

②对该事务的更新操作执行逆操作。

③继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。

④如此处理下去，直至读到此事务的开始标记，事务故障恢复完成。

#### （2）系统故障的恢复

系统故障的恢复在系统重新启动时自动完成，不需要用户干预。其步骤如下：

①正向扫描日志文件，找出在故障发生前已经提交的事务，将其事务标识记入重做（Redo）队列。同时找出故障发生时尚未完成的事务，将其事务标识记入撤销（Undo）队列。

②对撤销队列中的各个事务进行撤销处理：反向扫描日志文件，对每个Undo事务的更新操作执行逆操作。

③对重做队列中的各个事务进行重做处理：正向扫描日志文件，对每个Redo事务重新执行日志文件登记的操作。

#### （3）介质故障与病毒破坏的恢复

介质故障与病毒破坏的恢复步骤如下：

①装入最新的数据库后备副本，使数据库恢复到最近一次备份时的一致性状态。

②从故障点开始反向扫描日志文件，找出已提交事务标识并记入Redo队列。

③从起始点开始正向扫描日志文件，根据Redo队列中的记录，重做已完成的任务，将数据库恢复至故障前某一时刻的一致状态。

#### （4）有检查点的恢复技术

检查点记录的内容可包括建立检查点时刻所有正在执行的事务清单，以及这些事务最近一个日志记录的地址。采用检查点的恢复步骤如下：

①从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。

②由该检查点记录得到检查点建立时所有正在执行的事务清单队列（A）。

③建立重做队列（R）和撤销队列（U），把A队列放入U队列中，R队列为空。

④从检查点开始正向扫描日志文件，若有新开始的事务T1，则把T1放入U队列；若有提交的事务T2，则把T2从U队列移到R队列；直至日志文件结束。

⑤对U队列的每个事务执行Undo操作，对R队列的每个事务执行Redo操作。



## 数据库的安全性

DBS的信息安全性在技术上可以依赖于两种方式，一种是DBMS本身提供的用户身份识别、视图、使用权限控制、审计等管理措施，例如，大型数据库管理系统如Oracle和Sybase等均有此功能；另一种就是靠数据库的应用程序来实现对数据库访问进行控制和管理，例如，Dbase、Foxbase、Foxpro等开发的数据库应用程序，很多数据的安全控制都由应用程序里面的代码来实现。

### 1．用户认证

用户的身份认证是用户使用DBMS系统的第一个环节，用户的身份鉴别是DBMS识别什么用户能做什么事情的依据。

#### （1）口令认证。

口令（password，密码）是一种身份认证的基本形式，用户在建立与DBMS的访问连接前必须提供正确的用户账号（userid）和口令，DBMS与自身保存的用户列表中的用户标识和口令比较，如果匹配则认证成功，允许用户使用数据库系统；如果不匹配则返回拒绝信息。这种认证判断过程往往是数据库登录的第一步，用户账户（account）的账号和口令是口令认证方式中的核心，用户信息可以保存在数据库内、操作系统内或者集中的目录服务器（DirectoryServer）用户身份证书库内。

#### （2）强身份认证。

在网络环境下，客户端到DBMS服务器可能经过多个环节，在身份认证期间，用户的信息和口令可能会经过很多不安全的结点（如路由器和服务器），而被信息的窃听者窃取。强身份认证过程使认证可以结合信息安全领域一些更深入的技术保障措施，来强化用户身份的鉴别，例如，与用户证书、智能卡、用户指纹识别等多种身份识别技术相结合。

### 2．用户角色

按每个用户指定操作权限在用户数目比较多的时候往往是一项非常繁重的工作，所以DBMS提供角色来描述具有相同操作权限的用户集合，不同角色的用户授予不同的数据管理和访问操作权限。一般可以将权限角色分为3类，分别是数据库登录权限类、资源管理权限类和DBA权限类。

有了数据库登录权限的用户才能进入DBMS，才能使用DBMS所提供的各类工具和实用程序。同时，数据对象的创建者（owner）可以授予这类用户以数据查询、建立视图等权限。这类用户只能查阅部分数据库信息，不能修改数据库中的任何数据。

具有资源管理权限的用户，除了拥有上一类的用户权限外，还有创建数据库表、索引等数据对象的管理权限，可以在权限允许的范围内修改、查询数据库，还能将自己拥有的权限授予其他用户，可以申请审计。具有DBA权限的用户将具有数据库管理的全部权限，包括访问任何用户的任何数据，授予（或回收）用户的各种权限，创建各种数据对象，完成数据库的整库备份、装入重组及进行全系统的审计等工作。

当然，不同的DBMS，可能对用户角色的定义不尽相同，权限的划分的细致程度也远超过上面3种基本的类型，而基于角色的用户权限管理是现在每个主流数据库产品（例如，IBMDB2、Oracle、Sybase、MSSQLServer等）和一些专用的数据库产品（例如，NCRTeradata、HyperionEssbase等）都具有的特性。

### 3．数据授权

同一类功能操作权限的用户，对数据库中数据对象管理和使用的范围又可能是不同的，因此DBMS除了要提供基于功能角色的操作权限控制外，还提供了对数据对象的访问控制，访问控制可以根据对控制用户访问数据对象的粒度从大到小分为4个层次。

（1）**数据库级别**：判断用户是否可以使用访问数据库里的数据对象，包括表、视图、存储过程。

（2）**表级**：判断用户是否可以访问关系里面的内容。

（3）**行级**：判断用户是否能访问关系中的一行记录的内容。

（4）**属性级**：判断用户是否能访问表关系中的一个列（属性、字段）的内容。

管理员把某用户可查询的数据和元素在逻辑上归并起来，简称一个或多个用户视图，并赋予名称，再把该视图的各种使用权限授予该用户（也可以授予多个用户）。DBMS对于用户的访问存取控制有以下两个基本的原则：

（1）**隔离原则**：用户只能存取他自己所有的和已经取得授权的数据对象。

（2）**控制原则**：用户只能按他所取得的数据存取方式存取数据，不能越权。

数据库授权可以分为静态授权和动态授权。一般意义上，可以把静态授权理解成为是DBMS的隐性授权，也就是说用户（或DBA）对他自己拥有的信息是不需要有指定的授权动作就拥有全权管理和操作的权限的。与静态授权相对应，只有数据对象的所有者或者DBA默认地拥有对数据的存取权，动态授权则允许这些用户把这些权力授予其他的用户，现在DBMS支持的SQL（StructuredQueryLanguage，结构化查询语言）语言里面有专门的授权语句。

### 4．数据库视图

视图可以被看成是虚拟表或存储查询。可通过视图访问的数据不作为独特的对象存储在数据库内。数据库内存储的是SELECT语句。SELECT语句的结果集构成视图所返回的虚拟表。用户可以用引用表时所使用的方法，在SQL语句中通过引用视图名称来使用虚拟表。使用视图可以实现下列功能：

（1）将用户限定在表中的特定行上。例如，只允许雇员看见工作跟踪表内记录其工作的行。

（2）将用户限定在特定列上。例如，对于那些不负责处理工资单的雇员，只允许他们看见雇员表中的姓名、工作电话和部门列，而不能看见任何包含工资信息或个人信息的列。

（3）将多个表中的列连接起来，使它们看起来像一个表。

（4）聚合信息而非提供详细信息。例如，显示一个列的和，或者列的最大值和最小值。

如果需要限制用户使用的数据，可以将视图作为一种安全机制。通过定义SELECT语句以检索将在视图中显示的数据来创建视图。SELECT语句引用的数据表称为视图的基表。

### 5．审计功能

如果身份认证是一种事前的防范措施，审计则是一种事后监督的手段。跟踪也是DBMS提供的监视用户动作的功能，然而，审计和跟踪是两个不同的概念，主要是两者的目的不同。跟踪主要是满足系统调试的需要，捕捉到的用户行为记录往往只用于分析，而并不长久地保存，而审计作为一种安全检查的措施，会把系统的运行状况和用户访问数据库的行为记录以日志保存下来，这种日志往往作为一种稽查用户行为的一种证据。

根据审计对象的区分，有两种方式的审计，即用户审计和系统审计。用户审计时，DBMS的审计系统记下所有对自己表或视图进行访问的企图（包括成功的和不成功的）及每次操作的用户名、时间、操作代码等信息。这些信息一般都被记录在操作系统或DBMS的日志文件里面，利用这些信息可以对用户进行审计分析。系统审计由DBA进行，其审计内容主要是系统一级命令及数据对象的使用情况。



## 数据库的完整性

数据库的完整性是指数据的正确性和相容性。数据库是否具备完整性关系到DBS能否真实地反映现实世界，因此维护数据库的完整性是非常重要的。

### 1．完整性约束条件

保证数据完整性的方法之一是设置完整性检查，即对数据库中数据设置一些约束条件，这是数据的语义体现。数据的完整性约束条件一般在数据模式中给出，并在运行时做检查，当不满足条件时立即向用户通报以便采取措施。

完整性约束条件一般指的是对数据库中数据本身的某些语法、语义限制，数据间的逻辑约束，以及数据变化时应遵守的规则等。所有这些约束条件一般均以谓词逻辑形式表示，即以具有真假值的原子公式及命题连接词（并且、或者、否定）所组成的逻辑公式表示。完整性约束条件作用对象可以是关系、元组、列三种。

数据库中数据的语法、语义限制与数据间的逻辑约束称为静态约束。它反映了数据及数据间的固有的逻辑特性，是最重要的一类完整性约束。静态约束包括静态列级约束（对数据类型的约束、对数据格式的约束、对取值范围或取值集合的约束、对空值的约束、其他约束）、静态元组约束、静态关系约束（实体完整性约束、参照完整性约束、函数依赖约束、统计约束）。

数据库中的数据变化应遵守的规则称为数据动态约束，它反映了数据库状态变迁的约束。动态约束包括动态列级约束（修改列定义时的约束、修改列值时的约束）、动态元组约束、动态关系约束。

### 2．完整性控制

完整性控制机制应该具有定义功能（提供定义完整性约束条件的机制）和检查功能（检查用户发出的操作请求是否违背了完整性约束条件）。如果发现用户的操作请求违背了约束条件，则采取一定的动作来保证数据的完整性。数据库的完整性可分为实体完整性、参照完整性和用户定义的完整性。

#### （1）实体完整性

实体完整性要求主码中的任一属性不能为空，所谓空值是“不知道”或“无意义”的值。之所以要保证实体完整性，主要是因为在关系中，每一个元组的区分是依据主码值的不同，若主码值取空值，则不能标明该元组的存在。

#### （2）参照完整性

若基本关系R中含有与另一基本关系S的主码PK相对应的属性组FK（FK称为R的外码），则参照完整性要求，对R中的每个元组在FK上的值必须是S中某个元组的PK值，或者为空值。参照完整性的合理性在于，R中的外码只能对S中的主码引用，不能是S中主码没有的值。例如，对于学生和选课表两个关系，选课表中的学号是外码，它是学生表的主键，若选课表中出现了某个学生表中没有的学号，即某个学生还没有注册，却已有了选课记录，这显然是不合理的。

对于参照完整性，需要明确以下问题：

①外码能否接受空值问题，根据实际应用决定。

②在被参照关系中删除元组的问题。

- 级联删除：将参照关系中所有外码值与被参照关系中要删除元组主码值相同的元组一起删除。如果参照关系同时又是另一个关系的被参照关系，则这种删除操作会继续级联下去。
- 受限删除（一般系统默认）：仅当参照关系中没有任何元组的外码值与被参照关系中要删除元组的主码值相同时，系统才可以执行删除操作，否则拒绝执行删除操作。
- 置空删除：删除被参照关系的元组，并将参照关系中相应元组的外码值置为空值。

③在参照关系中插入元组的问题。

- 受限插入：仅当被参照关系中存在相应的元组时，其主码值与参照关系插入元组的外码值相同时，系统才执行插入操作，否则拒绝此操作.
- 递归插入：首先向被参照关系中插入相应的元组，其主码值等于参照关系插入元组的外码值，然后向参照关系插入元组。

#### （3）用户定义的完整性

实体完整性和参照完整性适用于任何关系型DBMS。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。

如果在一条语句执行完后立即检查，则称立即执行约束；如果在整个事务执行结束后再进行检查，则称延迟执行约束。完整性规则的五元组表示为（D，O，A，C，P），其中D表示约束作用的数据对象，O表示触发完整性检查的数据库操作，A表示数据对象必须满足的断言或语义约束，C表示选择A作用的数据对象值的谓词，P表示违反完整性规则时触发的过程。

#### （4）触发器

触发器是在关系型DBMS中应用得比较多的一种完整性保护措施。触发器的功能一般比完整性约束要强得多。一般而言，在完整性约束功能中，当系统检查出数据中有违反完整性约束条件时，则仅给出必要提示以通知用户，仅此而已。而触发器的功能则不仅仅起提示作用，它还会引起系统内自动进行某些操作以消除违反完整性约束条件所引起的负面影响。

所谓触发器，其抽象的含义即是一个事件的发生必然触发（或导致）另外一些事件的发生，其中前面的事件称为触发事件，后面的事件称为结果事件。触发事件一般即为完整性约束条件的否定。而结果事件即为一组操作用以消除触发事件所引起的不良影响。在目前数据库中事件一般表示为数据的插入、修改、删除等操作。希赛教育专家提示：触发器除了有完整性保护功能外，还有安全性保护功能。



## 数据库性能

数据库性能的调整是数据库管理员的日常工作之一。性能调整工作可以从逻辑上和物理上两个方面进行。

### 1．SQL的性能优化

SQL（STructuredQueryLanguage，结构化查询语言）语句是用户访问关系数据库中数据的唯一方法，通常在一个关系数据库上，服务器的SQL进程会使用该服务器60%～90%的资源，大部分数据库效率的问题都是由于SQL语句编写不善引起的，所以SQL语句的性能优化十分重要。

为了编写出高效的SQL语句，首先应按照一定的具体规范来编写SQL语句，我们建议每一个DBA都应该收集和整理一份SQL编码规范。其次是在真实数据库上对这些SQL语句进行性能测试和跟踪并不断调整，达到最优后才正式上线运行。最后需要强调的是，随着数据量的变化和数据库版本升级后，往往会导致部分SQL性能下降，所以对SQL的跟踪优化是DBA的一项持续不断的工作。

### 2．数据库的性能优化

DBS是一组程序作用在数据文件上对外提供服务，所以其本身的性能优化也十分重要，对其的优化工作主要是相应的参数调整，步骤一般如下：

（1）通过监视DBS的内存对象，获得系统性能指标，发现系统的性能缺陷及原因。

（2）针对导致系统性能缺陷的原因，进行相应的参数调整（如增加数据缓冲区的大小）。

（3）跟踪参数调整后系统的各项性能指标，看是否达到预期要求，否则继续调整。

以上3步反复循环迭代，持续进行，保证数据库本身运行状态的最优。

例如，Oracle通常利用定时执行statspacke.snap包收集数据库的运行状态，然后利用程序spreport.sql对两个采集点之间的数据产生报表，以分析这段时间数据库的各种运行指标。Sybase数据库用sp_sysmon、sp_monitor、sp_configure命令来采集和分析一定时间段内数据库的各种运行指标。

### 3．查询优化

可以通过如下方法来优化查询：

（1）把数据、日志、索引放到不同的I/O设备上，增加读取速度。数据量（尺寸）越大，提高I/O越重要。

（2）纵向、横向分割表，减少表的尺寸。

（4）根据查询条件，建立索引，优化索引、优化访问方式，限制结果集的数据量。注意填充因子要适当（最好是使用默认值0）。索引应该尽量小，使用字节数小的列建索引好，不要对有限的几个值的列建单一索引。

（5）用OR的子句可以分解成多个查询，并且通过UNION连接多个查询。它们的速度只与是否使用索引有关，如果查询需要用到联合索引，用UNIONall执行的效率更高。

（6）在查询SELECT语句中用WHERE子句限制返回的行数，避免表扫描。如果返回不必要的数据，浪费了服务器的I/O资源，加重了网络的负担降低性能。如果表很大，在表扫描的期间将表锁住，禁止其他的联接访问表，后果严重。

（7）注意使用DISTINCT，在没有必要时不要用，它同UNION一样会使查询变慢。

（8）在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。

（9）一般在GROUPBY和HAVING子句之前就能剔除多余的行，所以尽量不要用它们来做剔除行的工作。

（10）尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句（存储过程是数据库服务器端的一段程序），是控制流语言的集合，速度当然快。存储过程有两种类型。一种类似于SELECT查询，用于检索数据，检索到的数据能够以数据集的形式返回给客户。另一种类似于INSERT或DELETE查询，它不返回数据，只是执行一个动作。有的服务器允许同一个存储过程既可以返回数据又可以执行动作。

（11）不要在一句话里再三地使用相同的函数，浪费资源，将结果放在变量里再调用更快。另外，还可以针对大量只读查询操作进行优化，常见的方法有：

1. 数据量小的数据，可以考虑不存储在数据库中，而是通过程序常量的方式解决。
2. 需要存储在数据库中的数据，可以考虑采用物化视图（索引视图）。当DBA在视图上创建索引时，这个视图就被物化（执行）了，并且结果集被永久地保存在唯一聚簇索引中，保存方式与一个有聚簇索引的表的保存方式相同。物化视图减除了为引用视图的查询动态建立结果集的管理开销，优化人员可以在查询中使用视图索引，而不需要在FROM子句中直接指定视图。
3. 数据存储时可以考虑适当的数据冗余，以减少数据库表之间的连接操作，提高查询效率。
4. 针对数据的特点，采取特定的索引类型。例如位图索引等。



## 数据库工程
数据库工程是指基于DBS生存周期的所有活动的集合，其中包括数据库的规划、设计、实现和管理等。在DBS的管理方面，主要是对数据库进行控制，也就是2.4节所讨论的内容。

数据库设计是指对一个给定的应用环境，提供一个确定最优数据模型与处理模式的逻辑设计，以及一个确定数据库存储结构与存取方法的物理设计，建立起能反映现实世界信息和信息联系及满足用户数据要求和加工要求，以能够被某个DBMS所接受，同时能实现系统目标并有效存取数据的数据库。



## 数据库设计阶段

基于DBS生存期的数据库设计分成5个阶段，分别为**规划**、**需求分析**、**概念设计**、**逻辑设计**和**物理设计**。

### 1．规划

规划阶段的主要任务是进行建立数据库的必要性及可行性分析，确定DBS在组织中和信息系统中的地位，以及各个数据库之间的联系。有关这方面的详细知识，请阅读8.5节。

### 2．需求分析

需求分析可以通过3步来完成，即需求信息的收集、分析整理和评审，其目的在于对系统的应用情况做全面详细的调查，确定企业组织的目标，收集支持系统总的设计目标的基础数据和对这些数据的要求，确定用户的需求，并把这些要求写成用户和数据设计者都能够接受的文档。有关这方面的详细知识，请阅读8.6节。

### 3．概念设计

概念设计（概念结构设计）阶段的目标是对需求说明书提供的所有数据和处理要求进行抽象与综合处理，按一定的方法构造反映用户环境的数据及其相互联系的概念模型，即用户的数据模型或企业数据模型。这种概念数据模型与DBMS无关，是面向现实世界的、极易为用户所理解的数据模型。为保证所设计的概念数据模型能正确、完全地反映用户的数据及其相互关系，便于进行所要求的各种处理，在本阶段设计中可吸收用户参与和评议设计。在进行概念结构设计时，可先设计各个应用的视图，即各个应用所看到的数据及其结构，然后再进行视图集成，以形成一个单一的概念数据模型。这样形成的初步数据模型还要经过数据库设计者和用户的审查与修改，最后形成所需的概念数据模型。

有关概念模型的建立，请阅读2.6节。对概念模型的要求是：

（1）概念模型是对现实世界的抽象和概括，它应真实、充分地反映现实世界中事物和事物之间的联系，有丰富的语义表达能力，能表达用户的各种需求，包括描述现实世界中各种对象及其复杂联系、用户对数据对象的处理要求和手段。

（2）概念模型应简洁、明晰，独立于机器、容易理解、方便数据库设计人员与应用人员交换意见，使用户能积极地参与数据库的设计工作。

（3）概念模型应易于变动。当应用环境和应用要求改变时，容易对概念模型修改和补充。

（4）概念模型应很容易向关系、层次或网状等各种数据模型转换，易于从概念模式导出与DBMS有关的逻辑模式。

### 4．逻辑设计

逻辑设计（逻辑结构设计）主要是把概念模式转换成DBMS能处理的模式。转换过程中要对模式进行评价和性能测试，以便获得较好的模式设计。逻辑设计的主要内容包括初始模式的形成、子模式设计、应用程序设计梗概、模式评价、修正模式（通过模式分解或模式合并来实现规范化）。

逻辑设计的目的是把概念设计阶段设计好的基本E-R图转换为与选用的具体机器上的DBMS所支持的数据模型相符合的逻辑结构，包括数据库模式和外模式。

逻辑设计过程中的输入信息有：

（1）独立于DBMS的概念模式，即概念设计阶段产生的所有局部和全局概念模式。

（2）处理需求，即需求分析阶段产生的业务活动分析结果。

（3）约束条件，即完整性、一致性、安全性要求及响应时间要求等。

（4）DBMS特性，即特定的DBMS所支持的模式、子模式和程序语法的形式规则。

逻辑设计过程输出的信息有DBMS可处理的模式、子模式、应用程序设计指南、物理设计指南。

### 5．物理设计

物理设计（物理结构设计）是指对一个给定的逻辑数据模型选取一个最适合应用环境的物理结构的过程，所谓数据库的物理结构主要指数据库在物理设备上的存储结构和存取方法。

物理设计的步骤为：

（1）设计存储记录结构，包括记录的组成、数据项的类型和长度，以及逻辑记录到存储记录的映射。

（2）确定数据存储安排。

（3）设计访问方法，为存储在物理设备上的数据提供存储和检索的能力。

（4）进行完整性和安全性的分析、设计。

（5）程序设计。



## 设计约束和原则

在进行数据库设计的过程中，性能标准和性能约束的要求是设计者必须考虑的。通常性能约束也被看做需求的一部分，而性能标准是从不同的性能约束中推导出来的。一些典型的约束有：查询响应时间的上限，系统破坏后的恢复时间，为维护安全性和完整性而需要的特殊数据，等等。对最终结构进行性能标准的估价除了上述的响应时间外，还有更新、存储，以及再组织的代价。数据库设计过程的输出，主要有两部分：一部分是完整的数据库结构，其中包括逻辑结构与物理结构；另一部分是基于数据库结构和处理需求的应用程序的设计准则。这些输出都是以说明书的形式出现的。

为了使数据库设计更合理有效，需要有效的指导原则，这种指导原则称为数据库设计方法学。一个好的数据库设计方法学应该能在合理的期限内，以合理的工作量，产生一个有实用价值的数据库结构。这里“实用价值”是指满足用户关于功能、性能、安全性、完整性及发展需求等诸方面的要求，同时又服从于特定DBMS的约束，且可用简单的数据模型来表示。方法学还具有足够的通用



性、灵活性和可再生产性（不同的设计者应用同一方法学于同一设计问题时，应得到相同或类似的结果）。它有自顶向下、逐步求精的数据库结构设计过程，它对数据库结构和应用软件采取“多步设计评审方法”，其目的是要尽早发现系统设计中的错误，并在生存期的早期阶段给予纠正，以减少系统研制的成本。它有分析式、启发式或过程式的设计技术和定量（前面已讲到的如查询响应时间等）及定性的数据库评价原则。数据库定性分析是指其灵活性、适应性、新用户对设计的可理解性、与其他系统兼容性、对新环境的可改变性、恢复和重启动能力、对模块增生的分割和接受能力等。在数据库设计方法学中，信息需求渗透到数据库设计的整个过程，并且需要有3种基本类型的描述机制：

（1）实现设计过程的最终结果将用DBMS的DDL（DataDefinitionLanguage，数据定义语言）表示。DDL完全是针对现有的DBMS而言的。

（2）信息输入的描述。包括需求信息的收集和分析，数据元素及其联系的同义词、异义词和重叠定义等。这些都不容易用软件工具实现，可能要用一些人工方式。

（3）在信息输入和DDL描述之间的其他中间步骤的结果的描述。主要的中间结果是实体联系图，它是概念设计的产物，在概念设计和逻辑设计之间起桥梁作用。

**基于生存期的设计方法学进行设计并不是数据库设计的唯一途径。近年来由于设计辅助工具、第四代语言和程序自动生成技术的发展，快速原型法也是数据库设计中常用的方法。**

为了使数据库结构能适应应用中可能发生的变化，在数据库设计中，要充分注意数据库结构的可扩充性。例如，在设计数据库的时候要考虑到哪些数据字段将来可能会发生变更；给文本字段留足余量；估算未来5～10年的扩充数据量等。

## 数据库建模

本知识点主要考查E-R图的画法，各实体之间的关系，如何消除冲突，E-R图向关系模式的转换等。



## E-R图的画法

E-R模型简称E-R图，它是描述概念世界，建立概念模型的实用工具。E-R图包括三个要素：

（1）实体（型）：用矩形框表示，框内标注实体名称。

（2）属性：用椭圆形表示，并用连线与实体连接起来。

（3）实体之间的联系：用菱形框表示，框内标注联系名称，并用连线将菱形框分别与有关实体相连，并在连线上注明联系类型。

例如，图2-2就是一个教学系统的E-R图（为了简单起见，省略了部分实体的属性和联系的属性）。![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps10.png)图2-2某教学系统E-R图

E-R图中的联系归结为三种类型：

（1）一对一联系（1:1）。设A、B为两个实体集。若A中的每个实体至多和B中的一个实体有联系，反过来，B中的每个实体至多和A中的一个实体有联系，称A对B或B对A是1:1联系。注意：1:1联系不一定都是一一对应的关系。可能存在着无对应。例如，在图2-2中，一个班只有一个班主任，一个班主任不能同时在其他班再兼任班主任，由于老师紧缺，某个班的班主任也可能暂缺。

（2）一对多联系（1:n）。如果A实体集中的每个实体可以和B中的几个实体有联系，而B中的每个实体至少和A中的一个实体有联系，那么A对B属于1:n联系。例如，在图2-2中，一个班级有多个学生，而一个学生只能编排在一个班级，班级与学生属于一对多的联系。

（3）多对多联系（m:n）。若实体集A中的每个实体可与和B中的多个实体有联系，反过来，B中的每个实体也可以与A中的多个实体有联系，称A对B或B对A是m:n联系。例如，在图2-2中，一个学生可以选修多门课程，一门课程由多个学生选修，学生和课程间存在多对多的联系。希赛教育专家提示：有时联系也有属性，这类属性不属于任一实体，只能属于联系。



## E-R图的集成

在数据库的概念结构设计过程中，先设计各子系统的局部E-R图，设计过程可分为以下几个步骤：

（1）确定局部视图的范围。

（2）识别实体及其标识。

（3）确定实体间的联系。

（4）分配实体及联系的属性。

各子系统的局部E-R图设计好后，下一步就是要将所有的分E-R图综合成一个系统的总体E-R图，一般称为视图的集成。视图集成通常有两种方式：（1）多个局部E-R图一次集成。这种方式比较复杂，做起来难度较大。（2）逐步集成，用累加的方式一次集成两个局部E-R图。这种方式每次只集成两个局部E-R图，可以降低复杂度。

由于各子系统应用所面临的问题不同，且通常是由不同的设计人员进行局部视图设计，这就导致各个局部E-R图之间必定会存在许多不一致的问题，称之为冲突。因此合并E-R图时并不能简单地将各个局部E-R图画到一起，而是必须着力消除各个局部E-R图中的不一致，以形成一个能为全系统中所有用户共同理解和接受的统一的概念模型。

各局部E-R图之间的冲突主要有三类：

（1）属性冲突：包括属性域冲突和属性取值冲突。属性冲突理论上好解决，只要换成相同的属性就可以了，但实际上需要各部门协商，解决起来并不简单。

（2）命名冲突：包括同名异义和异名同义。处理命名冲突通常也像处理属性冲突一样，通过讨论和协商等行政手段加以解决。

（3）结构冲突：包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部E-R图中所包含的属性个数和属性排列次序不完全相同。对于前者的解决办法是把属性变换为实体或实体变换为属性，使同一对象具有相同的抽象。对于后者的解决办法是使该实体的属性取各局部E-R图中属性的并集，再适当调整属性的次序。

另外，实体间的联系在不同的局部E-R图中可能为不同的类型，其解决方法是根据应用的语义对实体联系的类型进行综合或调整。

在初步的E-R图中，可能存在一些冗余的数据和实体间冗余的联系。冗余数据和冗余联系容易破坏数据库的完整性，给数据库维护增加困难，应当予以消除。消除冗余的主要方法为分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。

在集成之后，还需要对E-R模型进行评审。评审的作用在于确认建模任务是否全部完成，通过评审可以避免重大的疏漏或错误。



## 图向关系模式的转换

E-R图向关系模式的转换属于数据库的逻辑设计阶段的工作，该阶段需要把E-R模型转换为某种DBMS能处理的关系模式，具体转换规则如下：

（1）一个实体转换为一个关系模式，实体的属性就是关系的属性，实体的码（关键字）就是关系的码。

（2）一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选键。如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。

（3）一个1:n联系可以转换为一个独立的关系模式，也可以与任意n端对应的关系模式合并。如果转换为一个独立的模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码。如果与n端实体对应的关系模式合并，则需要在该关系模式的属性中加入1端关系模式的码和联系本身的属性。

（4）一个m:n联系转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。

（5）三个以上实体间的一个多元联系可以转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。

另外，还有4种情况是需要特别注意的：

（1）多值属性的处理。如果E-R图中某实体具有一个多值属性，则应该进行优化，把该属性提升为一个实体。或者在转化为关系模式时，将实体的码与多值属性单独构成一个关系模式。

（2）BLOB型属性的处理。典型的BLOB是一张图片或一个声音文件，由于它们的容量比较大，必须使用特殊的方式来处理。处理BLOB的主要思想就是让文件处理器（如数据库管理器）不去理会文件是什么，而是关心如何去处理它。因此，从优化的角度考虑，应采用的设计方案是将BLOB字段与关系的码独立为一个关系模式。

（3）派生属性的处理。因为派生属性可由其他属性计算得到，因此，在转化成关系模式时，通常不转换派生属性。

（4）在对象-关系数据模型中，这里的关系模式就对应类，关系模式的属性就对应类的属性。



## 常见的数据库管理系统

目前，常见的DBMS主要有Oracle、Sybase、DB2、MSSQLServer等，本节简单介绍这些DBMS。



## Oracle

Oracle的结构包括数据库的内部结构、外存储结构、内存储结构和进程结构。在Oracle中，数据库不仅指物理上的数据，还包括处理这些数据的程序，即DBMS本身。Oracle提供了PL/SQL、Designer/2000、Forms等开发和设计工具。

除了以关系格式存储数据外，Oracle8以上的版本支持面向对象的结构（如抽象数据类型）。一个对象可以与其他对象建立联系，也可以包含其他对象，还可以用一个对象视图支持面向对象的接口数据而无须对表做任何修改。

无论是面向对象的结构还是关系结构，Oracle数据库都将其数据存储在物理的数据文件中。数据库结构提供数据存储到文件的逻辑图，允许不同类型的数据分开存储，这些逻辑划分即是表空间。在Oracle中，除了存储数据的文件外，还有DBMS的代码文件、日志文件和其他一些控制文件、跟踪文件等。外存储结构主要包括表空间和文件结构。

Oracle数据库在运行中使用两种类型的内存结构，分别是系统全局区和程序全局区。系统全局区是数据库运行时存放系统数据的内存区域，它由所有服务器进程和客户进程共享；程序全局区是单个存放Oracle进程工作时需要的数据和控制信息的，程序全局区不能共享。



## Sybase

为满足企业级分布式计算应用的要求，Sybase采用了基于构件方式的多层（常用三层）C/S架构。构件的主要优点是其自包含性和可重用性，系统中任何一个构件当被另一个具有同样功能的构件取代时，都无须对周围的构件进行重编码或修改。

第一层为客户应用程序。负责实现在客户系统上的数据显示和操作以及对用户输入做合理性检验。Sybase的开发工具产品系列（例如，PowerBuilder等）处在这一层。

第二层为基于构件方式的中间件层。该层能为分布式异构环境提供全局性的数据访问及事务管理控制。Sybase的中间件层产品主要有OmniConnect、OpenC1ient和OpenServer等。

第三层为服务器应用软件。它负责数据存取及完整性控制。Sybase数据库产品系列（例如，AdaptiveServerEnterprise、SybaseMPP、SybaseIQ和SQLAnywhere等）处于这一层。

Sybase这种架构的高适应性体现在企业可依据其特定的和变化中的分布式应用的需要来定制各个层次中的构件。Sybase的这些产品能优化地集成在一起协同运行，但它们彼此又是相互独立的，都能容易地与第三方产品实现集成，因而用户可灵活地构建一个完整的异构分布式系统。



## Informix

Informix是美国Informix公司（已被IBM公司收购）的主要产品。Informix是一个跨平台、全功能的关系型DBMS，后改造为面向对象型DBMS，它具有各种特性，并且能够十分方便地与各种图形用户界面前端工具相连接。

Informix动态服务器采用多线程架构实现，这意味着只需较少的进程完成数据库活动，同时也意味着一个数据库进程可以通过线程形式为多于一个的应用服务。通常称这样一组进程为数据库服务器。根据需要，可以为数据库服务器动态分配一个进程，故称之为动态服务器。多线程架构还可以有更好的可伸缩性。这意味着，当增加更多用户时，数据库服务器只需要少量额外资源，这得益于多线程服务器实现本质上的可伸缩性的效率。

Informix的软件开发工具主要有Informix-SQL、Informix-ESQL、Informix-4GL等，它们具有不同的功能和特点，既能单独使用，也可根据实际需要相互配合使用。



## SQLServer

SQLServer是微软公司的数据库产品，SQLServer的分布式架构把应用程序对数据库的访问和数据库引擎分离开来。SQLServer的核心数据库服务器运行在基于Windows的服务器之上。基于Windows的服务器一般通过以太局域网与多个客户机系统连接。这些客户机系统一般是运行SQLServer客户机软件的PC机。这些PC机既可以是单独的桌面系统，又可以是其他网络服务的平台，如IISWeb服务器。

SQLServer与流行的开发工具和桌面应用程序紧密集成，例如，可以从由VisualBasic、VisualC++、PowerBuilder、Delphi、VisualFoxPro和许多其他PC开发环境下开发的客户应用程序中访问SQLServer数据库。SQLServer与流行开发工具所使用的几种数据访问接口兼容，例如，可以通过MicrosoftJETEngine和DataAccessObjects（DAO）、RemoteDataObjects（RDO）、ActiveXDataObjects（ADO）、OLEDB、ODBC（OpenDatabaseConnectivity，开放数据库互连）、SQLServer内置DB-Library以及第三方开发工具来访问SQLServer数据库。对于无缝桌面数据库访问，SQLServer使用OLEDB提供者和ODBC驱动程序，这些驱动程序允许从任何与ODBC或者OLEDB兼容的桌面应用程序中访问SQLServer数据库。OLEDB和ODBC可以从数百个简化设计的桌面应用程序中为特定的查询、数据分析、自定义报表打开SQLServer数据库。桌面集成减少了自定义的编程工作。SQLSerevr对ODBC的支持允许其他平台，如Macintosh或各种Unix系统访问SQLServer数据库。

SQLServer的4个基本服务器组件包括OpenDataServices、MSSQLServer、SQLServerAgent和MSDTC。



## DB2

DB2是IBM公司研制的一种关系型数据库系统。DB2主要应用于大型应用系统，具有较好的可伸缩性，可支持从大型机到单用户环境，应用于OS/2、Windows等平台下。

DB2提供了高层次的数据利用性、完整性、安全性、可恢复性，以及小规模到大规模应用程序的执行能力，具有与平台无关的基本功能和SQL命令。DB2采用了数据分级技术，能够使大型机数据很方便地下载到局域网数据库服务器，使得C/S用户和基于局域网的应用程序可以访问大型机数据，并使数据库本地化及远程连接透明化。它以拥有一个非常完备的查询优化器而著称，其外部连接改善了查询性能，并支持多任务并行查询。

DB2具有很好的网络支持能力，每个子系统可以连接十几万个分布式用户，可同时激活上千个活动线程，对大型分布式应用系统尤为适用。



## MySQL

MySQL是一个开放源码的小型关联式数据库管理系统，开发者为瑞典MySQLAB公司。MySQL被广泛地应用在Internet上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库。



## 并行数据库系统

![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps20.png)并行DBS是在并行机上运行的具有并行处理能力的DBS。并行DBS是数据库技术与并行计算技术相结合的产物。并行计算技术利用多处理机并行处理产生的规模效益来提高系统的整体性能，为DBS提供了一个良好的硬件平台。

一个并行DBS应该实现如下目标：

（1）高性能：并行DBS通过将数据库管理技术与并行处理技术有机结合，发挥多处理机结构的优势，从而提供比相应的大型机系统要高得多的性能价格比和可用性。

（2）高可用性：并行DBS可通过数据复制来增强数据库的可用性。

（3）可扩充性：DBS的可扩充性指系统通过增加处理和存储能力而平滑地扩展性能的能力。



## 并行数据库的结构

从硬件结构来看，根据处理机与磁盘及内存的相互关系可以将并行计算机分为3种基本的架构，分别是共享内存（ShareMemory，SM）结构、共享磁盘（ShareDisk，SD）结构和无共享资源（Share-Nothing，SN）结构，并行DBS以这3种架构为基础。

### 1.SM结构

SM结构由多个处理机、一个共享内存和多个磁盘存储器构成。多处理机和共享内存由高速通信网络连接，每个处理机可直接存取一个或多个磁盘，即所有内存与磁盘为所有处理机共享。SM结构如图2-3所示。![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps22.png)图2-3SM结构SM结构的优势在于实现简单和负载均衡，但是这种结构的系统由于硬件成员之间的互连很复杂，故成本比较高。由于访问共享内存和磁盘会成为瓶颈，为了避免访问冲突增多而导致系统性能下降，节点数目必须限制在100个以下，可扩充性比较差。另外，内存的任何错误都将影响到多个处理机，系统的可用性不是很好。

### 2.SD结构

SD结构由多个具有独立内存的处理机和多个磁盘构成，每个处理机都可以读写任何磁盘，多个处理机和磁盘存储器由高速通信网络连接。SD结构如图2-4所示。![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps23.png)图2-4SD结构SD结构具有成本低、可扩充性好、可用性强，容易从单处理机系统迁移，以及负载均衡等优点。该结构的不足之处在于实现起来比较复杂，以及存在潜在的性能问题。

### 3.SN结构

SN结构由多个处理节点构成，每个处理节点具有自己独立的处理机、内存和磁盘存储器，多个处理机节点由高速通信网络连接。SN结构如图2-5所示。



![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps24.png)图2-5SN结构在SN结构中，由于每个节点可视为分布式DBS中的局部场地（拥有自己的数据库软件），因此分布式数据库设计中的多数设计思路，如数据库分片、分布事务管理和分布查询处理等，都可以借鉴。SN结构成本较低，它最大限度地减少了共享资源，具有极佳的可伸缩性，节点数目可达数千个，并可获得接近线性的伸缩比。而通过在多个节点上复制数据又可实现高可用性。SN结构的不足之处在于实现比较复杂，以及节点负荷难以均衡。往往只是根据数据的物理位置而不是系统的实际负载来分配任务。并且，系统中新节点的加入将导致重新组织数据库以均衡负载。



## 并行数据库的组织

并行数据库的组织主要涉及到并行粒度和操作算法问题。

并行粒度是指查询执行的并行程度，按照粒度从粗到细，主要有不同用户事务间的并行、同一事务内不同查询间的并行、同一查询内不同操作间的并行、同一操作内的并行性4种。

并行操作算法有并行连接算法、并行扫描算法和并行排序算法等。由于连接运算是数据库系统中最常用且最耗时的操作，因此对并行连接操作的研究最多。学者们提出了基于嵌套循环的并行连接算法、基于合并扫描的并行连接算法、基于Hash的并行连接算法和基于索引的并行连接算法等。

并行数据库以提高系统性能为宗旨，强调数据分布的均匀性。数据划分是并行查询处理的重要基础，根据存放关系的节点数目的不同，数据划分技术可分为完全划分（完全分布）和变量划分（部分分布）两种类型。完全划分将每一个关系分布存储到所有节点上，这种方法不适合小关系及节点数目大的系统；变量划分将每一个关系只分布存储到部分节点上，其中节点数目是关系大小和访问频率的一个函数，从而使数据分布更为灵活。

划分数据时可以依据一个属性的值，也可以同时依据多个属性的值，前者称为一维数据划分，后者称为多维数据划分。常用的划分方法有轮转法、Hash法和值域划分法、用户定义划分法、模式划分法和Hybrid_Range划分法等。



## 数据仓库与数据挖掘

企业常见的数据处理工作大致可以分成两大类，分别是OLTP（On-LineTransactionProcessing，联机事务处理）和OLAP（On-LineAnalyticalProcessing，联机分析处理）。OLTP是传统的关系型数据库的主要应用，OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。



## 联机分析处理

OLTP是传统关系型数据库的重要应用之一，主要是基本的、日常的事务处理，例如银行交易、电信计费、民航订票等，对响应时间要求比较高，强调的是密集数据更新处理的性能和系统的可靠性及效率。OLTP用短小和中等复杂程度的查询语句，读取或修改数据库中一个比较小的部分，数据访问方式是小的随机磁盘访问。

OLTP是事件驱动、面向应用的。OLTP的基本特点是：对响应时间要求非常高；用户数量非常庞大，主要是操作人员；数据库的各种操作基于索引进行；对数据库的事务均已预先定义，查询简单，一般不牵涉到多表连接操作。

OLAP使得数据分析人员能够从多角度对数据进行快速、一致、交互地存取，从而获得对数据的更深入的了解。OLAP的目标是满足决策支持或者在多维环境下特定的查询和报表需求。

OLTP与OLAP之间的比较。

|          | OLTP                               | OLAP                                 |
| -------- | ---------------------------------- | ------------------------------------ |
| 用户     | 操作人员，低层管理人员             | 决策人员，高级管理人员               |
| 功能     | 日常操作处理                       | 分析决策                             |
| DB设计   | 面向应用                           | 面向主题                             |
| 数据     | 当前的，最新的细节的，二维的分立的 | 历史的，聚集的，多维的集成的，统一的 |
| 存取     | 读/写数十条事务                    | 读上百万条记录                       |
| 工作单位 | 简单的事务                         | 复杂的查询                           |
| 用户数   | 上千个                             | 上百个                               |
| DB大小   | 100MB-GB                           | 100GB-TB                             |

OLAP是使分析人员、管理人员或执行人员能够从多角度对信息进行快速、一致、交互地存取，从而获得对数据的更深入了解的一类软件技术。OLAP的目标是满足决策支持或者满足在多维环境下特定的查询和报表需求，它的技术核心是“维”的概念。维是人们观察客观世界的角度，是一种高层次的类型划分。维一般包含着层次关系，这种层次关系有时会相当复杂。通过把一个实体的多项重要的属性定义为多个维，使用户能对不同维上的数据进行比较。因此OLAP也可以说是多维数据分析工具的集合。

OLAP的基本多维分析操作有钻取、切片和切块、旋转等。

（1）**钻取**：是改变维的层次，变换分析的粒度。它包括向上钻取和向下钻取。向上钻取是在某一维上将低层次的细节数据概括到高层次的汇总数据，或者减少维数；而向下钻取则相反，它从汇总数据深入到细节数据进行观察或增加新维

（2）**切片和切块**：是在一部分维上选定值后，关心度量数据在剩余维上的分布。如果剩余的维只有两个，则是切片；如果有三个，则是切块。

（3）**旋转**：是变换维的方向，即在表格中重新安排维的放置（例如行列互换）。

OLAP有多种实现方法，根据存储数据的方式不同，可以分为ROLAP（RelationalOLAP，基于关系数据库的OLAP实现）、MOLAP（MultidimensionalOLAP，基于多维数据组织的OLAP实现）、HOLAP（HybridOLAP，基于混合数据组织的OLAP实现）。

（1）ROLAP：以关系数据库为核心，以关系型结构进行多维数据的表示和存储。ROLAP将多维数据库的多维结构划分为两类表:一类是事实表，用来存储数据和维关键字;另一类是维表，即对每个维至少使用一个表来存放维的层次、成员类别等维的描述信息。维表和事实表通过主关键字和外关键字联系在一起，形成了“星型模式”。对于层次复杂的维，为避免冗余数据占用过大的存储空间，可以使用多个表来描述，这种星型模式的扩展称为“雪花模式”。

（2）MOLAP：以多维数据组织方式为核心，也就是说，MOLAP使用多维数组存储数据。多维数据在存储中将形成立方块（Cube）的结构，在MOLAP中对立方块的旋转、切块、切片是产生多维数据报表的主要技术。

（3）HOLAP：低层是关系型的，高层是多维矩阵型的；或者反之。这种方式具有更好的灵活性。

还有其他的一些实现OLAP的方法，如提供一个专用的SQLServer，对某些存储模式（如星型、雪片型）提供对SQL查询的特殊支持。

OLAP工具是针对特定问题的联机数据访问与分析，它通过多维的方式对数据进行分析、查询和报表。多维分析是指对以多维形式组织起来的数据采取切片、切块、钻取、旋转等各种分析动作，以求剖析数据，使用户能从多个角度、多侧面地观察数据库中的数据，从而深入理解包含在数据中的信息。



## 数据仓库的概念

数据仓库（DataWarehouse）是一个面向主题的、集成的、相对稳定的、且随时间变化的的数据集合，用于支持管理决策。

### 1．数据仓库的特征

（1）面向主题。操作型数据库的数据组织面向事务处理任务（面向应用），各个业务系统之间各自分离，而数据仓库中的数据是按照一定的主题域进行组织。主题是一个抽象的概念，是指用户使用数据仓库进行决策时所关心的重点方面，一个主题通常与多个操作型信息系统相关。例如，一个保险公司所进行的事务处理（应用问题）可能包括汽车保险、人寿保险、健康保险和意外保险等，而公司的主要主题范围可能是顾客、保险单、保险费和索赔等。

（2）集成的。在数据仓库的所有特性中，这是最重要的。面向事务处理的操作型数据库通常与某些特定的应用相关，数据库之间相互独立，并且往往是异构的。而数据仓库中的数据是在对原有分散的数据库数据抽取、清理的基础上经过系统加工、汇总和整理得到的，必须消除源数据中的不一致性，以保证数据仓库内的信息是关于整个企业的一致的全局信息。

（3）相对稳定的（非易失的）。操作型数据库中的数据通常实时更新，数据根据需要及时发生变化。数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一旦某个数据进入数据仓库以后，一般情况下将被长期保留，也就是数据仓库中一般有大量的查询操作，但修改和删除操作很少，通常只需要定期的加载、刷新。

（4）随时间变化。操作型数据库主要关心当前某一个时间段内的数据，而数据仓库中的数据通常包含历史信息，系统记录了企业从过去某一时点（如开始应用数据仓库的时点）到目前的各个阶段的信息，通过这些信息，可以对企业的发展历程和未来趋势做出定量分析和预测。

数据仓库反映历史变化的属性主要表现在：

（1）数据仓库中的数据时间期限要远远长于传统操作型数据系统中的数据时间期限，传统操作型数据系统中的数据时间期限可能为数十天或数个月，数据仓库中的数据时间期限往往为数年甚至几十年。

（2）传统操作型数据系统中的数据含有“当前值”的数据，这些数据在访问时是有效的，当然数据的当前值也能被更新，但数据仓库中的数据仅仅是一系列某一时刻（可能是传统操作型数据系统）生成的复杂的快照。

（3）传统操作型数据系统中可能包含也可能不包含时间元素，如年、月、日、时、分、秒等，而数据仓库中一定会包含时间元素。

### 2．数据仓库与传统数据的区别

数据仓库虽然是从传统数据库系统发展而来，但是两者还是存在着诸多差异，如：从数据存储的内容看，数据库只存放当前值，而数据仓库则存放历史值；数据库数据的目标是面向业务操作人员的，为业务处理人员提供数据处理的支持，而数据仓库则是面向中高层管理人员的，为其提供决策支持等。表2-3详细说明了数据仓库与传统数据库的区别。

数据仓库与传统数据库的比较

| 比较项目         | 数据库                     | 数据仓库                                       |
| ---------------- | -------------------------- | ---------------------------------------------- |
| 数据内容         | 当前值                     | 历史的、归档的、归纳的、计算的数据（处理过的） |
| 数据目标         | 面向业务操作程序、重复操作 | 面向主体域，分析应用                           |
| 数据特性         | 动态变化、更新             | 静态、不能直接更新，只能定时添加、更新         |
| 使用频率         | 高                         | 低                                             |
| 数据访问量       | 每个事务一般只访问少量记录 | 每个事务一般访问大量记录                       |
| 数据访问量       | 每个事务一般只访问少量记录 | 每个事务一般访问大量记录                       |
| 对响应事件的要求 | 记时单位小，如秒           | 记时单位相对较大，除了秒，还有分钟、小时       |

### 3．数据仓库的分类

从结构的角度看，有三种数据仓库模型，分别是企业仓库、数据集市和虚拟仓库。

企业仓库收集跨越整个企业的各个主题的所有信息，它提供全企业范围的数据集成，数据通常来自多个操作型数据库和外部信息提供者，并且是跨多个功能范围的。它通常包含详细数据和汇总数据。

数据集市包含对特定用户有用的、企业范围数据的一个子集，它的范围限定选定的主题。虚拟仓库是操作型数据库上视图的集合。



## 数据仓库的结构

从数据仓库的概念结构来看，一般来说，数据仓库系统要包含数据源、数据准备区、数据仓库数据库、数据集市/知识挖掘库以及各种管理工具和应用工具，如图2-6所示。

数据仓库建立之后，首先要从数据源中抽取相关的数据到数据准备区，在数据准备区中经过净化处理后再加载到数据仓库数据库，最后根据用户的需求将数据导入数据集市和知识挖掘库中。当用户使用数据仓库时，可以利用包括OLAP在内的多种数据仓库应用工具向数据集市/知识挖掘库或数据仓库进行决策查询分析或知识挖掘。数据仓库的创建、应用可以利用各种数据仓库管理工具辅助完成。![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps32.png)图2-6数据仓库的概念结构

### 1．数据仓库的参考框架

数据仓库的参考框架由数据仓库基本功能层、数据仓库管理层和数据仓库环境支持层组成。

（1）数据仓库基本功能层。数据仓库的基本功能层部分包含数据源、数据准备区、数据仓库结构、数据集市或知识挖掘库，以及存取和使用部分。本层的功能是从数据源抽取数据，对所抽取的数据进行筛选、清理，将处理过的数据导入或者说加载到数据仓库中，根据用户的需求设立数据集市，完成数据仓库的复杂查询、决策分析和知识的挖掘等。

（2）数据仓库管理层。数据仓库的正常运行除了需要数据仓库功能层提供的基本功能外，还需要对这些基本功能进行管理与支持的结构框架。数据仓库管理层由数据仓库的数据管理和数据仓库的元数据管理组成。数据仓库的数据管理层包含数据抽取、新数据需求与查询管理，数据加载、存储、刷新和更新系统，安全性与用户授权管理系统以及数据归档、恢复及净化系统等四部分。

（3）数据仓库的环境支持层。数据仓库的环境支持层由数据仓库数据传输层和数据仓库基础层组成。数据仓库中不同结构之间的数据传输需要数据仓库的传输层来完成。数据仓库的传输层包含数据传输和传送网络、客户/服务器代理和中间件、复制系统以及数据传输层的安全保障系统。

### 2．数据仓库的架构

大众观点的数据仓库的架构如图2-7所示：



![img](file:///C:\Users\m1885\AppData\Local\Temp\ksohtml13728\wps33.png)图2-7数据仓库架构

（1）数据源。是数据仓库系统的基础，是整个系统的数据源泉。通常包括企业内部信息和外部信息。内部信息包括存放于RDBMS中的各种业务处理数据和各类文档数据。外部信息包括各类法律法规、市场信息和竞争对手的信息等等。

（2）数据的存储与管理。是整个数据仓库系统的核心。数据仓库的真正关键是数据的存储和管理。数据仓库的组织管理方式决定了它有别于传统数据库，同时也决定了其对外部数据的表现形式。要决定采用什么产品和技术来建立数据仓库的核心，则需要从数据仓库的技术特点着手分析。针对现有各业务系统的数据，进行抽取、清理，并有效集成，按照主题进行组织。数据仓库按照数据的覆盖范围可以分为企业级数据仓库和部门级数据仓库（通常称为数据集市）。

（3）OLAP服务器。对分析需要的数据进行有效集成，按多维模型予以组织，以便进行多角度、多层次的分析，并发现趋势。

（4）前端工具。主要包括各种报表工具、查询工具、数据分析工具、数据挖掘工具以及各种基于数据仓库或数据集市的应用开发工具。其中数据分析工具主要针对OLAP服务器，报表工具、数据挖掘工具主要针对数据仓库。



## 数据挖掘的概念

数据挖掘（DataMining）技术是人们长期对数据库技术进行研究和开发的结果。

从技术上来看，数据挖掘就是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和知识的过程。这个定义包括好几层含义：数据源必须是真实的、大量的、含噪声的；发现的是用户感兴趣的知识；发现的知识要可接受、可理解、可运用；并不要求发现放之四海而皆准的知识，仅支持特定的发现问题。

从业务角度来看，数据挖掘是一种新的业务信息处理技术，其主要特点是对业务数据库中的大量业务数据进行抽取、转换、分析和其他模型化处理，从中提取辅助业务决策的关键性数据。

数据挖掘与传统的数据分析（如查询、报表、联机应用分析）的本质区别是数据挖掘是在没有明确假设的前提下去挖掘信息、发现知识。数据挖掘所得到的信息应具有先知、有效和可实用三个特征。先前未知的信息是指该信息是预先未曾预料到的，即数据挖掘是要发现那些不能靠直觉发现的信息或知识，甚至是违背直觉的信息或知识，挖掘出的信息越是出乎意料，就可能越有价值。

数据挖掘通过预测未来趋势及行为，做出前摄的、基于知识的决策。数据挖掘的目标是从数据库中发现隐含的、有意义的知识，主要有以下五类功能：

（1）**自动预测趋势和行为。**数据挖掘自动在大型数据库中寻找预测性信息，以往需要进行大量手工分析的问题如今可以迅速直接由数据本身得出结论。

（2）**关联分析。**数据关联是数据库中存在的一类重要的可被发现的知识。若两个或多个变量的取值之间存在某种规律性，就称为关联。关联可分为简单关联、时序关联、因果关联。关联分析的目的是找出数据库中隐藏的关联网。有时并不知道数据库中数据的关联函数，即使知道也是不确定的，因此关联分析生成的规则带有可信度。

（3）**聚类。**数据库中的记录可被划分为一系列有意义的子集，即聚类。聚类增强了人们对客观现实的认识，是概念描述和偏差分析的先决条件。聚类技术主要包括传统的模式识别方法和数学分类学。

（4）**概念描述。**概念描述就是对某类对象的内涵进行描述，并概括这类对象的有关特征。概念描述分为特征性描述和区别性描述，前者描述某类对象的共同特征，后者描述不同类对象之间的区别。生成一个类的特征性描述只涉及该类对象中所有对象的共性。生成区别性描述的方法很多，如决策树方法、遗传算法等。

（5）**偏差检测。**数据库中的数据常有一些异常记录，从数据库中检测这些偏差很有意义。偏差包括很多潜在的知识，如分类中的反常实例、不满足规则的特例、观测结果与模型预测值的偏差、量值随时间的变化等。偏差检测的基本方法是，寻找观测结果与参照值之间有意义的差别。


## 数据挖掘常用技术

常见和应用最广泛的数据挖掘方法有：

（1）**决策树**。利用信息论中的互信息（信息增益）寻找数据库中具有最大信息量的属性，建立决策树的一个结点，再根据该属性的不同取值建设树的分支；在每个分支子集中重复建立树的下层结点和分支的过程。国际上最早的、也是最有影响的决策树方法是Quiulan研究的ID3方法。

（2）**神经网络**。模拟人脑神经元结构，完成类似统计学中的判别、回归、聚类等功能，是一种非线性的模型，主要有三种神经网络模型，分别是前馈式网络、反馈式网络和自组织网络。人工神经网络最大的长处是可以自动地从数据中学习，形成知识，这些知识有些是我们过去未曾发现的，因此它具有较强的创新性。神经网络的知识体现在网络连接的权值上，神经网络的学习主要表现在神经网络权值的逐步计算上。

（3）**遗传算法**。模拟生物进化过程的算法，它由三个基本过程组成，分别是繁殖（选择）、交叉（重组）、变异（突变）。采用遗传算法可以产生优良的后代，经过若干代的遗传，将得到满足要求的后代即问题得解。

（4）**关联规则挖掘算法**。关联规则是描述数据之间存在关系的规则，一般分为两个步骤：首先求出大数据项集，然后用大数据项集产生关联规则。

除了上述的常用方法外，还有粗集方法、模糊集合方法、最邻近算法等。无论采用哪种方法完成数据挖掘，从功能上可以将数据挖掘的分析方法划分为6种，即关联分析、序列分析、分类分析、聚类分析、预测和时间序列分析。

（1）**关联分析**。关联分析主要用于发现不同事件之间的关联性，即一个事件发生的同时，另一个事件也经常发生。关联分析的重点在于快速发现那些有实用价值的关联发生的事件。其主要依据是事件发生的概率和条件概率应该符合一定的统计意义。

（2）**序列分析**。序列分析技术主要用于发现一定时间间隔内接连发生的事件。这些事件构成一个序列，发现的序列应该具有普遍意义，其依据除了统计上的概率之外，还要加上时间的约束。

（3）**分类分析**。分类分析通过分析具有类别的样本的特点，得到决定样本属于各种类别的规则或方法。利用这些规则和方法对未知类别的样本分类时应该具有一定的准确度。其主要方法有基于统计学的贝叶斯方法、神经网络方法、决策树方法等。

（4）**聚类分析**。聚类分析是根据物以类聚的原理，将本身没有类别的样本聚集成不同的组，并且对每一个这样的组进行描述的过程。其主要依据是聚到同一个组中的样本应该彼此相似，而属于不同组的样本应该足够不相似。

（5）**预测**。预测与分类分析相似，但预测是根据样本的已知特征估算某个连续类型的变量的取值的过程，而分类则只是用于判别样本所属的离散类别而已。预测常用的技术是回归分析。

（6）**时间序列分析**。时间序列分析的是随时间而变化的事件序列，目的是预测未来发展趋势，或者寻找相似发展模式或者是发现周期性发展规律。



## 数据挖掘的流程

数据挖掘是指一个完整的过程，该过程从大型数据库中挖掘先前未知的，有效的，可实用的信息，并使用这些信息做出决策或丰富知识。数据挖掘的流程大致如下：

（1）**问题定义**。在开始数据挖掘之前最先的也是最重要的要求就是熟悉背景知识，弄清用户的需求。缺少了背景知识，就不能明确定义要解决的问题，就不能为挖掘准备优质的数据，也很难正确的解释得到的结果。要想充分发挥数据挖掘的价值，必须对目标要有一个清晰明确的定义，即决定到底想干什么。

（2）**建立数据挖掘库**。要进行数据挖掘必须收集要挖掘的数据资源。一般建议把要挖掘的数据都收集到一个数据库中，而不是采用原有的数据库或数据仓库。这是因为大部分情况下需要修改要挖掘的数据，而且还会遇到采用外部数据的情况；另外，数据挖掘还要对数据进行各种纷繁复杂的统计分析，而数据仓库可能不支持这些数据结构。

（3）**分析数据**。分析数据就是通常所进行的对数据深入调查的过程。从数据集中找出规律和趋势，用聚类分析区分类别，最终要达到的目的就是搞清楚多因素相互影响的、十分复杂的关系，发现因素之间的相关性。

（4）**调整数据**。通过上述步骤的操作，对数据的状态和趋势有了进一步的了解，这时要尽可能对问题解决的要求能进一步明确化、进一步量化。针对问题的需求对数据进行增删，按照对整个数据挖掘过程的新认识组合或生成一个新的变量，以体现对状态的有效描述。

（5）**模型化**。在问题进一步明确，数据结构和内容进一步调整的基础上，就可以建立形成知识的模型。这一步是数据挖掘的核心环节，一般运用神经网络、决策树、数理统计、时间序列分析等方法来建立模型。

（6）**评价和解释**。上面得到的模式模型，有可能是没有实际意义或没有实用价值的，也有可能是其不能准确反映数据的真实意义，甚至在某些情况下是与事实相反的，因此需要评估，确定哪些是有效的、有用的模式。评估的一种办法是直接使用原先建立的挖掘数据库中的数据来进行检验，另一种办法是另找一批数据并对其进行检验，再一种办法是在实际运行的环境中取出新鲜数据进行检验。

数据挖掘是一个多种专家合作的过程，也是一个在资金上和技术上高投入的过程。这一过程要反复进行，在反复过程中，不断地趋近事物的本质，不断地优选问题的解决方案。



## NoSQL

NoSQL即NotOnlySQL，可直译“不仅仅是SQL”，这项技术正在掀起一场全新的数据库革命性运动。

在本章2.3.1节曾提到数据的模式包括多种类型，如层次模型、网状模型、关系模型等，而在实际应用过程中，几乎都是在用关系模型，主流的数据库系统都是关系型的。但随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。这也就使得NoSQL技术进入了人们的视野。

NoSQL的出现打破了长久以来关系型数据库与ACID理论大一统的局面。NoSQL数据存储不需要固定的表结构，通常也不存在连接操作。在大数据存取上具备关系型数据库无法比拟的性能优势。

关系型数据库中的表都是存储一些格式化的数据结构，每个元组字段的组成都一样，即使不是每个元组都需要所有的字段，但数据库会为每个元组分配所有的字段，这样的结构可以便于表与表之间进行连接等操作，但从另一个角度来说它也是关系型数据库性能瓶颈的一个因素。而非关系型数据库以键值对存储，它的结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。

与关系型数据库相比，NoSQL数据库具有以下优点：

1．易扩展

NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。

2．大数据量，高性能

NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用QueryCache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。

3．灵活的数据模型

NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的web2.0时代尤其明显。

4．高可用

NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。比如Cassandra，HBase模型，通过复制模型也能实现高可用。

当然，NoSQL也存在很多缺点，例如，并未形成一定标准，各种产品层出不穷，内部混乱，各种项目还需时间来检验，缺乏相关专家技术的支持等。



## 大数据

大数据（BigData），指的是所涉及的数据量规模巨大到无法通过目前主流软件工具，在合理时间内达到获取、管理、处理、并整理成为帮助企业经营决策目的的信息。

### 1．大数据的特点

大数据有4大特点：Volume（大量）、Velocity（高速）、Variety（多样）、Value（价值），由于他们的英文首字母都是V，所以也称为“4V特点”。

Volume（大量）：大量主要体现在非结构化数据的超大规模增长，比结构化数据增长快10到50倍，同时数据的量级已超越传统数据仓库的很多倍。Velocity（高速）：大数据的分析是一种实时分析而非批量式分析，所以效果是立竿见影而非事后见效。

Variety（多样）：大数据存在异构与多样性的特点，因为他有很多不同形式的数据，如文本、图像、音频、视频等。

Value（价值）：大数据的价值特性是指大数据价值密度低，因为大数据是有着海量数据的，这里面存在大量不相关的信息，所以单位价值密度低。

### 2．传统数据与大数据的比较

传统数据与大数据的差异请参看表2-4。

| 比较维度     | 传统数据             | 大数据                         |
| ------------ | -------------------- | ------------------------------ |
| 数据量       | GB或TB               | PB级或以上                     |
| 结构化程度   | 结构化或半结构化数据 | 所有类型数据                   |
| 数据分析需求 | 现有数据的分析与检测 | 深度分析（关联分析、回归分析） |
| 硬件平台     | 高端服务器           | 集群平台                       |

### 3．大数据处理关键技术

大数据处理关键技术一般包括：大数据采集、大数据预处理、大数据存储及管理、大数据分析及挖掘、大数据展现和应用（大数据检索、大数据可视化、大数据应用、大数据安全等）。

### 4．大数据应用

大数据可以各行各业应用，如金融服务、医疗保健、零售业、制造业、政府等。



# 数据通信与计算机网络

